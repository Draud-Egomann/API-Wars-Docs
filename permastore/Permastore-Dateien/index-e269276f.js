var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-e269276f.js"(exports, module) {
    function _mergeNamespaces(n2, m2) {
      for (var i = 0; i < m2.length; i++) {
        const e = m2[i];
        if (typeof e !== "string" && !Array.isArray(e)) {
          for (const k2 in e) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d = Object.getOwnPropertyDescriptor(e, k2);
              if (d) {
                Object.defineProperty(n2, k2, d.get ? d : {
                  enumerable: true,
                  get: () => e[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link2) {
        const fetchOpts = {};
        if (link2.integrity)
          fetchOpts.integrity = link2.integrity;
        if (link2.referrerPolicy)
          fetchOpts.referrerPolicy = link2.referrerPolicy;
        if (link2.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link2.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var jsxRuntimeExports = {};
    var jsxRuntime = {
      get exports() {
        return jsxRuntimeExports;
      },
      set exports(v2) {
        jsxRuntimeExports = v2;
      }
    };
    var reactJsxRuntime_production_min = {};
    var reactExports = {};
    var react = {
      get exports() {
        return reactExports;
      },
      set exports(v2) {
        reactExports = v2;
      }
    };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$1 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$2 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$1 = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
    function A$1(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = z$1 && a[z$1] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B$1 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C$1 = Object.assign, D$1 = {};
    function E$1(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D$1;
      this.updater = e || B$1;
    }
    E$1.prototype.isReactComponent = {};
    E$1.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E$1.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E$1.prototype;
    function G$1(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D$1;
      this.updater = e || B$1;
    }
    var H$1 = G$1.prototype = new F();
    H$1.constructor = G$1;
    C$1(H$1, E$1.prototype);
    H$1.isPureReactComponent = true;
    var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
    function M$1(a, b, e) {
      var d, c = {}, k2 = null, h2 = null;
      if (null != b)
        for (d in void 0 !== b.ref && (h2 = b.ref), void 0 !== b.key && (k2 = "" + b.key), b)
          J.call(b, d) && !L$1.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (1 === g)
        c.children = e;
      else if (1 < g) {
        for (var f2 = Array(g), m2 = 0; m2 < g; m2++)
          f2[m2] = arguments[m2 + 2];
        c.children = f2;
      }
      if (a && a.defaultProps)
        for (d in g = a.defaultProps, g)
          void 0 === c[d] && (c[d] = g[d]);
      return { $$typeof: l$1, type: a, key: k2, ref: h2, props: c, _owner: K$1.current };
    }
    function N$1(a, b) {
      return { $$typeof: l$1, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O$1(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l$1;
    }
    function escape(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P$1 = /\/+/g;
    function Q$1(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
    }
    function R$1(a, b, e, d, c) {
      var k2 = typeof a;
      if ("undefined" === k2 || "boolean" === k2)
        a = null;
      var h2 = false;
      if (null === a)
        h2 = true;
      else
        switch (k2) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l$1:
              case n$1:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a, c = c(h2), a = "" === d ? "." + Q$1(h2, 0) : d, I$1(c) ? (e = "", null != a && (e = a.replace(P$1, "$&/") + "/"), R$1(c, b, e, "", function(a2) {
          return a2;
        })) : null != c && (O$1(c) && (c = N$1(c, e + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + a)), b.push(c)), 1;
      h2 = 0;
      d = "" === d ? "." : d + ":";
      if (I$1(a))
        for (var g = 0; g < a.length; g++) {
          k2 = a[g];
          var f2 = d + Q$1(k2, g);
          h2 += R$1(k2, b, e, f2, c);
        }
      else if (f2 = A$1(a), "function" === typeof f2)
        for (a = f2.call(a), g = 0; !(k2 = a.next()).done; )
          k2 = k2.value, f2 = d + Q$1(k2, g++), h2 += R$1(k2, b, e, f2, c);
      else if ("object" === k2)
        throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h2;
    }
    function S$1(a, b, e) {
      if (null == a)
        return a;
      var d = [], c = 0;
      R$1(a, d, "", "", function(a2) {
        return b.call(e, a2, c++);
      });
      return d;
    }
    function T$1(a) {
      if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b2) {
          if (0 === a._status || -1 === a._status)
            a._status = 1, a._result = b2;
        }, function(b2) {
          if (0 === a._status || -1 === a._status)
            a._status = 2, a._result = b2;
        });
        -1 === a._status && (a._status = 0, a._result = b);
      }
      if (1 === a._status)
        return a._result.default;
      throw a._result;
    }
    var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
    react_production_min.Children = { map: S$1, forEach: function(a, b, e) {
      S$1(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      S$1(a, function() {
        b++;
      });
      return b;
    }, toArray: function(a) {
      return S$1(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O$1(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    react_production_min.Component = E$1;
    react_production_min.Fragment = p$2;
    react_production_min.Profiler = r;
    react_production_min.PureComponent = G$1;
    react_production_min.StrictMode = q$1;
    react_production_min.Suspense = w;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
    react_production_min.cloneElement = function(a, b, e) {
      if (null === a || void 0 === a)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C$1({}, a.props), c = a.key, k2 = a.ref, h2 = a._owner;
      if (null != b) {
        void 0 !== b.ref && (k2 = b.ref, h2 = K$1.current);
        void 0 !== b.key && (c = "" + b.key);
        if (a.type && a.type.defaultProps)
          var g = a.type.defaultProps;
        for (f2 in b)
          J.call(b, f2) && !L$1.hasOwnProperty(f2) && (d[f2] = void 0 === b[f2] && void 0 !== g ? g[f2] : b[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        d.children = e;
      else if (1 < f2) {
        g = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g[m2] = arguments[m2 + 2];
        d.children = g;
      }
      return { $$typeof: l$1, type: a.type, key: c, ref: k2, props: d, _owner: h2 };
    };
    react_production_min.createContext = function(a) {
      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t, _context: a };
      return a.Consumer = a;
    };
    react_production_min.createElement = M$1;
    react_production_min.createFactory = function(a) {
      var b = M$1.bind(null, a);
      b.type = a;
      return b;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a) {
      return { $$typeof: v$1, render: a };
    };
    react_production_min.isValidElement = O$1;
    react_production_min.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T$1 };
    };
    react_production_min.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
    };
    react_production_min.startTransition = function(a) {
      var b = V$1.transition;
      V$1.transition = {};
      try {
        a();
      } finally {
        V$1.transition = b;
      }
    };
    react_production_min.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    react_production_min.useCallback = function(a, b) {
      return U$1.current.useCallback(a, b);
    };
    react_production_min.useContext = function(a) {
      return U$1.current.useContext(a);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a) {
      return U$1.current.useDeferredValue(a);
    };
    react_production_min.useEffect = function(a, b) {
      return U$1.current.useEffect(a, b);
    };
    react_production_min.useId = function() {
      return U$1.current.useId();
    };
    react_production_min.useImperativeHandle = function(a, b, e) {
      return U$1.current.useImperativeHandle(a, b, e);
    };
    react_production_min.useInsertionEffect = function(a, b) {
      return U$1.current.useInsertionEffect(a, b);
    };
    react_production_min.useLayoutEffect = function(a, b) {
      return U$1.current.useLayoutEffect(a, b);
    };
    react_production_min.useMemo = function(a, b) {
      return U$1.current.useMemo(a, b);
    };
    react_production_min.useReducer = function(a, b, e) {
      return U$1.current.useReducer(a, b, e);
    };
    react_production_min.useRef = function(a) {
      return U$1.current.useRef(a);
    };
    react_production_min.useState = function(a) {
      return U$1.current.useState(a);
    };
    react_production_min.useSyncExternalStore = function(a, b, e) {
      return U$1.current.useSyncExternalStore(a, b, e);
    };
    react_production_min.useTransition = function() {
      return U$1.current.useTransition();
    };
    react_production_min.version = "18.2.0";
    (function(module2) {
      {
        module2.exports = react_production_min;
      }
    })(react);
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React
    }, [reactExports]);
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f = reactExports, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = { key: true, ref: true, __self: true, __source: true };
    function q(c, a, g) {
      var b, d = {}, e = null, h2 = null;
      void 0 !== g && (e = "" + g);
      void 0 !== a.key && (e = "" + a.key);
      void 0 !== a.ref && (h2 = a.ref);
      for (b in a)
        m$1.call(a, b) && !p$1.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps)
        for (b in a = c.defaultProps, a)
          void 0 === d[b] && (d[b] = a[b]);
      return { $$typeof: k, type: c, key: e, ref: h2, props: d, _owner: n.current };
    }
    reactJsxRuntime_production_min.Fragment = l;
    reactJsxRuntime_production_min.jsx = q;
    reactJsxRuntime_production_min.jsxs = q;
    (function(module2) {
      {
        module2.exports = reactJsxRuntime_production_min;
      }
    })(jsxRuntime);
    var client = {};
    var reactDomExports = {};
    var reactDom = {
      get exports() {
        return reactDomExports;
      },
      set exports(v2) {
        reactDomExports = v2;
      }
    };
    var reactDom_production_min = {};
    var schedulerExports = {};
    var scheduler = {
      get exports() {
        return schedulerExports;
      },
      set exports(v2) {
        schedulerExports = v2;
      }
    };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      function f2(a, b) {
        var c = a.length;
        a.push(b);
        a:
          for (; 0 < c; ) {
            var d = c - 1 >>> 1, e = a[d];
            if (0 < g(e, b))
              a[d] = b, a[c] = e, c = d;
            else
              break a;
          }
      }
      function h2(a) {
        return 0 === a.length ? null : a[0];
      }
      function k2(a) {
        if (0 === a.length)
          return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a:
            for (var d = 0, e = a.length, w2 = e >>> 1; d < w2; ) {
              var m2 = 2 * (d + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
              if (0 > g(C2, c))
                n2 < e && 0 > g(x2, C2) ? (a[d] = x2, a[n2] = c, d = n2) : (a[d] = C2, a[m2] = c, d = m2);
              else if (n2 < e && 0 > g(x2, c))
                a[d] = x2, a[n2] = c, d = n2;
              else
                break a;
            }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G2(a) {
        for (var b = h2(t2); null !== b; ) {
          if (null === b.callback)
            k2(t2);
          else if (b.startTime <= a)
            k2(t2), b.sortIndex = b.expirationTime, f2(r2, b);
          else
            break;
          b = h2(t2);
        }
      }
      function H2(a) {
        B2 = false;
        G2(a);
        if (!A2)
          if (null !== h2(r2))
            A2 = true, I2(J2);
          else {
            var b = h2(t2);
            null !== b && K2(H2, b.startTime - a);
          }
      }
      function J2(a, b) {
        A2 = false;
        B2 && (B2 = false, E2(L2), L2 = -1);
        z2 = true;
        var c = y2;
        try {
          G2(b);
          for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b) || a && !M2()); ) {
            var d = v2.callback;
            if ("function" === typeof d) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e = d(v2.expirationTime <= b);
              b = exports2.unstable_now();
              "function" === typeof e ? v2.callback = e : v2 === h2(r2) && k2(r2);
              G2(b);
            } else
              k2(r2);
            v2 = h2(r2);
          }
          if (null !== v2)
            var w2 = true;
          else {
            var m2 = h2(t2);
            null !== m2 && K2(H2, m2.startTime - b);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c, z2 = false;
        }
      }
      var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
      function M2() {
        return exports2.unstable_now() - Q2 < P2 ? false : true;
      }
      function R2() {
        if (null !== O2) {
          var a = exports2.unstable_now();
          Q2 = a;
          var b = true;
          try {
            b = O2(true, a);
          } finally {
            b ? S2() : (N2 = false, O2 = null);
          }
        } else
          N2 = false;
      }
      var S2;
      if ("function" === typeof F2)
        S2 = function() {
          F2(R2);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T2 = new MessageChannel(), U2 = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U2.postMessage(null);
        };
      } else
        S2 = function() {
          D2(R2, 0);
        };
      function I2(a) {
        O2 = a;
        N2 || (N2 = true, S2());
      }
      function K2(a, b) {
        L2 = D2(function() {
          a(exports2.unstable_now());
        }, b);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I2(J2));
      };
      exports2.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return h2(r2);
      };
      exports2.unstable_next = function(a) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y2;
        }
        var c = y2;
        y2 = b;
        try {
          return a();
        } finally {
          y2 = c;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y2;
        y2 = a;
        try {
          return b();
        } finally {
          y2 = c;
        }
      };
      exports2.unstable_scheduleCallback = function(a, b, c) {
        var d = exports2.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d))) : (a.sortIndex = e, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
        return a;
      };
      exports2.unstable_shouldYield = M2;
      exports2.unstable_wrapCallback = function(a) {
        var b = y2;
        return function() {
          var c = y2;
          y2 = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y2 = c;
          }
        };
      };
    })(scheduler_production_min);
    (function(module2) {
      {
        module2.exports = scheduler_production_min;
      }
    })(scheduler);
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = reactExports, ca = schedulerExports;
    function p(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a, b) {
      ha(a, b);
      ha(a + "Capture", b);
    }
    function ha(a, b) {
      ea[a] = b;
      for (a = 0; a < b.length; a++)
        da.add(b[a]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a) {
      if (ja.call(ma, a))
        return true;
      if (ja.call(la, a))
        return false;
      if (ka.test(a))
        return ma[a] = true;
      la[a] = true;
      return false;
    }
    function pa(a, b, c, d) {
      if (null !== c && 0 === c.type)
        return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d)
            return false;
          if (null !== c)
            return !c.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa(a, b, c, d) {
      if (null === b || "undefined" === typeof b || pa(a, b, c, d))
        return true;
      if (d)
        return false;
      if (null !== c)
        switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
      return false;
    }
    function v(a, b, c, d, e, f2, g) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a;
      this.type = b;
      this.sanitizeURL = f2;
      this.removeEmptyString = g;
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z[a] = new v(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      z[b] = new v(b, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z[a] = new v(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z[a] = new v(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z[a] = new v(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z[a] = new v(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ra,
        sa
      );
      z[b] = new v(b, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b, c, d) {
      var e = z.hasOwnProperty(b) ? z[b] : null;
      if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1])
        qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A = Object.assign, La;
    function Ma(a) {
      if (void 0 === La)
        try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
      return "\n" + La + a;
    }
    var Na = false;
    function Oa(a, b) {
      if (!a || Na)
        return "";
      Na = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b)
          if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l2) {
              var d = l2;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l2) {
              d = l2;
            }
            a.call(b.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l2) {
            d = l2;
          }
          a();
        }
      } catch (l2) {
        if (l2 && d && "string" === typeof l2.stack) {
          for (var e = l2.stack.split("\n"), f2 = d.stack.split("\n"), g = e.length - 1, h2 = f2.length - 1; 1 <= g && 0 <= h2 && e[g] !== f2[h2]; )
            h2--;
          for (; 1 <= g && 0 <= h2; g--, h2--)
            if (e[g] !== f2[h2]) {
              if (1 !== g || 1 !== h2) {
                do
                  if (g--, h2--, 0 > h2 || e[g] !== f2[h2]) {
                    var k2 = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                    return k2;
                  }
                while (1 <= g && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, false), a;
        case 11:
          return a = Oa(a.type.render, false), a;
        case 1:
          return a = Oa(a.type, true), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (null == a)
        return null;
      if ("function" === typeof a)
        return a.displayName || a.name || null;
      if ("string" === typeof a)
        return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a)
        switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
          case Ha:
            b = a._payload;
            a = a._init;
            try {
              return Qa(a(b));
            } catch (c) {
            }
        }
      return null;
    }
    function Ra(a) {
      var b = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b)
            return b.displayName || b.name || null;
          if ("string" === typeof b)
            return b;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    function Ua(a) {
      var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
      if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
        var e = c.get, f2 = c.set;
        Object.defineProperty(a, b, { configurable: true, get: function() {
          return e.call(this);
        }, set: function(a2) {
          d = "" + a2;
          f2.call(this, a2);
        } });
        Object.defineProperty(a, b, { enumerable: c.enumerable });
        return { getValue: function() {
          return d;
        }, setValue: function(a2) {
          d = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b];
        } };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a)
        return false;
      var b = a._valueTracker;
      if (!b)
        return true;
      var c = b.getValue();
      var d = "";
      a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d;
      return a !== c ? (b.setValue(a), true) : false;
    }
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a)
        return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    function Ya(a, b) {
      var c = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
    }
    function Za(a, b) {
      var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
      c = Sa(null != b.value ? b.value : c);
      a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    function ab(a, b) {
      b = b.checked;
      null != b && ta(a, "checked", b, false);
    }
    function bb(a, b) {
      ab(a, b);
      var c = Sa(b.value), d = b.type;
      if (null != c)
        if ("number" === d) {
          if (0 === c && "" === a.value || a.value != c)
            a.value = "" + c;
        } else
          a.value !== "" + c && (a.value = "" + c);
      else if ("submit" === d || "reset" === d) {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
    }
    function db(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
          return;
        b = "" + a._wrapperState.initialValue;
        c || b === a.value || (a.value = b);
        a.defaultValue = b;
      }
      c = a.name;
      "" !== c && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c && (a.name = c);
    }
    function cb(a, b, c) {
      if ("number" !== b || Xa(a.ownerDocument) !== a)
        null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    var eb = Array.isArray;
    function fb(a, b, c, d) {
      a = a.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++)
          b["$" + c[e]] = true;
        for (c = 0; c < a.length; c++)
          e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
      } else {
        c = "" + Sa(c);
        b = null;
        for (e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = true;
            d && (a[e].defaultSelected = true);
            return;
          }
          null !== b || a[e].disabled || (b = a[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    function gb(a, b) {
      if (null != b.dangerouslySetInnerHTML)
        throw Error(p(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b) {
      var c = b.value;
      if (null == c) {
        c = b.children;
        b = b.defaultValue;
        if (null != c) {
          if (null != b)
            throw Error(p(92));
          if (eb(c)) {
            if (1 < c.length)
              throw Error(p(93));
            c = c[0];
          }
          b = c;
        }
        null == b && (b = "");
        c = b;
      }
      a._wrapperState = { initialValue: Sa(c) };
    }
    function ib(a, b) {
      var c = Sa(b.value), d = Sa(b.defaultValue);
      null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
      null != d && (a.defaultValue = "" + d);
    }
    function jb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb, nb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d, e);
        });
      } : a;
    }(function(a, b) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
        a.innerHTML = b;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = mb.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b.firstChild; )
          a.appendChild(b.firstChild);
      }
    });
    function ob(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && 3 === c.nodeType) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b] = pb[a];
      });
    });
    function rb(a, b, c) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
    }
    function sb(a, b) {
      a = a.style;
      for (var c in b)
        if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
    }
    var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b) {
      if (b) {
        if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
          throw Error(p(137, a));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children)
            throw Error(p(60));
          if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML))
            throw Error(p(61));
        }
        if (null != b.style && "object" !== typeof b.style)
          throw Error(p(62));
      }
    }
    function vb(a, b) {
      if (-1 === a.indexOf("-"))
        return "string" === typeof b.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb)
          throw Error(p(280));
        var b = a.stateNode;
        b && (b = Db(b), yb(a.stateNode, a.type, b));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b = Ab;
        Ab = zb = null;
        Bb(a);
        if (b)
          for (a = 0; a < b.length; a++)
            Bb(b[a]);
      }
    }
    function Gb(a, b) {
      return a(b);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a, b, c) {
      if (Ib)
        return a(b, c);
      Ib = true;
      try {
        return Gb(a, b, c);
      } finally {
        if (Ib = false, null !== zb || null !== Ab)
          Hb(), Fb();
      }
    }
    function Kb(a, b) {
      var c = a.stateNode;
      if (null === c)
        return null;
      var d = Db(c);
      if (null === d)
        return null;
      c = d[b];
      a:
        switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;
          default:
            a = false;
        }
      if (a)
        return null;
      if (c && "function" !== typeof c)
        throw Error(p(231, b, typeof c));
      return c;
    }
    var Lb = false;
    if (ia)
      try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
    function Nb(a, b, c, d, e, f2, g, h2, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
      Ob = true;
      Pb = a;
    } };
    function Tb(a, b, c, d, e, f2, g, h2, k2) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a, b, c, d, e, f2, g, h2, k2) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l2 = Pb;
          Ob = false;
          Pb = null;
        } else
          throw Error(p(198));
        Qb || (Qb = true, Rb = l2);
      }
    }
    function Vb(a) {
      var b = a, c = a;
      if (a.alternate)
        for (; b.return; )
          b = b.return;
      else {
        a = b;
        do
          b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
        while (a);
      }
      return 3 === b.tag ? c : null;
    }
    function Wb(a) {
      if (13 === a.tag) {
        var b = a.memoizedState;
        null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
        if (null !== b)
          return b.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a)
        throw Error(p(188));
    }
    function Yb(a) {
      var b = a.alternate;
      if (!b) {
        b = Vb(a);
        if (null === b)
          throw Error(p(188));
        return b !== a ? null : a;
      }
      for (var c = a, d = b; ; ) {
        var e = c.return;
        if (null === e)
          break;
        var f2 = e.alternate;
        if (null === f2) {
          d = e.return;
          if (null !== d) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f2.child) {
          for (f2 = e.child; f2; ) {
            if (f2 === c)
              return Xb(e), a;
            if (f2 === d)
              return Xb(e), b;
            f2 = f2.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d.return)
          c = e, d = f2;
        else {
          for (var g = false, h2 = e.child; h2; ) {
            if (h2 === c) {
              g = true;
              c = e;
              d = f2;
              break;
            }
            if (h2 === d) {
              g = true;
              d = e;
              c = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c) {
                g = true;
                c = f2;
                d = e;
                break;
              }
              if (h2 === d) {
                g = true;
                d = f2;
                c = e;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g)
              throw Error(p(189));
          }
        }
        if (c.alternate !== d)
          throw Error(p(190));
      }
      if (3 !== c.tag)
        throw Error(p(188));
      return c.stateNode.current === c ? a : b;
    }
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    function $b(a) {
      if (5 === a.tag || 6 === a.tag)
        return a;
      for (a = a.child; null !== a; ) {
        var b = $b(a);
        if (null !== b)
          return b;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot)
        try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b) {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b) {
      var c = a.pendingLanes;
      if (0 === c)
        return 0;
      var d = 0, e = a.suspendedLanes, f2 = a.pingedLanes, g = c & 268435455;
      if (0 !== g) {
        var h2 = g & ~e;
        0 !== h2 ? d = tc(h2) : (f2 &= g, 0 !== f2 && (d = tc(f2)));
      } else
        g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f2 && (d = tc(f2));
      if (0 === d)
        return 0;
      if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f2 = b & -b, e >= f2 || 16 === e && 0 !== (f2 & 4194240)))
        return b;
      0 !== (d & 4) && (d |= c & 16);
      b = a.entangledLanes;
      if (0 !== b)
        for (a = a.entanglements, b &= d; 0 < b; )
          c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
      return d;
    }
    function vc(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b) {
      for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
        var g = 31 - oc(f2), h2 = 1 << g, k2 = e[g];
        if (-1 === k2) {
          if (0 === (h2 & c) || 0 !== (h2 & d))
            e[g] = vc(h2, b);
        } else
          k2 <= b && (a.expiredLanes |= h2);
        f2 &= ~h2;
      }
    }
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    function zc(a) {
      for (var b = [], c = 0; 31 > c; c++)
        b.push(a);
      return b;
    }
    function Ac(a, b, c) {
      a.pendingLanes |= b;
      536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b = 31 - oc(b);
      a[b] = c;
    }
    function Bc(a, b) {
      var c = a.pendingLanes & ~b;
      a.pendingLanes = b;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b;
      a.mutableReadLanes &= b;
      a.entangledLanes &= b;
      b = a.entanglements;
      var d = a.eventTimes;
      for (a = a.expirationTimes; 0 < c; ) {
        var e = 31 - oc(c), f2 = 1 << e;
        b[e] = 0;
        d[e] = -1;
        a[e] = -1;
        c &= ~f2;
      }
    }
    function Cc(a, b) {
      var c = a.entangledLanes |= b;
      for (a = a.entanglements; c; ) {
        var d = 31 - oc(c), e = 1 << d;
        e & b | a[d] & b && (a[d] |= b);
        c &= ~e;
      }
    }
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    function Tc(a, b, c, d, e, f2) {
      if (null === a || a.nativeEvent !== f2)
        return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
      a.eventSystemFlags |= d;
      b = a.targetContainers;
      null !== e && -1 === b.indexOf(e) && b.push(e);
      return a;
    }
    function Uc(a, b, c, d, e) {
      switch (b) {
        case "focusin":
          return Lc = Tc(Lc, a, b, c, d, e), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b, c, d, e), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b, c, d, e), true;
        case "pointerover":
          var f2 = e.pointerId;
          Oc.set(f2, Tc(Oc.get(f2) || null, a, b, c, d, e));
          return true;
        case "gotpointercapture":
          return f2 = e.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b, c, d, e)), true;
      }
      return false;
    }
    function Vc(a) {
      var b = Wc(a.target);
      if (null !== b) {
        var c = Vb(b);
        if (null !== c) {
          if (b = c.tag, 13 === b) {
            if (b = Wb(c), null !== b) {
              a.blockedOn = b;
              Ic(a.priority, function() {
                Gc(c);
              });
              return;
            }
          } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (null !== a.blockedOn)
        return false;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (null === c) {
          c = a.nativeEvent;
          var d = new c.constructor(c.type, c);
          wb = d;
          c.target.dispatchEvent(d);
          wb = null;
        } else
          return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
        b.shift();
      }
      return true;
    }
    function Zc(a, b, c) {
      Xc(a) && c.delete(b);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a, b) {
      a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b(b2) {
        return ad(b2, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c = 1; c < Kc.length; c++) {
          var d = Kc[c];
          d.blockedOn === a && (d.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b);
      Pc.forEach(b);
      for (c = 0; c < Qc.length; c++)
        d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
      for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); )
        Vc(c), null === c.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a, b, c, d) {
      var e = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f2;
      }
    }
    function gd(a, b, c, d) {
      var e = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f2;
      }
    }
    function fd(a, b, c, d) {
      if (dd) {
        var e = Yc(a, b, c, d);
        if (null === e)
          hd(a, b, d, id, c), Sc(a, d);
        else if (Uc(e, a, b, c, d))
          d.stopPropagation();
        else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e; ) {
            var f2 = Cb(e);
            null !== f2 && Ec(f2);
            f2 = Yc(a, b, c, d);
            null === f2 && hd(a, b, d, id, c);
            if (f2 === e)
              break;
            e = f2;
          }
          null !== e && d.stopPropagation();
        } else
          hd(a, b, d, null, c);
      }
    }
    var id = null;
    function Yc(a, b, c, d) {
      id = null;
      a = xb(d);
      a = Wc(a);
      if (null !== a)
        if (b = Vb(a), null === b)
          a = null;
        else if (c = b.tag, 13 === c) {
          a = Wb(b);
          if (null !== a)
            return a;
          a = null;
        } else if (3 === c) {
          if (b.stateNode.current.memoizedState.isDehydrated)
            return 3 === b.tag ? b.stateNode.containerInfo : null;
          a = null;
        } else
          b !== a && (a = null);
      id = a;
      return null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f2 = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++)
        ;
      var g = c - a;
      for (d = 1; d <= g && b[c - d] === e[f2 - d]; d++)
        ;
      return md = e.slice(a, 1 < d ? 1 - d : void 0);
    }
    function od(a) {
      var b = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b(b2, d, e, f2, g) {
        this._reactName = b2;
        this._targetInst = e;
        this.type = d;
        this.nativeEvent = f2;
        this.target = g;
        this.currentTarget = null;
        for (var c in a)
          a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f2) : f2[c]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A(b.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a)
        return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id$1 = A({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd = rd(Id$1), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A({}, ud, { key: function(a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if ("Unidentified" !== b)
          return b;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b) {
      if (ie)
        return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length)
              return b.char;
            if (b.which)
              return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
    }
    function ne(a, b, c, d) {
      Eb(d);
      b = oe(b, "onChange");
      0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
    }
    var pe = null, qe = null;
    function re$1(a) {
      se(a, 0);
    }
    function te(a) {
      var b = ue(a);
      if (Wa(b))
        return a;
    }
    function ve(a, b) {
      if ("change" === a)
        return b;
    }
    var we = false;
    if (ia) {
      var xe;
      if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b = [];
        ne(b, qe, a, xb(a));
        Jb(re$1, b);
      }
    }
    function Ce(a, b, c) {
      "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
    }
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a)
        return te(qe);
    }
    function Ee(a, b) {
      if ("click" === a)
        return te(b);
    }
    function Fe(a, b) {
      if ("input" === a || "change" === a)
        return te(b);
    }
    function Ge(a, b) {
      return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a, b) {
      if (He(a, b))
        return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b || null === b)
        return false;
      var c = Object.keys(a), d = Object.keys(b);
      if (c.length !== d.length)
        return false;
      for (d = 0; d < c.length; d++) {
        var e = c[d];
        if (!ja.call(b, e) || !He(a[e], b[e]))
          return false;
      }
      return true;
    }
    function Je(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Ke(a, b) {
      var c = Je(a);
      a = 0;
      for (var d; c; ) {
        if (3 === c.nodeType) {
          d = a + c.textContent.length;
          if (a <= b && d >= b)
            return { node: c, offset: b - a };
          a = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Je(c);
      }
    }
    function Le(a, b) {
      return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
    }
    function Me() {
      for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = "string" === typeof b.contentWindow.location.href;
        } catch (d) {
          c = false;
        }
        if (c)
          a = b.contentWindow;
        else
          break;
        b = Xa(a.document);
      }
      return b;
    }
    function Ne(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
    }
    function Oe(a) {
      var b = Me(), c = a.focusedElem, d = a.selectionRange;
      if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
        if (null !== d && Ne(c)) {
          if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c)
            c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
          else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e = c.textContent.length, f2 = Math.min(d.start, e);
            d = void 0 === d.end ? f2 : Math.min(d.end, e);
            !a.extend && f2 > d && (e = d, d = f2, f2 = e);
            e = Ke(c, f2);
            var g = Ke(
              c,
              d
            );
            e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f2 > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
          }
        }
        b = [];
        for (a = c; a = a.parentNode; )
          1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c.focus && c.focus();
        for (c = 0; c < b.length; c++)
          a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a, b, c) {
      var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
      Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
    }
    function Ve(a, b) {
      var c = {};
      c[a.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a] = "webkit" + b;
      c["Moz" + a] = "moz" + b;
      return c;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a])
        return Xe[a];
      if (!We[a])
        return a;
      var b = We[a], c;
      for (c in b)
        if (b.hasOwnProperty(c) && c in Ye)
          return Xe[a] = b[c];
      return a;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b) {
      df.set(a, b);
      fa(b, [a]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b, c) {
      var d = a.type || "unknown-event";
      a.currentTarget = c;
      Ub(d, b, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b) {
      b = 0 !== (b & 4);
      for (var c = 0; c < a.length; c++) {
        var d = a[c], e = d.event;
        d = d.listeners;
        a: {
          var f2 = void 0;
          if (b)
            for (var g = d.length - 1; 0 <= g; g--) {
              var h2 = d[g], k2 = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e.isPropagationStopped())
                break a;
              nf(e, h2, l2);
              f2 = k2;
            }
          else
            for (g = 0; g < d.length; g++) {
              h2 = d[g];
              k2 = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e.isPropagationStopped())
                break a;
              nf(e, h2, l2);
              f2 = k2;
            }
        }
      }
      if (Qb)
        throw a = Rb, Qb = false, Rb = null, a;
    }
    function D(a, b) {
      var c = b[of];
      void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
      var d = a + "__bubble";
      c.has(d) || (pf(b, a, 2, false), c.add(d));
    }
    function qf(a, b, c) {
      var d = 0;
      b && (d |= 4);
      pf(c, a, d, b);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function(b2) {
          "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
        });
        var b = 9 === a.nodeType ? a : a.ownerDocument;
        null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
      }
    }
    function pf(a, b, c, d) {
      switch (jd(b)) {
        case 1:
          var e = ed;
          break;
        case 4:
          e = gd;
          break;
        default:
          e = fd;
      }
      c = e.bind(null, b, c, a);
      e = void 0;
      !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
      d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
    }
    function hd(a, b, c, d, e) {
      var f2 = d;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d)
        a:
          for (; ; ) {
            if (null === d)
              return;
            var g = d.tag;
            if (3 === g || 4 === g) {
              var h2 = d.stateNode.containerInfo;
              if (h2 === e || 8 === h2.nodeType && h2.parentNode === e)
                break;
              if (4 === g)
                for (g = d.return; null !== g; ) {
                  var k2 = g.tag;
                  if (3 === k2 || 4 === k2) {
                    if (k2 = g.stateNode.containerInfo, k2 === e || 8 === k2.nodeType && k2.parentNode === e)
                      return;
                  }
                  g = g.return;
                }
              for (; null !== h2; ) {
                g = Wc(h2);
                if (null === g)
                  return;
                k2 = g.tag;
                if (5 === k2 || 6 === k2) {
                  d = f2 = g;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d = d.return;
          }
      Jb(function() {
        var d2 = f2, e2 = xb(c), g2 = [];
        a: {
          var h3 = df.get(a);
          if (void 0 !== h3) {
            var k3 = td, n2 = a;
            switch (a) {
              case "keypress":
                if (0 === od(c))
                  break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                n2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                n2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k3 = Hd;
                break;
              case cf:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td;
            }
            var t2 = 0 !== (b & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
            t2 = [];
            for (var w2 = d2, u2; null !== w2; ) {
              u2 = w2;
              var F2 = u2.stateNode;
              5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
              if (J2)
                break;
              w2 = w2.return;
            }
            0 < t2.length && (h3 = new k3(h3, n2, null, c, e2), g2.push({ event: h3, listeners: t2 }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h3 = "mouseover" === a || "pointerover" === a;
            k3 = "mouseout" === a || "pointerout" === a;
            if (h3 && c !== wb && (n2 = c.relatedTarget || c.fromElement) && (Wc(n2) || n2[uf]))
              break a;
            if (k3 || h3) {
              h3 = e2.window === e2 ? e2 : (h3 = e2.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k3) {
                if (n2 = c.relatedTarget || c.toElement, k3 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                  n2 = null;
              } else
                k3 = null, n2 = d2;
              if (k3 !== n2) {
                t2 = Bd;
                F2 = "onMouseLeave";
                x2 = "onMouseEnter";
                w2 = "mouse";
                if ("pointerout" === a || "pointerover" === a)
                  t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                J2 = null == k3 ? h3 : ue(k3);
                u2 = null == n2 ? h3 : ue(n2);
                h3 = new t2(F2, w2 + "leave", k3, c, e2);
                h3.target = J2;
                h3.relatedTarget = u2;
                F2 = null;
                Wc(e2) === d2 && (t2 = new t2(x2, w2 + "enter", n2, c, e2), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
                J2 = F2;
                if (k3 && n2)
                  b: {
                    t2 = k3;
                    x2 = n2;
                    w2 = 0;
                    for (u2 = t2; u2; u2 = vf(u2))
                      w2++;
                    u2 = 0;
                    for (F2 = x2; F2; F2 = vf(F2))
                      u2++;
                    for (; 0 < w2 - u2; )
                      t2 = vf(t2), w2--;
                    for (; 0 < u2 - w2; )
                      x2 = vf(x2), u2--;
                    for (; w2--; ) {
                      if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                        break b;
                      t2 = vf(t2);
                      x2 = vf(x2);
                    }
                    t2 = null;
                  }
                else
                  t2 = null;
                null !== k3 && wf(g2, h3, k3, t2, false);
                null !== n2 && null !== J2 && wf(g2, J2, n2, t2, true);
              }
            }
          }
          a: {
            h3 = d2 ? ue(d2) : window;
            k3 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h3.type)
              var na = ve;
            else if (me(h3))
              if (we)
                na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
            else
              (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
            if (na && (na = na(a, d2))) {
              ne(g2, na, c, e2);
              break a;
            }
            xa && xa(a, h3, d2);
            "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
          }
          xa = d2 ? ue(d2) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable)
                Qe = xa, Re = d2, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g2, c, e2);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g2, c, e2);
          }
          var $a;
          if (ae)
            b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a, c) : ke(a, c))
            d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
        }
        se(g2, b);
      });
    }
    function tf(a, b, c) {
      return { instance: a, listener: b, currentTarget: c };
    }
    function oe(a, b) {
      for (var c = b + "Capture", d = []; null !== a; ) {
        var e = a, f2 = e.stateNode;
        5 === e.tag && null !== f2 && (e = f2, f2 = Kb(a, c), null != f2 && d.unshift(tf(a, f2, e)), f2 = Kb(a, b), null != f2 && d.push(tf(a, f2, e)));
        a = a.return;
      }
      return d;
    }
    function vf(a) {
      if (null === a)
        return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf(a, b, c, d, e) {
      for (var f2 = b._reactName, g = []; null !== c && c !== d; ) {
        var h2 = c, k2 = h2.alternate, l2 = h2.stateNode;
        if (null !== k2 && k2 === d)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e ? (k2 = Kb(c, f2), null != k2 && g.unshift(tf(c, k2, h2))) : e || (k2 = Kb(c, f2), null != k2 && g.push(tf(c, k2, h2))));
        c = c.return;
      }
      0 !== g.length && a.push({ event: b, listeners: g });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    function Af(a, b, c) {
      b = zf(b);
      if (zf(a) !== b && c)
        throw Error(p(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a, b) {
      return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b) {
      var c = b, d = 0;
      do {
        var e = c.nextSibling;
        a.removeChild(c);
        if (e && 8 === e.nodeType)
          if (c = e.data, "/$" === c) {
            if (0 === d) {
              a.removeChild(e);
              bd(b);
              return;
            }
            d--;
          } else
            "$" !== c && "$?" !== c && "$!" !== c || d++;
        c = e;
      } while (c);
      bd(b);
    }
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b = a.nodeType;
        if (1 === b || 3 === b)
          break;
        if (8 === b) {
          b = a.data;
          if ("$" === b || "$!" === b || "$?" === b)
            break;
          if ("/$" === b)
            return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("$" === c || "$!" === c || "$?" === c) {
            if (0 === b)
              return a;
            b--;
          } else
            "/$" === c && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b = a[Of];
      if (b)
        return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[uf] || c[Of]) {
          c = b.alternate;
          if (null !== b.child || null !== c && null !== c.child)
            for (a = Mf(a); null !== a; ) {
              if (c = a[Of])
                return c;
              a = Mf(a);
            }
          return b;
        }
        a = c;
        c = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function ue(a) {
      if (5 === a.tag || 6 === a.tag)
        return a.stateNode;
      throw Error(p(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a, b) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a, b) {
      var c = a.type.contextTypes;
      if (!c)
        return Vf;
      var d = a.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
        return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f2;
      for (f2 in c)
        e[f2] = b[f2];
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a, b, c) {
      if (H.current !== Vf)
        throw Error(p(168));
      G(H, b);
      G(Wf, c);
    }
    function bg(a, b, c) {
      var d = a.stateNode;
      b = b.childContextTypes;
      if ("function" !== typeof d.getChildContext)
        return c;
      d = d.getChildContext();
      for (var e in d)
        if (!(e in b))
          throw Error(p(108, Ra(a) || "Unknown", e));
      return A({}, c, d);
    }
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a, b, c) {
      var d = a.stateNode;
      if (!d)
        throw Error(p(169));
      c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
      G(Wf, c);
    }
    var eg = null, fg = false, gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = true;
      hg(a);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b = C;
        try {
          var c = eg;
          for (C = 1; a < c.length; a++) {
            var d = c[a];
            do
              d = d(true);
            while (null !== d);
          }
          eg = null;
          fg = false;
        } catch (e) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
        } finally {
          C = b, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a, b) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b;
    }
    function ug(a, b, c) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d = rg;
      a = sg;
      var e = 32 - oc(d) - 1;
      d &= ~(1 << e);
      c += 1;
      var f2 = 32 - oc(b) + e;
      if (30 < f2) {
        var g = e - e % 5;
        f2 = (d & (1 << g) - 1).toString(32);
        d >>= g;
        e -= g;
        rg = 1 << 32 - oc(b) + e | c << e | d;
        sg = f2 + a;
      } else
        rg = 1 << f2 | c << e | d, sg = a;
    }
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = false, zg = null;
    function Ag(a, b) {
      var c = Bg(5, null, null, 0);
      c.elementType = "DELETED";
      c.stateNode = b;
      c.return = a;
      b = a.deletions;
      null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
    }
    function Cg(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
        case 6:
          return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
        case 13:
          return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg(a) {
      if (I) {
        var b = yg;
        if (b) {
          var c = b;
          if (!Cg(a, b)) {
            if (Dg(a))
              throw Error(p(418));
            b = Lf(c.nextSibling);
            var d = xg;
            b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
          }
        } else {
          if (Dg(a))
            throw Error(p(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
        a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg)
        return false;
      if (!I)
        return Fg(a), I = true, false;
      var b;
      (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
      if (b && (b = yg)) {
        if (Dg(a))
          throw Hg(), Error(p(418));
        for (; b; )
          Ag(a, b), b = Lf(b.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a)
          throw Error(p(317));
        a: {
          a = a.nextSibling;
          for (b = 0; a; ) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("/$" === c) {
                if (0 === b) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b--;
              } else
                "$" !== c && "$!" !== c && "$?" !== c || b++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a = yg; a; )
        a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b);
        a = a.defaultProps;
        for (var c in a)
          void 0 === b[c] && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    var Mg = Uf(null), Ng = null, Og = null, Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    function Rg(a) {
      var b = Mg.current;
      E(Mg);
      a._currentValue = b;
    }
    function Sg(a, b, c) {
      for (; null !== a; ) {
        var d = a.alternate;
        (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
        if (a === c)
          break;
        a = a.return;
      }
    }
    function Tg(a, b) {
      Ng = a;
      Pg = Og = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = true), a.firstContext = null);
    }
    function Vg(a) {
      var b = a._currentValue;
      if (Pg !== a)
        if (a = { context: a, memoizedValue: b, next: null }, null === Og) {
          if (null === Ng)
            throw Error(p(308));
          Og = a;
          Ng.dependencies = { lanes: 0, firstContext: a };
        } else
          Og = Og.next = a;
      return b;
    }
    var Wg = null;
    function Xg(a) {
      null === Wg ? Wg = [a] : Wg.push(a);
    }
    function Yg(a, b, c, d) {
      var e = b.interleaved;
      null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
      b.interleaved = c;
      return Zg(a, d);
    }
    function Zg(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      null !== c && (c.lanes |= b);
      c = a;
      for (a = a.return; null !== a; )
        a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
      return 3 === c.tag ? c.stateNode : null;
    }
    var $g = false;
    function ah(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function bh(a, b) {
      a = a.updateQueue;
      b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function ch(a, b) {
      return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    function dh(a, b, c) {
      var d = a.updateQueue;
      if (null === d)
        return null;
      d = d.shared;
      if (0 !== (K & 2)) {
        var e = d.pending;
        null === e ? b.next = b : (b.next = e.next, e.next = b);
        d.pending = b;
        return Zg(a, c);
      }
      e = d.interleaved;
      null === e ? (b.next = b, Xg(d)) : (b.next = e.next, e.next = b);
      d.interleaved = b;
      return Zg(a, c);
    }
    function eh(a, b, c) {
      b = b.updateQueue;
      if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc(a, c);
      }
    }
    function fh(a, b) {
      var c = a.updateQueue, d = a.alternate;
      if (null !== d && (d = d.updateQueue, c === d)) {
        var e = null, f2 = null;
        c = c.firstBaseUpdate;
        if (null !== c) {
          do {
            var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
            null === f2 ? e = f2 = g : f2 = f2.next = g;
            c = c.next;
          } while (null !== c);
          null === f2 ? e = f2 = b : f2 = f2.next = b;
        } else
          e = f2 = b;
        c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
        a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate;
      null === a ? c.firstBaseUpdate = b : a.next = b;
      c.lastBaseUpdate = b;
    }
    function gh(a, b, c, d) {
      var e = a.updateQueue;
      $g = false;
      var f2 = e.firstBaseUpdate, g = e.lastBaseUpdate, h2 = e.shared.pending;
      if (null !== h2) {
        e.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        null === g ? f2 = l2 : g.next = l2;
        g = k2;
        var m2 = a.alternate;
        null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
      }
      if (null !== f2) {
        var q2 = e.baseState;
        g = 0;
        m2 = l2 = k2 = null;
        h2 = f2;
        do {
          var r2 = h2.lane, y2 = h2.eventTime;
          if ((d & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y2,
              lane: 0,
              tag: h2.tag,
              payload: h2.payload,
              callback: h2.callback,
              next: null
            });
            a: {
              var n2 = a, t2 = h2;
              r2 = b;
              y2 = c;
              switch (t2.tag) {
                case 1:
                  n2 = t2.payload;
                  if ("function" === typeof n2) {
                    q2 = n2.call(y2, q2, r2);
                    break a;
                  }
                  q2 = n2;
                  break a;
                case 3:
                  n2.flags = n2.flags & -65537 | 128;
                case 0:
                  n2 = t2.payload;
                  r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                  if (null === r2 || void 0 === r2)
                    break a;
                  q2 = A({}, q2, r2);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h2] : r2.push(h2));
          } else
            y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g |= r2;
          h2 = h2.next;
          if (null === h2)
            if (h2 = e.shared.pending, null === h2)
              break;
            else
              r2 = h2, h2 = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
        } while (1);
        null === m2 && (k2 = q2);
        e.baseState = k2;
        e.firstBaseUpdate = l2;
        e.lastBaseUpdate = m2;
        b = e.shared.interleaved;
        if (null !== b) {
          e = b;
          do
            g |= e.lane, e = e.next;
          while (e !== b);
        } else
          null === f2 && (e.shared.lanes = 0);
        hh |= g;
        a.lanes = g;
        a.memoizedState = q2;
      }
    }
    function ih(a, b, c) {
      a = b.effects;
      b.effects = null;
      if (null !== a)
        for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e)
              throw Error(p(191, e));
            e.call(d);
          }
        }
    }
    var jh = new aa.Component().refs;
    function kh(a, b, c, d) {
      b = a.memoizedState;
      c = c(d, b);
      c = null === c || void 0 === c ? b : A({}, b, c);
      a.memoizedState = c;
      0 === a.lanes && (a.updateQueue.baseState = c);
    }
    var nh = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, enqueueSetState: function(a, b, c) {
      a = a._reactInternals;
      var d = L(), e = lh(a), f2 = ch(d, e);
      f2.payload = b;
      void 0 !== c && null !== c && (f2.callback = c);
      b = dh(a, f2, e);
      null !== b && (mh(b, a, e, d), eh(b, a, e));
    }, enqueueReplaceState: function(a, b, c) {
      a = a._reactInternals;
      var d = L(), e = lh(a), f2 = ch(d, e);
      f2.tag = 1;
      f2.payload = b;
      void 0 !== c && null !== c && (f2.callback = c);
      b = dh(a, f2, e);
      null !== b && (mh(b, a, e, d), eh(b, a, e));
    }, enqueueForceUpdate: function(a, b) {
      a = a._reactInternals;
      var c = L(), d = lh(a), e = ch(c, d);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      b = dh(a, e, d);
      null !== b && (mh(b, a, d, c), eh(b, a, d));
    } };
    function oh(a, b, c, d, e, f2, g) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f2) : true;
    }
    function ph(a, b, c) {
      var d = false, e = Vf;
      var f2 = b.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
      b = new b(c, f2);
      a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = nh;
      a.stateNode = b;
      b._reactInternals = a;
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f2);
      return b;
    }
    function qh(a, b, c, d) {
      a = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
      b.state !== a && nh.enqueueReplaceState(b, b.state, null);
    }
    function rh(a, b, c, d) {
      var e = a.stateNode;
      e.props = c;
      e.state = a.memoizedState;
      e.refs = jh;
      ah(a);
      var f2 = b.contextType;
      "object" === typeof f2 && null !== f2 ? e.context = Vg(f2) : (f2 = Zf(b) ? Xf : H.current, e.context = Yf(a, f2));
      e.state = a.memoizedState;
      f2 = b.getDerivedStateFromProps;
      "function" === typeof f2 && (kh(a, b, f2, c), e.state = a.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d), e.state = a.memoizedState);
      "function" === typeof e.componentDidMount && (a.flags |= 4194308);
    }
    function sh(a, b, c) {
      a = c.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (1 !== c.tag)
              throw Error(p(309));
            var d = c.stateNode;
          }
          if (!d)
            throw Error(p(147, a));
          var e = d, f2 = "" + a;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f2)
            return b.ref;
          b = function(a2) {
            var b2 = e.refs;
            b2 === jh && (b2 = e.refs = {});
            null === a2 ? delete b2[f2] : b2[f2] = a2;
          };
          b._stringRef = f2;
          return b;
        }
        if ("string" !== typeof a)
          throw Error(p(284));
        if (!c._owner)
          throw Error(p(290, a));
      }
      return a;
    }
    function th(a, b) {
      a = Object.prototype.toString.call(b);
      throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
    }
    function uh(a) {
      var b = a._init;
      return b(a._payload);
    }
    function vh(a) {
      function b(b2, c2) {
        if (a) {
          var d2 = b2.deletions;
          null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
        }
      }
      function c(c2, d2) {
        if (!a)
          return null;
        for (; null !== d2; )
          b(c2, d2), d2 = d2.sibling;
        return null;
      }
      function d(a2, b2) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b2; )
          null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
        return a2;
      }
      function e(a2, b2) {
        a2 = wh(a2, b2);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f2(b2, c2, d2) {
        b2.index = d2;
        if (!a)
          return b2.flags |= 1048576, c2;
        d2 = b2.alternate;
        if (null !== d2)
          return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
        b2.flags |= 2;
        return c2;
      }
      function g(b2) {
        a && null === b2.alternate && (b2.flags |= 2);
        return b2;
      }
      function h2(a2, b2, c2, d2) {
        if (null === b2 || 6 !== b2.tag)
          return b2 = xh(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function k2(a2, b2, c2, d2) {
        var f3 = c2.type;
        if (f3 === ya)
          return m2(a2, b2, c2.props.children, d2, c2.key);
        if (null !== b2 && (b2.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b2.type))
          return d2 = e(b2, c2.props), d2.ref = sh(a2, b2, c2), d2.return = a2, d2;
        d2 = yh(c2.type, c2.key, c2.props, null, a2.mode, d2);
        d2.ref = sh(a2, b2, c2);
        d2.return = a2;
        return d2;
      }
      function l2(a2, b2, c2, d2) {
        if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
          return b2 = zh(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2.children || []);
        b2.return = a2;
        return b2;
      }
      function m2(a2, b2, c2, d2, f3) {
        if (null === b2 || 7 !== b2.tag)
          return b2 = Ah(c2, a2.mode, d2, f3), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function q2(a2, b2, c2) {
        if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2)
          return b2 = xh("" + b2, a2.mode, c2), b2.return = a2, b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case va:
              return c2 = yh(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = sh(a2, null, b2), c2.return = a2, c2;
            case wa:
              return b2 = zh(b2, a2.mode, c2), b2.return = a2, b2;
            case Ha:
              var d2 = b2._init;
              return q2(a2, d2(b2._payload), c2);
          }
          if (eb(b2) || Ka(b2))
            return b2 = Ah(b2, a2.mode, c2, null), b2.return = a2, b2;
          th(a2, b2);
        }
        return null;
      }
      function r2(a2, b2, c2, d2) {
        var e2 = null !== b2 ? b2.key : null;
        if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2)
          return null !== e2 ? null : h2(a2, b2, "" + c2, d2);
        if ("object" === typeof c2 && null !== c2) {
          switch (c2.$$typeof) {
            case va:
              return c2.key === e2 ? k2(a2, b2, c2, d2) : null;
            case wa:
              return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
            case Ha:
              return e2 = c2._init, r2(
                a2,
                b2,
                e2(c2._payload),
                d2
              );
          }
          if (eb(c2) || Ka(c2))
            return null !== e2 ? null : m2(a2, b2, c2, d2, null);
          th(a2, c2);
        }
        return null;
      }
      function y2(a2, b2, c2, d2, e2) {
        if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2)
          return a2 = a2.get(c2) || null, h2(b2, a2, "" + d2, e2);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case va:
              return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k2(b2, a2, d2, e2);
            case wa:
              return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
            case Ha:
              var f3 = d2._init;
              return y2(a2, b2, c2, f3(d2._payload), e2);
          }
          if (eb(d2) || Ka(d2))
            return a2 = a2.get(c2) || null, m2(b2, a2, d2, e2, null);
          th(b2, d2);
        }
        return null;
      }
      function n2(e2, g2, h3, k3) {
        for (var l3 = null, m3 = null, u2 = g2, w2 = g2 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
          u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
          var n3 = r2(e2, u2, h3[w2], k3);
          if (null === n3) {
            null === u2 && (u2 = x2);
            break;
          }
          a && u2 && null === n3.alternate && b(e2, u2);
          g2 = f2(n3, g2, w2);
          null === m3 ? l3 = n3 : m3.sibling = n3;
          m3 = n3;
          u2 = x2;
        }
        if (w2 === h3.length)
          return c(e2, u2), I && tg(e2, w2), l3;
        if (null === u2) {
          for (; w2 < h3.length; w2++)
            u2 = q2(e2, h3[w2], k3), null !== u2 && (g2 = f2(u2, g2, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
          I && tg(e2, w2);
          return l3;
        }
        for (u2 = d(e2, u2); w2 < h3.length; w2++)
          x2 = y2(u2, e2, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g2 = f2(x2, g2, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
        a && u2.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w2);
        return l3;
      }
      function t2(e2, g2, h3, k3) {
        var l3 = Ka(h3);
        if ("function" !== typeof l3)
          throw Error(p(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(p(151));
        for (var u2 = l3 = null, m3 = g2, w2 = g2 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
          m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
          var t3 = r2(e2, m3, n3.value, k3);
          if (null === t3) {
            null === m3 && (m3 = x2);
            break;
          }
          a && m3 && null === t3.alternate && b(e2, m3);
          g2 = f2(t3, g2, w2);
          null === u2 ? l3 = t3 : u2.sibling = t3;
          u2 = t3;
          m3 = x2;
        }
        if (n3.done)
          return c(
            e2,
            m3
          ), I && tg(e2, w2), l3;
        if (null === m3) {
          for (; !n3.done; w2++, n3 = h3.next())
            n3 = q2(e2, n3.value, k3), null !== n3 && (g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          I && tg(e2, w2);
          return l3;
        }
        for (m3 = d(e2, m3); !n3.done; w2++, n3 = h3.next())
          n3 = y2(m3, e2, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        a && m3.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w2);
        return l3;
      }
      function J2(a2, d2, f3, h3) {
        "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
        if ("object" === typeof f3 && null !== f3) {
          switch (f3.$$typeof) {
            case va:
              a: {
                for (var k3 = f3.key, l3 = d2; null !== l3; ) {
                  if (l3.key === k3) {
                    k3 = f3.type;
                    if (k3 === ya) {
                      if (7 === l3.tag) {
                        c(a2, l3.sibling);
                        d2 = e(l3, f3.props.children);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                    } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                      c(a2, l3.sibling);
                      d2 = e(l3, f3.props);
                      d2.ref = sh(a2, l3, f3);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    c(a2, l3);
                    break;
                  } else
                    b(a2, l3);
                  l3 = l3.sibling;
                }
                f3.type === ya ? (d2 = Ah(f3.props.children, a2.mode, h3, f3.key), d2.return = a2, a2 = d2) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d2, f3), h3.return = a2, a2 = h3);
              }
              return g(a2);
            case wa:
              a: {
                for (l3 = f3.key; null !== d2; ) {
                  if (d2.key === l3)
                    if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f3.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                  else
                    b(a2, d2);
                  d2 = d2.sibling;
                }
                d2 = zh(f3, a2.mode, h3);
                d2.return = a2;
                a2 = d2;
              }
              return g(a2);
            case Ha:
              return l3 = f3._init, J2(a2, d2, l3(f3._payload), h3);
          }
          if (eb(f3))
            return n2(a2, d2, f3, h3);
          if (Ka(f3))
            return t2(a2, d2, f3, h3);
          th(a2, f3);
        }
        return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = xh(f3, a2.mode, h3), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
      }
      return J2;
    }
    var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
    function Hh(a) {
      if (a === Dh)
        throw Error(p(174));
      return a;
    }
    function Ih(a, b) {
      G(Gh, b);
      G(Fh, a);
      G(Eh, Dh);
      a = b.nodeType;
      switch (a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
      }
      E(Eh);
      G(Eh, b);
    }
    function Jh() {
      E(Eh);
      E(Fh);
      E(Gh);
    }
    function Kh(a) {
      Hh(Gh.current);
      var b = Hh(Eh.current);
      var c = lb(b, a.type);
      b !== c && (G(Fh, a), G(Eh, c));
    }
    function Lh(a) {
      Fh.current === a && (E(Eh), E(Fh));
    }
    var M = Uf(0);
    function Mh(a) {
      for (var b = a; null !== b; ) {
        if (13 === b.tag) {
          var c = b.memoizedState;
          if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
            return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 128))
            return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a)
          break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var Nh = [];
    function Oh() {
      for (var a = 0; a < Nh.length; a++)
        Nh[a]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
    function Q() {
      throw Error(p(321));
    }
    function Wh(a, b) {
      if (null === b)
        return false;
      for (var c = 0; c < b.length && c < a.length; c++)
        if (!He(a[c], b[c]))
          return false;
      return true;
    }
    function Xh(a, b, c, d, e, f2) {
      Rh = f2;
      N = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
      a = c(d, e);
      if (Th) {
        f2 = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f2)
            throw Error(p(301));
          f2 += 1;
          P = O = null;
          b.updateQueue = null;
          Ph.current = $h;
          a = c(d, e);
        } while (Th);
      }
      Ph.current = ai;
      b = null !== O && null !== O.next;
      Rh = 0;
      P = O = N = null;
      Sh = false;
      if (b)
        throw Error(p(300));
      return a;
    }
    function bi() {
      var a = 0 !== Uh;
      Uh = 0;
      return a;
    }
    function ci() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P ? N.memoizedState = P = a : P = P.next = a;
      return P;
    }
    function di() {
      if (null === O) {
        var a = N.alternate;
        a = null !== a ? a.memoizedState : null;
      } else
        a = O.next;
      var b = null === P ? N.memoizedState : P.next;
      if (null !== b)
        P = b, O = a;
      else {
        if (null === a)
          throw Error(p(310));
        O = a;
        a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
        null === P ? N.memoizedState = P = a : P = P.next = a;
      }
      return P;
    }
    function ei(a, b) {
      return "function" === typeof b ? b(a) : b;
    }
    function fi(a) {
      var b = di(), c = b.queue;
      if (null === c)
        throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = O, e = d.baseQueue, f2 = c.pending;
      if (null !== f2) {
        if (null !== e) {
          var g = e.next;
          e.next = f2.next;
          f2.next = g;
        }
        d.baseQueue = e = f2;
        c.pending = null;
      }
      if (null !== e) {
        f2 = e.next;
        d = d.baseState;
        var h2 = g = null, k2 = null, l2 = f2;
        do {
          var m2 = l2.lane;
          if ((Rh & m2) === m2)
            null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a(d, l2.action);
          else {
            var q2 = {
              lane: m2,
              action: l2.action,
              hasEagerState: l2.hasEagerState,
              eagerState: l2.eagerState,
              next: null
            };
            null === k2 ? (h2 = k2 = q2, g = d) : k2 = k2.next = q2;
            N.lanes |= m2;
            hh |= m2;
          }
          l2 = l2.next;
        } while (null !== l2 && l2 !== f2);
        null === k2 ? g = d : k2.next = h2;
        He(d, b.memoizedState) || (Ug = true);
        b.memoizedState = d;
        b.baseState = g;
        b.baseQueue = k2;
        c.lastRenderedState = d;
      }
      a = c.interleaved;
      if (null !== a) {
        e = a;
        do
          f2 = e.lane, N.lanes |= f2, hh |= f2, e = e.next;
        while (e !== a);
      } else
        null === e && (c.lanes = 0);
      return [b.memoizedState, c.dispatch];
    }
    function gi(a) {
      var b = di(), c = b.queue;
      if (null === c)
        throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = c.dispatch, e = c.pending, f2 = b.memoizedState;
      if (null !== e) {
        c.pending = null;
        var g = e = e.next;
        do
          f2 = a(f2, g.action), g = g.next;
        while (g !== e);
        He(f2, b.memoizedState) || (Ug = true);
        b.memoizedState = f2;
        null === b.baseQueue && (b.baseState = f2);
        c.lastRenderedState = f2;
      }
      return [f2, d];
    }
    function hi() {
    }
    function ii(a, b) {
      var c = N, d = di(), e = b(), f2 = !He(d.memoizedState, e);
      f2 && (d.memoizedState = e, Ug = true);
      d = d.queue;
      ji(ki.bind(null, c, d, a), [a]);
      if (d.getSnapshot !== b || f2 || null !== P && P.memoizedState.tag & 1) {
        c.flags |= 2048;
        li(9, mi.bind(null, c, d, e, b), void 0, null);
        if (null === R)
          throw Error(p(349));
        0 !== (Rh & 30) || ni(c, b, e);
      }
      return e;
    }
    function ni(a, b, c) {
      a.flags |= 16384;
      a = { getSnapshot: b, value: c };
      b = N.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
    }
    function mi(a, b, c, d) {
      b.value = c;
      b.getSnapshot = d;
      oi(b) && pi(a);
    }
    function ki(a, b, c) {
      return c(function() {
        oi(b) && pi(a);
      });
    }
    function oi(a) {
      var b = a.getSnapshot;
      a = a.value;
      try {
        var c = b();
        return !He(a, c);
      } catch (d) {
        return true;
      }
    }
    function pi(a) {
      var b = Zg(a, 1);
      null !== b && mh(b, a, 1, -1);
    }
    function qi(a) {
      var b = ci();
      "function" === typeof a && (a = a());
      b.memoizedState = b.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
      b.queue = a;
      a = a.dispatch = ri.bind(null, N, a);
      return [b.memoizedState, a];
    }
    function li(a, b, c, d) {
      a = { tag: a, create: b, destroy: c, deps: d, next: null };
      b = N.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
      return a;
    }
    function si() {
      return di().memoizedState;
    }
    function ti(a, b, c, d) {
      var e = ci();
      N.flags |= a;
      e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
    }
    function ui(a, b, c, d) {
      var e = di();
      d = void 0 === d ? null : d;
      var f2 = void 0;
      if (null !== O) {
        var g = O.memoizedState;
        f2 = g.destroy;
        if (null !== d && Wh(d, g.deps)) {
          e.memoizedState = li(b, c, f2, d);
          return;
        }
      }
      N.flags |= a;
      e.memoizedState = li(1 | b, c, f2, d);
    }
    function vi(a, b) {
      return ti(8390656, 8, a, b);
    }
    function ji(a, b) {
      return ui(2048, 8, a, b);
    }
    function wi(a, b) {
      return ui(4, 2, a, b);
    }
    function xi(a, b) {
      return ui(4, 4, a, b);
    }
    function yi(a, b) {
      if ("function" === typeof b)
        return a = a(), b(a), function() {
          b(null);
        };
      if (null !== b && void 0 !== b)
        return a = a(), b.current = a, function() {
          b.current = null;
        };
    }
    function zi(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ui(4, 4, yi.bind(null, b, a), c);
    }
    function Ai() {
    }
    function Bi(a, b) {
      var c = di();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Wh(b, d[1]))
        return d[0];
      c.memoizedState = [a, b];
      return a;
    }
    function Ci(a, b) {
      var c = di();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Wh(b, d[1]))
        return d[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    }
    function Di(a, b, c) {
      if (0 === (Rh & 21))
        return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c;
      He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = true);
      return b;
    }
    function Ei(a, b) {
      var c = C;
      C = 0 !== c && 4 > c ? c : 4;
      a(true);
      var d = Qh.transition;
      Qh.transition = {};
      try {
        a(false), b();
      } finally {
        C = c, Qh.transition = d;
      }
    }
    function Fi() {
      return di().memoizedState;
    }
    function Gi(a, b, c) {
      var d = lh(a);
      c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a))
        Ii(b, c);
      else if (c = Yg(a, b, c, d), null !== c) {
        var e = L();
        mh(c, a, d, e);
        Ji(c, b, d);
      }
    }
    function ri(a, b, c) {
      var d = lh(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a))
        Ii(b, e);
      else {
        var f2 = a.alternate;
        if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b.lastRenderedReducer, null !== f2))
          try {
            var g = b.lastRenderedState, h2 = f2(g, c);
            e.hasEagerState = true;
            e.eagerState = h2;
            if (He(h2, g)) {
              var k2 = b.interleaved;
              null === k2 ? (e.next = e, Xg(b)) : (e.next = k2.next, k2.next = e);
              b.interleaved = e;
              return;
            }
          } catch (l2) {
          } finally {
          }
        c = Yg(a, b, e, d);
        null !== c && (e = L(), mh(c, a, d, e), Ji(c, b, d));
      }
    }
    function Hi(a) {
      var b = a.alternate;
      return a === N || null !== b && b === N;
    }
    function Ii(a, b) {
      Th = Sh = true;
      var c = a.pending;
      null === c ? b.next = b : (b.next = c.next, c.next = b);
      a.pending = b;
    }
    function Ji(a, b, c) {
      if (0 !== (c & 4194240)) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc(a, c);
      }
    }
    var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b) {
      ci().memoizedState = [a, void 0 === b ? null : b];
      return a;
    }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b, a),
        c
      );
    }, useLayoutEffect: function(a, b) {
      return ti(4194308, 4, a, b);
    }, useInsertionEffect: function(a, b) {
      return ti(4, 2, a, b);
    }, useMemo: function(a, b) {
      var c = ci();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    }, useReducer: function(a, b, c) {
      var d = ci();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
      d.queue = a;
      a = a.dispatch = Gi.bind(null, N, a);
      return [d.memoizedState, a];
    }, useRef: function(a) {
      var b = ci();
      a = { current: a };
      return b.memoizedState = a;
    }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
      return ci().memoizedState = a;
    }, useTransition: function() {
      var a = qi(false), b = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b, c) {
      var d = N, e = ci();
      if (I) {
        if (void 0 === c)
          throw Error(p(407));
        c = c();
      } else {
        c = b();
        if (null === R)
          throw Error(p(349));
        0 !== (Rh & 30) || ni(d, b, c);
      }
      e.memoizedState = c;
      var f2 = { value: c, getSnapshot: b };
      e.queue = f2;
      vi(ki.bind(
        null,
        d,
        f2,
        a
      ), [a]);
      d.flags |= 2048;
      li(9, mi.bind(null, d, f2, c, b), void 0, null);
      return c;
    }, useId: function() {
      var a = ci(), b = R.identifierPrefix;
      if (I) {
        var c = sg;
        var d = rg;
        c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
        b = ":" + b + "R" + c;
        c = Uh++;
        0 < c && (b += "H" + c.toString(32));
        b += ":";
      } else
        c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    }, unstable_isNewReconciler: false }, Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: function() {
        return fi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function(a) {
        var b = di();
        return Di(b, O.memoizedState, a);
      },
      useTransition: function() {
        var a = fi(ei)[0], b = di().memoizedState;
        return [a, b];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false
    }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
      return gi(ei);
    }, useDebugValue: Ai, useDeferredValue: function(a) {
      var b = di();
      return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
    }, useTransition: function() {
      var a = gi(ei)[0], b = di().memoizedState;
      return [a, b];
    }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
    function Ki(a, b) {
      try {
        var c = "", d = b;
        do
          c += Pa(d), d = d.return;
        while (d);
        var e = c;
      } catch (f2) {
        e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a, source: b, stack: e, digest: null };
    }
    function Li(a, b, c) {
      return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
    }
    function Mi(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a, b, c) {
      c = ch(-1, c);
      c.tag = 3;
      c.payload = { element: null };
      var d = b.value;
      c.callback = function() {
        Pi || (Pi = true, Qi = d);
        Mi(a, b);
      };
      return c;
    }
    function Ri(a, b, c) {
      c = ch(-1, c);
      c.tag = 3;
      var d = a.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c.payload = function() {
          return d(e);
        };
        c.callback = function() {
          Mi(a, b);
        };
      }
      var f2 = a.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
        Mi(a, b);
        "function" !== typeof d && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c2 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
      });
      return c;
    }
    function Ti(a, b, c) {
      var d = a.pingCache;
      if (null === d) {
        d = a.pingCache = new Ni();
        var e = /* @__PURE__ */ new Set();
        d.set(b, e);
      } else
        e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
      e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
    }
    function Vi(a) {
      do {
        var b;
        if (b = 13 === a.tag)
          b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
        if (b)
          return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Wi(a, b, c, d, e) {
      if (0 === (a.mode & 1))
        return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e;
      return a;
    }
    var Xi = ua.ReactCurrentOwner, Ug = false;
    function Yi(a, b, c, d) {
      b.child = null === a ? Ch(b, null, c, d) : Bh(b, a.child, c, d);
    }
    function Zi(a, b, c, d, e) {
      c = c.render;
      var f2 = b.ref;
      Tg(b, e);
      d = Xh(a, b, c, d, f2, e);
      c = bi();
      if (null !== a && !Ug)
        return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
      I && c && vg(b);
      b.flags |= 1;
      Yi(a, b, d, e);
      return b.child;
    }
    function aj(a, b, c, d, e) {
      if (null === a) {
        var f2 = c.type;
        if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c.compare && void 0 === c.defaultProps)
          return b.tag = 15, b.type = f2, cj(a, b, f2, d, e);
        a = yh(c.type, null, d, b, b.mode, e);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      f2 = a.child;
      if (0 === (a.lanes & e)) {
        var g = f2.memoizedProps;
        c = c.compare;
        c = null !== c ? c : Ie;
        if (c(g, d) && a.ref === b.ref)
          return $i(a, b, e);
      }
      b.flags |= 1;
      a = wh(f2, d);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    function cj(a, b, c, d, e) {
      if (null !== a) {
        var f2 = a.memoizedProps;
        if (Ie(f2, d) && a.ref === b.ref)
          if (Ug = false, b.pendingProps = d = f2, 0 !== (a.lanes & e))
            0 !== (a.flags & 131072) && (Ug = true);
          else
            return b.lanes = a.lanes, $i(a, b, e);
      }
      return dj(a, b, c, d, e);
    }
    function ej(a, b, c) {
      var d = b.pendingProps, e = d.children, f2 = null !== a ? a.memoizedState : null;
      if ("hidden" === d.mode)
        if (0 === (b.mode & 1))
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c;
        else {
          if (0 === (c & 1073741824))
            return a = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(fj, gj), gj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d = null !== f2 ? f2.baseLanes : c;
          G(fj, gj);
          gj |= d;
        }
      else
        null !== f2 ? (d = f2.baseLanes | c, b.memoizedState = null) : d = c, G(fj, gj), gj |= d;
      Yi(a, b, e, c);
      return b.child;
    }
    function hj(a, b) {
      var c = b.ref;
      if (null === a && null !== c || null !== a && a.ref !== c)
        b.flags |= 512, b.flags |= 2097152;
    }
    function dj(a, b, c, d, e) {
      var f2 = Zf(c) ? Xf : H.current;
      f2 = Yf(b, f2);
      Tg(b, e);
      c = Xh(a, b, c, d, f2, e);
      d = bi();
      if (null !== a && !Ug)
        return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
      I && d && vg(b);
      b.flags |= 1;
      Yi(a, b, c, e);
      return b.child;
    }
    function ij(a, b, c, d, e) {
      if (Zf(c)) {
        var f2 = true;
        cg(b);
      } else
        f2 = false;
      Tg(b, e);
      if (null === b.stateNode)
        jj(a, b), ph(b, c, d), rh(b, c, d, e), d = true;
      else if (null === a) {
        var g = b.stateNode, h2 = b.memoizedProps;
        g.props = h2;
        var k2 = g.context, l2 = c.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c) ? Xf : H.current, l2 = Yf(b, l2));
        var m2 = c.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
        q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== d || k2 !== l2) && qh(b, g, d, l2);
        $g = false;
        var r2 = b.memoizedState;
        g.state = r2;
        gh(b, d, g, e);
        k2 = b.memoizedState;
        h2 !== d || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b, c, m2, d), k2 = b.memoizedState), (h2 = $g || oh(b, c, h2, d, r2, k2, l2)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k2), g.props = d, g.state = k2, g.context = l2, d = h2) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
      } else {
        g = b.stateNode;
        bh(a, b);
        h2 = b.memoizedProps;
        l2 = b.type === b.elementType ? h2 : Lg(b.type, h2);
        g.props = l2;
        q2 = b.pendingProps;
        r2 = g.context;
        k2 = c.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c) ? Xf : H.current, k2 = Yf(b, k2));
        var y2 = c.getDerivedStateFromProps;
        (m2 = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b, g, d, k2);
        $g = false;
        r2 = b.memoizedState;
        g.state = r2;
        gh(b, d, g, e);
        var n2 = b.memoizedState;
        h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b, c, y2, d), n2 = b.memoizedState), (l2 = $g || oh(b, c, l2, d, r2, n2, k2) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n2, k2), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n2, k2)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n2), g.props = d, g.state = n2, g.context = k2, d = l2) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d = false);
      }
      return kj(a, b, c, d, f2, e);
    }
    function kj(a, b, c, d, e, f2) {
      hj(a, b);
      var g = 0 !== (b.flags & 128);
      if (!d && !g)
        return e && dg(b, c, false), $i(a, b, f2);
      d = b.stateNode;
      Xi.current = b;
      var h2 = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
      b.flags |= 1;
      null !== a && g ? (b.child = Bh(b, a.child, null, f2), b.child = Bh(b, null, h2, f2)) : Yi(a, b, h2, f2);
      b.memoizedState = d.state;
      e && dg(b, c, true);
      return b.child;
    }
    function lj(a) {
      var b = a.stateNode;
      b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
      Ih(a, b.containerInfo);
    }
    function mj(a, b, c, d, e) {
      Ig();
      Jg(e);
      b.flags |= 256;
      Yi(a, b, c, d);
      return b.child;
    }
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function pj(a, b, c) {
      var d = b.pendingProps, e = M.current, f2 = false, g = 0 !== (b.flags & 128), h2;
      (h2 = g) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
      if (h2)
        f2 = true, b.flags &= -129;
      else if (null === a || null !== a.memoizedState)
        e |= 1;
      G(M, e & 1);
      if (null === a) {
        Eg(b);
        a = b.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a))
          return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
        g = d.children;
        a = d.fallback;
        return f2 ? (d = b.mode, f2 = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g) : f2 = qj(g, d, 0, null), a = Ah(a, d, c, null), f2.return = b, a.return = b, f2.sibling = a, b.child = f2, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
      }
      e = a.memoizedState;
      if (null !== e && (h2 = e.dehydrated, null !== h2))
        return sj(a, b, g, d, h2, e, c);
      if (f2) {
        f2 = d.fallback;
        g = b.mode;
        e = a.child;
        h2 = e.sibling;
        var k2 = { mode: "hidden", children: d.children };
        0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k2, b.deletions = null) : (d = wh(e, k2), d.subtreeFlags = e.subtreeFlags & 14680064);
        null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g, c, null), f2.flags |= 2);
        f2.return = b;
        d.return = b;
        d.sibling = f2;
        b.child = d;
        d = f2;
        f2 = b.child;
        g = a.child.memoizedState;
        g = null === g ? oj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
        f2.memoizedState = g;
        f2.childLanes = a.childLanes & ~c;
        b.memoizedState = nj;
        return d;
      }
      f2 = a.child;
      a = f2.sibling;
      d = wh(f2, { mode: "visible", children: d.children });
      0 === (b.mode & 1) && (d.lanes = c);
      d.return = b;
      d.sibling = null;
      null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
      b.child = d;
      b.memoizedState = null;
      return d;
    }
    function rj(a, b) {
      b = qj({ mode: "visible", children: b }, a.mode, 0, null);
      b.return = a;
      return a.child = b;
    }
    function tj(a, b, c, d) {
      null !== d && Jg(d);
      Bh(b, a.child, null, c);
      a = rj(b, b.pendingProps.children);
      a.flags |= 2;
      b.memoizedState = null;
      return a;
    }
    function sj(a, b, c, d, e, f2, g) {
      if (c) {
        if (b.flags & 256)
          return b.flags &= -257, d = Li(Error(p(422))), tj(a, b, g, d);
        if (null !== b.memoizedState)
          return b.child = a.child, b.flags |= 128, null;
        f2 = d.fallback;
        e = b.mode;
        d = qj({ mode: "visible", children: d.children }, e, 0, null);
        f2 = Ah(f2, e, g, null);
        f2.flags |= 2;
        d.return = b;
        f2.return = b;
        d.sibling = f2;
        b.child = d;
        0 !== (b.mode & 1) && Bh(b, a.child, null, g);
        b.child.memoizedState = oj(g);
        b.memoizedState = nj;
        return f2;
      }
      if (0 === (b.mode & 1))
        return tj(a, b, g, null);
      if ("$!" === e.data) {
        d = e.nextSibling && e.nextSibling.dataset;
        if (d)
          var h2 = d.dgst;
        d = h2;
        f2 = Error(p(419));
        d = Li(f2, d, void 0);
        return tj(a, b, g, d);
      }
      h2 = 0 !== (g & a.childLanes);
      if (Ug || h2) {
        d = R;
        if (null !== d) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
          0 !== e && e !== f2.retryLane && (f2.retryLane = e, Zg(a, e), mh(d, a, e, -1));
        }
        uj();
        d = Li(Error(p(421)));
        return tj(a, b, g, d);
      }
      if ("$?" === e.data)
        return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
      a = f2.treeContext;
      yg = Lf(e.nextSibling);
      xg = b;
      I = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
      b = rj(b, d.children);
      b.flags |= 4096;
      return b;
    }
    function wj(a, b, c) {
      a.lanes |= b;
      var d = a.alternate;
      null !== d && (d.lanes |= b);
      Sg(a.return, b, c);
    }
    function xj(a, b, c, d, e) {
      var f2 = a.memoizedState;
      null === f2 ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c, f2.tailMode = e);
    }
    function yj(a, b, c) {
      var d = b.pendingProps, e = d.revealOrder, f2 = d.tail;
      Yi(a, b, d.children, c);
      d = M.current;
      if (0 !== (d & 2))
        d = d & 1 | 2, b.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128))
          a:
            for (a = b.child; null !== a; ) {
              if (13 === a.tag)
                null !== a.memoizedState && wj(a, c, b);
              else if (19 === a.tag)
                wj(a, c, b);
              else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b)
                break a;
              for (; null === a.sibling; ) {
                if (null === a.return || a.return === b)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
        d &= 1;
      }
      G(M, d);
      if (0 === (b.mode & 1))
        b.memoizedState = null;
      else
        switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; )
              a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            xj(b, false, e, c, f2);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === Mh(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            xj(b, true, c, null, f2);
            break;
          case "together":
            xj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function jj(a, b) {
      0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
    }
    function $i(a, b, c) {
      null !== a && (b.dependencies = a.dependencies);
      hh |= b.lanes;
      if (0 === (c & b.childLanes))
        return null;
      if (null !== a && b.child !== a.child)
        throw Error(p(153));
      if (null !== b.child) {
        a = b.child;
        c = wh(a, a.pendingProps);
        b.child = c;
        for (c.return = b; null !== a.sibling; )
          a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
        c.sibling = null;
      }
      return b.child;
    }
    function zj(a, b, c) {
      switch (b.tag) {
        case 3:
          lj(b);
          Ig();
          break;
        case 5:
          Kh(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          Ih(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d = b.type._context, e = b.memoizedProps.value;
          G(Mg, d._currentValue);
          d._currentValue = e;
          break;
        case 13:
          d = b.memoizedState;
          if (null !== d) {
            if (null !== d.dehydrated)
              return G(M, M.current & 1), b.flags |= 128, null;
            if (0 !== (c & b.child.childLanes))
              return pj(a, b, c);
            G(M, M.current & 1);
            a = $i(a, b, c);
            return null !== a ? a.sibling : null;
          }
          G(M, M.current & 1);
          break;
        case 19:
          d = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d)
              return yj(a, b, c);
            b.flags |= 128;
          }
          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          G(M, M.current);
          if (d)
            break;
          else
            return null;
        case 22:
        case 23:
          return b.lanes = 0, ej(a, b, c);
      }
      return $i(a, b, c);
    }
    var Aj, Bj, Cj, Dj;
    Aj = function(a, b) {
      for (var c = b.child; null !== c; ) {
        if (5 === c.tag || 6 === c.tag)
          a.appendChild(c.stateNode);
        else if (4 !== c.tag && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b)
          break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b)
            return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    };
    Bj = function() {
    };
    Cj = function(a, b, c, d) {
      var e = a.memoizedProps;
      if (e !== d) {
        a = b.stateNode;
        Hh(Eh.current);
        var f2 = null;
        switch (c) {
          case "input":
            e = Ya(a, e);
            d = Ya(a, d);
            f2 = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 });
            d = A({}, d, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e = gb(a, e);
            d = gb(a, d);
            f2 = [];
            break;
          default:
            "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
        }
        ub(c, d);
        var g;
        c = null;
        for (l2 in e)
          if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && null != e[l2])
            if ("style" === l2) {
              var h2 = e[l2];
              for (g in h2)
                h2.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d) {
          var k2 = d[l2];
          h2 = null != e ? e[l2] : void 0;
          if (d.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g in h2)
                  !h2.hasOwnProperty(g) || k2 && k2.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                for (g in k2)
                  k2.hasOwnProperty(g) && h2[g] !== k2[g] && (c || (c = {}), c[g] = k2[g]);
              } else
                c || (f2 || (f2 = []), f2.push(
                  l2,
                  c
                )), c = k2;
            else
              "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
        }
        c && (f2 = f2 || []).push("style", c);
        var l2 = f2;
        if (b.updateQueue = l2)
          b.flags |= 4;
      }
    };
    Dj = function(a, b, c, d) {
      c !== d && (b.flags |= 4);
    };
    function Ej(a, b) {
      if (!I)
        switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; null !== b; )
              null !== b.alternate && (c = b), b = b.sibling;
            null === c ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; null !== c; )
              null !== c.alternate && (d = c), c = c.sibling;
            null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
    }
    function S(a) {
      var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
      if (b)
        for (var e = a.child; null !== e; )
          c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
      else
        for (e = a.child; null !== e; )
          c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
      a.subtreeFlags |= d;
      a.childLanes = c;
      return b;
    }
    function Fj(a, b, c) {
      var d = b.pendingProps;
      wg(b);
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          d = b.stateNode;
          Jh();
          E(Wf);
          E(H);
          Oh();
          d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
          if (null === a || null === a.child)
            Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a, b);
          S(b);
          return null;
        case 5:
          Lh(b);
          var e = Hh(Gh.current);
          c = b.type;
          if (null !== a && null != b.stateNode)
            Cj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d) {
              if (null === b.stateNode)
                throw Error(p(166));
              S(b);
              return null;
            }
            a = Hh(Eh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c = b.type;
              var f2 = b.memoizedProps;
              d[Of] = b;
              d[Pf] = f2;
              a = 0 !== (b.mode & 1);
              switch (c) {
                case "dialog":
                  D("cancel", d);
                  D("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++)
                    D(lf[e], d);
                  break;
                case "source":
                  D("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d
                  );
                  D("load", d);
                  break;
                case "details":
                  D("toggle", d);
                  break;
                case "input":
                  Za(d, f2);
                  D("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f2.multiple };
                  D("invalid", d);
                  break;
                case "textarea":
                  hb(d, f2), D("invalid", d);
              }
              ub(c, f2);
              e = null;
              for (var g in f2)
                if (f2.hasOwnProperty(g)) {
                  var h2 = f2[g];
                  "children" === g ? "string" === typeof h2 ? d.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d.textContent, h2, a), e = ["children", h2]) : "number" === typeof h2 && d.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                    d.textContent,
                    h2,
                    a
                  ), e = ["children", "" + h2]) : ea.hasOwnProperty(g) && null != h2 && "onScroll" === g && D("scroll", d);
                }
              switch (c) {
                case "input":
                  Va(d);
                  db(d, f2, true);
                  break;
                case "textarea":
                  Va(d);
                  jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d.onclick = Bf);
              }
              d = e;
              b.updateQueue = d;
              null !== d && (b.flags |= 4);
            } else {
              g = 9 === e.nodeType ? e : e.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
              a[Of] = b;
              a[Pf] = d;
              Aj(a, b, false, false);
              b.stateNode = a;
              a: {
                g = vb(c, d);
                switch (c) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++)
                      D(lf[e], a);
                    e = d;
                    break;
                  case "source":
                    D("error", a);
                    e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e = d;
                    break;
                  case "details":
                    D("toggle", a);
                    e = d;
                    break;
                  case "input":
                    Za(a, d);
                    e = Ya(a, d);
                    D("invalid", a);
                    break;
                  case "option":
                    e = d;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d.multiple };
                    e = A({}, d, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d);
                    e = gb(a, d);
                    D("invalid", a);
                    break;
                  default:
                    e = d;
                }
                ub(c, e);
                h2 = e;
                for (f2 in h2)
                  if (h2.hasOwnProperty(f2)) {
                    var k2 = h2[f2];
                    "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g));
                  }
                switch (c) {
                  case "input":
                    Va(a);
                    db(a, d, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d.value && a.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a.multiple = !!d.multiple;
                    f2 = d.value;
                    null != f2 ? fb(a, !!d.multiple, f2, false) : null != d.defaultValue && fb(
                      a,
                      !!d.multiple,
                      d.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e.onClick && (a.onclick = Bf);
                }
                switch (c) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d = !!d.autoFocus;
                    break a;
                  case "img":
                    d = true;
                    break a;
                  default:
                    d = false;
                }
              }
              d && (b.flags |= 4);
            }
            null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          }
          S(b);
          return null;
        case 6:
          if (a && null != b.stateNode)
            Dj(a, b, a.memoizedProps, d);
          else {
            if ("string" !== typeof d && null === b.stateNode)
              throw Error(p(166));
            c = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c = b.memoizedProps;
              d[Of] = b;
              if (f2 = d.nodeValue !== c) {
                if (a = xg, null !== a)
                  switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
              }
              f2 && (b.flags |= 4);
            } else
              d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
          }
          S(b);
          return null;
        case 13:
          E(M);
          d = b.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128))
              Hg(), Ig(), b.flags |= 98560, f2 = false;
            else if (f2 = Gg(b), null !== d && null !== d.dehydrated) {
              if (null === a) {
                if (!f2)
                  throw Error(p(318));
                f2 = b.memoizedState;
                f2 = null !== f2 ? f2.dehydrated : null;
                if (!f2)
                  throw Error(p(317));
                f2[Of] = b;
              } else
                Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b);
              f2 = false;
            } else
              null !== zg && (Gj(zg), zg = null), f2 = true;
            if (!f2)
              return b.flags & 65536 ? b : null;
          }
          if (0 !== (b.flags & 128))
            return b.lanes = c, b;
          d = null !== d;
          d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
          null !== b.updateQueue && (b.flags |= 4);
          S(b);
          return null;
        case 4:
          return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
        case 10:
          return Rg(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          E(M);
          f2 = b.memoizedState;
          if (null === f2)
            return S(b), null;
          d = 0 !== (b.flags & 128);
          g = f2.rendering;
          if (null === g)
            if (d)
              Ej(f2, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128))
                for (a = b.child; null !== a; ) {
                  g = Mh(a);
                  if (null !== g) {
                    b.flags |= 128;
                    Ej(f2, false);
                    d = g.updateQueue;
                    null !== d && (b.updateQueue = d, b.flags |= 4);
                    b.subtreeFlags = 0;
                    d = c;
                    for (c = b.child; null !== c; )
                      f2 = c, a = d, f2.flags &= 14680066, g = f2.alternate, null === g ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g.childLanes, f2.lanes = g.lanes, f2.child = g.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g.memoizedProps, f2.memoizedState = g.memoizedState, f2.updateQueue = g.updateQueue, f2.type = g.type, a = g.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                    G(M, M.current & 1 | 2);
                    return b.child;
                  }
                  a = a.sibling;
                }
              null !== f2.tail && B() > Hj && (b.flags |= 128, d = true, Ej(f2, false), b.lanes = 4194304);
            }
          else {
            if (!d)
              if (a = Mh(g), null !== a) {
                if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g.alternate && !I)
                  return S(b), null;
              } else
                2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d = true, Ej(f2, false), b.lanes = 4194304);
            f2.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f2.last, null !== c ? c.sibling = g : b.child = g, f2.last = g);
          }
          if (null !== f2.tail)
            return b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d ? c & 1 | 2 : c & 1), b;
          S(b);
          return null;
        case 22:
        case 23:
          return Ij(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    function Jj(a, b) {
      wg(b);
      switch (b.tag) {
        case 1:
          return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 3:
          return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
        case 5:
          return Lh(b), null;
        case 13:
          E(M);
          a = b.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b.alternate)
              throw Error(p(340));
            Ig();
          }
          a = b.flags;
          return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 19:
          return E(M), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Mj(a, b) {
      var c = a.ref;
      if (null !== c)
        if ("function" === typeof c)
          try {
            c(null);
          } catch (d) {
            W(a, b, d);
          }
        else
          c.current = null;
    }
    function Nj(a, b, c) {
      try {
        c();
      } catch (d) {
        W(a, b, d);
      }
    }
    var Oj = false;
    function Pj(a, b) {
      Cf = dd;
      a = Me();
      if (Ne(a)) {
        if ("selectionStart" in a)
          var c = { start: a.selectionStart, end: a.selectionEnd };
        else
          a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && 0 !== d.rangeCount) {
              c = d.anchorNode;
              var e = d.anchorOffset, f2 = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f2.nodeType;
              } catch (F2) {
                c = null;
                break a;
              }
              var g = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
              b:
                for (; ; ) {
                  for (var y2; ; ) {
                    q2 !== c || 0 !== e && 3 !== q2.nodeType || (h2 = g + e);
                    q2 !== f2 || 0 !== d && 3 !== q2.nodeType || (k2 = g + d);
                    3 === q2.nodeType && (g += q2.nodeValue.length);
                    if (null === (y2 = q2.firstChild))
                      break;
                    r2 = q2;
                    q2 = y2;
                  }
                  for (; ; ) {
                    if (q2 === a)
                      break b;
                    r2 === c && ++l2 === e && (h2 = g);
                    r2 === f2 && ++m2 === d && (k2 = g);
                    if (null !== (y2 = q2.nextSibling))
                      break;
                    q2 = r2;
                    r2 = q2.parentNode;
                  }
                  q2 = y2;
                }
              c = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
            } else
              c = null;
          }
        c = c || { start: 0, end: 0 };
      } else
        c = null;
      Df = { focusedElem: a, selectionRange: c };
      dd = false;
      for (V = b; null !== V; )
        if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a)
          a.return = b, V = a;
        else
          for (; null !== V; ) {
            b = V;
            try {
              var n2 = b.alternate;
              if (0 !== (b.flags & 1024))
                switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n2) {
                      var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b.stateNode, w2 = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Lg(b.type, t2), J2);
                      x2.__reactInternalSnapshotBeforeUpdate = w2;
                    }
                    break;
                  case 3:
                    var u2 = b.stateNode.containerInfo;
                    1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p(163));
                }
            } catch (F2) {
              W(b, b.return, F2);
            }
            a = b.sibling;
            if (null !== a) {
              a.return = b.return;
              V = a;
              break;
            }
            V = b.return;
          }
      n2 = Oj;
      Oj = false;
      return n2;
    }
    function Qj(a, b, c) {
      var d = b.updateQueue;
      d = null !== d ? d.lastEffect : null;
      if (null !== d) {
        var e = d = d.next;
        do {
          if ((e.tag & a) === a) {
            var f2 = e.destroy;
            e.destroy = void 0;
            void 0 !== f2 && Nj(b, c, f2);
          }
          e = e.next;
        } while (e !== d);
      }
    }
    function Rj(a, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d = c.create;
            c.destroy = d();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Sj(a) {
      var b = a.ref;
      if (null !== b) {
        var c = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c;
            break;
          default:
            a = c;
        }
        "function" === typeof b ? b(a) : b.current = a;
      }
    }
    function Tj(a) {
      var b = a.alternate;
      null !== b && (a.alternate = null, Tj(b));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Uj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Vj(a) {
      a:
        for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Uj(a.return))
              return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2)
              continue a;
            if (null === a.child || 4 === a.tag)
              continue a;
            else
              a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2))
            return a.stateNode;
        }
    }
    function Wj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d)
        a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
      else if (4 !== d && (a = a.child, null !== a))
        for (Wj(a, b, c), a = a.sibling; null !== a; )
          Wj(a, b, c), a = a.sibling;
    }
    function Xj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d)
        a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (4 !== d && (a = a.child, null !== a))
        for (Xj(a, b, c), a = a.sibling; null !== a; )
          Xj(a, b, c), a = a.sibling;
    }
    var X = null, Yj = false;
    function Zj(a, b, c) {
      for (c = c.child; null !== c; )
        ak(a, b, c), c = c.sibling;
    }
    function ak(a, b, c) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount)
        try {
          lc.onCommitFiberUnmount(kc, c);
        } catch (h2) {
        }
      switch (c.tag) {
        case 5:
          U || Mj(c, b);
        case 6:
          var d = X, e = Yj;
          X = null;
          Zj(a, b, c);
          X = d;
          Yj = e;
          null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
          break;
        case 18:
          null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
          break;
        case 4:
          d = X;
          e = Yj;
          X = c.stateNode.containerInfo;
          Yj = true;
          Zj(a, b, c);
          X = d;
          Yj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
            e = d = d.next;
            do {
              var f2 = e, g = f2.destroy;
              f2 = f2.tag;
              void 0 !== g && (0 !== (f2 & 2) ? Nj(c, b, g) : 0 !== (f2 & 4) && Nj(c, b, g));
              e = e.next;
            } while (e !== d);
          }
          Zj(a, b, c);
          break;
        case 1:
          if (!U && (Mj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount))
            try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h2) {
              W(c, b, h2);
            }
          Zj(a, b, c);
          break;
        case 21:
          Zj(a, b, c);
          break;
        case 22:
          c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Zj(a, b, c), U = d) : Zj(a, b, c);
          break;
        default:
          Zj(a, b, c);
      }
    }
    function bk(a) {
      var b = a.updateQueue;
      if (null !== b) {
        a.updateQueue = null;
        var c = a.stateNode;
        null === c && (c = a.stateNode = new Lj());
        b.forEach(function(b2) {
          var d = ck.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d, d));
        });
      }
    }
    function dk(a, b) {
      var c = b.deletions;
      if (null !== c)
        for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f2 = a, g = b, h2 = g;
            a:
              for (; null !== h2; ) {
                switch (h2.tag) {
                  case 5:
                    X = h2.stateNode;
                    Yj = false;
                    break a;
                  case 3:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                  case 4:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                }
                h2 = h2.return;
              }
            if (null === X)
              throw Error(p(160));
            ak(f2, g, e);
            X = null;
            Yj = false;
            var k2 = e.alternate;
            null !== k2 && (k2.return = null);
            e.return = null;
          } catch (l2) {
            W(e, b, l2);
          }
        }
      if (b.subtreeFlags & 12854)
        for (b = b.child; null !== b; )
          ek(b, a), b = b.sibling;
    }
    function ek(a, b) {
      var c = a.alternate, d = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b, a);
          fk(a);
          if (d & 4) {
            try {
              Qj(3, a, a.return), Rj(3, a);
            } catch (t2) {
              W(a, a.return, t2);
            }
            try {
              Qj(5, a, a.return);
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          break;
        case 1:
          dk(b, a);
          fk(a);
          d & 512 && null !== c && Mj(c, c.return);
          break;
        case 5:
          dk(b, a);
          fk(a);
          d & 512 && null !== c && Mj(c, c.return);
          if (a.flags & 32) {
            var e = a.stateNode;
            try {
              ob(e, "");
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          if (d & 4 && (e = a.stateNode, null != e)) {
            var f2 = a.memoizedProps, g = null !== c ? c.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
            a.updateQueue = null;
            if (null !== k2)
              try {
                "input" === h2 && "radio" === f2.type && null != f2.name && ab(e, f2);
                vb(h2, g);
                var l2 = vb(h2, f2);
                for (g = 0; g < k2.length; g += 2) {
                  var m2 = k2[g], q2 = k2[g + 1];
                  "style" === m2 ? sb(e, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e, q2) : "children" === m2 ? ob(e, q2) : ta(e, m2, q2, l2);
                }
                switch (h2) {
                  case "input":
                    bb(e, f2);
                    break;
                  case "textarea":
                    ib(e, f2);
                    break;
                  case "select":
                    var r2 = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f2.multiple;
                    var y2 = f2.value;
                    null != y2 ? fb(e, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                      e,
                      !!f2.multiple,
                      f2.defaultValue,
                      true
                    ) : fb(e, !!f2.multiple, f2.multiple ? [] : "", false));
                }
                e[Pf] = f2;
              } catch (t2) {
                W(a, a.return, t2);
              }
          }
          break;
        case 6:
          dk(b, a);
          fk(a);
          if (d & 4) {
            if (null === a.stateNode)
              throw Error(p(162));
            e = a.stateNode;
            f2 = a.memoizedProps;
            try {
              e.nodeValue = f2;
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          break;
        case 3:
          dk(b, a);
          fk(a);
          if (d & 4 && null !== c && c.memoizedState.isDehydrated)
            try {
              bd(b.containerInfo);
            } catch (t2) {
              W(a, a.return, t2);
            }
          break;
        case 4:
          dk(b, a);
          fk(a);
          break;
        case 13:
          dk(b, a);
          fk(a);
          e = a.child;
          e.flags & 8192 && (f2 = null !== e.memoizedState, e.stateNode.isHidden = f2, !f2 || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B()));
          d & 4 && bk(a);
          break;
        case 22:
          m2 = null !== c && null !== c.memoizedState;
          a.mode & 1 ? (U = (l2 = U) || m2, dk(b, a), U = l2) : dk(b, a);
          fk(a);
          if (d & 8192) {
            l2 = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
              for (V = a, m2 = a.child; null !== m2; ) {
                for (q2 = V = m2; null !== V; ) {
                  r2 = V;
                  y2 = r2.child;
                  switch (r2.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r2, r2.return);
                      break;
                    case 1:
                      Mj(r2, r2.return);
                      var n2 = r2.stateNode;
                      if ("function" === typeof n2.componentWillUnmount) {
                        d = r2;
                        c = r2.return;
                        try {
                          b = d, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                        } catch (t2) {
                          W(d, c, t2);
                        }
                      }
                      break;
                    case 5:
                      Mj(r2, r2.return);
                      break;
                    case 22:
                      if (null !== r2.memoizedState) {
                        hk(q2);
                        continue;
                      }
                  }
                  null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
                }
                m2 = m2.sibling;
              }
            a:
              for (m2 = null, q2 = a; ; ) {
                if (5 === q2.tag) {
                  if (null === m2) {
                    m2 = q2;
                    try {
                      e = q2.stateNode, l2 ? (f2 = e.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g));
                    } catch (t2) {
                      W(a, a.return, t2);
                    }
                  }
                } else if (6 === q2.tag) {
                  if (null === m2)
                    try {
                      q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                    } catch (t2) {
                      W(a, a.return, t2);
                    }
                } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
                  q2.child.return = q2;
                  q2 = q2.child;
                  continue;
                }
                if (q2 === a)
                  break a;
                for (; null === q2.sibling; ) {
                  if (null === q2.return || q2.return === a)
                    break a;
                  m2 === q2 && (m2 = null);
                  q2 = q2.return;
                }
                m2 === q2 && (m2 = null);
                q2.sibling.return = q2.return;
                q2 = q2.sibling;
              }
          }
          break;
        case 19:
          dk(b, a);
          fk(a);
          d & 4 && bk(a);
          break;
        case 21:
          break;
        default:
          dk(
            b,
            a
          ), fk(a);
      }
    }
    function fk(a) {
      var b = a.flags;
      if (b & 2) {
        try {
          a: {
            for (var c = a.return; null !== c; ) {
              if (Uj(c)) {
                var d = c;
                break a;
              }
              c = c.return;
            }
            throw Error(p(160));
          }
          switch (d.tag) {
            case 5:
              var e = d.stateNode;
              d.flags & 32 && (ob(e, ""), d.flags &= -33);
              var f2 = Vj(a);
              Xj(a, f2, e);
              break;
            case 3:
            case 4:
              var g = d.stateNode.containerInfo, h2 = Vj(a);
              Wj(a, h2, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k2) {
          W(a, a.return, k2);
        }
        a.flags &= -3;
      }
      b & 4096 && (a.flags &= -4097);
    }
    function ik(a, b, c) {
      V = a;
      jk(a);
    }
    function jk(a, b, c) {
      for (var d = 0 !== (a.mode & 1); null !== V; ) {
        var e = V, f2 = e.child;
        if (22 === e.tag && d) {
          var g = null !== e.memoizedState || Kj;
          if (!g) {
            var h2 = e.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
            h2 = Kj;
            var l2 = U;
            Kj = g;
            if ((U = k2) && !l2)
              for (V = e; null !== V; )
                g = V, k2 = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k2 ? (k2.return = g, V = k2) : kk(e);
            for (; null !== f2; )
              V = f2, jk(f2), f2 = f2.sibling;
            V = e;
            Kj = h2;
            U = l2;
          }
          lk(a);
        } else
          0 !== (e.subtreeFlags & 8772) && null !== f2 ? (f2.return = e, V = f2) : lk(a);
      }
    }
    function lk(a) {
      for (; null !== V; ) {
        var b = V;
        if (0 !== (b.flags & 8772)) {
          var c = b.alternate;
          try {
            if (0 !== (b.flags & 8772))
              switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Rj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U)
                    if (null === c)
                      d.componentDidMount();
                    else {
                      var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
                      d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f2 = b.updateQueue;
                  null !== f2 && ih(b, f2, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (null !== g) {
                    c = null;
                    if (null !== b.child)
                      switch (b.child.tag) {
                        case 5:
                          c = b.child.stateNode;
                          break;
                        case 1:
                          c = b.child.stateNode;
                      }
                    ih(b, g, c);
                  }
                  break;
                case 5:
                  var h2 = b.stateNode;
                  if (null === c && b.flags & 4) {
                    c = h2;
                    var k2 = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k2.autoFocus && c.focus();
                        break;
                      case "img":
                        k2.src && (c.src = k2.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l2 = b.alternate;
                    if (null !== l2) {
                      var m2 = l2.memoizedState;
                      if (null !== m2) {
                        var q2 = m2.dehydrated;
                        null !== q2 && bd(q2);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
            U || b.flags & 512 && Sj(b);
          } catch (r2) {
            W(b, b.return, r2);
          }
        }
        if (b === a) {
          V = null;
          break;
        }
        c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function hk(a) {
      for (; null !== V; ) {
        var b = V;
        if (b === a) {
          V = null;
          break;
        }
        var c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c = b.return;
              try {
                Rj(4, b);
              } catch (k2) {
                W(b, c, k2);
              }
              break;
            case 1:
              var d = b.stateNode;
              if ("function" === typeof d.componentDidMount) {
                var e = b.return;
                try {
                  d.componentDidMount();
                } catch (k2) {
                  W(b, e, k2);
                }
              }
              var f2 = b.return;
              try {
                Sj(b);
              } catch (k2) {
                W(b, f2, k2);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Sj(b);
              } catch (k2) {
                W(b, g, k2);
              }
          }
        } catch (k2) {
          W(b, b.return, k2);
        }
        if (b === a) {
          V = null;
          break;
        }
        var h2 = b.sibling;
        if (null !== h2) {
          h2.return = b.return;
          V = h2;
          break;
        }
        V = b.return;
      }
    }
    var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok$2 = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
    function L() {
      return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
    }
    function lh(a) {
      if (0 === (a.mode & 1))
        return 1;
      if (0 !== (K & 2) && 0 !== Z)
        return Z & -Z;
      if (null !== Kg.transition)
        return 0 === Ck && (Ck = yc()), Ck;
      a = C;
      if (0 !== a)
        return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    function mh(a, b, c, d) {
      if (50 < zk)
        throw zk = 0, Ak = null, Error(p(185));
      Ac(a, c, d);
      if (0 === (K & 2) || a !== R)
        a === R && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
    }
    function Ek(a, b) {
      var c = a.callbackNode;
      wc(a, b);
      var d = uc(a, a === R ? Z : 0);
      if (0 === d)
        null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
      else if (b = d & -d, a.callbackPriority !== b) {
        null != c && bc(c);
        if (1 === b)
          0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c = null;
        else {
          switch (Dc(d)) {
            case 1:
              c = fc;
              break;
            case 4:
              c = gc;
              break;
            case 16:
              c = hc;
              break;
            case 536870912:
              c = jc;
              break;
            default:
              c = hc;
          }
          c = Gk(c, Hk.bind(null, a));
        }
        a.callbackPriority = b;
        a.callbackNode = c;
      }
    }
    function Hk(a, b) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6))
        throw Error(p(327));
      var c = a.callbackNode;
      if (Ik() && a.callbackNode !== c)
        return null;
      var d = uc(a, a === R ? Z : 0);
      if (0 === d)
        return null;
      if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b)
        b = Jk(a, d);
      else {
        b = d;
        var e = K;
        K |= 2;
        var f2 = Kk();
        if (R !== a || Z !== b)
          vk = null, Hj = B() + 500, Lk(a, b);
        do
          try {
            Mk();
            break;
          } catch (h2) {
            Nk(a, h2);
          }
        while (1);
        Qg();
        nk.current = f2;
        K = e;
        null !== Y ? b = 0 : (R = null, Z = 0, b = T);
      }
      if (0 !== b) {
        2 === b && (e = xc(a), 0 !== e && (d = e, b = Ok(a, e)));
        if (1 === b)
          throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
        if (6 === b)
          Dk(a, d);
        else {
          e = a.current.alternate;
          if (0 === (d & 30) && !Pk(e) && (b = Jk(a, d), 2 === b && (f2 = xc(a), 0 !== f2 && (d = f2, b = Ok(a, f2))), 1 === b))
            throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
          a.finishedWork = e;
          a.finishedLanes = d;
          switch (b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Qk(a, uk, vk);
              break;
            case 3:
              Dk(a, d);
              if ((d & 130023424) === d && (b = gk + 500 - B(), 10 < b)) {
                if (0 !== uc(a, 0))
                  break;
                e = a.suspendedLanes;
                if ((e & d) !== d) {
                  L();
                  a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 4:
              Dk(a, d);
              if ((d & 4194240) === d)
                break;
              b = a.eventTimes;
              for (e = -1; 0 < d; ) {
                var g = 31 - oc(d);
                f2 = 1 << g;
                g = b[g];
                g > e && (e = g);
                d &= ~f2;
              }
              d = e;
              d = B() - d;
              d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * mk(d / 1960)) - d;
              if (10 < d) {
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 5:
              Qk(a, uk, vk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      Ek(a, B());
      return a.callbackNode === c ? Hk.bind(null, a) : null;
    }
    function Ok(a, b) {
      var c = tk;
      a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
      a = Jk(a, b);
      2 !== a && (b = uk, uk = c, null !== b && Gj(b));
      return a;
    }
    function Gj(a) {
      null === uk ? uk = a : uk.push.apply(uk, a);
    }
    function Pk(a) {
      for (var b = a; ; ) {
        if (b.flags & 16384) {
          var c = b.updateQueue;
          if (null !== c && (c = c.stores, null !== c))
            for (var d = 0; d < c.length; d++) {
              var e = c[d], f2 = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f2(), e))
                  return false;
              } catch (g) {
                return false;
              }
            }
        }
        c = b.child;
        if (b.subtreeFlags & 16384 && null !== c)
          c.return = b, b = c;
        else {
          if (b === a)
            break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a)
              return true;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return true;
    }
    function Dk(a, b) {
      b &= ~sk;
      b &= ~rk;
      a.suspendedLanes |= b;
      a.pingedLanes &= ~b;
      for (a = a.expirationTimes; 0 < b; ) {
        var c = 31 - oc(b), d = 1 << c;
        a[c] = -1;
        b &= ~d;
      }
    }
    function Fk(a) {
      if (0 !== (K & 6))
        throw Error(p(327));
      Ik();
      var b = uc(a, 0);
      if (0 === (b & 1))
        return Ek(a, B()), null;
      var c = Jk(a, b);
      if (0 !== a.tag && 2 === c) {
        var d = xc(a);
        0 !== d && (b = d, c = Ok(a, d));
      }
      if (1 === c)
        throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
      if (6 === c)
        throw Error(p(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b;
      Qk(a, uk, vk);
      Ek(a, B());
      return null;
    }
    function Rk(a, b) {
      var c = K;
      K |= 1;
      try {
        return a(b);
      } finally {
        K = c, 0 === K && (Hj = B() + 500, fg && jg());
      }
    }
    function Sk(a) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b = K;
      K |= 1;
      var c = pk.transition, d = C;
      try {
        if (pk.transition = null, C = 1, a)
          return a();
      } finally {
        C = d, pk.transition = c, K = b, 0 === (K & 6) && jg();
      }
    }
    function Ij() {
      gj = fj.current;
      E(fj);
    }
    function Lk(a, b) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c = a.timeoutHandle;
      -1 !== c && (a.timeoutHandle = -1, Gf(c));
      if (null !== Y)
        for (c = Y.return; null !== c; ) {
          var d = c;
          wg(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f();
              break;
            case 3:
              Jh();
              E(Wf);
              E(H);
              Oh();
              break;
            case 5:
              Lh(d);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E(M);
              break;
            case 19:
              E(M);
              break;
            case 10:
              Rg(d.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c = c.return;
        }
      R = a;
      Y = a = wh(a.current, null);
      Z = gj = b;
      T = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b = 0; b < Wg.length; b++)
          if (c = Wg[b], d = c.interleaved, null !== d) {
            c.interleaved = null;
            var e = d.next, f2 = c.pending;
            if (null !== f2) {
              var g = f2.next;
              f2.next = e;
              d.next = g;
            }
            c.pending = d;
          }
        Wg = null;
      }
      return a;
    }
    function Nk(a, b) {
      do {
        var c = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d = N.memoizedState; null !== d; ) {
              var e = d.queue;
              null !== e && (e.pending = null);
              d = d.next;
            }
            Sh = false;
          }
          Rh = 0;
          P = O = N = null;
          Th = false;
          Uh = 0;
          ok$2.current = null;
          if (null === c || null === c.return) {
            T = 1;
            qk = b;
            Y = null;
            break;
          }
          a: {
            var f2 = a, g = c.return, h2 = c, k2 = b;
            b = Z;
            h2.flags |= 32768;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2, m2 = h2, q2 = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y2 = Vi(g);
              if (null !== y2) {
                y2.flags &= -257;
                Wi(y2, g, h2, f2, b);
                y2.mode & 1 && Ti(f2, l2, b);
                b = y2;
                k2 = l2;
                var n2 = b.updateQueue;
                if (null === n2) {
                  var t2 = /* @__PURE__ */ new Set();
                  t2.add(k2);
                  b.updateQueue = t2;
                } else
                  n2.add(k2);
                break a;
              } else {
                if (0 === (b & 1)) {
                  Ti(f2, l2, b);
                  uj();
                  break a;
                }
                k2 = Error(p(426));
              }
            } else if (I && h2.mode & 1) {
              var J2 = Vi(g);
              if (null !== J2) {
                0 === (J2.flags & 65536) && (J2.flags |= 256);
                Wi(J2, g, h2, f2, b);
                Jg(Ki(k2, h2));
                break a;
              }
            }
            f2 = k2 = Ki(k2, h2);
            4 !== T && (T = 2);
            null === tk ? tk = [f2] : tk.push(f2);
            f2 = g;
            do {
              switch (f2.tag) {
                case 3:
                  f2.flags |= 65536;
                  b &= -b;
                  f2.lanes |= b;
                  var x2 = Oi(f2, k2, b);
                  fh(f2, x2);
                  break a;
                case 1:
                  h2 = k2;
                  var w2 = f2.type, u2 = f2.stateNode;
                  if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                    f2.flags |= 65536;
                    b &= -b;
                    f2.lanes |= b;
                    var F2 = Ri(f2, h2, b);
                    fh(f2, F2);
                    break a;
                  }
              }
              f2 = f2.return;
            } while (null !== f2);
          }
          Tk(c);
        } catch (na) {
          b = na;
          Y === c && null !== c && (Y = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    function Kk() {
      var a = nk.current;
      nk.current = ai;
      return null === a ? ai : a;
    }
    function uj() {
      if (0 === T || 3 === T || 2 === T)
        T = 4;
      null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
    }
    function Jk(a, b) {
      var c = K;
      K |= 2;
      var d = Kk();
      if (R !== a || Z !== b)
        vk = null, Lk(a, b);
      do
        try {
          Uk();
          break;
        } catch (e) {
          Nk(a, e);
        }
      while (1);
      Qg();
      K = c;
      nk.current = d;
      if (null !== Y)
        throw Error(p(261));
      R = null;
      Z = 0;
      return T;
    }
    function Uk() {
      for (; null !== Y; )
        Vk(Y);
    }
    function Mk() {
      for (; null !== Y && !cc(); )
        Vk(Y);
    }
    function Vk(a) {
      var b = Wk(a.alternate, a, gj);
      a.memoizedProps = a.pendingProps;
      null === b ? Tk(a) : Y = b;
      ok$2.current = null;
    }
    function Tk(a) {
      var b = a;
      do {
        var c = b.alternate;
        a = b.return;
        if (0 === (b.flags & 32768)) {
          if (c = Fj(c, b, gj), null !== c) {
            Y = c;
            return;
          }
        } else {
          c = Jj(c, b);
          if (null !== c) {
            c.flags &= 32767;
            Y = c;
            return;
          }
          if (null !== a)
            a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b = b.sibling;
        if (null !== b) {
          Y = b;
          return;
        }
        Y = b = a;
      } while (null !== b);
      0 === T && (T = 5);
    }
    function Qk(a, b, c) {
      var d = C, e = pk.transition;
      try {
        pk.transition = null, C = 1, Xk(a, b, c, d);
      } finally {
        pk.transition = e, C = d;
      }
      return null;
    }
    function Xk(a, b, c, d) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K & 6))
        throw Error(p(327));
      c = a.finishedWork;
      var e = a.finishedLanes;
      if (null === c)
        return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c === a.current)
        throw Error(p(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f2 = c.lanes | c.childLanes;
      Bc(a, f2);
      a === R && (Y = R = null, Z = 0);
      0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f2 = 0 !== (c.flags & 15990);
      if (0 !== (c.subtreeFlags & 15990) || f2) {
        f2 = pk.transition;
        pk.transition = null;
        var g = C;
        C = 1;
        var h2 = K;
        K |= 4;
        ok$2.current = null;
        Pj(a, c);
        ek(c, a);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c;
        ik(c);
        dc();
        K = h2;
        C = g;
        pk.transition = f2;
      } else
        a.current = c;
      wk && (wk = false, xk = a, yk = e);
      f2 = a.pendingLanes;
      0 === f2 && (Si = null);
      mc(c.stateNode);
      Ek(a, B());
      if (null !== b)
        for (d = a.onRecoverableError, c = 0; c < b.length; c++)
          e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
      if (Pi)
        throw Pi = false, a = Qi, Qi = null, a;
      0 !== (yk & 1) && 0 !== a.tag && Ik();
      f2 = a.pendingLanes;
      0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
      jg();
      return null;
    }
    function Ik() {
      if (null !== xk) {
        var a = Dc(yk), b = pk.transition, c = C;
        try {
          pk.transition = null;
          C = 16 > a ? 16 : a;
          if (null === xk)
            var d = false;
          else {
            a = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6))
              throw Error(p(331));
            var e = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f2 = V, g = f2.child;
              if (0 !== (V.flags & 16)) {
                var h2 = f2.deletions;
                if (null !== h2) {
                  for (var k2 = 0; k2 < h2.length; k2++) {
                    var l2 = h2[k2];
                    for (V = l2; null !== V; ) {
                      var m2 = V;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m2, f2);
                      }
                      var q2 = m2.child;
                      if (null !== q2)
                        q2.return = m2, V = q2;
                      else
                        for (; null !== V; ) {
                          m2 = V;
                          var r2 = m2.sibling, y2 = m2.return;
                          Tj(m2);
                          if (m2 === l2) {
                            V = null;
                            break;
                          }
                          if (null !== r2) {
                            r2.return = y2;
                            V = r2;
                            break;
                          }
                          V = y2;
                        }
                    }
                  }
                  var n2 = f2.alternate;
                  if (null !== n2) {
                    var t2 = n2.child;
                    if (null !== t2) {
                      n2.child = null;
                      do {
                        var J2 = t2.sibling;
                        t2.sibling = null;
                        t2 = J2;
                      } while (null !== t2);
                    }
                  }
                  V = f2;
                }
              }
              if (0 !== (f2.subtreeFlags & 2064) && null !== g)
                g.return = f2, V = g;
              else
                b:
                  for (; null !== V; ) {
                    f2 = V;
                    if (0 !== (f2.flags & 2048))
                      switch (f2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, f2, f2.return);
                      }
                    var x2 = f2.sibling;
                    if (null !== x2) {
                      x2.return = f2.return;
                      V = x2;
                      break b;
                    }
                    V = f2.return;
                  }
            }
            var w2 = a.current;
            for (V = w2; null !== V; ) {
              g = V;
              var u2 = g.child;
              if (0 !== (g.subtreeFlags & 2064) && null !== u2)
                u2.return = g, V = u2;
              else
                b:
                  for (g = w2; null !== V; ) {
                    h2 = V;
                    if (0 !== (h2.flags & 2048))
                      try {
                        switch (h2.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rj(9, h2);
                        }
                      } catch (na) {
                        W(h2, h2.return, na);
                      }
                    if (h2 === g) {
                      V = null;
                      break b;
                    }
                    var F2 = h2.sibling;
                    if (null !== F2) {
                      F2.return = h2.return;
                      V = F2;
                      break b;
                    }
                    V = h2.return;
                  }
            }
            K = e;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot)
              try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
            d = true;
          }
          return d;
        } finally {
          C = c, pk.transition = b;
        }
      }
      return false;
    }
    function Yk(a, b, c) {
      b = Ki(c, b);
      b = Oi(a, b, 1);
      a = dh(a, b, 1);
      b = L();
      null !== a && (Ac(a, 1, b), Ek(a, b));
    }
    function W(a, b, c) {
      if (3 === a.tag)
        Yk(a, a, c);
      else
        for (; null !== b; ) {
          if (3 === b.tag) {
            Yk(b, a, c);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
              a = Ki(c, a);
              a = Ri(b, a, 1);
              b = dh(b, a, 1);
              a = L();
              null !== b && (Ac(b, 1, a), Ek(b, a));
              break;
            }
          }
          b = b.return;
        }
    }
    function Ui(a, b, c) {
      var d = a.pingCache;
      null !== d && d.delete(b);
      b = L();
      a.pingedLanes |= a.suspendedLanes & c;
      R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
      Ek(a, b);
    }
    function Zk(a, b) {
      0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c = L();
      a = Zg(a, b);
      null !== a && (Ac(a, b, c), Ek(a, c));
    }
    function vj(a) {
      var b = a.memoizedState, c = 0;
      null !== b && (c = b.retryLane);
      Zk(a, c);
    }
    function ck(a, b) {
      var c = 0;
      switch (a.tag) {
        case 13:
          var d = a.stateNode;
          var e = a.memoizedState;
          null !== e && (c = e.retryLane);
          break;
        case 19:
          d = a.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      null !== d && d.delete(b);
      Zk(a, c);
    }
    var Wk;
    Wk = function(a, b, c) {
      if (null !== a)
        if (a.memoizedProps !== b.pendingProps || Wf.current)
          Ug = true;
        else {
          if (0 === (a.lanes & c) && 0 === (b.flags & 128))
            return Ug = false, zj(a, b, c);
          Ug = 0 !== (a.flags & 131072) ? true : false;
        }
      else
        Ug = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          var d = b.type;
          jj(a, b);
          a = b.pendingProps;
          var e = Yf(b, H.current);
          Tg(b, c);
          e = Xh(null, b, d, a, e, c);
          var f2 = bi();
          b.flags |= 1;
          "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f2 = true, cg(b)) : f2 = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d, a, c), b = kj(null, b, d, true, f2, c)) : (b.tag = 0, I && f2 && vg(b), Yi(null, b, e, c), b = b.child);
          return b;
        case 16:
          d = b.elementType;
          a: {
            jj(a, b);
            a = b.pendingProps;
            e = d._init;
            d = e(d._payload);
            b.type = d;
            e = b.tag = $k(d);
            a = Lg(d, a);
            switch (e) {
              case 0:
                b = dj(null, b, d, a, c);
                break a;
              case 1:
                b = ij(null, b, d, a, c);
                break a;
              case 11:
                b = Zi(null, b, d, a, c);
                break a;
              case 14:
                b = aj(null, b, d, Lg(d.type, a), c);
                break a;
            }
            throw Error(p(
              306,
              d,
              ""
            ));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), dj(a, b, d, e, c);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), ij(a, b, d, e, c);
        case 3:
          a: {
            lj(b);
            if (null === a)
              throw Error(p(387));
            d = b.pendingProps;
            f2 = b.memoizedState;
            e = f2.element;
            bh(a, b);
            gh(b, d, null, c);
            var g = b.memoizedState;
            d = g.element;
            if (f2.isDehydrated)
              if (f2 = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
                e = Ki(Error(p(423)), b);
                b = mj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ki(Error(p(424)), b);
                b = mj(a, b, d, c, e);
                break a;
              } else
                for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Ch(b, null, d, c), b.child = c; c; )
                  c.flags = c.flags & -3 | 4096, c = c.sibling;
            else {
              Ig();
              if (d === e) {
                b = $i(a, b, c);
                break a;
              }
              Yi(a, b, d, c);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Kh(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f2 = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f2 && Ef(d, f2) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
        case 6:
          return null === a && Eg(b), null;
        case 13:
          return pj(a, b, c);
        case 4:
          return Ih(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Bh(b, null, d, c) : Yi(a, b, d, c), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), Zi(a, b, d, e, c);
        case 7:
          return Yi(a, b, b.pendingProps, c), b.child;
        case 8:
          return Yi(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return Yi(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            f2 = b.memoizedProps;
            g = e.value;
            G(Mg, d._currentValue);
            d._currentValue = g;
            if (null !== f2)
              if (He(f2.value, g)) {
                if (f2.children === e.children && !Wf.current) {
                  b = $i(a, b, c);
                  break a;
                }
              } else
                for (f2 = b.child, null !== f2 && (f2.return = b); null !== f2; ) {
                  var h2 = f2.dependencies;
                  if (null !== h2) {
                    g = f2.child;
                    for (var k2 = h2.firstContext; null !== k2; ) {
                      if (k2.context === d) {
                        if (1 === f2.tag) {
                          k2 = ch(-1, c & -c);
                          k2.tag = 2;
                          var l2 = f2.updateQueue;
                          if (null !== l2) {
                            l2 = l2.shared;
                            var m2 = l2.pending;
                            null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                            l2.pending = k2;
                          }
                        }
                        f2.lanes |= c;
                        k2 = f2.alternate;
                        null !== k2 && (k2.lanes |= c);
                        Sg(
                          f2.return,
                          c,
                          b
                        );
                        h2.lanes |= c;
                        break;
                      }
                      k2 = k2.next;
                    }
                  } else if (10 === f2.tag)
                    g = f2.type === b.type ? null : f2.child;
                  else if (18 === f2.tag) {
                    g = f2.return;
                    if (null === g)
                      throw Error(p(341));
                    g.lanes |= c;
                    h2 = g.alternate;
                    null !== h2 && (h2.lanes |= c);
                    Sg(g, c, b);
                    g = f2.sibling;
                  } else
                    g = f2.child;
                  if (null !== g)
                    g.return = f2;
                  else
                    for (g = f2; null !== g; ) {
                      if (g === b) {
                        g = null;
                        break;
                      }
                      f2 = g.sibling;
                      if (null !== f2) {
                        f2.return = g.return;
                        g = f2;
                        break;
                      }
                      g = g.return;
                    }
                  f2 = g;
                }
            Yi(a, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, d = b.pendingProps.children, Tg(b, c), e = Vg(e), d = d(e), b.flags |= 1, Yi(a, b, d, c), b.child;
        case 14:
          return d = b.type, e = Lg(d, b.pendingProps), e = Lg(d.type, e), aj(a, b, d, e, c);
        case 15:
          return cj(a, b, b.type, b.pendingProps, c);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), jj(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, Tg(b, c), ph(b, d, e), rh(b, d, e, c), kj(null, b, d, true, a, c);
        case 19:
          return yj(a, b, c);
        case 22:
          return ej(a, b, c);
      }
      throw Error(p(156, b.tag));
    };
    function Gk(a, b) {
      return ac(a, b);
    }
    function al(a, b, c, d) {
      this.tag = a;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a, b, c, d) {
      return new al(a, b, c, d);
    }
    function bj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function $k(a) {
      if ("function" === typeof a)
        return bj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da)
          return 11;
        if (a === Ga)
          return 14;
      }
      return 2;
    }
    function wh(a, b) {
      var c = a.alternate;
      null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
      c.flags = a.flags & 14680064;
      c.childLanes = a.childLanes;
      c.lanes = a.lanes;
      c.child = a.child;
      c.memoizedProps = a.memoizedProps;
      c.memoizedState = a.memoizedState;
      c.updateQueue = a.updateQueue;
      b = a.dependencies;
      c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c.sibling = a.sibling;
      c.index = a.index;
      c.ref = a.ref;
      return c;
    }
    function yh(a, b, c, d, e, f2) {
      var g = 2;
      d = a;
      if ("function" === typeof a)
        bj(a) && (g = 1);
      else if ("string" === typeof a)
        g = 5;
      else
        a:
          switch (a) {
            case ya:
              return Ah(c.children, e, f2, b);
            case za:
              g = 8;
              e |= 8;
              break;
            case Aa:
              return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f2, a;
            case Ea:
              return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f2, a;
            case Fa:
              return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f2, a;
            case Ia:
              return qj(c, e, f2, b);
            default:
              if ("object" === typeof a && null !== a)
                switch (a.$$typeof) {
                  case Ba:
                    g = 10;
                    break a;
                  case Ca:
                    g = 9;
                    break a;
                  case Da:
                    g = 11;
                    break a;
                  case Ga:
                    g = 14;
                    break a;
                  case Ha:
                    g = 16;
                    d = null;
                    break a;
                }
              throw Error(p(130, null == a ? a : typeof a, ""));
          }
      b = Bg(g, c, b, e);
      b.elementType = a;
      b.type = d;
      b.lanes = f2;
      return b;
    }
    function Ah(a, b, c, d) {
      a = Bg(7, a, d, b);
      a.lanes = c;
      return a;
    }
    function qj(a, b, c, d) {
      a = Bg(22, a, d, b);
      a.elementType = Ia;
      a.lanes = c;
      a.stateNode = { isHidden: false };
      return a;
    }
    function xh(a, b, c) {
      a = Bg(6, a, null, b);
      a.lanes = c;
      return a;
    }
    function zh(a, b, c) {
      b = Bg(4, null !== a.children ? a.children : [], a.key, b);
      b.lanes = c;
      b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b;
    }
    function bl(a, b, c, d, e) {
      this.tag = b;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d;
      this.onRecoverableError = e;
      this.mutableSourceEagerHydrationData = null;
    }
    function cl(a, b, c, d, e, f2, g, h2, k2) {
      a = new bl(a, b, c, h2, k2);
      1 === b ? (b = 1, true === f2 && (b |= 8)) : b = 0;
      f2 = Bg(3, null, null, b);
      a.current = f2;
      f2.stateNode = a;
      f2.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f2);
      return a;
    }
    function dl(a, b, c) {
      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
    }
    function el$1(a) {
      if (!a)
        return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag)
          throw Error(p(170));
        var b = a;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (null !== b);
        throw Error(p(171));
      }
      if (1 === a.tag) {
        var c = a.type;
        if (Zf(c))
          return bg(a, c, b);
      }
      return b;
    }
    function fl(a, b, c, d, e, f2, g, h2, k2) {
      a = cl(c, d, true, a, e, f2, g, h2, k2);
      a.context = el$1(null);
      c = a.current;
      d = L();
      e = lh(c);
      f2 = ch(d, e);
      f2.callback = void 0 !== b && null !== b ? b : null;
      dh(c, f2, e);
      a.current.lanes = e;
      Ac(a, e, d);
      Ek(a, d);
      return a;
    }
    function gl(a, b, c, d) {
      var e = b.current, f2 = L(), g = lh(e);
      c = el$1(c);
      null === b.context ? b.context = c : b.pendingContext = c;
      b = ch(f2, g);
      b.payload = { element: a };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      a = dh(e, b, g);
      null !== a && (mh(a, e, g, f2), eh(a, e, g));
      return g;
    }
    function hl(a) {
      a = a.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function il(a, b) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c = a.retryLane;
        a.retryLane = 0 !== c && c < b ? c : b;
      }
    }
    function jl(a, b) {
      il(a, b);
      (a = a.alternate) && il(a, b);
    }
    function kl() {
      return null;
    }
    var ll = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ml(a) {
      this._internalRoot = a;
    }
    nl.prototype.render = ml.prototype.render = function(a) {
      var b = this._internalRoot;
      if (null === b)
        throw Error(p(409));
      gl(a, b, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b = a.containerInfo;
        Sk(function() {
          gl(null, a, null, null);
        });
        b[uf] = null;
      }
    };
    function nl(a) {
      this._internalRoot = a;
    }
    nl.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b = Hc();
        a = { blockedOn: null, target: a, priority: b };
        for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++)
          ;
        Qc.splice(c, 0, a);
        0 === c && Vc(a);
      }
    };
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    function pl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function ql() {
    }
    function rl(a, b, c, d, e) {
      if (e) {
        if ("function" === typeof d) {
          var f2 = d;
          d = function() {
            var a2 = hl(g);
            f2.call(a2);
          };
        }
        var g = fl(b, d, a, 0, null, false, false, "", ql);
        a._reactRootContainer = g;
        a[uf] = g.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk();
        return g;
      }
      for (; e = a.lastChild; )
        a.removeChild(e);
      if ("function" === typeof d) {
        var h2 = d;
        d = function() {
          var a2 = hl(k2);
          h2.call(a2);
        };
      }
      var k2 = cl(a, 0, false, null, null, false, false, "", ql);
      a._reactRootContainer = k2;
      a[uf] = k2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Sk(function() {
        gl(b, k2, c, d);
      });
      return k2;
    }
    function sl(a, b, c, d, e) {
      var f2 = c._reactRootContainer;
      if (f2) {
        var g = f2;
        if ("function" === typeof e) {
          var h2 = e;
          e = function() {
            var a2 = hl(g);
            h2.call(a2);
          };
        }
        gl(b, g, a, e);
      } else
        g = rl(c, b, a, e, d);
      return hl(g);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c = tc(b.pendingLanes);
            0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b2 = Zg(a, 1);
            if (null !== b2) {
              var c2 = L();
              mh(b2, a, 1, c2);
            }
          }), jl(a, 1);
      }
    };
    Fc = function(a) {
      if (13 === a.tag) {
        var b = Zg(a, 134217728);
        if (null !== b) {
          var c = L();
          mh(b, a, 134217728, c);
        }
        jl(a, 134217728);
      }
    };
    Gc = function(a) {
      if (13 === a.tag) {
        var b = lh(a), c = Zg(a, b);
        if (null !== c) {
          var d = L();
          mh(c, a, b, d);
        }
        jl(a, b);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a, b) {
      var c = C;
      try {
        return C = a, b();
      } finally {
        C = c;
      }
    };
    yb = function(a, b, c) {
      switch (b) {
        case "input":
          bb(a, c);
          b = c.name;
          if ("radio" === c.type && null != b) {
            for (c = a; c.parentNode; )
              c = c.parentNode;
            c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a && d.form === a.form) {
                var e = Db(d);
                if (!e)
                  throw Error(p(90));
                Wa(d);
                bb(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c);
          break;
        case "select":
          b = c.value, null != b && fb(a, !!c.multiple, b, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber)
        try {
          kc = wl.inject(vl), lc = wl;
        } catch (a) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    reactDom_production_min.createPortal = function(a, b) {
      var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b))
        throw Error(p(200));
      return dl(a, b, null, c);
    };
    reactDom_production_min.createRoot = function(a, b) {
      if (!ol(a))
        throw Error(p(299));
      var c = false, d = "", e = ll;
      null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
      b = cl(a, 1, false, null, null, c, false, d, e);
      a[uf] = b.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ml(b);
    };
    reactDom_production_min.findDOMNode = function(a) {
      if (null == a)
        return null;
      if (1 === a.nodeType)
        return a;
      var b = a._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a.render)
          throw Error(p(188));
        a = Object.keys(a).join(",");
        throw Error(p(268, a));
      }
      a = Zb(b);
      a = null === a ? null : a.stateNode;
      return a;
    };
    reactDom_production_min.flushSync = function(a) {
      return Sk(a);
    };
    reactDom_production_min.hydrate = function(a, b, c) {
      if (!pl(b))
        throw Error(p(200));
      return sl(null, a, b, true, c);
    };
    reactDom_production_min.hydrateRoot = function(a, b, c) {
      if (!ol(a))
        throw Error(p(405));
      var d = null != c && c.hydratedSources || null, e = false, f2 = "", g = ll;
      null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f2 = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
      b = fl(b, null, a, 1, null != c ? c : null, e, false, f2, g);
      a[uf] = b.current;
      sf(a);
      if (d)
        for (a = 0; a < d.length; a++)
          c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
            c,
            e
          );
      return new nl(b);
    };
    reactDom_production_min.render = function(a, b, c) {
      if (!pl(b))
        throw Error(p(200));
      return sl(null, a, b, false, c);
    };
    reactDom_production_min.unmountComponentAtNode = function(a) {
      if (!pl(a))
        throw Error(p(40));
      return a._reactRootContainer ? (Sk(function() {
        sl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Rk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
      if (!pl(c))
        throw Error(p(200));
      if (null == a || void 0 === a._reactInternals)
        throw Error(p(38));
      return sl(a, b, c, false, d);
    };
    reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
    (function(module2) {
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        module2.exports = reactDom_production_min;
      }
    })(reactDom);
    var m = reactDomExports;
    {
      client.createRoot = m.createRoot;
      client.hydrateRoot = m.hydrateRoot;
    }
    function ok$1() {
    }
    function unreachable() {
    }
    function stringify$5(values, options) {
      const settings = options || {};
      const input = values[values.length - 1] === "" ? [...values, ""] : values;
      return input.join(
        (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
      ).trim();
    }
    const re = /[ \t\n\f\r]/g;
    function whitespace(thing) {
      return typeof thing === "object" ? thing.type === "text" ? empty$3(thing.value) : false : empty$3(thing);
    }
    function empty$3(value) {
      return value.replace(re, "") === "";
    }
    let Schema$3 = class Schema {
      /**
       * @constructor
       * @param {Properties} property
       * @param {Normal} normal
       * @param {string} [space]
       */
      constructor(property2, normal, space2) {
        this.property = property2;
        this.normal = normal;
        if (space2) {
          this.space = space2;
        }
      }
    };
    Schema$3.prototype.property = {};
    Schema$3.prototype.normal = {};
    Schema$3.prototype.space = null;
    function merge$2(definitions, space2) {
      const property2 = {};
      const normal = {};
      let index2 = -1;
      while (++index2 < definitions.length) {
        Object.assign(property2, definitions[index2].property);
        Object.assign(normal, definitions[index2].normal);
      }
      return new Schema$3(property2, normal, space2);
    }
    function normalize$5(value) {
      return value.toLowerCase();
    }
    let Info$3 = class Info {
      /**
       * @constructor
       * @param {string} property
       * @param {string} attribute
       */
      constructor(property2, attribute) {
        this.property = property2;
        this.attribute = attribute;
      }
    };
    Info$3.prototype.space = null;
    Info$3.prototype.boolean = false;
    Info$3.prototype.booleanish = false;
    Info$3.prototype.overloadedBoolean = false;
    Info$3.prototype.number = false;
    Info$3.prototype.commaSeparated = false;
    Info$3.prototype.spaceSeparated = false;
    Info$3.prototype.commaOrSpaceSeparated = false;
    Info$3.prototype.mustUseProperty = false;
    Info$3.prototype.defined = false;
    let powers$1 = 0;
    const boolean$1 = increment$1();
    const booleanish$2 = increment$1();
    const overloadedBoolean$1 = increment$1();
    const number$2 = increment$1();
    const spaceSeparated$2 = increment$1();
    const commaSeparated$1 = increment$1();
    const commaOrSpaceSeparated = increment$1();
    function increment$1() {
      return 2 ** ++powers$1;
    }
    const types$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      boolean: boolean$1,
      booleanish: booleanish$2,
      commaOrSpaceSeparated,
      commaSeparated: commaSeparated$1,
      number: number$2,
      overloadedBoolean: overloadedBoolean$1,
      spaceSeparated: spaceSeparated$2
    }, Symbol.toStringTag, { value: "Module" }));
    const checks$1 = Object.keys(types$4);
    let DefinedInfo$3 = class DefinedInfo extends Info$3 {
      /**
       * @constructor
       * @param {string} property
       * @param {string} attribute
       * @param {number|null} [mask]
       * @param {string} [space]
       */
      constructor(property2, attribute, mask, space2) {
        let index2 = -1;
        super(property2, attribute);
        mark$1(this, "space", space2);
        if (typeof mask === "number") {
          while (++index2 < checks$1.length) {
            const check = checks$1[index2];
            mark$1(this, checks$1[index2], (mask & types$4[check]) === types$4[check]);
          }
        }
      }
    };
    DefinedInfo$3.prototype.defined = true;
    function mark$1(values, key, value) {
      if (value) {
        values[key] = value;
      }
    }
    const own$8 = {}.hasOwnProperty;
    function create$6(definition2) {
      const property2 = {};
      const normal = {};
      let prop;
      for (prop in definition2.properties) {
        if (own$8.call(definition2.properties, prop)) {
          const value = definition2.properties[prop];
          const info2 = new DefinedInfo$3(
            prop,
            definition2.transform(definition2.attributes || {}, prop),
            value,
            definition2.space
          );
          if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
            info2.mustUseProperty = true;
          }
          property2[prop] = info2;
          normal[normalize$5(prop)] = prop;
          normal[normalize$5(info2.attribute)] = prop;
        }
      }
      return new Schema$3(property2, normal, definition2.space);
    }
    const xlink$2 = create$6({
      space: "xlink",
      transform(_, prop) {
        return "xlink:" + prop.slice(5).toLowerCase();
      },
      properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
      }
    });
    const xml$2 = create$6({
      space: "xml",
      transform(_, prop) {
        return "xml:" + prop.slice(3).toLowerCase();
      },
      properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
    });
    function caseSensitiveTransform$2(attributes2, attribute) {
      return attribute in attributes2 ? attributes2[attribute] : attribute;
    }
    function caseInsensitiveTransform$3(attributes2, property2) {
      return caseSensitiveTransform$2(attributes2, property2.toLowerCase());
    }
    const xmlns$2 = create$6({
      space: "xmlns",
      attributes: { xmlnsxlink: "xmlns:xlink" },
      transform: caseInsensitiveTransform$3,
      properties: { xmlns: null, xmlnsXLink: null }
    });
    const aria$2 = create$6({
      transform(_, prop) {
        return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
      },
      properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish$2,
        ariaAutoComplete: null,
        ariaBusy: booleanish$2,
        ariaChecked: booleanish$2,
        ariaColCount: number$2,
        ariaColIndex: number$2,
        ariaColSpan: number$2,
        ariaControls: spaceSeparated$2,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated$2,
        ariaDetails: null,
        ariaDisabled: booleanish$2,
        ariaDropEffect: spaceSeparated$2,
        ariaErrorMessage: null,
        ariaExpanded: booleanish$2,
        ariaFlowTo: spaceSeparated$2,
        ariaGrabbed: booleanish$2,
        ariaHasPopup: null,
        ariaHidden: booleanish$2,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated$2,
        ariaLevel: number$2,
        ariaLive: null,
        ariaModal: booleanish$2,
        ariaMultiLine: booleanish$2,
        ariaMultiSelectable: booleanish$2,
        ariaOrientation: null,
        ariaOwns: spaceSeparated$2,
        ariaPlaceholder: null,
        ariaPosInSet: number$2,
        ariaPressed: booleanish$2,
        ariaReadOnly: booleanish$2,
        ariaRelevant: null,
        ariaRequired: booleanish$2,
        ariaRoleDescription: spaceSeparated$2,
        ariaRowCount: number$2,
        ariaRowIndex: number$2,
        ariaRowSpan: number$2,
        ariaSelected: booleanish$2,
        ariaSetSize: number$2,
        ariaSort: null,
        ariaValueMax: number$2,
        ariaValueMin: number$2,
        ariaValueNow: number$2,
        ariaValueText: null,
        role: null
      }
    });
    const html$6 = create$6({
      space: "html",
      attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
      },
      transform: caseInsensitiveTransform$3,
      mustUseProperty: ["checked", "multiple", "muted", "selected"],
      properties: {
        // Standard Properties.
        abbr: null,
        accept: commaSeparated$1,
        acceptCharset: spaceSeparated$2,
        accessKey: spaceSeparated$2,
        action: null,
        allow: null,
        allowFullScreen: boolean$1,
        allowPaymentRequest: boolean$1,
        allowUserMedia: boolean$1,
        alt: null,
        as: null,
        async: boolean$1,
        autoCapitalize: null,
        autoComplete: spaceSeparated$2,
        autoFocus: boolean$1,
        autoPlay: boolean$1,
        blocking: spaceSeparated$2,
        capture: boolean$1,
        charSet: null,
        checked: boolean$1,
        cite: null,
        className: spaceSeparated$2,
        cols: number$2,
        colSpan: null,
        content: null,
        contentEditable: booleanish$2,
        controls: boolean$1,
        controlsList: spaceSeparated$2,
        coords: number$2 | commaSeparated$1,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean$1,
        defer: boolean$1,
        dir: null,
        dirName: null,
        disabled: boolean$1,
        download: overloadedBoolean$1,
        draggable: booleanish$2,
        encType: null,
        enterKeyHint: null,
        fetchPriority: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean$1,
        formTarget: null,
        headers: spaceSeparated$2,
        height: number$2,
        hidden: boolean$1,
        high: number$2,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated$2,
        httpEquiv: spaceSeparated$2,
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inert: boolean$1,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean$1,
        itemId: null,
        itemProp: spaceSeparated$2,
        itemRef: spaceSeparated$2,
        itemScope: boolean$1,
        itemType: spaceSeparated$2,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean$1,
        low: number$2,
        manifest: null,
        max: null,
        maxLength: number$2,
        media: null,
        method: null,
        min: null,
        minLength: number$2,
        multiple: boolean$1,
        muted: boolean$1,
        name: null,
        nonce: null,
        noModule: boolean$1,
        noValidate: boolean$1,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean$1,
        optimum: number$2,
        pattern: null,
        ping: spaceSeparated$2,
        placeholder: null,
        playsInline: boolean$1,
        popover: null,
        popoverTarget: null,
        popoverTargetAction: null,
        poster: null,
        preload: null,
        readOnly: boolean$1,
        referrerPolicy: null,
        rel: spaceSeparated$2,
        required: boolean$1,
        reversed: boolean$1,
        rows: number$2,
        rowSpan: number$2,
        sandbox: spaceSeparated$2,
        scope: null,
        scoped: boolean$1,
        seamless: boolean$1,
        selected: boolean$1,
        shape: null,
        size: number$2,
        sizes: null,
        slot: null,
        span: number$2,
        spellCheck: booleanish$2,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: number$2,
        step: null,
        style: null,
        tabIndex: number$2,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean$1,
        useMap: null,
        value: booleanish$2,
        width: number$2,
        wrap: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        // Several. Use CSS `text-align` instead,
        aLink: null,
        // `<body>`. Use CSS `a:active {color}` instead
        archive: spaceSeparated$2,
        // `<object>`. List of URIs to archives
        axis: null,
        // `<td>` and `<th>`. Use `scope` on `<th>`
        background: null,
        // `<body>`. Use CSS `background-image` instead
        bgColor: null,
        // `<body>` and table elements. Use CSS `background-color` instead
        border: number$2,
        // `<table>`. Use CSS `border-width` instead,
        borderColor: null,
        // `<table>`. Use CSS `border-color` instead,
        bottomMargin: number$2,
        // `<body>`
        cellPadding: null,
        // `<table>`
        cellSpacing: null,
        // `<table>`
        char: null,
        // Several table elements. When `align=char`, sets the character to align on
        charOff: null,
        // Several table elements. When `char`, offsets the alignment
        classId: null,
        // `<object>`
        clear: null,
        // `<br>`. Use CSS `clear` instead
        code: null,
        // `<object>`
        codeBase: null,
        // `<object>`
        codeType: null,
        // `<object>`
        color: null,
        // `<font>` and `<hr>`. Use CSS instead
        compact: boolean$1,
        // Lists. Use CSS to reduce space between items instead
        declare: boolean$1,
        // `<object>`
        event: null,
        // `<script>`
        face: null,
        // `<font>`. Use CSS instead
        frame: null,
        // `<table>`
        frameBorder: null,
        // `<iframe>`. Use CSS `border` instead
        hSpace: number$2,
        // `<img>` and `<object>`
        leftMargin: number$2,
        // `<body>`
        link: null,
        // `<body>`. Use CSS `a:link {color: *}` instead
        longDesc: null,
        // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
        lowSrc: null,
        // `<img>`. Use a `<picture>`
        marginHeight: number$2,
        // `<body>`
        marginWidth: number$2,
        // `<body>`
        noResize: boolean$1,
        // `<frame>`
        noHref: boolean$1,
        // `<area>`. Use no href instead of an explicit `nohref`
        noShade: boolean$1,
        // `<hr>`. Use background-color and height instead of borders
        noWrap: boolean$1,
        // `<td>` and `<th>`
        object: null,
        // `<applet>`
        profile: null,
        // `<head>`
        prompt: null,
        // `<isindex>`
        rev: null,
        // `<link>`
        rightMargin: number$2,
        // `<body>`
        rules: null,
        // `<table>`
        scheme: null,
        // `<meta>`
        scrolling: booleanish$2,
        // `<frame>`. Use overflow in the child context
        standby: null,
        // `<object>`
        summary: null,
        // `<table>`
        text: null,
        // `<body>`. Use CSS `color` instead
        topMargin: number$2,
        // `<body>`
        valueType: null,
        // `<param>`
        version: null,
        // `<html>`. Use a doctype.
        vAlign: null,
        // Several. Use CSS `vertical-align` instead
        vLink: null,
        // `<body>`. Use CSS `a:visited {color}` instead
        vSpace: number$2,
        // `<img>` and `<object>`
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean$1,
        disableRemotePlayback: boolean$1,
        prefix: null,
        property: null,
        results: number$2,
        security: null,
        unselectable: null
      }
    });
    const svg$1 = create$6({
      space: "svg",
      attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        transformOrigin: "transform-origin",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        // These were camelcased in Tiny. Now lowercased in SVG 2
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
      },
      transform: caseSensitiveTransform$2,
      properties: {
        about: commaOrSpaceSeparated,
        accentHeight: number$2,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: number$2,
        amplitude: number$2,
        arabicForm: null,
        ascent: number$2,
        attributeName: null,
        attributeType: null,
        azimuth: number$2,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: number$2,
        by: null,
        calcMode: null,
        capHeight: number$2,
        className: spaceSeparated$2,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: number$2,
        diffuseConstant: number$2,
        direction: null,
        display: null,
        dur: null,
        divisor: number$2,
        dominantBaseline: null,
        download: boolean$1,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: number$2,
        enableBackground: null,
        end: null,
        event: null,
        exponent: number$2,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: number$2,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: commaSeparated$1,
        g2: commaSeparated$1,
        glyphName: commaSeparated$1,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: number$2,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: number$2,
        horizOriginX: number$2,
        horizOriginY: number$2,
        id: null,
        ideographic: number$2,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: number$2,
        k: number$2,
        k1: number$2,
        k2: number$2,
        k3: number$2,
        k4: number$2,
        kernelMatrix: commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null,
        // SEMI_COLON_SEPARATED
        keySplines: null,
        // SEMI_COLON_SEPARATED
        keyTimes: null,
        // SEMI_COLON_SEPARATED
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: number$2,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: number$2,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: number$2,
        overlineThickness: number$2,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: number$2,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: spaceSeparated$2,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: number$2,
        pointsAtY: number$2,
        pointsAtZ: number$2,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: commaOrSpaceSeparated,
        rev: commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: commaOrSpaceSeparated,
        requiredFeatures: commaOrSpaceSeparated,
        requiredFonts: commaOrSpaceSeparated,
        requiredFormats: commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: number$2,
        specularExponent: number$2,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: number$2,
        strikethroughThickness: number$2,
        string: null,
        stroke: null,
        strokeDashArray: commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: number$2,
        strokeOpacity: number$2,
        strokeWidth: null,
        style: null,
        surfaceScale: number$2,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: commaOrSpaceSeparated,
        tabIndex: number$2,
        tableValues: null,
        target: null,
        targetX: number$2,
        targetY: number$2,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: commaOrSpaceSeparated,
        to: null,
        transform: null,
        transformOrigin: null,
        u1: null,
        u2: null,
        underlinePosition: number$2,
        underlineThickness: number$2,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: number$2,
        values: null,
        vAlphabetic: number$2,
        vMathematical: number$2,
        vectorEffect: null,
        vHanging: number$2,
        vIdeographic: number$2,
        version: null,
        vertAdvY: number$2,
        vertOriginX: number$2,
        vertOriginY: number$2,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: number$2,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
      }
    });
    const valid$1 = /^data[-\w.:]+$/i;
    const dash$1 = /-[a-z]/g;
    const cap$2 = /[A-Z]/g;
    function find$2(schema2, value) {
      const normal = normalize$5(value);
      let prop = value;
      let Type = Info$3;
      if (normal in schema2.normal) {
        return schema2.property[schema2.normal[normal]];
      }
      if (normal.length > 4 && normal.slice(0, 4) === "data" && valid$1.test(value)) {
        if (value.charAt(4) === "-") {
          const rest = value.slice(5).replace(dash$1, camelcase$1);
          prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
        } else {
          const rest = value.slice(4);
          if (!dash$1.test(rest)) {
            let dashes = rest.replace(cap$2, kebab$1);
            if (dashes.charAt(0) !== "-") {
              dashes = "-" + dashes;
            }
            value = "data" + dashes;
          }
        }
        Type = DefinedInfo$3;
      }
      return new Type(prop, value);
    }
    function kebab$1($0) {
      return "-" + $0.toLowerCase();
    }
    function camelcase$1($0) {
      return $0.charAt(1).toUpperCase();
    }
    const hastToReact = {
      classId: "classID",
      dataType: "datatype",
      itemId: "itemID",
      strokeDashArray: "strokeDasharray",
      strokeDashOffset: "strokeDashoffset",
      strokeLineCap: "strokeLinecap",
      strokeLineJoin: "strokeLinejoin",
      strokeMiterLimit: "strokeMiterlimit",
      typeOf: "typeof",
      xLinkActuate: "xlinkActuate",
      xLinkArcRole: "xlinkArcrole",
      xLinkHref: "xlinkHref",
      xLinkRole: "xlinkRole",
      xLinkShow: "xlinkShow",
      xLinkTitle: "xlinkTitle",
      xLinkType: "xlinkType",
      xmlnsXLink: "xmlnsXlink"
    };
    const html$5 = merge$2([xml$2, xlink$2, xmlns$2, aria$2, html$6], "html");
    const svg = merge$2([xml$2, xlink$2, xmlns$2, aria$2, svg$1], "svg");
    function stringify$4(values) {
      return values.join(" ").trim();
    }
    var styleToObjectExports = {};
    var styleToObject$1 = {
      get exports() {
        return styleToObjectExports;
      },
      set exports(v2) {
        styleToObjectExports = v2;
      }
    };
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    var inlineStyleParser = function(style2, options) {
      if (typeof style2 !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style2)
        return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines)
          lineno += lines.length;
        var i = str.lastIndexOf(NEWLINE);
        column = ~i ? str.length - i : column + str.length;
      }
      function position2() {
        var start = { line: lineno, column };
        return function(node2) {
          node2.position = new Position(start);
          whitespace2();
          return node2;
        };
      }
      function Position(start) {
        this.start = start;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style2;
      function error(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style2;
        if (options.silent)
          ;
        else {
          throw err;
        }
      }
      function match(re2) {
        var m2 = re2.exec(style2);
        if (!m2)
          return;
        var str = m2[0];
        updatePosition(str);
        style2 = style2.slice(str.length);
        return m2;
      }
      function whitespace2() {
        match(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c;
        rules = rules || [];
        while (c = comment()) {
          if (c !== false) {
            rules.push(c);
          }
        }
        return rules;
      }
      function comment() {
        var pos = position2();
        if (FORWARD_SLASH != style2.charAt(0) || ASTERISK != style2.charAt(1))
          return;
        var i = 2;
        while (EMPTY_STRING != style2.charAt(i) && (ASTERISK != style2.charAt(i) || FORWARD_SLASH != style2.charAt(i + 1))) {
          ++i;
        }
        i += 2;
        if (EMPTY_STRING === style2.charAt(i - 1)) {
          return error("End of comment missing");
        }
        var str = style2.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        style2 = style2.slice(i);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position2();
        var prop = match(PROPERTY_REGEX);
        if (!prop)
          return;
        comment();
        if (!match(COLON_REGEX))
          return error("property missing ':'");
        var val = match(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace2();
      return declarations();
    };
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
    var parse$6 = inlineStyleParser;
    function StyleToObject(style2, iterator) {
      var output = null;
      if (!style2 || typeof style2 !== "string") {
        return output;
      }
      var declaration;
      var declarations = parse$6(style2);
      var hasIterator = typeof iterator === "function";
      var property2;
      var value;
      for (var i = 0, len = declarations.length; i < len; i++) {
        declaration = declarations[i];
        property2 = declaration.property;
        value = declaration.value;
        if (hasIterator) {
          iterator(property2, value, declaration);
        } else if (value) {
          output || (output = {});
          output[property2] = value;
        }
      }
      return output;
    }
    styleToObject$1.exports = StyleToObject;
    styleToObjectExports.default = StyleToObject;
    const styleToObject = styleToObjectExports;
    const pointEnd = point$2("end");
    const pointStart = point$2("start");
    function point$2(type) {
      return point2;
      function point2(node2) {
        const point3 = node2 && node2.position && node2.position[type] || {};
        if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
          return {
            line: point3.line,
            column: point3.column,
            offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
          };
        }
      }
    }
    function position$1(node2) {
      const start = pointStart(node2);
      const end = pointEnd(node2);
      if (start && end) {
        return { start, end };
      }
    }
    function stringifyPosition(value) {
      if (!value || typeof value !== "object") {
        return "";
      }
      if ("position" in value || "type" in value) {
        return position(value.position);
      }
      if ("start" in value || "end" in value) {
        return position(value);
      }
      if ("line" in value || "column" in value) {
        return point$1(value);
      }
      return "";
    }
    function point$1(point2) {
      return index$1(point2 && point2.line) + ":" + index$1(point2 && point2.column);
    }
    function position(pos) {
      return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
    }
    function index$1(value) {
      return value && typeof value === "number" ? value : 1;
    }
    class VFileMessage extends Error {
      /**
       * Create a message for `reason`.
       *
       * > 🪦 **Note**: also has obsolete signatures.
       *
       * @overload
       * @param {string} reason
       * @param {Options | null | undefined} [options]
       * @returns
       *
       * @overload
       * @param {string} reason
       * @param {Node | NodeLike | null | undefined} parent
       * @param {string | null | undefined} [origin]
       * @returns
       *
       * @overload
       * @param {string} reason
       * @param {Point | Position | null | undefined} place
       * @param {string | null | undefined} [origin]
       * @returns
       *
       * @overload
       * @param {string} reason
       * @param {string | null | undefined} [origin]
       * @returns
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {Node | NodeLike | null | undefined} parent
       * @param {string | null | undefined} [origin]
       * @returns
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {Point | Position | null | undefined} place
       * @param {string | null | undefined} [origin]
       * @returns
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {string | null | undefined} [origin]
       * @returns
       *
       * @param {Error | VFileMessage | string} causeOrReason
       *   Reason for message, should use markdown.
       * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
       *   Configuration (optional).
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns
       *   Instance of `VFileMessage`.
       */
      // eslint-disable-next-line complexity
      constructor(causeOrReason, optionsOrParentOrPlace, origin) {
        super();
        if (typeof optionsOrParentOrPlace === "string") {
          origin = optionsOrParentOrPlace;
          optionsOrParentOrPlace = void 0;
        }
        let reason = "";
        let options = {};
        let legacyCause = false;
        if (optionsOrParentOrPlace) {
          if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
            options = { place: optionsOrParentOrPlace };
          } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
            options = { place: optionsOrParentOrPlace };
          } else if ("type" in optionsOrParentOrPlace) {
            options = {
              ancestors: [optionsOrParentOrPlace],
              place: optionsOrParentOrPlace.position
            };
          } else {
            options = { ...optionsOrParentOrPlace };
          }
        }
        if (typeof causeOrReason === "string") {
          reason = causeOrReason;
        } else if (!options.cause && causeOrReason) {
          legacyCause = true;
          reason = causeOrReason.message;
          options.cause = causeOrReason;
        }
        if (!options.ruleId && !options.source && typeof origin === "string") {
          const index2 = origin.indexOf(":");
          if (index2 === -1) {
            options.ruleId = origin;
          } else {
            options.source = origin.slice(0, index2);
            options.ruleId = origin.slice(index2 + 1);
          }
        }
        if (!options.place && options.ancestors && options.ancestors) {
          const parent = options.ancestors[options.ancestors.length - 1];
          if (parent) {
            options.place = parent.position;
          }
        }
        const start = options.place && "start" in options.place ? options.place.start : options.place;
        this.ancestors = options.ancestors || void 0;
        this.cause = options.cause || void 0;
        this.column = start ? start.column : void 0;
        this.fatal = void 0;
        this.file;
        this.message = reason;
        this.line = start ? start.line : void 0;
        this.name = stringifyPosition(options.place) || "1:1";
        this.place = options.place || void 0;
        this.reason = this.message;
        this.ruleId = options.ruleId || void 0;
        this.source = options.source || void 0;
        this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
        this.actual;
        this.expected;
        this.note;
        this.url;
      }
    }
    VFileMessage.prototype.file = "";
    VFileMessage.prototype.name = "";
    VFileMessage.prototype.reason = "";
    VFileMessage.prototype.message = "";
    VFileMessage.prototype.stack = "";
    VFileMessage.prototype.column = void 0;
    VFileMessage.prototype.line = void 0;
    VFileMessage.prototype.ancestors = void 0;
    VFileMessage.prototype.cause = void 0;
    VFileMessage.prototype.fatal = void 0;
    VFileMessage.prototype.place = void 0;
    VFileMessage.prototype.ruleId = void 0;
    VFileMessage.prototype.source = void 0;
    const own$7 = {}.hasOwnProperty;
    const emptyMap = /* @__PURE__ */ new Map();
    const cap$1 = /[A-Z]/g;
    const dashSomething = /-([a-z])/g;
    const tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
    const tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
    function toJsxRuntime(tree, options) {
      if (!options || options.Fragment === void 0) {
        throw new TypeError("Expected `Fragment` in options");
      }
      const filePath = options.filePath || void 0;
      let create2;
      if (options.development) {
        if (typeof options.jsxDEV !== "function") {
          throw new TypeError(
            "Expected `jsxDEV` in options when `development: true`"
          );
        }
        create2 = developmentCreate(filePath, options.jsxDEV);
      } else {
        if (typeof options.jsx !== "function") {
          throw new TypeError("Expected `jsx` in production options");
        }
        if (typeof options.jsxs !== "function") {
          throw new TypeError("Expected `jsxs` in production options");
        }
        create2 = productionCreate(filePath, options.jsx, options.jsxs);
      }
      const state = {
        Fragment: options.Fragment,
        ancestors: [],
        components: options.components || {},
        create: create2,
        elementAttributeNameCase: options.elementAttributeNameCase || "react",
        filePath,
        ignoreInvalidStyle: options.ignoreInvalidStyle || false,
        passKeys: options.passKeys !== false,
        passNode: options.passNode || false,
        schema: options.space === "svg" ? svg : html$5,
        stylePropertyNameCase: options.stylePropertyNameCase || "dom",
        tableCellAlignToStyle: options.tableCellAlignToStyle !== false
      };
      const result = one$1(state, tree, void 0);
      if (result && typeof result !== "string") {
        return result;
      }
      return state.create(
        tree,
        state.Fragment,
        { children: result || void 0 },
        void 0
      );
    }
    function one$1(state, node2, key) {
      if (node2.type === "element" || node2.type === "root") {
        const parentSchema = state.schema;
        let schema2 = parentSchema;
        if (node2.type === "element" && node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
          schema2 = svg;
          state.schema = schema2;
        }
        state.ancestors.push(node2);
        let children = createChildren$1(state, node2);
        const props = createProperties(state, state.ancestors);
        let type = state.Fragment;
        state.ancestors.pop();
        if (node2.type === "element") {
          if (children && tableElements.has(node2.tagName)) {
            children = children.filter(function(child) {
              return typeof child === "string" ? !whitespace(child) : true;
            });
          }
          if (own$7.call(state.components, node2.tagName)) {
            const key2 = (
              /** @type {keyof JSX.IntrinsicElements} */
              node2.tagName
            );
            type = state.components[key2];
            if (typeof type !== "string" && type !== state.Fragment && state.passNode) {
              props.node = node2;
            }
          } else {
            type = node2.tagName;
          }
        }
        if (children.length > 0) {
          const value = children.length > 1 ? children : children[0];
          if (value) {
            props.children = value;
          }
        }
        state.schema = parentSchema;
        return state.create(node2, type, props, key);
      }
      if (node2.type === "text") {
        return node2.value;
      }
    }
    function productionCreate(_, jsx, jsxs) {
      return create2;
      function create2(_2, type, props, key) {
        const isStaticChildren = Array.isArray(props.children);
        const fn = isStaticChildren ? jsxs : jsx;
        return key ? fn(type, props, key) : fn(type, props);
      }
    }
    function developmentCreate(filePath, jsxDEV) {
      return create2;
      function create2(node2, type, props, key) {
        const isStaticChildren = Array.isArray(props.children);
        const point2 = pointStart(node2);
        return jsxDEV(
          type,
          props,
          key,
          isStaticChildren,
          {
            columnNumber: point2 ? point2.column - 1 : void 0,
            fileName: filePath,
            lineNumber: point2 ? point2.line : void 0
          },
          void 0
        );
      }
    }
    function createChildren$1(state, node2) {
      const children = [];
      let index2 = -1;
      const countsByTagName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
      while (++index2 < node2.children.length) {
        const child = node2.children[index2];
        let key;
        if (state.passKeys && child.type === "element") {
          const count = countsByTagName.get(child.tagName) || 0;
          key = child.tagName + "-" + count;
          countsByTagName.set(child.tagName, count + 1);
        }
        const result = one$1(state, child, key);
        if (result !== void 0)
          children.push(result);
      }
      return children;
    }
    function createProperties(state, ancestors) {
      const node2 = ancestors[ancestors.length - 1];
      const props = {};
      let prop;
      if ("properties" in node2 && node2.properties) {
        let alignValue;
        for (prop in node2.properties) {
          if (prop !== "children" && own$7.call(node2.properties, prop)) {
            const result = createProperty(
              state,
              ancestors,
              prop,
              node2.properties[prop]
            );
            if (result) {
              const [key, value] = result;
              if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
                alignValue = value;
              } else {
                props[key] = value;
              }
            }
          }
        }
        if (alignValue) {
          const style2 = (
            /** @type {Style} */
            props.style || (props.style = {})
          );
          style2[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
        }
      }
      return props;
    }
    function createProperty(state, ancestors, prop, value) {
      const info2 = find$2(state.schema, prop);
      if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
        return;
      }
      if (Array.isArray(value)) {
        value = info2.commaSeparated ? stringify$5(value) : stringify$4(value);
      }
      if (info2.property === "style") {
        let styleObject = typeof value === "object" ? value : parseStyle(state, ancestors, String(value));
        if (state.stylePropertyNameCase === "css") {
          styleObject = transformStylesToCssCasing(styleObject);
        }
        return ["style", styleObject];
      }
      return [
        state.elementAttributeNameCase === "react" && info2.space ? hastToReact[info2.property] || info2.property : info2.attribute,
        value
      ];
    }
    function parseStyle(state, ancestors, value) {
      const result = {};
      try {
        styleToObject(value, replacer);
      } catch (error) {
        if (!state.ignoreInvalidStyle) {
          const cause = (
            /** @type {Error} */
            error
          );
          const message = new VFileMessage("Cannot parse `style` attribute", {
            ancestors,
            cause,
            source: "hast-util-to-jsx-runtime",
            ruleId: "style"
          });
          message.file = state.filePath || void 0;
          message.url = "https://github.com/syntax-tree/hast-util-to-jsx-runtime#cannot-parse-style-attribute";
          throw message;
        }
      }
      return result;
      function replacer(name2, value2) {
        let key = name2;
        if (key.slice(0, 2) !== "--") {
          if (key.slice(0, 4) === "-ms-")
            key = "ms-" + key.slice(4);
          key = key.replace(dashSomething, toCamel);
        }
        result[key] = value2;
      }
    }
    function transformStylesToCssCasing(domCasing) {
      const cssCasing = {};
      let from;
      for (from in domCasing) {
        if (own$7.call(domCasing, from)) {
          cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
        }
      }
      return cssCasing;
    }
    function transformStyleToCssCasing(from) {
      let to = from.replace(cap$1, toDash);
      if (to.slice(0, 3) === "ms-")
        to = "-" + to;
      return to;
    }
    function toCamel(_, $1) {
      return $1.toUpperCase();
    }
    function toDash($0) {
      return "-" + $0.toLowerCase();
    }
    const urlAttributes = {
      action: ["form"],
      cite: ["blockquote", "del", "ins", "q"],
      data: ["object"],
      formAction: ["button", "input"],
      href: ["a", "area", "base", "link"],
      icon: ["menuitem"],
      itemId: null,
      manifest: ["html"],
      ping: ["a", "area"],
      poster: ["video"],
      src: [
        "audio",
        "embed",
        "iframe",
        "img",
        "input",
        "script",
        "source",
        "track",
        "video"
      ]
    };
    const unicodePunctuationInternal = regexCheck(/\p{P}/u);
    const asciiAlpha = regexCheck(/[A-Za-z]/);
    const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
    const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
    function asciiControl(code2) {
      return (
        // Special whitespace codes (which have negative values), C0 and Control
        // character DEL
        code2 !== null && (code2 < 32 || code2 === 127)
      );
    }
    const asciiDigit = regexCheck(/\d/);
    const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
    const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
    function markdownLineEnding(code2) {
      return code2 !== null && code2 < -2;
    }
    function markdownLineEndingOrSpace(code2) {
      return code2 !== null && (code2 < 0 || code2 === 32);
    }
    function markdownSpace(code2) {
      return code2 === -2 || code2 === -1 || code2 === 32;
    }
    function unicodePunctuation(code2) {
      return asciiPunctuation(code2) || unicodePunctuationInternal(code2);
    }
    const unicodeWhitespace = regexCheck(/\s/);
    function regexCheck(regex) {
      return check;
      function check(code2) {
        return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
      }
    }
    const characterReferences = { '"': "quot", "&": "amp", "<": "lt", ">": "gt" };
    function encode$1(value) {
      return value.replace(/["&<>]/g, replace2);
      function replace2(value2) {
        return "&" + characterReferences[value2] + ";";
      }
    }
    function sanitizeUri(url, protocol) {
      const value = encode$1(normalizeUri(url || ""));
      if (!protocol) {
        return value;
      }
      const colon = value.indexOf(":");
      const questionMark = value.indexOf("?");
      const numberSign2 = value.indexOf("#");
      const slash = value.indexOf("/");
      if (
        // If there is no protocol, it’s relative.
        colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
        slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign2 > -1 && colon > numberSign2 || // It is a protocol, it should be allowed.
        protocol.test(value.slice(0, colon))
      ) {
        return value;
      }
      return "";
    }
    function normalizeUri(value) {
      const result = [];
      let index2 = -1;
      let start = 0;
      let skip = 0;
      while (++index2 < value.length) {
        const code2 = value.charCodeAt(index2);
        let replace2 = "";
        if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
          skip = 2;
        } else if (code2 < 128) {
          if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
            replace2 = String.fromCharCode(code2);
          }
        } else if (code2 > 55295 && code2 < 57344) {
          const next = value.charCodeAt(index2 + 1);
          if (code2 < 56320 && next > 56319 && next < 57344) {
            replace2 = String.fromCharCode(code2, next);
            skip = 1;
          } else {
            replace2 = "�";
          }
        } else {
          replace2 = String.fromCharCode(code2);
        }
        if (replace2) {
          result.push(value.slice(start, index2), encodeURIComponent(replace2));
          start = index2 + skip + 1;
          replace2 = "";
        }
        if (skip) {
          index2 += skip;
          skip = 0;
        }
      }
      return result.join("") + value.slice(start);
    }
    const emptyOptions$2 = {};
    function toString$3(value, options) {
      const settings = options || emptyOptions$2;
      const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
      const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
      return one(value, includeImageAlt, includeHtml);
    }
    function one(value, includeImageAlt, includeHtml) {
      if (node(value)) {
        if ("value" in value) {
          return value.type === "html" && !includeHtml ? "" : value.value;
        }
        if (includeImageAlt && "alt" in value && value.alt) {
          return value.alt;
        }
        if ("children" in value) {
          return all(value.children, includeImageAlt, includeHtml);
        }
      }
      if (Array.isArray(value)) {
        return all(value, includeImageAlt, includeHtml);
      }
      return "";
    }
    function all(values, includeImageAlt, includeHtml) {
      const result = [];
      let index2 = -1;
      while (++index2 < values.length) {
        result[index2] = one(values[index2], includeImageAlt, includeHtml);
      }
      return result.join("");
    }
    function node(value) {
      return Boolean(value && typeof value === "object");
    }
    const element = document.createElement("i");
    function decodeNamedCharacterReference(value) {
      const characterReference2 = "&" + value + ";";
      element.innerHTML = characterReference2;
      const char = element.textContent;
      if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
        return false;
      }
      return char === characterReference2 ? false : char;
    }
    function splice$1(list2, start, remove, items) {
      const end = list2.length;
      let chunkStart = 0;
      let parameters;
      if (start < 0) {
        start = -start > end ? 0 : end + start;
      } else {
        start = start > end ? end : start;
      }
      remove = remove > 0 ? remove : 0;
      if (items.length < 1e4) {
        parameters = Array.from(items);
        parameters.unshift(start, remove);
        list2.splice(...parameters);
      } else {
        if (remove)
          list2.splice(start, remove);
        while (chunkStart < items.length) {
          parameters = items.slice(chunkStart, chunkStart + 1e4);
          parameters.unshift(start, 0);
          list2.splice(...parameters);
          chunkStart += 1e4;
          start += 1e4;
        }
      }
    }
    function push(list2, items) {
      if (list2.length > 0) {
        splice$1(list2, list2.length, 0, items);
        return list2;
      }
      return items;
    }
    const hasOwnProperty$e = {}.hasOwnProperty;
    function combineExtensions(extensions) {
      const all2 = {};
      let index2 = -1;
      while (++index2 < extensions.length) {
        syntaxExtension(all2, extensions[index2]);
      }
      return all2;
    }
    function syntaxExtension(all2, extension2) {
      let hook;
      for (hook in extension2) {
        const maybe = hasOwnProperty$e.call(all2, hook) ? all2[hook] : void 0;
        const left = maybe || (all2[hook] = {});
        const right = extension2[hook];
        let code2;
        if (right) {
          for (code2 in right) {
            if (!hasOwnProperty$e.call(left, code2))
              left[code2] = [];
            const value = right[code2];
            constructs(
              // @ts-expect-error Looks like a list.
              left[code2],
              Array.isArray(value) ? value : value ? [value] : []
            );
          }
        }
      }
    }
    function constructs(existing, list2) {
      let index2 = -1;
      const before = [];
      while (++index2 < list2.length) {
        (list2[index2].add === "after" ? existing : before).push(list2[index2]);
      }
      splice$1(existing, 0, 0, before);
    }
    function decodeNumericCharacterReference(value, base) {
      const code2 = Number.parseInt(value, base);
      if (
        // C0 except for HT, LF, FF, CR, space.
        code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
        code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
        code2 > 55295 && code2 < 57344 || // Noncharacters.
        code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || // Out of range
        code2 > 1114111
      ) {
        return "�";
      }
      return String.fromCharCode(code2);
    }
    function normalizeIdentifier(value) {
      return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
    }
    function factorySpace(effects, ok2, type, max) {
      const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
      let size = 0;
      return start;
      function start(code2) {
        if (markdownSpace(code2)) {
          effects.enter(type);
          return prefix(code2);
        }
        return ok2(code2);
      }
      function prefix(code2) {
        if (markdownSpace(code2) && size++ < limit) {
          effects.consume(code2);
          return prefix;
        }
        effects.exit(type);
        return ok2(code2);
      }
    }
    const content$1 = {
      tokenize: initializeContent
    };
    function initializeContent(effects) {
      const contentStart = effects.attempt(
        this.parser.constructs.contentInitial,
        afterContentStartConstruct,
        paragraphInitial
      );
      let previous2;
      return contentStart;
      function afterContentStartConstruct(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace(effects, contentStart, "linePrefix");
      }
      function paragraphInitial(code2) {
        effects.enter("paragraph");
        return lineStart(code2);
      }
      function lineStart(code2) {
        const token = effects.enter("chunkText", {
          contentType: "text",
          previous: previous2
        });
        if (previous2) {
          previous2.next = token;
        }
        previous2 = token;
        return data2(code2);
      }
      function data2(code2) {
        if (code2 === null) {
          effects.exit("chunkText");
          effects.exit("paragraph");
          effects.consume(code2);
          return;
        }
        if (markdownLineEnding(code2)) {
          effects.consume(code2);
          effects.exit("chunkText");
          return lineStart;
        }
        effects.consume(code2);
        return data2;
      }
    }
    const document$2 = {
      tokenize: initializeDocument
    };
    const containerConstruct = {
      tokenize: tokenizeContainer
    };
    function initializeDocument(effects) {
      const self2 = this;
      const stack = [];
      let continued = 0;
      let childFlow;
      let childToken;
      let lineStartOffset;
      return start;
      function start(code2) {
        if (continued < stack.length) {
          const item = stack[continued];
          self2.containerState = item[1];
          return effects.attempt(
            item[0].continuation,
            documentContinue,
            checkNewContainers
          )(code2);
        }
        return checkNewContainers(code2);
      }
      function documentContinue(code2) {
        continued++;
        if (self2.containerState._closeFlow) {
          self2.containerState._closeFlow = void 0;
          if (childFlow) {
            closeFlow();
          }
          const indexBeforeExits = self2.events.length;
          let indexBeforeFlow = indexBeforeExits;
          let point2;
          while (indexBeforeFlow--) {
            if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
              point2 = self2.events[indexBeforeFlow][1].end;
              break;
            }
          }
          exitContainers(continued);
          let index2 = indexBeforeExits;
          while (index2 < self2.events.length) {
            self2.events[index2][1].end = Object.assign({}, point2);
            index2++;
          }
          splice$1(
            self2.events,
            indexBeforeFlow + 1,
            0,
            self2.events.slice(indexBeforeExits)
          );
          self2.events.length = index2;
          return checkNewContainers(code2);
        }
        return start(code2);
      }
      function checkNewContainers(code2) {
        if (continued === stack.length) {
          if (!childFlow) {
            return documentContinued(code2);
          }
          if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
            return flowStart(code2);
          }
          self2.interrupt = Boolean(
            childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
          );
        }
        self2.containerState = {};
        return effects.check(
          containerConstruct,
          thereIsANewContainer,
          thereIsNoNewContainer
        )(code2);
      }
      function thereIsANewContainer(code2) {
        if (childFlow)
          closeFlow();
        exitContainers(continued);
        return documentContinued(code2);
      }
      function thereIsNoNewContainer(code2) {
        self2.parser.lazy[self2.now().line] = continued !== stack.length;
        lineStartOffset = self2.now().offset;
        return flowStart(code2);
      }
      function documentContinued(code2) {
        self2.containerState = {};
        return effects.attempt(
          containerConstruct,
          containerContinue,
          flowStart
        )(code2);
      }
      function containerContinue(code2) {
        continued++;
        stack.push([self2.currentConstruct, self2.containerState]);
        return documentContinued(code2);
      }
      function flowStart(code2) {
        if (code2 === null) {
          if (childFlow)
            closeFlow();
          exitContainers(0);
          effects.consume(code2);
          return;
        }
        childFlow = childFlow || self2.parser.flow(self2.now());
        effects.enter("chunkFlow", {
          contentType: "flow",
          previous: childToken,
          _tokenizer: childFlow
        });
        return flowContinue(code2);
      }
      function flowContinue(code2) {
        if (code2 === null) {
          writeToChild(effects.exit("chunkFlow"), true);
          exitContainers(0);
          effects.consume(code2);
          return;
        }
        if (markdownLineEnding(code2)) {
          effects.consume(code2);
          writeToChild(effects.exit("chunkFlow"));
          continued = 0;
          self2.interrupt = void 0;
          return start;
        }
        effects.consume(code2);
        return flowContinue;
      }
      function writeToChild(token, eof) {
        const stream = self2.sliceStream(token);
        if (eof)
          stream.push(null);
        token.previous = childToken;
        if (childToken)
          childToken.next = token;
        childToken = token;
        childFlow.defineSkip(token.start);
        childFlow.write(stream);
        if (self2.parser.lazy[token.start.line]) {
          let index2 = childFlow.events.length;
          while (index2--) {
            if (
              // The token starts before the line ending…
              childFlow.events[index2][1].start.offset < lineStartOffset && // …and either is not ended yet…
              (!childFlow.events[index2][1].end || // …or ends after it.
              childFlow.events[index2][1].end.offset > lineStartOffset)
            ) {
              return;
            }
          }
          const indexBeforeExits = self2.events.length;
          let indexBeforeFlow = indexBeforeExits;
          let seen;
          let point2;
          while (indexBeforeFlow--) {
            if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
              if (seen) {
                point2 = self2.events[indexBeforeFlow][1].end;
                break;
              }
              seen = true;
            }
          }
          exitContainers(continued);
          index2 = indexBeforeExits;
          while (index2 < self2.events.length) {
            self2.events[index2][1].end = Object.assign({}, point2);
            index2++;
          }
          splice$1(
            self2.events,
            indexBeforeFlow + 1,
            0,
            self2.events.slice(indexBeforeExits)
          );
          self2.events.length = index2;
        }
      }
      function exitContainers(size) {
        let index2 = stack.length;
        while (index2-- > size) {
          const entry = stack[index2];
          self2.containerState = entry[1];
          entry[0].exit.call(self2, effects);
        }
        stack.length = size;
      }
      function closeFlow() {
        childFlow.write([null]);
        childToken = void 0;
        childFlow = void 0;
        self2.containerState._closeFlow = void 0;
      }
    }
    function tokenizeContainer(effects, ok2, nok) {
      return factorySpace(
        effects,
        effects.attempt(this.parser.constructs.document, ok2, nok),
        "linePrefix",
        this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      );
    }
    function classifyCharacter(code2) {
      if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
        return 1;
      }
      if (unicodePunctuation(code2)) {
        return 2;
      }
    }
    function resolveAll(constructs2, events, context) {
      const called = [];
      let index2 = -1;
      while (++index2 < constructs2.length) {
        const resolve = constructs2[index2].resolveAll;
        if (resolve && !called.includes(resolve)) {
          events = resolve(events, context);
          called.push(resolve);
        }
      }
      return events;
    }
    const attention = {
      name: "attention",
      tokenize: tokenizeAttention,
      resolveAll: resolveAllAttention
    };
    function resolveAllAttention(events, context) {
      let index2 = -1;
      let open;
      let group;
      let text2;
      let openingSequence;
      let closingSequence;
      let use;
      let nextEvents;
      let offset;
      while (++index2 < events.length) {
        if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
          open = index2;
          while (open--) {
            if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
            context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
              if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
                continue;
              }
              use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
              const start = Object.assign({}, events[open][1].end);
              const end = Object.assign({}, events[index2][1].start);
              movePoint(start, -use);
              movePoint(end, use);
              openingSequence = {
                type: use > 1 ? "strongSequence" : "emphasisSequence",
                start,
                end: Object.assign({}, events[open][1].end)
              };
              closingSequence = {
                type: use > 1 ? "strongSequence" : "emphasisSequence",
                start: Object.assign({}, events[index2][1].start),
                end
              };
              text2 = {
                type: use > 1 ? "strongText" : "emphasisText",
                start: Object.assign({}, events[open][1].end),
                end: Object.assign({}, events[index2][1].start)
              };
              group = {
                type: use > 1 ? "strong" : "emphasis",
                start: Object.assign({}, openingSequence.start),
                end: Object.assign({}, closingSequence.end)
              };
              events[open][1].end = Object.assign({}, openingSequence.start);
              events[index2][1].start = Object.assign({}, closingSequence.end);
              nextEvents = [];
              if (events[open][1].end.offset - events[open][1].start.offset) {
                nextEvents = push(nextEvents, [
                  ["enter", events[open][1], context],
                  ["exit", events[open][1], context]
                ]);
              }
              nextEvents = push(nextEvents, [
                ["enter", group, context],
                ["enter", openingSequence, context],
                ["exit", openingSequence, context],
                ["enter", text2, context]
              ]);
              nextEvents = push(
                nextEvents,
                resolveAll(
                  context.parser.constructs.insideSpan.null,
                  events.slice(open + 1, index2),
                  context
                )
              );
              nextEvents = push(nextEvents, [
                ["exit", text2, context],
                ["enter", closingSequence, context],
                ["exit", closingSequence, context],
                ["exit", group, context]
              ]);
              if (events[index2][1].end.offset - events[index2][1].start.offset) {
                offset = 2;
                nextEvents = push(nextEvents, [
                  ["enter", events[index2][1], context],
                  ["exit", events[index2][1], context]
                ]);
              } else {
                offset = 0;
              }
              splice$1(events, open - 1, index2 - open + 3, nextEvents);
              index2 = open + nextEvents.length - offset - 2;
              break;
            }
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "attentionSequence") {
          events[index2][1].type = "data";
        }
      }
      return events;
    }
    function tokenizeAttention(effects, ok2) {
      const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
      const previous2 = this.previous;
      const before = classifyCharacter(previous2);
      let marker;
      return start;
      function start(code2) {
        marker = code2;
        effects.enter("attentionSequence");
        return inside(code2);
      }
      function inside(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return inside;
        }
        const token = effects.exit("attentionSequence");
        const after = classifyCharacter(code2);
        const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
        const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
        token._open = Boolean(marker === 42 ? open : open && (before || !close));
        token._close = Boolean(marker === 42 ? close : close && (after || !open));
        return ok2(code2);
      }
    }
    function movePoint(point2, offset) {
      point2.column += offset;
      point2.offset += offset;
      point2._bufferIndex += offset;
    }
    const autolink = {
      name: "autolink",
      tokenize: tokenizeAutolink
    };
    function tokenizeAutolink(effects, ok2, nok) {
      let size = 0;
      return start;
      function start(code2) {
        effects.enter("autolink");
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.enter("autolinkProtocol");
        return open;
      }
      function open(code2) {
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return schemeOrEmailAtext;
        }
        return emailAtext(code2);
      }
      function schemeOrEmailAtext(code2) {
        if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
          size = 1;
          return schemeInsideOrEmailAtext(code2);
        }
        return emailAtext(code2);
      }
      function schemeInsideOrEmailAtext(code2) {
        if (code2 === 58) {
          effects.consume(code2);
          size = 0;
          return urlInside;
        }
        if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
          effects.consume(code2);
          return schemeInsideOrEmailAtext;
        }
        size = 0;
        return emailAtext(code2);
      }
      function urlInside(code2) {
        if (code2 === 62) {
          effects.exit("autolinkProtocol");
          effects.enter("autolinkMarker");
          effects.consume(code2);
          effects.exit("autolinkMarker");
          effects.exit("autolink");
          return ok2;
        }
        if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return urlInside;
      }
      function emailAtext(code2) {
        if (code2 === 64) {
          effects.consume(code2);
          return emailAtSignOrDot;
        }
        if (asciiAtext(code2)) {
          effects.consume(code2);
          return emailAtext;
        }
        return nok(code2);
      }
      function emailAtSignOrDot(code2) {
        return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
      }
      function emailLabel(code2) {
        if (code2 === 46) {
          effects.consume(code2);
          size = 0;
          return emailAtSignOrDot;
        }
        if (code2 === 62) {
          effects.exit("autolinkProtocol").type = "autolinkEmail";
          effects.enter("autolinkMarker");
          effects.consume(code2);
          effects.exit("autolinkMarker");
          effects.exit("autolink");
          return ok2;
        }
        return emailValue(code2);
      }
      function emailValue(code2) {
        if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
          const next = code2 === 45 ? emailValue : emailLabel;
          effects.consume(code2);
          return next;
        }
        return nok(code2);
      }
    }
    const blankLine = {
      tokenize: tokenizeBlankLine,
      partial: true
    };
    function tokenizeBlankLine(effects, ok2, nok) {
      return start;
      function start(code2) {
        return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
      }
      function after(code2) {
        return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
      }
    }
    const blockQuote = {
      name: "blockQuote",
      tokenize: tokenizeBlockQuoteStart,
      continuation: {
        tokenize: tokenizeBlockQuoteContinuation
      },
      exit: exit$1
    };
    function tokenizeBlockQuoteStart(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        if (code2 === 62) {
          const state = self2.containerState;
          if (!state.open) {
            effects.enter("blockQuote", {
              _container: true
            });
            state.open = true;
          }
          effects.enter("blockQuotePrefix");
          effects.enter("blockQuoteMarker");
          effects.consume(code2);
          effects.exit("blockQuoteMarker");
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        if (markdownSpace(code2)) {
          effects.enter("blockQuotePrefixWhitespace");
          effects.consume(code2);
          effects.exit("blockQuotePrefixWhitespace");
          effects.exit("blockQuotePrefix");
          return ok2;
        }
        effects.exit("blockQuotePrefix");
        return ok2(code2);
      }
    }
    function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
      const self2 = this;
      return contStart;
      function contStart(code2) {
        if (markdownSpace(code2)) {
          return factorySpace(
            effects,
            contBefore,
            "linePrefix",
            self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
          )(code2);
        }
        return contBefore(code2);
      }
      function contBefore(code2) {
        return effects.attempt(blockQuote, ok2, nok)(code2);
      }
    }
    function exit$1(effects) {
      effects.exit("blockQuote");
    }
    const characterEscape = {
      name: "characterEscape",
      tokenize: tokenizeCharacterEscape
    };
    function tokenizeCharacterEscape(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.enter("characterEscape");
        effects.enter("escapeMarker");
        effects.consume(code2);
        effects.exit("escapeMarker");
        return inside;
      }
      function inside(code2) {
        if (asciiPunctuation(code2)) {
          effects.enter("characterEscapeValue");
          effects.consume(code2);
          effects.exit("characterEscapeValue");
          effects.exit("characterEscape");
          return ok2;
        }
        return nok(code2);
      }
    }
    const characterReference = {
      name: "characterReference",
      tokenize: tokenizeCharacterReference
    };
    function tokenizeCharacterReference(effects, ok2, nok) {
      const self2 = this;
      let size = 0;
      let max;
      let test;
      return start;
      function start(code2) {
        effects.enter("characterReference");
        effects.enter("characterReferenceMarker");
        effects.consume(code2);
        effects.exit("characterReferenceMarker");
        return open;
      }
      function open(code2) {
        if (code2 === 35) {
          effects.enter("characterReferenceMarkerNumeric");
          effects.consume(code2);
          effects.exit("characterReferenceMarkerNumeric");
          return numeric;
        }
        effects.enter("characterReferenceValue");
        max = 31;
        test = asciiAlphanumeric;
        return value(code2);
      }
      function numeric(code2) {
        if (code2 === 88 || code2 === 120) {
          effects.enter("characterReferenceMarkerHexadecimal");
          effects.consume(code2);
          effects.exit("characterReferenceMarkerHexadecimal");
          effects.enter("characterReferenceValue");
          max = 6;
          test = asciiHexDigit;
          return value;
        }
        effects.enter("characterReferenceValue");
        max = 7;
        test = asciiDigit;
        return value(code2);
      }
      function value(code2) {
        if (code2 === 59 && size) {
          const token = effects.exit("characterReferenceValue");
          if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
            return nok(code2);
          }
          effects.enter("characterReferenceMarker");
          effects.consume(code2);
          effects.exit("characterReferenceMarker");
          effects.exit("characterReference");
          return ok2;
        }
        if (test(code2) && size++ < max) {
          effects.consume(code2);
          return value;
        }
        return nok(code2);
      }
    }
    const nonLazyContinuation = {
      tokenize: tokenizeNonLazyContinuation,
      partial: true
    };
    const codeFenced = {
      name: "codeFenced",
      tokenize: tokenizeCodeFenced,
      concrete: true
    };
    function tokenizeCodeFenced(effects, ok2, nok) {
      const self2 = this;
      const closeStart = {
        tokenize: tokenizeCloseStart,
        partial: true
      };
      let initialPrefix = 0;
      let sizeOpen = 0;
      let marker;
      return start;
      function start(code2) {
        return beforeSequenceOpen(code2);
      }
      function beforeSequenceOpen(code2) {
        const tail = self2.events[self2.events.length - 1];
        initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
        marker = code2;
        effects.enter("codeFenced");
        effects.enter("codeFencedFence");
        effects.enter("codeFencedFenceSequence");
        return sequenceOpen(code2);
      }
      function sequenceOpen(code2) {
        if (code2 === marker) {
          sizeOpen++;
          effects.consume(code2);
          return sequenceOpen;
        }
        if (sizeOpen < 3) {
          return nok(code2);
        }
        effects.exit("codeFencedFenceSequence");
        return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
      }
      function infoBefore(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("codeFencedFence");
          return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
        }
        effects.enter("codeFencedFenceInfo");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return info2(code2);
      }
      function info2(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceInfo");
          return infoBefore(code2);
        }
        if (markdownSpace(code2)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceInfo");
          return factorySpace(effects, metaBefore, "whitespace")(code2);
        }
        if (code2 === 96 && code2 === marker) {
          return nok(code2);
        }
        effects.consume(code2);
        return info2;
      }
      function metaBefore(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return infoBefore(code2);
        }
        effects.enter("codeFencedFenceMeta");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return meta(code2);
      }
      function meta(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceMeta");
          return infoBefore(code2);
        }
        if (code2 === 96 && code2 === marker) {
          return nok(code2);
        }
        effects.consume(code2);
        return meta;
      }
      function atNonLazyBreak(code2) {
        return effects.attempt(closeStart, after, contentBefore)(code2);
      }
      function contentBefore(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return contentStart;
      }
      function contentStart(code2) {
        return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
          effects,
          beforeContentChunk,
          "linePrefix",
          initialPrefix + 1
        )(code2) : beforeContentChunk(code2);
      }
      function beforeContentChunk(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
        }
        effects.enter("codeFlowValue");
        return contentChunk(code2);
      }
      function contentChunk(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("codeFlowValue");
          return beforeContentChunk(code2);
        }
        effects.consume(code2);
        return contentChunk;
      }
      function after(code2) {
        effects.exit("codeFenced");
        return ok2(code2);
      }
      function tokenizeCloseStart(effects2, ok3, nok2) {
        let size = 0;
        return startBefore;
        function startBefore(code2) {
          effects2.enter("lineEnding");
          effects2.consume(code2);
          effects2.exit("lineEnding");
          return start2;
        }
        function start2(code2) {
          effects2.enter("codeFencedFence");
          return markdownSpace(code2) ? factorySpace(
            effects2,
            beforeSequenceClose,
            "linePrefix",
            self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
          )(code2) : beforeSequenceClose(code2);
        }
        function beforeSequenceClose(code2) {
          if (code2 === marker) {
            effects2.enter("codeFencedFenceSequence");
            return sequenceClose(code2);
          }
          return nok2(code2);
        }
        function sequenceClose(code2) {
          if (code2 === marker) {
            size++;
            effects2.consume(code2);
            return sequenceClose;
          }
          if (size >= sizeOpen) {
            effects2.exit("codeFencedFenceSequence");
            return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
          }
          return nok2(code2);
        }
        function sequenceCloseAfter(code2) {
          if (code2 === null || markdownLineEnding(code2)) {
            effects2.exit("codeFencedFence");
            return ok3(code2);
          }
          return nok2(code2);
        }
      }
    }
    function tokenizeNonLazyContinuation(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return lineStart;
      }
      function lineStart(code2) {
        return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
      }
    }
    const codeIndented = {
      name: "codeIndented",
      tokenize: tokenizeCodeIndented
    };
    const furtherStart = {
      tokenize: tokenizeFurtherStart,
      partial: true
    };
    function tokenizeCodeIndented(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        effects.enter("codeIndented");
        return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
      }
      function afterPrefix(code2) {
        const tail = self2.events[self2.events.length - 1];
        return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
      }
      function atBreak(code2) {
        if (code2 === null) {
          return after(code2);
        }
        if (markdownLineEnding(code2)) {
          return effects.attempt(furtherStart, atBreak, after)(code2);
        }
        effects.enter("codeFlowValue");
        return inside(code2);
      }
      function inside(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("codeFlowValue");
          return atBreak(code2);
        }
        effects.consume(code2);
        return inside;
      }
      function after(code2) {
        effects.exit("codeIndented");
        return ok2(code2);
      }
    }
    function tokenizeFurtherStart(effects, ok2, nok) {
      const self2 = this;
      return furtherStart2;
      function furtherStart2(code2) {
        if (self2.parser.lazy[self2.now().line]) {
          return nok(code2);
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return furtherStart2;
        }
        return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
      }
      function afterPrefix(code2) {
        const tail = self2.events[self2.events.length - 1];
        return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
      }
    }
    const codeText = {
      name: "codeText",
      tokenize: tokenizeCodeText,
      resolve: resolveCodeText,
      previous: previous$1
    };
    function resolveCodeText(events) {
      let tailExitIndex = events.length - 4;
      let headEnterIndex = 3;
      let index2;
      let enter;
      if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
        index2 = headEnterIndex;
        while (++index2 < tailExitIndex) {
          if (events[index2][1].type === "codeTextData") {
            events[headEnterIndex][1].type = "codeTextPadding";
            events[tailExitIndex][1].type = "codeTextPadding";
            headEnterIndex += 2;
            tailExitIndex -= 2;
            break;
          }
        }
      }
      index2 = headEnterIndex - 1;
      tailExitIndex++;
      while (++index2 <= tailExitIndex) {
        if (enter === void 0) {
          if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
            enter = index2;
          }
        } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
          events[enter][1].type = "codeTextData";
          if (index2 !== enter + 2) {
            events[enter][1].end = events[index2 - 1][1].end;
            events.splice(enter + 2, index2 - enter - 2);
            tailExitIndex -= index2 - enter - 2;
            index2 = enter + 2;
          }
          enter = void 0;
        }
      }
      return events;
    }
    function previous$1(code2) {
      return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
    }
    function tokenizeCodeText(effects, ok2, nok) {
      let sizeOpen = 0;
      let size;
      let token;
      return start;
      function start(code2) {
        effects.enter("codeText");
        effects.enter("codeTextSequence");
        return sequenceOpen(code2);
      }
      function sequenceOpen(code2) {
        if (code2 === 96) {
          effects.consume(code2);
          sizeOpen++;
          return sequenceOpen;
        }
        effects.exit("codeTextSequence");
        return between(code2);
      }
      function between(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 32) {
          effects.enter("space");
          effects.consume(code2);
          effects.exit("space");
          return between;
        }
        if (code2 === 96) {
          token = effects.enter("codeTextSequence");
          size = 0;
          return sequenceClose(code2);
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return between;
        }
        effects.enter("codeTextData");
        return data2(code2);
      }
      function data2(code2) {
        if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
          effects.exit("codeTextData");
          return between(code2);
        }
        effects.consume(code2);
        return data2;
      }
      function sequenceClose(code2) {
        if (code2 === 96) {
          effects.consume(code2);
          size++;
          return sequenceClose;
        }
        if (size === sizeOpen) {
          effects.exit("codeTextSequence");
          effects.exit("codeText");
          return ok2(code2);
        }
        token.type = "codeTextData";
        return data2(code2);
      }
    }
    function subtokenize(events) {
      const jumps = {};
      let index2 = -1;
      let event;
      let lineIndex;
      let otherIndex;
      let otherEvent;
      let parameters;
      let subevents;
      let more;
      while (++index2 < events.length) {
        while (index2 in jumps) {
          index2 = jumps[index2];
        }
        event = events[index2];
        if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
          subevents = event[1]._tokenizer.events;
          otherIndex = 0;
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
            otherIndex += 2;
          }
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
            while (++otherIndex < subevents.length) {
              if (subevents[otherIndex][1].type === "content") {
                break;
              }
              if (subevents[otherIndex][1].type === "chunkText") {
                subevents[otherIndex][1]._isInFirstContentOfListItem = true;
                otherIndex++;
              }
            }
          }
        }
        if (event[0] === "enter") {
          if (event[1].contentType) {
            Object.assign(jumps, subcontent(events, index2));
            index2 = jumps[index2];
            more = true;
          }
        } else if (event[1]._container) {
          otherIndex = index2;
          lineIndex = void 0;
          while (otherIndex--) {
            otherEvent = events[otherIndex];
            if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
              if (otherEvent[0] === "enter") {
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                }
                otherEvent[1].type = "lineEnding";
                lineIndex = otherIndex;
              }
            } else {
              break;
            }
          }
          if (lineIndex) {
            event[1].end = Object.assign({}, events[lineIndex][1].start);
            parameters = events.slice(lineIndex, index2);
            parameters.unshift(event);
            splice$1(events, lineIndex, index2 - lineIndex + 1, parameters);
          }
        }
      }
      return !more;
    }
    function subcontent(events, eventIndex) {
      const token = events[eventIndex][1];
      const context = events[eventIndex][2];
      let startPosition = eventIndex - 1;
      const startPositions = [];
      const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
      const childEvents = tokenizer.events;
      const jumps = [];
      const gaps = {};
      let stream;
      let previous2;
      let index2 = -1;
      let current = token;
      let adjust = 0;
      let start = 0;
      const breaks = [start];
      while (current) {
        while (events[++startPosition][1] !== current) {
        }
        startPositions.push(startPosition);
        if (!current._tokenizer) {
          stream = context.sliceStream(current);
          if (!current.next) {
            stream.push(null);
          }
          if (previous2) {
            tokenizer.defineSkip(current.start);
          }
          if (current._isInFirstContentOfListItem) {
            tokenizer._gfmTasklistFirstContentOfListItem = true;
          }
          tokenizer.write(stream);
          if (current._isInFirstContentOfListItem) {
            tokenizer._gfmTasklistFirstContentOfListItem = void 0;
          }
        }
        previous2 = current;
        current = current.next;
      }
      current = token;
      while (++index2 < childEvents.length) {
        if (
          // Find a void token that includes a break.
          childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
        ) {
          start = index2 + 1;
          breaks.push(start);
          current._tokenizer = void 0;
          current.previous = void 0;
          current = current.next;
        }
      }
      tokenizer.events = [];
      if (current) {
        current._tokenizer = void 0;
        current.previous = void 0;
      } else {
        breaks.pop();
      }
      index2 = breaks.length;
      while (index2--) {
        const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
        const start2 = startPositions.pop();
        jumps.unshift([start2, start2 + slice.length - 1]);
        splice$1(events, start2, 2, slice);
      }
      index2 = -1;
      while (++index2 < jumps.length) {
        gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
        adjust += jumps[index2][1] - jumps[index2][0] - 1;
      }
      return gaps;
    }
    const content = {
      tokenize: tokenizeContent,
      resolve: resolveContent
    };
    const continuationConstruct = {
      tokenize: tokenizeContinuation,
      partial: true
    };
    function resolveContent(events) {
      subtokenize(events);
      return events;
    }
    function tokenizeContent(effects, ok2) {
      let previous2;
      return chunkStart;
      function chunkStart(code2) {
        effects.enter("content");
        previous2 = effects.enter("chunkContent", {
          contentType: "content"
        });
        return chunkInside(code2);
      }
      function chunkInside(code2) {
        if (code2 === null) {
          return contentEnd(code2);
        }
        if (markdownLineEnding(code2)) {
          return effects.check(
            continuationConstruct,
            contentContinue,
            contentEnd
          )(code2);
        }
        effects.consume(code2);
        return chunkInside;
      }
      function contentEnd(code2) {
        effects.exit("chunkContent");
        effects.exit("content");
        return ok2(code2);
      }
      function contentContinue(code2) {
        effects.consume(code2);
        effects.exit("chunkContent");
        previous2.next = effects.enter("chunkContent", {
          contentType: "content",
          previous: previous2
        });
        previous2 = previous2.next;
        return chunkInside;
      }
    }
    function tokenizeContinuation(effects, ok2, nok) {
      const self2 = this;
      return startLookahead;
      function startLookahead(code2) {
        effects.exit("chunkContent");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace(effects, prefixed, "linePrefix");
      }
      function prefixed(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return nok(code2);
        }
        const tail = self2.events[self2.events.length - 1];
        if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
          return ok2(code2);
        }
        return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
      }
    }
    function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
      const limit = max || Number.POSITIVE_INFINITY;
      let balance = 0;
      return start;
      function start(code2) {
        if (code2 === 60) {
          effects.enter(type);
          effects.enter(literalType);
          effects.enter(literalMarkerType);
          effects.consume(code2);
          effects.exit(literalMarkerType);
          return enclosedBefore;
        }
        if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
          return nok(code2);
        }
        effects.enter(type);
        effects.enter(rawType);
        effects.enter(stringType);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return raw(code2);
      }
      function enclosedBefore(code2) {
        if (code2 === 62) {
          effects.enter(literalMarkerType);
          effects.consume(code2);
          effects.exit(literalMarkerType);
          effects.exit(literalType);
          effects.exit(type);
          return ok2;
        }
        effects.enter(stringType);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return enclosed(code2);
      }
      function enclosed(code2) {
        if (code2 === 62) {
          effects.exit("chunkString");
          effects.exit(stringType);
          return enclosedBefore(code2);
        }
        if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? enclosedEscape : enclosed;
      }
      function enclosedEscape(code2) {
        if (code2 === 60 || code2 === 62 || code2 === 92) {
          effects.consume(code2);
          return enclosed;
        }
        return enclosed(code2);
      }
      function raw(code2) {
        if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
          effects.exit("chunkString");
          effects.exit(stringType);
          effects.exit(rawType);
          effects.exit(type);
          return ok2(code2);
        }
        if (balance < limit && code2 === 40) {
          effects.consume(code2);
          balance++;
          return raw;
        }
        if (code2 === 41) {
          effects.consume(code2);
          balance--;
          return raw;
        }
        if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? rawEscape : raw;
      }
      function rawEscape(code2) {
        if (code2 === 40 || code2 === 41 || code2 === 92) {
          effects.consume(code2);
          return raw;
        }
        return raw(code2);
      }
    }
    function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
      const self2 = this;
      let size = 0;
      let seen;
      return start;
      function start(code2) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        effects.enter(stringType);
        return atBreak;
      }
      function atBreak(code2) {
        if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || // To do: remove in the future once we’ve switched from
        // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
        // which doesn’t need this.
        // Hidden footnotes hook.
        /* c8 ignore next 3 */
        code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
          return nok(code2);
        }
        if (code2 === 93) {
          effects.exit(stringType);
          effects.enter(markerType);
          effects.consume(code2);
          effects.exit(markerType);
          effects.exit(type);
          return ok2;
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return atBreak;
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return labelInside(code2);
      }
      function labelInside(code2) {
        if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
          effects.exit("chunkString");
          return atBreak(code2);
        }
        effects.consume(code2);
        if (!seen)
          seen = !markdownSpace(code2);
        return code2 === 92 ? labelEscape : labelInside;
      }
      function labelEscape(code2) {
        if (code2 === 91 || code2 === 92 || code2 === 93) {
          effects.consume(code2);
          size++;
          return labelInside;
        }
        return labelInside(code2);
      }
    }
    function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
      let marker;
      return start;
      function start(code2) {
        if (code2 === 34 || code2 === 39 || code2 === 40) {
          effects.enter(type);
          effects.enter(markerType);
          effects.consume(code2);
          effects.exit(markerType);
          marker = code2 === 40 ? 41 : code2;
          return begin;
        }
        return nok(code2);
      }
      function begin(code2) {
        if (code2 === marker) {
          effects.enter(markerType);
          effects.consume(code2);
          effects.exit(markerType);
          effects.exit(type);
          return ok2;
        }
        effects.enter(stringType);
        return atBreak(code2);
      }
      function atBreak(code2) {
        if (code2 === marker) {
          effects.exit(stringType);
          return begin(marker);
        }
        if (code2 === null) {
          return nok(code2);
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return factorySpace(effects, atBreak, "linePrefix");
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return inside(code2);
      }
      function inside(code2) {
        if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
          effects.exit("chunkString");
          return atBreak(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? escape2 : inside;
      }
      function escape2(code2) {
        if (code2 === marker || code2 === 92) {
          effects.consume(code2);
          return inside;
        }
        return inside(code2);
      }
    }
    function factoryWhitespace(effects, ok2) {
      let seen;
      return start;
      function start(code2) {
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          seen = true;
          return start;
        }
        if (markdownSpace(code2)) {
          return factorySpace(
            effects,
            start,
            seen ? "linePrefix" : "lineSuffix"
          )(code2);
        }
        return ok2(code2);
      }
    }
    const definition$1 = {
      name: "definition",
      tokenize: tokenizeDefinition
    };
    const titleBefore = {
      tokenize: tokenizeTitleBefore,
      partial: true
    };
    function tokenizeDefinition(effects, ok2, nok) {
      const self2 = this;
      let identifier;
      return start;
      function start(code2) {
        effects.enter("definition");
        return before(code2);
      }
      function before(code2) {
        return factoryLabel.call(
          self2,
          effects,
          labelAfter,
          // Note: we don’t need to reset the way `markdown-rs` does.
          nok,
          "definitionLabel",
          "definitionLabelMarker",
          "definitionLabelString"
        )(code2);
      }
      function labelAfter(code2) {
        identifier = normalizeIdentifier(
          self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
        );
        if (code2 === 58) {
          effects.enter("definitionMarker");
          effects.consume(code2);
          effects.exit("definitionMarker");
          return markerAfter;
        }
        return nok(code2);
      }
      function markerAfter(code2) {
        return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
      }
      function destinationBefore(code2) {
        return factoryDestination(
          effects,
          destinationAfter,
          // Note: we don’t need to reset the way `markdown-rs` does.
          nok,
          "definitionDestination",
          "definitionDestinationLiteral",
          "definitionDestinationLiteralMarker",
          "definitionDestinationRaw",
          "definitionDestinationString"
        )(code2);
      }
      function destinationAfter(code2) {
        return effects.attempt(titleBefore, after, after)(code2);
      }
      function after(code2) {
        return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
      }
      function afterWhitespace(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("definition");
          self2.parser.defined.push(identifier);
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    function tokenizeTitleBefore(effects, ok2, nok) {
      return titleBefore2;
      function titleBefore2(code2) {
        return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
      }
      function beforeMarker(code2) {
        return factoryTitle(
          effects,
          titleAfter,
          nok,
          "definitionTitle",
          "definitionTitleMarker",
          "definitionTitleString"
        )(code2);
      }
      function titleAfter(code2) {
        return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
      }
      function titleAfterOptionalWhitespace(code2) {
        return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
      }
    }
    const hardBreakEscape = {
      name: "hardBreakEscape",
      tokenize: tokenizeHardBreakEscape
    };
    function tokenizeHardBreakEscape(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.enter("hardBreakEscape");
        effects.consume(code2);
        return after;
      }
      function after(code2) {
        if (markdownLineEnding(code2)) {
          effects.exit("hardBreakEscape");
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    const headingAtx = {
      name: "headingAtx",
      tokenize: tokenizeHeadingAtx,
      resolve: resolveHeadingAtx
    };
    function resolveHeadingAtx(events, context) {
      let contentEnd = events.length - 2;
      let contentStart = 3;
      let content2;
      let text2;
      if (events[contentStart][1].type === "whitespace") {
        contentStart += 2;
      }
      if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
        contentEnd -= 2;
      }
      if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
        contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
      }
      if (contentEnd > contentStart) {
        content2 = {
          type: "atxHeadingText",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        text2 = {
          type: "chunkText",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end,
          contentType: "text"
        };
        splice$1(events, contentStart, contentEnd - contentStart + 1, [
          ["enter", content2, context],
          ["enter", text2, context],
          ["exit", text2, context],
          ["exit", content2, context]
        ]);
      }
      return events;
    }
    function tokenizeHeadingAtx(effects, ok2, nok) {
      let size = 0;
      return start;
      function start(code2) {
        effects.enter("atxHeading");
        return before(code2);
      }
      function before(code2) {
        effects.enter("atxHeadingSequence");
        return sequenceOpen(code2);
      }
      function sequenceOpen(code2) {
        if (code2 === 35 && size++ < 6) {
          effects.consume(code2);
          return sequenceOpen;
        }
        if (code2 === null || markdownLineEndingOrSpace(code2)) {
          effects.exit("atxHeadingSequence");
          return atBreak(code2);
        }
        return nok(code2);
      }
      function atBreak(code2) {
        if (code2 === 35) {
          effects.enter("atxHeadingSequence");
          return sequenceFurther(code2);
        }
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("atxHeading");
          return ok2(code2);
        }
        if (markdownSpace(code2)) {
          return factorySpace(effects, atBreak, "whitespace")(code2);
        }
        effects.enter("atxHeadingText");
        return data2(code2);
      }
      function sequenceFurther(code2) {
        if (code2 === 35) {
          effects.consume(code2);
          return sequenceFurther;
        }
        effects.exit("atxHeadingSequence");
        return atBreak(code2);
      }
      function data2(code2) {
        if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
          effects.exit("atxHeadingText");
          return atBreak(code2);
        }
        effects.consume(code2);
        return data2;
      }
    }
    const htmlBlockNames = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "search",
      "section",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    const htmlRawNames = ["pre", "script", "style", "textarea"];
    const htmlFlow = {
      name: "htmlFlow",
      tokenize: tokenizeHtmlFlow,
      resolveTo: resolveToHtmlFlow,
      concrete: true
    };
    const blankLineBefore = {
      tokenize: tokenizeBlankLineBefore,
      partial: true
    };
    const nonLazyContinuationStart = {
      tokenize: tokenizeNonLazyContinuationStart,
      partial: true
    };
    function resolveToHtmlFlow(events) {
      let index2 = events.length;
      while (index2--) {
        if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
          break;
        }
      }
      if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
        events[index2][1].start = events[index2 - 2][1].start;
        events[index2 + 1][1].start = events[index2 - 2][1].start;
        events.splice(index2 - 2, 2);
      }
      return events;
    }
    function tokenizeHtmlFlow(effects, ok2, nok) {
      const self2 = this;
      let marker;
      let closingTag;
      let buffer;
      let index2;
      let markerB;
      return start;
      function start(code2) {
        return before(code2);
      }
      function before(code2) {
        effects.enter("htmlFlow");
        effects.enter("htmlFlowData");
        effects.consume(code2);
        return open;
      }
      function open(code2) {
        if (code2 === 33) {
          effects.consume(code2);
          return declarationOpen;
        }
        if (code2 === 47) {
          effects.consume(code2);
          closingTag = true;
          return tagCloseStart;
        }
        if (code2 === 63) {
          effects.consume(code2);
          marker = 3;
          return self2.interrupt ? ok2 : continuationDeclarationInside;
        }
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          buffer = String.fromCharCode(code2);
          return tagName;
        }
        return nok(code2);
      }
      function declarationOpen(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          marker = 2;
          return commentOpenInside;
        }
        if (code2 === 91) {
          effects.consume(code2);
          marker = 5;
          index2 = 0;
          return cdataOpenInside;
        }
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          marker = 4;
          return self2.interrupt ? ok2 : continuationDeclarationInside;
        }
        return nok(code2);
      }
      function commentOpenInside(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return self2.interrupt ? ok2 : continuationDeclarationInside;
        }
        return nok(code2);
      }
      function cdataOpenInside(code2) {
        const value = "CDATA[";
        if (code2 === value.charCodeAt(index2++)) {
          effects.consume(code2);
          if (index2 === value.length) {
            return self2.interrupt ? ok2 : continuation;
          }
          return cdataOpenInside;
        }
        return nok(code2);
      }
      function tagCloseStart(code2) {
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          buffer = String.fromCharCode(code2);
          return tagName;
        }
        return nok(code2);
      }
      function tagName(code2) {
        if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
          const slash = code2 === 47;
          const name2 = buffer.toLowerCase();
          if (!slash && !closingTag && htmlRawNames.includes(name2)) {
            marker = 1;
            return self2.interrupt ? ok2(code2) : continuation(code2);
          }
          if (htmlBlockNames.includes(buffer.toLowerCase())) {
            marker = 6;
            if (slash) {
              effects.consume(code2);
              return basicSelfClosing;
            }
            return self2.interrupt ? ok2(code2) : continuation(code2);
          }
          marker = 7;
          return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
        }
        if (code2 === 45 || asciiAlphanumeric(code2)) {
          effects.consume(code2);
          buffer += String.fromCharCode(code2);
          return tagName;
        }
        return nok(code2);
      }
      function basicSelfClosing(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return self2.interrupt ? ok2 : continuation;
        }
        return nok(code2);
      }
      function completeClosingTagAfter(code2) {
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return completeClosingTagAfter;
        }
        return completeEnd(code2);
      }
      function completeAttributeNameBefore(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return completeEnd;
        }
        if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
          effects.consume(code2);
          return completeAttributeName;
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return completeAttributeNameBefore;
        }
        return completeEnd(code2);
      }
      function completeAttributeName(code2) {
        if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
          effects.consume(code2);
          return completeAttributeName;
        }
        return completeAttributeNameAfter(code2);
      }
      function completeAttributeNameAfter(code2) {
        if (code2 === 61) {
          effects.consume(code2);
          return completeAttributeValueBefore;
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return completeAttributeNameAfter;
        }
        return completeAttributeNameBefore(code2);
      }
      function completeAttributeValueBefore(code2) {
        if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 34 || code2 === 39) {
          effects.consume(code2);
          markerB = code2;
          return completeAttributeValueQuoted;
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return completeAttributeValueBefore;
        }
        return completeAttributeValueUnquoted(code2);
      }
      function completeAttributeValueQuoted(code2) {
        if (code2 === markerB) {
          effects.consume(code2);
          markerB = null;
          return completeAttributeValueQuotedAfter;
        }
        if (code2 === null || markdownLineEnding(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return completeAttributeValueQuoted;
      }
      function completeAttributeValueUnquoted(code2) {
        if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
          return completeAttributeNameAfter(code2);
        }
        effects.consume(code2);
        return completeAttributeValueUnquoted;
      }
      function completeAttributeValueQuotedAfter(code2) {
        if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
          return completeAttributeNameBefore(code2);
        }
        return nok(code2);
      }
      function completeEnd(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return completeAfter;
        }
        return nok(code2);
      }
      function completeAfter(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return continuation(code2);
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return completeAfter;
        }
        return nok(code2);
      }
      function continuation(code2) {
        if (code2 === 45 && marker === 2) {
          effects.consume(code2);
          return continuationCommentInside;
        }
        if (code2 === 60 && marker === 1) {
          effects.consume(code2);
          return continuationRawTagOpen;
        }
        if (code2 === 62 && marker === 4) {
          effects.consume(code2);
          return continuationClose;
        }
        if (code2 === 63 && marker === 3) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        if (code2 === 93 && marker === 5) {
          effects.consume(code2);
          return continuationCdataInside;
        }
        if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
          effects.exit("htmlFlowData");
          return effects.check(
            blankLineBefore,
            continuationAfter,
            continuationStart
          )(code2);
        }
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("htmlFlowData");
          return continuationStart(code2);
        }
        effects.consume(code2);
        return continuation;
      }
      function continuationStart(code2) {
        return effects.check(
          nonLazyContinuationStart,
          continuationStartNonLazy,
          continuationAfter
        )(code2);
      }
      function continuationStartNonLazy(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return continuationBefore;
      }
      function continuationBefore(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return continuationStart(code2);
        }
        effects.enter("htmlFlowData");
        return continuation(code2);
      }
      function continuationCommentInside(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        return continuation(code2);
      }
      function continuationRawTagOpen(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          buffer = "";
          return continuationRawEndTag;
        }
        return continuation(code2);
      }
      function continuationRawEndTag(code2) {
        if (code2 === 62) {
          const name2 = buffer.toLowerCase();
          if (htmlRawNames.includes(name2)) {
            effects.consume(code2);
            return continuationClose;
          }
          return continuation(code2);
        }
        if (asciiAlpha(code2) && buffer.length < 8) {
          effects.consume(code2);
          buffer += String.fromCharCode(code2);
          return continuationRawEndTag;
        }
        return continuation(code2);
      }
      function continuationCdataInside(code2) {
        if (code2 === 93) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        return continuation(code2);
      }
      function continuationDeclarationInside(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return continuationClose;
        }
        if (code2 === 45 && marker === 2) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        return continuation(code2);
      }
      function continuationClose(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("htmlFlowData");
          return continuationAfter(code2);
        }
        effects.consume(code2);
        return continuationClose;
      }
      function continuationAfter(code2) {
        effects.exit("htmlFlow");
        return ok2(code2);
      }
    }
    function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
      }
    }
    function tokenizeBlankLineBefore(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return effects.attempt(blankLine, ok2, nok);
      }
    }
    const htmlText = {
      name: "htmlText",
      tokenize: tokenizeHtmlText
    };
    function tokenizeHtmlText(effects, ok2, nok) {
      const self2 = this;
      let marker;
      let index2;
      let returnState;
      return start;
      function start(code2) {
        effects.enter("htmlText");
        effects.enter("htmlTextData");
        effects.consume(code2);
        return open;
      }
      function open(code2) {
        if (code2 === 33) {
          effects.consume(code2);
          return declarationOpen;
        }
        if (code2 === 47) {
          effects.consume(code2);
          return tagCloseStart;
        }
        if (code2 === 63) {
          effects.consume(code2);
          return instruction;
        }
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return tagOpen;
        }
        return nok(code2);
      }
      function declarationOpen(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return commentOpenInside;
        }
        if (code2 === 91) {
          effects.consume(code2);
          index2 = 0;
          return cdataOpenInside;
        }
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return declaration;
        }
        return nok(code2);
      }
      function commentOpenInside(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return commentEnd;
        }
        return nok(code2);
      }
      function comment(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 45) {
          effects.consume(code2);
          return commentClose;
        }
        if (markdownLineEnding(code2)) {
          returnState = comment;
          return lineEndingBefore(code2);
        }
        effects.consume(code2);
        return comment;
      }
      function commentClose(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return commentEnd;
        }
        return comment(code2);
      }
      function commentEnd(code2) {
        return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment(code2);
      }
      function cdataOpenInside(code2) {
        const value = "CDATA[";
        if (code2 === value.charCodeAt(index2++)) {
          effects.consume(code2);
          return index2 === value.length ? cdata : cdataOpenInside;
        }
        return nok(code2);
      }
      function cdata(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 93) {
          effects.consume(code2);
          return cdataClose;
        }
        if (markdownLineEnding(code2)) {
          returnState = cdata;
          return lineEndingBefore(code2);
        }
        effects.consume(code2);
        return cdata;
      }
      function cdataClose(code2) {
        if (code2 === 93) {
          effects.consume(code2);
          return cdataEnd;
        }
        return cdata(code2);
      }
      function cdataEnd(code2) {
        if (code2 === 62) {
          return end(code2);
        }
        if (code2 === 93) {
          effects.consume(code2);
          return cdataEnd;
        }
        return cdata(code2);
      }
      function declaration(code2) {
        if (code2 === null || code2 === 62) {
          return end(code2);
        }
        if (markdownLineEnding(code2)) {
          returnState = declaration;
          return lineEndingBefore(code2);
        }
        effects.consume(code2);
        return declaration;
      }
      function instruction(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 63) {
          effects.consume(code2);
          return instructionClose;
        }
        if (markdownLineEnding(code2)) {
          returnState = instruction;
          return lineEndingBefore(code2);
        }
        effects.consume(code2);
        return instruction;
      }
      function instructionClose(code2) {
        return code2 === 62 ? end(code2) : instruction(code2);
      }
      function tagCloseStart(code2) {
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return tagClose;
        }
        return nok(code2);
      }
      function tagClose(code2) {
        if (code2 === 45 || asciiAlphanumeric(code2)) {
          effects.consume(code2);
          return tagClose;
        }
        return tagCloseBetween(code2);
      }
      function tagCloseBetween(code2) {
        if (markdownLineEnding(code2)) {
          returnState = tagCloseBetween;
          return lineEndingBefore(code2);
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return tagCloseBetween;
        }
        return end(code2);
      }
      function tagOpen(code2) {
        if (code2 === 45 || asciiAlphanumeric(code2)) {
          effects.consume(code2);
          return tagOpen;
        }
        if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
          return tagOpenBetween(code2);
        }
        return nok(code2);
      }
      function tagOpenBetween(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return end;
        }
        if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
          effects.consume(code2);
          return tagOpenAttributeName;
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenBetween;
          return lineEndingBefore(code2);
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return tagOpenBetween;
        }
        return end(code2);
      }
      function tagOpenAttributeName(code2) {
        if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
          effects.consume(code2);
          return tagOpenAttributeName;
        }
        return tagOpenAttributeNameAfter(code2);
      }
      function tagOpenAttributeNameAfter(code2) {
        if (code2 === 61) {
          effects.consume(code2);
          return tagOpenAttributeValueBefore;
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenAttributeNameAfter;
          return lineEndingBefore(code2);
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return tagOpenAttributeNameAfter;
        }
        return tagOpenBetween(code2);
      }
      function tagOpenAttributeValueBefore(code2) {
        if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 34 || code2 === 39) {
          effects.consume(code2);
          marker = code2;
          return tagOpenAttributeValueQuoted;
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenAttributeValueBefore;
          return lineEndingBefore(code2);
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return tagOpenAttributeValueBefore;
        }
        effects.consume(code2);
        return tagOpenAttributeValueUnquoted;
      }
      function tagOpenAttributeValueQuoted(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          marker = void 0;
          return tagOpenAttributeValueQuotedAfter;
        }
        if (code2 === null) {
          return nok(code2);
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenAttributeValueQuoted;
          return lineEndingBefore(code2);
        }
        effects.consume(code2);
        return tagOpenAttributeValueQuoted;
      }
      function tagOpenAttributeValueUnquoted(code2) {
        if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
          return tagOpenBetween(code2);
        }
        effects.consume(code2);
        return tagOpenAttributeValueUnquoted;
      }
      function tagOpenAttributeValueQuotedAfter(code2) {
        if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
          return tagOpenBetween(code2);
        }
        return nok(code2);
      }
      function end(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          effects.exit("htmlTextData");
          effects.exit("htmlText");
          return ok2;
        }
        return nok(code2);
      }
      function lineEndingBefore(code2) {
        effects.exit("htmlTextData");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return lineEndingAfter;
      }
      function lineEndingAfter(code2) {
        return markdownSpace(code2) ? factorySpace(
          effects,
          lineEndingAfterPrefix,
          "linePrefix",
          self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
        )(code2) : lineEndingAfterPrefix(code2);
      }
      function lineEndingAfterPrefix(code2) {
        effects.enter("htmlTextData");
        return returnState(code2);
      }
    }
    const labelEnd = {
      name: "labelEnd",
      tokenize: tokenizeLabelEnd,
      resolveTo: resolveToLabelEnd,
      resolveAll: resolveAllLabelEnd
    };
    const resourceConstruct = {
      tokenize: tokenizeResource
    };
    const referenceFullConstruct = {
      tokenize: tokenizeReferenceFull
    };
    const referenceCollapsedConstruct = {
      tokenize: tokenizeReferenceCollapsed
    };
    function resolveAllLabelEnd(events) {
      let index2 = -1;
      while (++index2 < events.length) {
        const token = events[index2][1];
        if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
          events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
          token.type = "data";
          index2++;
        }
      }
      return events;
    }
    function resolveToLabelEnd(events, context) {
      let index2 = events.length;
      let offset = 0;
      let token;
      let open;
      let close;
      let media;
      while (index2--) {
        token = events[index2][1];
        if (open) {
          if (token.type === "link" || token.type === "labelLink" && token._inactive) {
            break;
          }
          if (events[index2][0] === "enter" && token.type === "labelLink") {
            token._inactive = true;
          }
        } else if (close) {
          if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
            open = index2;
            if (token.type !== "labelLink") {
              offset = 2;
              break;
            }
          }
        } else if (token.type === "labelEnd") {
          close = index2;
        }
      }
      const group = {
        type: events[open][1].type === "labelLink" ? "link" : "image",
        start: Object.assign({}, events[open][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
      };
      const label = {
        type: "label",
        start: Object.assign({}, events[open][1].start),
        end: Object.assign({}, events[close][1].end)
      };
      const text2 = {
        type: "labelText",
        start: Object.assign({}, events[open + offset + 2][1].end),
        end: Object.assign({}, events[close - 2][1].start)
      };
      media = [
        ["enter", group, context],
        ["enter", label, context]
      ];
      media = push(media, events.slice(open + 1, open + offset + 3));
      media = push(media, [["enter", text2, context]]);
      media = push(
        media,
        resolveAll(
          context.parser.constructs.insideSpan.null,
          events.slice(open + offset + 4, close - 3),
          context
        )
      );
      media = push(media, [
        ["exit", text2, context],
        events[close - 2],
        events[close - 1],
        ["exit", label, context]
      ]);
      media = push(media, events.slice(close + 1));
      media = push(media, [["exit", group, context]]);
      splice$1(events, open, events.length, media);
      return events;
    }
    function tokenizeLabelEnd(effects, ok2, nok) {
      const self2 = this;
      let index2 = self2.events.length;
      let labelStart;
      let defined;
      while (index2--) {
        if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
          labelStart = self2.events[index2][1];
          break;
        }
      }
      return start;
      function start(code2) {
        if (!labelStart) {
          return nok(code2);
        }
        if (labelStart._inactive) {
          return labelEndNok(code2);
        }
        defined = self2.parser.defined.includes(
          normalizeIdentifier(
            self2.sliceSerialize({
              start: labelStart.end,
              end: self2.now()
            })
          )
        );
        effects.enter("labelEnd");
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelEnd");
        return after;
      }
      function after(code2) {
        if (code2 === 40) {
          return effects.attempt(
            resourceConstruct,
            labelEndOk,
            defined ? labelEndOk : labelEndNok
          )(code2);
        }
        if (code2 === 91) {
          return effects.attempt(
            referenceFullConstruct,
            labelEndOk,
            defined ? referenceNotFull : labelEndNok
          )(code2);
        }
        return defined ? labelEndOk(code2) : labelEndNok(code2);
      }
      function referenceNotFull(code2) {
        return effects.attempt(
          referenceCollapsedConstruct,
          labelEndOk,
          labelEndNok
        )(code2);
      }
      function labelEndOk(code2) {
        return ok2(code2);
      }
      function labelEndNok(code2) {
        labelStart._balanced = true;
        return nok(code2);
      }
    }
    function tokenizeResource(effects, ok2, nok) {
      return resourceStart;
      function resourceStart(code2) {
        effects.enter("resource");
        effects.enter("resourceMarker");
        effects.consume(code2);
        effects.exit("resourceMarker");
        return resourceBefore;
      }
      function resourceBefore(code2) {
        return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
      }
      function resourceOpen(code2) {
        if (code2 === 41) {
          return resourceEnd(code2);
        }
        return factoryDestination(
          effects,
          resourceDestinationAfter,
          resourceDestinationMissing,
          "resourceDestination",
          "resourceDestinationLiteral",
          "resourceDestinationLiteralMarker",
          "resourceDestinationRaw",
          "resourceDestinationString",
          32
        )(code2);
      }
      function resourceDestinationAfter(code2) {
        return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
      }
      function resourceDestinationMissing(code2) {
        return nok(code2);
      }
      function resourceBetween(code2) {
        if (code2 === 34 || code2 === 39 || code2 === 40) {
          return factoryTitle(
            effects,
            resourceTitleAfter,
            nok,
            "resourceTitle",
            "resourceTitleMarker",
            "resourceTitleString"
          )(code2);
        }
        return resourceEnd(code2);
      }
      function resourceTitleAfter(code2) {
        return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
      }
      function resourceEnd(code2) {
        if (code2 === 41) {
          effects.enter("resourceMarker");
          effects.consume(code2);
          effects.exit("resourceMarker");
          effects.exit("resource");
          return ok2;
        }
        return nok(code2);
      }
    }
    function tokenizeReferenceFull(effects, ok2, nok) {
      const self2 = this;
      return referenceFull;
      function referenceFull(code2) {
        return factoryLabel.call(
          self2,
          effects,
          referenceFullAfter,
          referenceFullMissing,
          "reference",
          "referenceMarker",
          "referenceString"
        )(code2);
      }
      function referenceFullAfter(code2) {
        return self2.parser.defined.includes(
          normalizeIdentifier(
            self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
          )
        ) ? ok2(code2) : nok(code2);
      }
      function referenceFullMissing(code2) {
        return nok(code2);
      }
    }
    function tokenizeReferenceCollapsed(effects, ok2, nok) {
      return referenceCollapsedStart;
      function referenceCollapsedStart(code2) {
        effects.enter("reference");
        effects.enter("referenceMarker");
        effects.consume(code2);
        effects.exit("referenceMarker");
        return referenceCollapsedOpen;
      }
      function referenceCollapsedOpen(code2) {
        if (code2 === 93) {
          effects.enter("referenceMarker");
          effects.consume(code2);
          effects.exit("referenceMarker");
          effects.exit("reference");
          return ok2;
        }
        return nok(code2);
      }
    }
    const labelStartImage = {
      name: "labelStartImage",
      tokenize: tokenizeLabelStartImage,
      resolveAll: labelEnd.resolveAll
    };
    function tokenizeLabelStartImage(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        effects.enter("labelImage");
        effects.enter("labelImageMarker");
        effects.consume(code2);
        effects.exit("labelImageMarker");
        return open;
      }
      function open(code2) {
        if (code2 === 91) {
          effects.enter("labelMarker");
          effects.consume(code2);
          effects.exit("labelMarker");
          effects.exit("labelImage");
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
      }
    }
    const labelStartLink = {
      name: "labelStartLink",
      tokenize: tokenizeLabelStartLink,
      resolveAll: labelEnd.resolveAll
    };
    function tokenizeLabelStartLink(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        effects.enter("labelLink");
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelLink");
        return after;
      }
      function after(code2) {
        return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
      }
    }
    const lineEnding = {
      name: "lineEnding",
      tokenize: tokenizeLineEnding
    };
    function tokenizeLineEnding(effects, ok2) {
      return start;
      function start(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace(effects, ok2, "linePrefix");
      }
    }
    const thematicBreak$2 = {
      name: "thematicBreak",
      tokenize: tokenizeThematicBreak
    };
    function tokenizeThematicBreak(effects, ok2, nok) {
      let size = 0;
      let marker;
      return start;
      function start(code2) {
        effects.enter("thematicBreak");
        return before(code2);
      }
      function before(code2) {
        marker = code2;
        return atBreak(code2);
      }
      function atBreak(code2) {
        if (code2 === marker) {
          effects.enter("thematicBreakSequence");
          return sequence(code2);
        }
        if (size >= 3 && (code2 === null || markdownLineEnding(code2))) {
          effects.exit("thematicBreak");
          return ok2(code2);
        }
        return nok(code2);
      }
      function sequence(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          size++;
          return sequence;
        }
        effects.exit("thematicBreakSequence");
        return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
      }
    }
    const list$2 = {
      name: "list",
      tokenize: tokenizeListStart,
      continuation: {
        tokenize: tokenizeListContinuation
      },
      exit: tokenizeListEnd
    };
    const listItemPrefixWhitespaceConstruct = {
      tokenize: tokenizeListItemPrefixWhitespace,
      partial: true
    };
    const indentConstruct = {
      tokenize: tokenizeIndent$1,
      partial: true
    };
    function tokenizeListStart(effects, ok2, nok) {
      const self2 = this;
      const tail = self2.events[self2.events.length - 1];
      let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
      let size = 0;
      return start;
      function start(code2) {
        const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
        if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
          if (!self2.containerState.type) {
            self2.containerState.type = kind;
            effects.enter(kind, {
              _container: true
            });
          }
          if (kind === "listUnordered") {
            effects.enter("listItemPrefix");
            return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$2, nok, atMarker)(code2) : atMarker(code2);
          }
          if (!self2.interrupt || code2 === 49) {
            effects.enter("listItemPrefix");
            effects.enter("listItemValue");
            return inside(code2);
          }
        }
        return nok(code2);
      }
      function inside(code2) {
        if (asciiDigit(code2) && ++size < 10) {
          effects.consume(code2);
          return inside;
        }
        if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
          effects.exit("listItemValue");
          return atMarker(code2);
        }
        return nok(code2);
      }
      function atMarker(code2) {
        effects.enter("listItemMarker");
        effects.consume(code2);
        effects.exit("listItemMarker");
        self2.containerState.marker = self2.containerState.marker || code2;
        return effects.check(
          blankLine,
          // Can’t be empty when interrupting.
          self2.interrupt ? nok : onBlank,
          effects.attempt(
            listItemPrefixWhitespaceConstruct,
            endOfPrefix,
            otherPrefix
          )
        );
      }
      function onBlank(code2) {
        self2.containerState.initialBlankLine = true;
        initialSize++;
        return endOfPrefix(code2);
      }
      function otherPrefix(code2) {
        if (markdownSpace(code2)) {
          effects.enter("listItemPrefixWhitespace");
          effects.consume(code2);
          effects.exit("listItemPrefixWhitespace");
          return endOfPrefix;
        }
        return nok(code2);
      }
      function endOfPrefix(code2) {
        self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
        return ok2(code2);
      }
    }
    function tokenizeListContinuation(effects, ok2, nok) {
      const self2 = this;
      self2.containerState._closeFlow = void 0;
      return effects.check(blankLine, onBlank, notBlank);
      function onBlank(code2) {
        self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
        return factorySpace(
          effects,
          ok2,
          "listItemIndent",
          self2.containerState.size + 1
        )(code2);
      }
      function notBlank(code2) {
        if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
          self2.containerState.furtherBlankLines = void 0;
          self2.containerState.initialBlankLine = void 0;
          return notInCurrentItem(code2);
        }
        self2.containerState.furtherBlankLines = void 0;
        self2.containerState.initialBlankLine = void 0;
        return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
      }
      function notInCurrentItem(code2) {
        self2.containerState._closeFlow = true;
        self2.interrupt = void 0;
        return factorySpace(
          effects,
          effects.attempt(list$2, ok2, nok),
          "linePrefix",
          self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
        )(code2);
      }
    }
    function tokenizeIndent$1(effects, ok2, nok) {
      const self2 = this;
      return factorySpace(
        effects,
        afterPrefix,
        "listItemIndent",
        self2.containerState.size + 1
      );
      function afterPrefix(code2) {
        const tail = self2.events[self2.events.length - 1];
        return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
      }
    }
    function tokenizeListEnd(effects) {
      effects.exit(this.containerState.type);
    }
    function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
      const self2 = this;
      return factorySpace(
        effects,
        afterPrefix,
        "listItemPrefixWhitespace",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
      );
      function afterPrefix(code2) {
        const tail = self2.events[self2.events.length - 1];
        return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
      }
    }
    const setextUnderline = {
      name: "setextUnderline",
      tokenize: tokenizeSetextUnderline,
      resolveTo: resolveToSetextUnderline
    };
    function resolveToSetextUnderline(events, context) {
      let index2 = events.length;
      let content2;
      let text2;
      let definition2;
      while (index2--) {
        if (events[index2][0] === "enter") {
          if (events[index2][1].type === "content") {
            content2 = index2;
            break;
          }
          if (events[index2][1].type === "paragraph") {
            text2 = index2;
          }
        } else {
          if (events[index2][1].type === "content") {
            events.splice(index2, 1);
          }
          if (!definition2 && events[index2][1].type === "definition") {
            definition2 = index2;
          }
        }
      }
      const heading2 = {
        type: "setextHeading",
        start: Object.assign({}, events[text2][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
      };
      events[text2][1].type = "setextHeadingText";
      if (definition2) {
        events.splice(text2, 0, ["enter", heading2, context]);
        events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
        events[content2][1].end = Object.assign({}, events[definition2][1].end);
      } else {
        events[content2][1] = heading2;
      }
      events.push(["exit", heading2, context]);
      return events;
    }
    function tokenizeSetextUnderline(effects, ok2, nok) {
      const self2 = this;
      let marker;
      return start;
      function start(code2) {
        let index2 = self2.events.length;
        let paragraph2;
        while (index2--) {
          if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
            paragraph2 = self2.events[index2][1].type === "paragraph";
            break;
          }
        }
        if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
          effects.enter("setextHeadingLine");
          marker = code2;
          return before(code2);
        }
        return nok(code2);
      }
      function before(code2) {
        effects.enter("setextHeadingLineSequence");
        return inside(code2);
      }
      function inside(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return inside;
        }
        effects.exit("setextHeadingLineSequence");
        return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
      }
      function after(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("setextHeadingLine");
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    const flow$1 = {
      tokenize: initializeFlow
    };
    function initializeFlow(effects) {
      const self2 = this;
      const initial = effects.attempt(
        // Try to parse a blank line.
        blankLine,
        atBlankEnding,
        // Try to parse initial flow (essentially, only code).
        effects.attempt(
          this.parser.constructs.flowInitial,
          afterConstruct,
          factorySpace(
            effects,
            effects.attempt(
              this.parser.constructs.flow,
              afterConstruct,
              effects.attempt(content, afterConstruct)
            ),
            "linePrefix"
          )
        )
      );
      return initial;
      function atBlankEnding(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEndingBlank");
        effects.consume(code2);
        effects.exit("lineEndingBlank");
        self2.currentConstruct = void 0;
        return initial;
      }
      function afterConstruct(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        self2.currentConstruct = void 0;
        return initial;
      }
    }
    const resolver = {
      resolveAll: createResolver()
    };
    const string$1 = initializeFactory("string");
    const text$4 = initializeFactory("text");
    function initializeFactory(field) {
      return {
        tokenize: initializeText,
        resolveAll: createResolver(
          field === "text" ? resolveAllLineSuffixes : void 0
        )
      };
      function initializeText(effects) {
        const self2 = this;
        const constructs2 = this.parser.constructs[field];
        const text2 = effects.attempt(constructs2, start, notText);
        return start;
        function start(code2) {
          return atBreak(code2) ? text2(code2) : notText(code2);
        }
        function notText(code2) {
          if (code2 === null) {
            effects.consume(code2);
            return;
          }
          effects.enter("data");
          effects.consume(code2);
          return data2;
        }
        function data2(code2) {
          if (atBreak(code2)) {
            effects.exit("data");
            return text2(code2);
          }
          effects.consume(code2);
          return data2;
        }
        function atBreak(code2) {
          if (code2 === null) {
            return true;
          }
          const list2 = constructs2[code2];
          let index2 = -1;
          if (list2) {
            while (++index2 < list2.length) {
              const item = list2[index2];
              if (!item.previous || item.previous.call(self2, self2.previous)) {
                return true;
              }
            }
          }
          return false;
        }
      }
    }
    function createResolver(extraResolver) {
      return resolveAllText;
      function resolveAllText(events, context) {
        let index2 = -1;
        let enter;
        while (++index2 <= events.length) {
          if (enter === void 0) {
            if (events[index2] && events[index2][1].type === "data") {
              enter = index2;
              index2++;
            }
          } else if (!events[index2] || events[index2][1].type !== "data") {
            if (index2 !== enter + 2) {
              events[enter][1].end = events[index2 - 1][1].end;
              events.splice(enter + 2, index2 - enter - 2);
              index2 = enter + 2;
            }
            enter = void 0;
          }
        }
        return extraResolver ? extraResolver(events, context) : events;
      }
    }
    function resolveAllLineSuffixes(events, context) {
      let eventIndex = 0;
      while (++eventIndex <= events.length) {
        if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
          const data2 = events[eventIndex - 1][1];
          const chunks = context.sliceStream(data2);
          let index2 = chunks.length;
          let bufferIndex = -1;
          let size = 0;
          let tabs;
          while (index2--) {
            const chunk = chunks[index2];
            if (typeof chunk === "string") {
              bufferIndex = chunk.length;
              while (chunk.charCodeAt(bufferIndex - 1) === 32) {
                size++;
                bufferIndex--;
              }
              if (bufferIndex)
                break;
              bufferIndex = -1;
            } else if (chunk === -2) {
              tabs = true;
              size++;
            } else if (chunk === -1)
              ;
            else {
              index2++;
              break;
            }
          }
          if (size) {
            const token = {
              type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
              start: {
                line: data2.end.line,
                column: data2.end.column - size,
                offset: data2.end.offset - size,
                _index: data2.start._index + index2,
                _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex
              },
              end: Object.assign({}, data2.end)
            };
            data2.end = Object.assign({}, token.start);
            if (data2.start.offset === data2.end.offset) {
              Object.assign(data2, token);
            } else {
              events.splice(
                eventIndex,
                0,
                ["enter", token, context],
                ["exit", token, context]
              );
              eventIndex += 2;
            }
          }
          eventIndex++;
        }
      }
      return events;
    }
    function createTokenizer(parser, initialize, from) {
      let point2 = Object.assign(
        from ? Object.assign({}, from) : {
          line: 1,
          column: 1,
          offset: 0
        },
        {
          _index: 0,
          _bufferIndex: -1
        }
      );
      const columnStart = {};
      const resolveAllConstructs = [];
      let chunks = [];
      let stack = [];
      const effects = {
        consume,
        enter,
        exit: exit2,
        attempt: constructFactory(onsuccessfulconstruct),
        check: constructFactory(onsuccessfulcheck),
        interrupt: constructFactory(onsuccessfulcheck, {
          interrupt: true
        })
      };
      const context = {
        previous: null,
        code: null,
        containerState: {},
        events: [],
        parser,
        sliceStream,
        sliceSerialize,
        now,
        defineSkip,
        write
      };
      let state = initialize.tokenize.call(context, effects);
      if (initialize.resolveAll) {
        resolveAllConstructs.push(initialize);
      }
      return context;
      function write(slice) {
        chunks = push(chunks, slice);
        main();
        if (chunks[chunks.length - 1] !== null) {
          return [];
        }
        addResult(initialize, 0);
        context.events = resolveAll(resolveAllConstructs, context.events, context);
        return context.events;
      }
      function sliceSerialize(token, expandTabs) {
        return serializeChunks(sliceStream(token), expandTabs);
      }
      function sliceStream(token) {
        return sliceChunks(chunks, token);
      }
      function now() {
        const { line, column, offset, _index, _bufferIndex } = point2;
        return {
          line,
          column,
          offset,
          _index,
          _bufferIndex
        };
      }
      function defineSkip(value) {
        columnStart[value.line] = value.column;
        accountForPotentialSkip();
      }
      function main() {
        let chunkIndex;
        while (point2._index < chunks.length) {
          const chunk = chunks[point2._index];
          if (typeof chunk === "string") {
            chunkIndex = point2._index;
            if (point2._bufferIndex < 0) {
              point2._bufferIndex = 0;
            }
            while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
              go(chunk.charCodeAt(point2._bufferIndex));
            }
          } else {
            go(chunk);
          }
        }
      }
      function go(code2) {
        state = state(code2);
      }
      function consume(code2) {
        if (markdownLineEnding(code2)) {
          point2.line++;
          point2.column = 1;
          point2.offset += code2 === -3 ? 2 : 1;
          accountForPotentialSkip();
        } else if (code2 !== -1) {
          point2.column++;
          point2.offset++;
        }
        if (point2._bufferIndex < 0) {
          point2._index++;
        } else {
          point2._bufferIndex++;
          if (point2._bufferIndex === chunks[point2._index].length) {
            point2._bufferIndex = -1;
            point2._index++;
          }
        }
        context.previous = code2;
      }
      function enter(type, fields) {
        const token = fields || {};
        token.type = type;
        token.start = now();
        context.events.push(["enter", token, context]);
        stack.push(token);
        return token;
      }
      function exit2(type) {
        const token = stack.pop();
        token.end = now();
        context.events.push(["exit", token, context]);
        return token;
      }
      function onsuccessfulconstruct(construct, info2) {
        addResult(construct, info2.from);
      }
      function onsuccessfulcheck(_, info2) {
        info2.restore();
      }
      function constructFactory(onreturn, fields) {
        return hook;
        function hook(constructs2, returnState, bogusState) {
          let listOfConstructs;
          let constructIndex;
          let currentConstruct;
          let info2;
          return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
            // @ts-expect-error Looks like a construct.
            handleListOfConstructs([constructs2])
          ) : handleMapOfConstructs(constructs2);
          function handleMapOfConstructs(map2) {
            return start;
            function start(code2) {
              const def = code2 !== null && map2[code2];
              const all2 = code2 !== null && map2.null;
              const list2 = [
                // To do: add more extension tests.
                /* c8 ignore next 2 */
                ...Array.isArray(def) ? def : def ? [def] : [],
                ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
              ];
              return handleListOfConstructs(list2)(code2);
            }
          }
          function handleListOfConstructs(list2) {
            listOfConstructs = list2;
            constructIndex = 0;
            if (list2.length === 0) {
              return bogusState;
            }
            return handleConstruct(list2[constructIndex]);
          }
          function handleConstruct(construct) {
            return start;
            function start(code2) {
              info2 = store();
              currentConstruct = construct;
              if (!construct.partial) {
                context.currentConstruct = construct;
              }
              if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
                return nok();
              }
              return construct.tokenize.call(
                // If we do have fields, create an object w/ `context` as its
                // prototype.
                // This allows a “live binding”, which is needed for `interrupt`.
                fields ? Object.assign(Object.create(context), fields) : context,
                effects,
                ok2,
                nok
              )(code2);
            }
          }
          function ok2(code2) {
            onreturn(currentConstruct, info2);
            return returnState;
          }
          function nok(code2) {
            info2.restore();
            if (++constructIndex < listOfConstructs.length) {
              return handleConstruct(listOfConstructs[constructIndex]);
            }
            return bogusState;
          }
        }
      }
      function addResult(construct, from2) {
        if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
          resolveAllConstructs.push(construct);
        }
        if (construct.resolve) {
          splice$1(
            context.events,
            from2,
            context.events.length - from2,
            construct.resolve(context.events.slice(from2), context)
          );
        }
        if (construct.resolveTo) {
          context.events = construct.resolveTo(context.events, context);
        }
      }
      function store() {
        const startPoint = now();
        const startPrevious = context.previous;
        const startCurrentConstruct = context.currentConstruct;
        const startEventsIndex = context.events.length;
        const startStack = Array.from(stack);
        return {
          restore: restore2,
          from: startEventsIndex
        };
        function restore2() {
          point2 = startPoint;
          context.previous = startPrevious;
          context.currentConstruct = startCurrentConstruct;
          context.events.length = startEventsIndex;
          stack = startStack;
          accountForPotentialSkip();
        }
      }
      function accountForPotentialSkip() {
        if (point2.line in columnStart && point2.column < 2) {
          point2.column = columnStart[point2.line];
          point2.offset += columnStart[point2.line] - 1;
        }
      }
    }
    function sliceChunks(chunks, token) {
      const startIndex = token.start._index;
      const startBufferIndex = token.start._bufferIndex;
      const endIndex = token.end._index;
      const endBufferIndex = token.end._bufferIndex;
      let view;
      if (startIndex === endIndex) {
        view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
      } else {
        view = chunks.slice(startIndex, endIndex);
        if (startBufferIndex > -1) {
          const head = view[0];
          if (typeof head === "string") {
            view[0] = head.slice(startBufferIndex);
          } else {
            view.shift();
          }
        }
        if (endBufferIndex > 0) {
          view.push(chunks[endIndex].slice(0, endBufferIndex));
        }
      }
      return view;
    }
    function serializeChunks(chunks, expandTabs) {
      let index2 = -1;
      const result = [];
      let atTab;
      while (++index2 < chunks.length) {
        const chunk = chunks[index2];
        let value;
        if (typeof chunk === "string") {
          value = chunk;
        } else
          switch (chunk) {
            case -5: {
              value = "\r";
              break;
            }
            case -4: {
              value = "\n";
              break;
            }
            case -3: {
              value = "\r\n";
              break;
            }
            case -2: {
              value = expandTabs ? " " : "	";
              break;
            }
            case -1: {
              if (!expandTabs && atTab)
                continue;
              value = " ";
              break;
            }
            default: {
              value = String.fromCharCode(chunk);
            }
          }
        atTab = chunk === -2;
        result.push(value);
      }
      return result.join("");
    }
    const document$1 = {
      [42]: list$2,
      [43]: list$2,
      [45]: list$2,
      [48]: list$2,
      [49]: list$2,
      [50]: list$2,
      [51]: list$2,
      [52]: list$2,
      [53]: list$2,
      [54]: list$2,
      [55]: list$2,
      [56]: list$2,
      [57]: list$2,
      [62]: blockQuote
    };
    const contentInitial = {
      [91]: definition$1
    };
    const flowInitial = {
      [-2]: codeIndented,
      [-1]: codeIndented,
      [32]: codeIndented
    };
    const flow = {
      [35]: headingAtx,
      [42]: thematicBreak$2,
      [45]: [setextUnderline, thematicBreak$2],
      [60]: htmlFlow,
      [61]: setextUnderline,
      [95]: thematicBreak$2,
      [96]: codeFenced,
      [126]: codeFenced
    };
    const string = {
      [38]: characterReference,
      [92]: characterEscape
    };
    const text$3 = {
      [-5]: lineEnding,
      [-4]: lineEnding,
      [-3]: lineEnding,
      [33]: labelStartImage,
      [38]: characterReference,
      [42]: attention,
      [60]: [autolink, htmlText],
      [91]: labelStartLink,
      [92]: [hardBreakEscape, characterEscape],
      [93]: labelEnd,
      [95]: attention,
      [96]: codeText
    };
    const insideSpan = {
      null: [attention, resolver]
    };
    const attentionMarkers = {
      null: [42, 95]
    };
    const disable = {
      null: []
    };
    const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      attentionMarkers,
      contentInitial,
      disable,
      document: document$1,
      flow,
      flowInitial,
      insideSpan,
      string,
      text: text$3
    }, Symbol.toStringTag, { value: "Module" }));
    function parse$5(options) {
      const settings = options || {};
      const constructs2 = (
        /** @type {FullNormalizedExtension} */
        combineExtensions([defaultConstructs, ...settings.extensions || []])
      );
      const parser = {
        defined: [],
        lazy: {},
        constructs: constructs2,
        content: create2(content$1),
        document: create2(document$2),
        flow: create2(flow$1),
        string: create2(string$1),
        text: create2(text$4)
      };
      return parser;
      function create2(initial) {
        return creator;
        function creator(from) {
          return createTokenizer(parser, initial, from);
        }
      }
    }
    function postprocess(events) {
      while (!subtokenize(events)) {
      }
      return events;
    }
    const search$1 = /[\0\t\n\r]/g;
    function preprocess() {
      let column = 1;
      let buffer = "";
      let start = true;
      let atCarriageReturn;
      return preprocessor;
      function preprocessor(value, encoding, end) {
        const chunks = [];
        let match;
        let next;
        let startPosition;
        let endPosition;
        let code2;
        value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
        startPosition = 0;
        buffer = "";
        if (start) {
          if (value.charCodeAt(0) === 65279) {
            startPosition++;
          }
          start = void 0;
        }
        while (startPosition < value.length) {
          search$1.lastIndex = startPosition;
          match = search$1.exec(value);
          endPosition = match && match.index !== void 0 ? match.index : value.length;
          code2 = value.charCodeAt(endPosition);
          if (!match) {
            buffer = value.slice(startPosition);
            break;
          }
          if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
            chunks.push(-3);
            atCarriageReturn = void 0;
          } else {
            if (atCarriageReturn) {
              chunks.push(-5);
              atCarriageReturn = void 0;
            }
            if (startPosition < endPosition) {
              chunks.push(value.slice(startPosition, endPosition));
              column += endPosition - startPosition;
            }
            switch (code2) {
              case 0: {
                chunks.push(65533);
                column++;
                break;
              }
              case 9: {
                next = Math.ceil(column / 4) * 4;
                chunks.push(-2);
                while (column++ < next)
                  chunks.push(-1);
                break;
              }
              case 10: {
                chunks.push(-4);
                column = 1;
                break;
              }
              default: {
                atCarriageReturn = true;
                column = 1;
              }
            }
          }
          startPosition = endPosition + 1;
        }
        if (end) {
          if (atCarriageReturn)
            chunks.push(-5);
          if (buffer)
            chunks.push(buffer);
          chunks.push(null);
        }
        return chunks;
      }
    }
    const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
    function decodeString(value) {
      return value.replace(characterEscapeOrReference, decode$1);
    }
    function decode$1($0, $1, $2) {
      if ($1) {
        return $1;
      }
      const head = $2.charCodeAt(0);
      if (head === 35) {
        const head2 = $2.charCodeAt(1);
        const hex = head2 === 120 || head2 === 88;
        return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
      }
      return decodeNamedCharacterReference($2) || $0;
    }
    const own$6 = {}.hasOwnProperty;
    function fromMarkdown(value, encoding, options) {
      if (typeof encoding !== "string") {
        options = encoding;
        encoding = void 0;
      }
      return compiler(options)(
        postprocess(
          parse$5(options).document().write(preprocess()(value, encoding, true))
        )
      );
    }
    function compiler(options) {
      const config2 = {
        transforms: [],
        canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
        enter: {
          autolink: opener(link2),
          autolinkProtocol: onenterdata,
          autolinkEmail: onenterdata,
          atxHeading: opener(heading2),
          blockQuote: opener(blockQuote2),
          characterEscape: onenterdata,
          characterReference: onenterdata,
          codeFenced: opener(codeFlow),
          codeFencedFenceInfo: buffer,
          codeFencedFenceMeta: buffer,
          codeIndented: opener(codeFlow, buffer),
          codeText: opener(codeText2, buffer),
          codeTextData: onenterdata,
          data: onenterdata,
          codeFlowValue: onenterdata,
          definition: opener(definition2),
          definitionDestinationString: buffer,
          definitionLabelString: buffer,
          definitionTitleString: buffer,
          emphasis: opener(emphasis2),
          hardBreakEscape: opener(hardBreak2),
          hardBreakTrailing: opener(hardBreak2),
          htmlFlow: opener(html2, buffer),
          htmlFlowData: onenterdata,
          htmlText: opener(html2, buffer),
          htmlTextData: onenterdata,
          image: opener(image2),
          label: buffer,
          link: opener(link2),
          listItem: opener(listItem2),
          listItemValue: onenterlistitemvalue,
          listOrdered: opener(list2, onenterlistordered),
          listUnordered: opener(list2),
          paragraph: opener(paragraph2),
          reference: onenterreference,
          referenceString: buffer,
          resourceDestinationString: buffer,
          resourceTitleString: buffer,
          setextHeading: opener(heading2),
          strong: opener(strong2),
          thematicBreak: opener(thematicBreak2)
        },
        exit: {
          atxHeading: closer(),
          atxHeadingSequence: onexitatxheadingsequence,
          autolink: closer(),
          autolinkEmail: onexitautolinkemail,
          autolinkProtocol: onexitautolinkprotocol,
          blockQuote: closer(),
          characterEscapeValue: onexitdata,
          characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
          characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
          characterReferenceValue: onexitcharacterreferencevalue,
          codeFenced: closer(onexitcodefenced),
          codeFencedFence: onexitcodefencedfence,
          codeFencedFenceInfo: onexitcodefencedfenceinfo,
          codeFencedFenceMeta: onexitcodefencedfencemeta,
          codeFlowValue: onexitdata,
          codeIndented: closer(onexitcodeindented),
          codeText: closer(onexitcodetext),
          codeTextData: onexitdata,
          data: onexitdata,
          definition: closer(),
          definitionDestinationString: onexitdefinitiondestinationstring,
          definitionLabelString: onexitdefinitionlabelstring,
          definitionTitleString: onexitdefinitiontitlestring,
          emphasis: closer(),
          hardBreakEscape: closer(onexithardbreak),
          hardBreakTrailing: closer(onexithardbreak),
          htmlFlow: closer(onexithtmlflow),
          htmlFlowData: onexitdata,
          htmlText: closer(onexithtmltext),
          htmlTextData: onexitdata,
          image: closer(onexitimage),
          label: onexitlabel,
          labelText: onexitlabeltext,
          lineEnding: onexitlineending,
          link: closer(onexitlink),
          listItem: closer(),
          listOrdered: closer(),
          listUnordered: closer(),
          paragraph: closer(),
          referenceString: onexitreferencestring,
          resourceDestinationString: onexitresourcedestinationstring,
          resourceTitleString: onexitresourcetitlestring,
          resource: onexitresource,
          setextHeading: closer(onexitsetextheading),
          setextHeadingLineSequence: onexitsetextheadinglinesequence,
          setextHeadingText: onexitsetextheadingtext,
          strong: closer(),
          thematicBreak: closer()
        }
      };
      configure(config2, (options || {}).mdastExtensions || []);
      const data2 = {};
      return compile;
      function compile(events) {
        let tree = {
          type: "root",
          children: []
        };
        const context = {
          stack: [tree],
          tokenStack: [],
          config: config2,
          enter,
          exit: exit2,
          buffer,
          resume,
          data: data2
        };
        const listStack = [];
        let index2 = -1;
        while (++index2 < events.length) {
          if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
            if (events[index2][0] === "enter") {
              listStack.push(index2);
            } else {
              const tail = listStack.pop();
              index2 = prepareList(events, tail, index2);
            }
          }
        }
        index2 = -1;
        while (++index2 < events.length) {
          const handler = config2[events[index2][0]];
          if (own$6.call(handler, events[index2][1].type)) {
            handler[events[index2][1].type].call(
              Object.assign(
                {
                  sliceSerialize: events[index2][2].sliceSerialize
                },
                context
              ),
              events[index2][1]
            );
          }
        }
        if (context.tokenStack.length > 0) {
          const tail = context.tokenStack[context.tokenStack.length - 1];
          const handler = tail[1] || defaultOnError;
          handler.call(context, void 0, tail[0]);
        }
        tree.position = {
          start: point(
            events.length > 0 ? events[0][1].start : {
              line: 1,
              column: 1,
              offset: 0
            }
          ),
          end: point(
            events.length > 0 ? events[events.length - 2][1].end : {
              line: 1,
              column: 1,
              offset: 0
            }
          )
        };
        index2 = -1;
        while (++index2 < config2.transforms.length) {
          tree = config2.transforms[index2](tree) || tree;
        }
        return tree;
      }
      function prepareList(events, start, length) {
        let index2 = start - 1;
        let containerBalance = -1;
        let listSpread = false;
        let listItem3;
        let lineIndex;
        let firstBlankLineIndex;
        let atMarker;
        while (++index2 <= length) {
          const event = events[index2];
          switch (event[1].type) {
            case "listUnordered":
            case "listOrdered":
            case "blockQuote": {
              if (event[0] === "enter") {
                containerBalance++;
              } else {
                containerBalance--;
              }
              atMarker = void 0;
              break;
            }
            case "lineEndingBlank": {
              if (event[0] === "enter") {
                if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                  firstBlankLineIndex = index2;
                }
                atMarker = void 0;
              }
              break;
            }
            case "linePrefix":
            case "listItemValue":
            case "listItemMarker":
            case "listItemPrefix":
            case "listItemPrefixWhitespace": {
              break;
            }
            default: {
              atMarker = void 0;
            }
          }
          if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
            if (listItem3) {
              let tailIndex = index2;
              lineIndex = void 0;
              while (tailIndex--) {
                const tailEvent = events[tailIndex];
                if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                  if (tailEvent[0] === "exit")
                    continue;
                  if (lineIndex) {
                    events[lineIndex][1].type = "lineEndingBlank";
                    listSpread = true;
                  }
                  tailEvent[1].type = "lineEnding";
                  lineIndex = tailIndex;
                } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
                  ;
                else {
                  break;
                }
              }
              if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
                listItem3._spread = true;
              }
              listItem3.end = Object.assign(
                {},
                lineIndex ? events[lineIndex][1].start : event[1].end
              );
              events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
              index2++;
              length++;
            }
            if (event[1].type === "listItemPrefix") {
              const item = {
                type: "listItem",
                _spread: false,
                start: Object.assign({}, event[1].start),
                // @ts-expect-error: we’ll add `end` in a second.
                end: void 0
              };
              listItem3 = item;
              events.splice(index2, 0, ["enter", item, event[2]]);
              index2++;
              length++;
              firstBlankLineIndex = void 0;
              atMarker = true;
            }
          }
        }
        events[start][1]._spread = listSpread;
        return length;
      }
      function opener(create2, and) {
        return open;
        function open(token) {
          enter.call(this, create2(token), token);
          if (and)
            and.call(this, token);
        }
      }
      function buffer() {
        this.stack.push({
          type: "fragment",
          children: []
        });
      }
      function enter(node2, token, errorHandler) {
        const parent = this.stack[this.stack.length - 1];
        const siblings = parent.children;
        siblings.push(node2);
        this.stack.push(node2);
        this.tokenStack.push([token, errorHandler]);
        node2.position = {
          start: point(token.start),
          // @ts-expect-error: `end` will be patched later.
          end: void 0
        };
      }
      function closer(and) {
        return close;
        function close(token) {
          if (and)
            and.call(this, token);
          exit2.call(this, token);
        }
      }
      function exit2(token, onExitError) {
        const node2 = this.stack.pop();
        const open = this.tokenStack.pop();
        if (!open) {
          throw new Error(
            "Cannot close `" + token.type + "` (" + stringifyPosition({
              start: token.start,
              end: token.end
            }) + "): it’s not open"
          );
        } else if (open[0].type !== token.type) {
          if (onExitError) {
            onExitError.call(this, token, open[0]);
          } else {
            const handler = open[1] || defaultOnError;
            handler.call(this, token, open[0]);
          }
        }
        node2.position.end = point(token.end);
      }
      function resume() {
        return toString$3(this.stack.pop());
      }
      function onenterlistordered() {
        this.data.expectingFirstListItemValue = true;
      }
      function onenterlistitemvalue(token) {
        if (this.data.expectingFirstListItemValue) {
          const ancestor = this.stack[this.stack.length - 2];
          ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
          this.data.expectingFirstListItemValue = void 0;
        }
      }
      function onexitcodefencedfenceinfo() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.lang = data3;
      }
      function onexitcodefencedfencemeta() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.meta = data3;
      }
      function onexitcodefencedfence() {
        if (this.data.flowCodeInside)
          return;
        this.buffer();
        this.data.flowCodeInside = true;
      }
      function onexitcodefenced() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
        this.data.flowCodeInside = void 0;
      }
      function onexitcodeindented() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.value = data3.replace(/(\r?\n|\r)$/g, "");
      }
      function onexitdefinitionlabelstring(token) {
        const label = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.label = label;
        node2.identifier = normalizeIdentifier(
          this.sliceSerialize(token)
        ).toLowerCase();
      }
      function onexitdefinitiontitlestring() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.title = data3;
      }
      function onexitdefinitiondestinationstring() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.url = data3;
      }
      function onexitatxheadingsequence(token) {
        const node2 = this.stack[this.stack.length - 1];
        if (!node2.depth) {
          const depth = this.sliceSerialize(token).length;
          node2.depth = depth;
        }
      }
      function onexitsetextheadingtext() {
        this.data.setextHeadingSlurpLineEnding = true;
      }
      function onexitsetextheadinglinesequence(token) {
        const node2 = this.stack[this.stack.length - 1];
        node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
      }
      function onexitsetextheading() {
        this.data.setextHeadingSlurpLineEnding = void 0;
      }
      function onenterdata(token) {
        const node2 = this.stack[this.stack.length - 1];
        const siblings = node2.children;
        let tail = siblings[siblings.length - 1];
        if (!tail || tail.type !== "text") {
          tail = text2();
          tail.position = {
            start: point(token.start),
            // @ts-expect-error: we’ll add `end` later.
            end: void 0
          };
          siblings.push(tail);
        }
        this.stack.push(tail);
      }
      function onexitdata(token) {
        const tail = this.stack.pop();
        tail.value += this.sliceSerialize(token);
        tail.position.end = point(token.end);
      }
      function onexitlineending(token) {
        const context = this.stack[this.stack.length - 1];
        if (this.data.atHardBreak) {
          const tail = context.children[context.children.length - 1];
          tail.position.end = point(token.end);
          this.data.atHardBreak = void 0;
          return;
        }
        if (!this.data.setextHeadingSlurpLineEnding && config2.canContainEols.includes(context.type)) {
          onenterdata.call(this, token);
          onexitdata.call(this, token);
        }
      }
      function onexithardbreak() {
        this.data.atHardBreak = true;
      }
      function onexithtmlflow() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.value = data3;
      }
      function onexithtmltext() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.value = data3;
      }
      function onexitcodetext() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.value = data3;
      }
      function onexitlink() {
        const node2 = this.stack[this.stack.length - 1];
        if (this.data.inReference) {
          const referenceType = this.data.referenceType || "shortcut";
          node2.type += "Reference";
          node2.referenceType = referenceType;
          delete node2.url;
          delete node2.title;
        } else {
          delete node2.identifier;
          delete node2.label;
        }
        this.data.referenceType = void 0;
      }
      function onexitimage() {
        const node2 = this.stack[this.stack.length - 1];
        if (this.data.inReference) {
          const referenceType = this.data.referenceType || "shortcut";
          node2.type += "Reference";
          node2.referenceType = referenceType;
          delete node2.url;
          delete node2.title;
        } else {
          delete node2.identifier;
          delete node2.label;
        }
        this.data.referenceType = void 0;
      }
      function onexitlabeltext(token) {
        const string2 = this.sliceSerialize(token);
        const ancestor = this.stack[this.stack.length - 2];
        ancestor.label = decodeString(string2);
        ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
      }
      function onexitlabel() {
        const fragment = this.stack[this.stack.length - 1];
        const value = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        this.data.inReference = true;
        if (node2.type === "link") {
          const children = fragment.children;
          node2.children = children;
        } else {
          node2.alt = value;
        }
      }
      function onexitresourcedestinationstring() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.url = data3;
      }
      function onexitresourcetitlestring() {
        const data3 = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.title = data3;
      }
      function onexitresource() {
        this.data.inReference = void 0;
      }
      function onenterreference() {
        this.data.referenceType = "collapsed";
      }
      function onexitreferencestring(token) {
        const label = this.resume();
        const node2 = this.stack[this.stack.length - 1];
        node2.label = label;
        node2.identifier = normalizeIdentifier(
          this.sliceSerialize(token)
        ).toLowerCase();
        this.data.referenceType = "full";
      }
      function onexitcharacterreferencemarker(token) {
        this.data.characterReferenceType = token.type;
      }
      function onexitcharacterreferencevalue(token) {
        const data3 = this.sliceSerialize(token);
        const type = this.data.characterReferenceType;
        let value;
        if (type) {
          value = decodeNumericCharacterReference(
            data3,
            type === "characterReferenceMarkerNumeric" ? 10 : 16
          );
          this.data.characterReferenceType = void 0;
        } else {
          const result = decodeNamedCharacterReference(data3);
          value = result;
        }
        const tail = this.stack.pop();
        tail.value += value;
        tail.position.end = point(token.end);
      }
      function onexitautolinkprotocol(token) {
        onexitdata.call(this, token);
        const node2 = this.stack[this.stack.length - 1];
        node2.url = this.sliceSerialize(token);
      }
      function onexitautolinkemail(token) {
        onexitdata.call(this, token);
        const node2 = this.stack[this.stack.length - 1];
        node2.url = "mailto:" + this.sliceSerialize(token);
      }
      function blockQuote2() {
        return {
          type: "blockquote",
          children: []
        };
      }
      function codeFlow() {
        return {
          type: "code",
          lang: null,
          meta: null,
          value: ""
        };
      }
      function codeText2() {
        return {
          type: "inlineCode",
          value: ""
        };
      }
      function definition2() {
        return {
          type: "definition",
          identifier: "",
          label: null,
          title: null,
          url: ""
        };
      }
      function emphasis2() {
        return {
          type: "emphasis",
          children: []
        };
      }
      function heading2() {
        return {
          type: "heading",
          // @ts-expect-error `depth` will be set later.
          depth: 0,
          children: []
        };
      }
      function hardBreak2() {
        return {
          type: "break"
        };
      }
      function html2() {
        return {
          type: "html",
          value: ""
        };
      }
      function image2() {
        return {
          type: "image",
          title: null,
          url: "",
          alt: null
        };
      }
      function link2() {
        return {
          type: "link",
          title: null,
          url: "",
          children: []
        };
      }
      function list2(token) {
        return {
          type: "list",
          ordered: token.type === "listOrdered",
          start: null,
          spread: token._spread,
          children: []
        };
      }
      function listItem2(token) {
        return {
          type: "listItem",
          spread: token._spread,
          checked: null,
          children: []
        };
      }
      function paragraph2() {
        return {
          type: "paragraph",
          children: []
        };
      }
      function strong2() {
        return {
          type: "strong",
          children: []
        };
      }
      function text2() {
        return {
          type: "text",
          value: ""
        };
      }
      function thematicBreak2() {
        return {
          type: "thematicBreak"
        };
      }
    }
    function point(d) {
      return {
        line: d.line,
        column: d.column,
        offset: d.offset
      };
    }
    function configure(combined, extensions) {
      let index2 = -1;
      while (++index2 < extensions.length) {
        const value = extensions[index2];
        if (Array.isArray(value)) {
          configure(combined, value);
        } else {
          extension(combined, value);
        }
      }
    }
    function extension(combined, extension2) {
      let key;
      for (key in extension2) {
        if (own$6.call(extension2, key)) {
          switch (key) {
            case "canContainEols": {
              const right = extension2[key];
              if (right) {
                combined[key].push(...right);
              }
              break;
            }
            case "transforms": {
              const right = extension2[key];
              if (right) {
                combined[key].push(...right);
              }
              break;
            }
            case "enter":
            case "exit": {
              const right = extension2[key];
              if (right) {
                Object.assign(combined[key], right);
              }
              break;
            }
          }
        }
      }
    }
    function defaultOnError(left, right) {
      if (left) {
        throw new Error(
          "Cannot close `" + left.type + "` (" + stringifyPosition({
            start: left.start,
            end: left.end
          }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
            start: right.start,
            end: right.end
          }) + ") is open"
        );
      } else {
        throw new Error(
          "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
            start: right.start,
            end: right.end
          }) + ") is still open"
        );
      }
    }
    function remarkParse(options) {
      const self2 = this;
      self2.parser = parser;
      function parser(doc) {
        return fromMarkdown(doc, {
          ...self2.data("settings"),
          ...options,
          // Note: these options are not in the readme.
          // The goal is for them to be set by plugins on `data` instead of being
          // passed by users.
          extensions: self2.data("micromarkExtensions") || [],
          mdastExtensions: self2.data("fromMarkdownExtensions") || []
        });
      }
    }
    function blockquote$1(state, node2) {
      const result = {
        type: "element",
        tagName: "blockquote",
        properties: {},
        children: state.wrap(state.all(node2), true)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function hardBreak$1(state, node2) {
      const result = { type: "element", tagName: "br", properties: {}, children: [] };
      state.patch(node2, result);
      return [state.applyData(node2, result), { type: "text", value: "\n" }];
    }
    function code$2(state, node2) {
      const value = node2.value ? node2.value + "\n" : "";
      const properties = {};
      if (node2.lang) {
        properties.className = ["language-" + node2.lang];
      }
      let result = {
        type: "element",
        tagName: "code",
        properties,
        children: [{ type: "text", value }]
      };
      if (node2.meta) {
        result.data = { meta: node2.meta };
      }
      state.patch(node2, result);
      result = state.applyData(node2, result);
      result = { type: "element", tagName: "pre", properties: {}, children: [result] };
      state.patch(node2, result);
      return result;
    }
    function strikethrough(state, node2) {
      const result = {
        type: "element",
        tagName: "del",
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function emphasis$1(state, node2) {
      const result = {
        type: "element",
        tagName: "em",
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function footnoteReference$1(state, node2) {
      const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
      const id2 = String(node2.identifier).toUpperCase();
      const safeId = normalizeUri(id2.toLowerCase());
      const index2 = state.footnoteOrder.indexOf(id2);
      let counter;
      let reuseCounter = state.footnoteCounts.get(id2);
      if (reuseCounter === void 0) {
        reuseCounter = 0;
        state.footnoteOrder.push(id2);
        counter = state.footnoteOrder.length;
      } else {
        counter = index2 + 1;
      }
      reuseCounter += 1;
      state.footnoteCounts.set(id2, reuseCounter);
      const link2 = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fn-" + safeId,
          id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
          dataFootnoteRef: true,
          ariaDescribedBy: ["footnote-label"]
        },
        children: [{ type: "text", value: String(counter) }]
      };
      state.patch(node2, link2);
      const sup = {
        type: "element",
        tagName: "sup",
        properties: {},
        children: [link2]
      };
      state.patch(node2, sup);
      return state.applyData(node2, sup);
    }
    function heading$1(state, node2) {
      const result = {
        type: "element",
        tagName: "h" + node2.depth,
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function html$4(state, node2) {
      if (state.options.allowDangerousHtml) {
        const result = { type: "raw", value: node2.value };
        state.patch(node2, result);
        return state.applyData(node2, result);
      }
      return void 0;
    }
    function revert(state, node2) {
      const subtype = node2.referenceType;
      let suffix = "]";
      if (subtype === "collapsed") {
        suffix += "[]";
      } else if (subtype === "full") {
        suffix += "[" + (node2.label || node2.identifier) + "]";
      }
      if (node2.type === "imageReference") {
        return [{ type: "text", value: "![" + node2.alt + suffix }];
      }
      const contents = state.all(node2);
      const head = contents[0];
      if (head && head.type === "text") {
        head.value = "[" + head.value;
      } else {
        contents.unshift({ type: "text", value: "[" });
      }
      const tail = contents[contents.length - 1];
      if (tail && tail.type === "text") {
        tail.value += suffix;
      } else {
        contents.push({ type: "text", value: suffix });
      }
      return contents;
    }
    function imageReference$1(state, node2) {
      const id2 = String(node2.identifier).toUpperCase();
      const def = state.definitionById.get(id2);
      if (!def) {
        return revert(state, node2);
      }
      const properties = { src: normalizeUri(def.url || ""), alt: node2.alt };
      if (def.title !== null && def.title !== void 0) {
        properties.title = def.title;
      }
      const result = { type: "element", tagName: "img", properties, children: [] };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function image$1(state, node2) {
      const properties = { src: normalizeUri(node2.url) };
      if (node2.alt !== null && node2.alt !== void 0) {
        properties.alt = node2.alt;
      }
      if (node2.title !== null && node2.title !== void 0) {
        properties.title = node2.title;
      }
      const result = { type: "element", tagName: "img", properties, children: [] };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function inlineCode$1(state, node2) {
      const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
      state.patch(node2, text2);
      const result = {
        type: "element",
        tagName: "code",
        properties: {},
        children: [text2]
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function linkReference$1(state, node2) {
      const id2 = String(node2.identifier).toUpperCase();
      const def = state.definitionById.get(id2);
      if (!def) {
        return revert(state, node2);
      }
      const properties = { href: normalizeUri(def.url || "") };
      if (def.title !== null && def.title !== void 0) {
        properties.title = def.title;
      }
      const result = {
        type: "element",
        tagName: "a",
        properties,
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function link$1(state, node2) {
      const properties = { href: normalizeUri(node2.url) };
      if (node2.title !== null && node2.title !== void 0) {
        properties.title = node2.title;
      }
      const result = {
        type: "element",
        tagName: "a",
        properties,
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function listItem$1(state, node2, parent) {
      const results = state.all(node2);
      const loose = parent ? listLoose(parent) : listItemLoose(node2);
      const properties = {};
      const children = [];
      if (typeof node2.checked === "boolean") {
        const head = results[0];
        let paragraph2;
        if (head && head.type === "element" && head.tagName === "p") {
          paragraph2 = head;
        } else {
          paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
          results.unshift(paragraph2);
        }
        if (paragraph2.children.length > 0) {
          paragraph2.children.unshift({ type: "text", value: " " });
        }
        paragraph2.children.unshift({
          type: "element",
          tagName: "input",
          properties: { type: "checkbox", checked: node2.checked, disabled: true },
          children: []
        });
        properties.className = ["task-list-item"];
      }
      let index2 = -1;
      while (++index2 < results.length) {
        const child = results[index2];
        if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
          children.push({ type: "text", value: "\n" });
        }
        if (child.type === "element" && child.tagName === "p" && !loose) {
          children.push(...child.children);
        } else {
          children.push(child);
        }
      }
      const tail = results[results.length - 1];
      if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
        children.push({ type: "text", value: "\n" });
      }
      const result = { type: "element", tagName: "li", properties, children };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function listLoose(node2) {
      let loose = false;
      if (node2.type === "list") {
        loose = node2.spread || false;
        const children = node2.children;
        let index2 = -1;
        while (!loose && ++index2 < children.length) {
          loose = listItemLoose(children[index2]);
        }
      }
      return loose;
    }
    function listItemLoose(node2) {
      const spread = node2.spread;
      return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
    }
    function list$1(state, node2) {
      const properties = {};
      const results = state.all(node2);
      let index2 = -1;
      if (typeof node2.start === "number" && node2.start !== 1) {
        properties.start = node2.start;
      }
      while (++index2 < results.length) {
        const child = results[index2];
        if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
          properties.className = ["contains-task-list"];
          break;
        }
      }
      const result = {
        type: "element",
        tagName: node2.ordered ? "ol" : "ul",
        properties,
        children: state.wrap(results, true)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function paragraph$1(state, node2) {
      const result = {
        type: "element",
        tagName: "p",
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function root$3(state, node2) {
      const result = { type: "root", children: state.wrap(state.all(node2)) };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function strong$1(state, node2) {
      const result = {
        type: "element",
        tagName: "strong",
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function table(state, node2) {
      const rows = state.all(node2);
      const firstRow = rows.shift();
      const tableContent = [];
      if (firstRow) {
        const head = {
          type: "element",
          tagName: "thead",
          properties: {},
          children: state.wrap([firstRow], true)
        };
        state.patch(node2.children[0], head);
        tableContent.push(head);
      }
      if (rows.length > 0) {
        const body = {
          type: "element",
          tagName: "tbody",
          properties: {},
          children: state.wrap(rows, true)
        };
        const start = pointStart(node2.children[1]);
        const end = pointEnd(node2.children[node2.children.length - 1]);
        if (start && end)
          body.position = { start, end };
        tableContent.push(body);
      }
      const result = {
        type: "element",
        tagName: "table",
        properties: {},
        children: state.wrap(tableContent, true)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function tableRow(state, node2, parent) {
      const siblings = parent ? parent.children : void 0;
      const rowIndex = siblings ? siblings.indexOf(node2) : 1;
      const tagName = rowIndex === 0 ? "th" : "td";
      const align = parent && parent.type === "table" ? parent.align : void 0;
      const length = align ? align.length : node2.children.length;
      let cellIndex = -1;
      const cells = [];
      while (++cellIndex < length) {
        const cell = node2.children[cellIndex];
        const properties = {};
        const alignValue = align ? align[cellIndex] : void 0;
        if (alignValue) {
          properties.align = alignValue;
        }
        let result2 = { type: "element", tagName, properties, children: [] };
        if (cell) {
          result2.children = state.all(cell);
          state.patch(cell, result2);
          result2 = state.applyData(cell, result2);
        }
        cells.push(result2);
      }
      const result = {
        type: "element",
        tagName: "tr",
        properties: {},
        children: state.wrap(cells, true)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function tableCell(state, node2) {
      const result = {
        type: "element",
        tagName: "td",
        // Assume body cell.
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    const tab$1 = 9;
    const space$3 = 32;
    function trimLines(value) {
      const source = String(value);
      const search2 = /\r?\n|\r/g;
      let match = search2.exec(source);
      let last = 0;
      const lines = [];
      while (match) {
        lines.push(
          trimLine(source.slice(last, match.index), last > 0, true),
          match[0]
        );
        last = match.index + match[0].length;
        match = search2.exec(source);
      }
      lines.push(trimLine(source.slice(last), last > 0, false));
      return lines.join("");
    }
    function trimLine(value, start, end) {
      let startIndex = 0;
      let endIndex = value.length;
      if (start) {
        let code2 = value.codePointAt(startIndex);
        while (code2 === tab$1 || code2 === space$3) {
          startIndex++;
          code2 = value.codePointAt(startIndex);
        }
      }
      if (end) {
        let code2 = value.codePointAt(endIndex - 1);
        while (code2 === tab$1 || code2 === space$3) {
          endIndex--;
          code2 = value.codePointAt(endIndex - 1);
        }
      }
      return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
    }
    function text$2(state, node2) {
      const result = { type: "text", value: trimLines(String(node2.value)) };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function thematicBreak$1(state, node2) {
      const result = {
        type: "element",
        tagName: "hr",
        properties: {},
        children: []
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    const handlers = {
      blockquote: blockquote$1,
      break: hardBreak$1,
      code: code$2,
      delete: strikethrough,
      emphasis: emphasis$1,
      footnoteReference: footnoteReference$1,
      heading: heading$1,
      html: html$4,
      imageReference: imageReference$1,
      image: image$1,
      inlineCode: inlineCode$1,
      linkReference: linkReference$1,
      link: link$1,
      listItem: listItem$1,
      list: list$1,
      paragraph: paragraph$1,
      // @ts-expect-error: root is different, but hard to type.
      root: root$3,
      strong: strong$1,
      table,
      tableCell,
      tableRow,
      text: text$2,
      thematicBreak: thematicBreak$1,
      toml: ignore,
      yaml: ignore,
      definition: ignore,
      footnoteDefinition: ignore
    };
    function ignore() {
      return void 0;
    }
    const VOID = -1;
    const PRIMITIVE = 0;
    const ARRAY = 1;
    const OBJECT = 2;
    const DATE = 3;
    const REGEXP = 4;
    const MAP = 5;
    const SET = 6;
    const ERROR = 7;
    const BIGINT = 8;
    const env = typeof self === "object" ? self : globalThis;
    const deserializer = ($, _) => {
      const as = (out, index2) => {
        $.set(index2, out);
        return out;
      };
      const unpair = (index2) => {
        if ($.has(index2))
          return $.get(index2);
        const [type, value] = _[index2];
        switch (type) {
          case PRIMITIVE:
          case VOID:
            return as(value, index2);
          case ARRAY: {
            const arr = as([], index2);
            for (const index3 of value)
              arr.push(unpair(index3));
            return arr;
          }
          case OBJECT: {
            const object = as({}, index2);
            for (const [key, index3] of value)
              object[unpair(key)] = unpair(index3);
            return object;
          }
          case DATE:
            return as(new Date(value), index2);
          case REGEXP: {
            const { source, flags } = value;
            return as(new RegExp(source, flags), index2);
          }
          case MAP: {
            const map2 = as(/* @__PURE__ */ new Map(), index2);
            for (const [key, index3] of value)
              map2.set(unpair(key), unpair(index3));
            return map2;
          }
          case SET: {
            const set = as(/* @__PURE__ */ new Set(), index2);
            for (const index3 of value)
              set.add(unpair(index3));
            return set;
          }
          case ERROR: {
            const { name: name2, message } = value;
            return as(new env[name2](message), index2);
          }
          case BIGINT:
            return as(BigInt(value), index2);
          case "BigInt":
            return as(Object(BigInt(value)), index2);
        }
        return as(new env[type](value), index2);
      };
      return unpair;
    };
    const deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
    const EMPTY = "";
    const { toString: toString$2 } = {};
    const { keys: keys$1 } = Object;
    const typeOf = (value) => {
      const type = typeof value;
      if (type !== "object" || !value)
        return [PRIMITIVE, type];
      const asString = toString$2.call(value).slice(8, -1);
      switch (asString) {
        case "Array":
          return [ARRAY, EMPTY];
        case "Object":
          return [OBJECT, EMPTY];
        case "Date":
          return [DATE, EMPTY];
        case "RegExp":
          return [REGEXP, EMPTY];
        case "Map":
          return [MAP, EMPTY];
        case "Set":
          return [SET, EMPTY];
      }
      if (asString.includes("Array"))
        return [ARRAY, asString];
      if (asString.includes("Error"))
        return [ERROR, asString];
      return [OBJECT, asString];
    };
    const shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
    const serializer = (strict, json, $, _) => {
      const as = (out, value) => {
        const index2 = _.push(out) - 1;
        $.set(value, index2);
        return index2;
      };
      const pair = (value) => {
        if ($.has(value))
          return $.get(value);
        let [TYPE, type] = typeOf(value);
        switch (TYPE) {
          case PRIMITIVE: {
            let entry = value;
            switch (type) {
              case "bigint":
                TYPE = BIGINT;
                entry = value.toString();
                break;
              case "function":
              case "symbol":
                if (strict)
                  throw new TypeError("unable to serialize " + type);
                entry = null;
                break;
              case "undefined":
                return as([VOID], value);
            }
            return as([TYPE, entry], value);
          }
          case ARRAY: {
            if (type)
              return as([type, [...value]], value);
            const arr = [];
            const index2 = as([TYPE, arr], value);
            for (const entry of value)
              arr.push(pair(entry));
            return index2;
          }
          case OBJECT: {
            if (type) {
              switch (type) {
                case "BigInt":
                  return as([type, value.toString()], value);
                case "Boolean":
                case "Number":
                case "String":
                  return as([type, value.valueOf()], value);
              }
            }
            if (json && "toJSON" in value)
              return pair(value.toJSON());
            const entries = [];
            const index2 = as([TYPE, entries], value);
            for (const key of keys$1(value)) {
              if (strict || !shouldSkip(typeOf(value[key])))
                entries.push([pair(key), pair(value[key])]);
            }
            return index2;
          }
          case DATE:
            return as([TYPE, value.toISOString()], value);
          case REGEXP: {
            const { source, flags } = value;
            return as([TYPE, { source, flags }], value);
          }
          case MAP: {
            const entries = [];
            const index2 = as([TYPE, entries], value);
            for (const [key, entry] of value) {
              if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
                entries.push([pair(key), pair(entry)]);
            }
            return index2;
          }
          case SET: {
            const entries = [];
            const index2 = as([TYPE, entries], value);
            for (const entry of value) {
              if (strict || !shouldSkip(typeOf(entry)))
                entries.push(pair(entry));
            }
            return index2;
          }
        }
        const { message } = value;
        return as([TYPE, { name: type, message }], value);
      };
      return pair;
    };
    const serialize$1 = (value, { json, lossy } = {}) => {
      const _ = [];
      return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
    };
    const structuredClone$1 = typeof structuredClone === "function" ? (
      /* c8 ignore start */
      (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize$1(any, options)) : structuredClone(any)
    ) : (any, options) => deserialize(serialize$1(any, options));
    function defaultFootnoteBackContent(_, rereferenceIndex) {
      const result = [{ type: "text", value: "↩" }];
      if (rereferenceIndex > 1) {
        result.push({
          type: "element",
          tagName: "sup",
          properties: {},
          children: [{ type: "text", value: String(rereferenceIndex) }]
        });
      }
      return result;
    }
    function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
      return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
    }
    function footer(state) {
      const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
      const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
      const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
      const footnoteLabel = state.options.footnoteLabel || "Footnotes";
      const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
      const footnoteLabelProperties = state.options.footnoteLabelProperties || {
        className: ["sr-only"]
      };
      const listItems = [];
      let referenceIndex = -1;
      while (++referenceIndex < state.footnoteOrder.length) {
        const def = state.footnoteById.get(state.footnoteOrder[referenceIndex]);
        if (!def) {
          continue;
        }
        const content2 = state.all(def);
        const id2 = String(def.identifier).toUpperCase();
        const safeId = normalizeUri(id2.toLowerCase());
        let rereferenceIndex = 0;
        const backReferences = [];
        const counts = state.footnoteCounts.get(id2);
        while (counts !== void 0 && ++rereferenceIndex <= counts) {
          if (backReferences.length > 0) {
            backReferences.push({ type: "text", value: " " });
          }
          let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
          if (typeof children === "string") {
            children = { type: "text", value: children };
          }
          backReferences.push({
            type: "element",
            tagName: "a",
            properties: {
              href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
              dataFootnoteBackref: "",
              ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
              className: ["data-footnote-backref"]
            },
            children: Array.isArray(children) ? children : [children]
          });
        }
        const tail = content2[content2.length - 1];
        if (tail && tail.type === "element" && tail.tagName === "p") {
          const tailTail = tail.children[tail.children.length - 1];
          if (tailTail && tailTail.type === "text") {
            tailTail.value += " ";
          } else {
            tail.children.push({ type: "text", value: " " });
          }
          tail.children.push(...backReferences);
        } else {
          content2.push(...backReferences);
        }
        const listItem2 = {
          type: "element",
          tagName: "li",
          properties: { id: clobberPrefix + "fn-" + safeId },
          children: state.wrap(content2, true)
        };
        state.patch(def, listItem2);
        listItems.push(listItem2);
      }
      if (listItems.length === 0) {
        return;
      }
      return {
        type: "element",
        tagName: "section",
        properties: { dataFootnotes: true, className: ["footnotes"] },
        children: [
          {
            type: "element",
            tagName: footnoteLabelTagName,
            properties: {
              ...structuredClone$1(footnoteLabelProperties),
              id: "footnote-label"
            },
            children: [{ type: "text", value: footnoteLabel }]
          },
          { type: "text", value: "\n" },
          {
            type: "element",
            tagName: "ol",
            properties: {},
            children: state.wrap(listItems, true)
          },
          { type: "text", value: "\n" }
        ]
      };
    }
    const convert = (
      // Note: overloads in JSDoc can’t yet use different `@template`s.
      /**
       * @type {(
       *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
       *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
       *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
       *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
       *   ((test?: Test) => Check)
       * )}
       */
      /**
       * @param {Test} [test]
       * @returns {Check}
       */
      function(test) {
        if (test === null || test === void 0) {
          return ok;
        }
        if (typeof test === "function") {
          return castFactory(test);
        }
        if (typeof test === "object") {
          return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
        }
        if (typeof test === "string") {
          return typeFactory(test);
        }
        throw new Error("Expected function, string, or object as test");
      }
    );
    function anyFactory(tests2) {
      const checks2 = [];
      let index2 = -1;
      while (++index2 < tests2.length) {
        checks2[index2] = convert(tests2[index2]);
      }
      return castFactory(any);
      function any(...parameters) {
        let index3 = -1;
        while (++index3 < checks2.length) {
          if (checks2[index3].apply(this, parameters))
            return true;
        }
        return false;
      }
    }
    function propsFactory(check) {
      const checkAsRecord = (
        /** @type {Record<string, unknown>} */
        check
      );
      return castFactory(all2);
      function all2(node2) {
        const nodeAsRecord = (
          /** @type {Record<string, unknown>} */
          /** @type {unknown} */
          node2
        );
        let key;
        for (key in check) {
          if (nodeAsRecord[key] !== checkAsRecord[key])
            return false;
        }
        return true;
      }
    }
    function typeFactory(check) {
      return castFactory(type);
      function type(node2) {
        return node2 && node2.type === check;
      }
    }
    function castFactory(testFunction) {
      return check;
      function check(value, index2, parent) {
        return Boolean(
          looksLikeANode(value) && testFunction.call(
            this,
            value,
            typeof index2 === "number" ? index2 : void 0,
            parent || void 0
          )
        );
      }
    }
    function ok() {
      return true;
    }
    function looksLikeANode(value) {
      return value !== null && typeof value === "object" && "type" in value;
    }
    function color(d) {
      return d;
    }
    const empty$2 = [];
    const CONTINUE = true;
    const EXIT = false;
    const SKIP = "skip";
    function visitParents(tree, test, visitor, reverse) {
      let check;
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
      } else {
        check = test;
      }
      const is = convert(check);
      const step = reverse ? -1 : 1;
      factory2(tree, void 0, [])();
      function factory2(node2, index2, parents) {
        const value = (
          /** @type {Record<string, unknown>} */
          node2 && typeof node2 === "object" ? node2 : {}
        );
        if (typeof value.type === "string") {
          const name2 = (
            // `hast`
            typeof value.tagName === "string" ? value.tagName : (
              // `xast`
              typeof value.name === "string" ? value.name : void 0
            )
          );
          Object.defineProperty(visit2, "name", {
            value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
          });
        }
        return visit2;
        function visit2() {
          let result = empty$2;
          let subresult;
          let offset;
          let grandparents;
          if (!test || is(node2, index2, parents[parents.length - 1] || void 0)) {
            result = toResult(visitor(node2, parents));
            if (result[0] === EXIT) {
              return result;
            }
          }
          if ("children" in node2 && node2.children) {
            const nodeAsParent = (
              /** @type {UnistParent} */
              node2
            );
            if (nodeAsParent.children && result[0] !== SKIP) {
              offset = (reverse ? nodeAsParent.children.length : -1) + step;
              grandparents = parents.concat(nodeAsParent);
              while (offset > -1 && offset < nodeAsParent.children.length) {
                const child = nodeAsParent.children[offset];
                subresult = factory2(child, offset, grandparents)();
                if (subresult[0] === EXIT) {
                  return subresult;
                }
                offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
              }
            }
          }
          return result;
        }
      }
    }
    function toResult(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "number") {
        return [CONTINUE, value];
      }
      return value === null || value === void 0 ? empty$2 : [value];
    }
    function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
      let reverse;
      let test;
      let visitor;
      if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
        test = void 0;
        visitor = testOrVisitor;
        reverse = visitorOrReverse;
      } else {
        test = testOrVisitor;
        visitor = visitorOrReverse;
        reverse = maybeReverse;
      }
      visitParents(tree, test, overload, reverse);
      function overload(node2, parents) {
        const parent = parents[parents.length - 1];
        const index2 = parent ? parent.children.indexOf(node2) : void 0;
        return visitor(node2, index2, parent);
      }
    }
    const own$5 = {}.hasOwnProperty;
    const emptyOptions$1 = {};
    function createState(tree, options) {
      const settings = options || emptyOptions$1;
      const definitionById = /* @__PURE__ */ new Map();
      const footnoteById = /* @__PURE__ */ new Map();
      const footnoteCounts = /* @__PURE__ */ new Map();
      const handlers$1 = { ...handlers, ...settings.handlers };
      const state = {
        all: all2,
        applyData,
        definitionById,
        footnoteById,
        footnoteCounts,
        footnoteOrder: [],
        handlers: handlers$1,
        one: one2,
        options: settings,
        patch,
        wrap: wrap$1
      };
      visit(tree, function(node2) {
        if (node2.type === "definition" || node2.type === "footnoteDefinition") {
          const map2 = node2.type === "definition" ? definitionById : footnoteById;
          const id2 = String(node2.identifier).toUpperCase();
          if (!map2.has(id2)) {
            map2.set(id2, node2);
          }
        }
      });
      return state;
      function one2(node2, parent) {
        const type = node2.type;
        const handle2 = state.handlers[type];
        if (own$5.call(state.handlers, type) && handle2) {
          return handle2(state, node2, parent);
        }
        if (state.options.passThrough && state.options.passThrough.includes(type)) {
          if ("children" in node2) {
            const { children, ...shallow } = node2;
            const result = structuredClone$1(shallow);
            result.children = state.all(node2);
            return result;
          }
          return structuredClone$1(node2);
        }
        const unknown = state.options.unknownHandler || defaultUnknownHandler;
        return unknown(state, node2, parent);
      }
      function all2(parent) {
        const values = [];
        if ("children" in parent) {
          const nodes = parent.children;
          let index2 = -1;
          while (++index2 < nodes.length) {
            const result = state.one(nodes[index2], parent);
            if (result) {
              if (index2 && nodes[index2 - 1].type === "break") {
                if (!Array.isArray(result) && result.type === "text") {
                  result.value = trimMarkdownSpaceStart(result.value);
                }
                if (!Array.isArray(result) && result.type === "element") {
                  const head = result.children[0];
                  if (head && head.type === "text") {
                    head.value = trimMarkdownSpaceStart(head.value);
                  }
                }
              }
              if (Array.isArray(result)) {
                values.push(...result);
              } else {
                values.push(result);
              }
            }
          }
        }
        return values;
      }
    }
    function patch(from, to) {
      if (from.position)
        to.position = position$1(from);
    }
    function applyData(from, to) {
      let result = to;
      if (from && from.data) {
        const hName = from.data.hName;
        const hChildren = from.data.hChildren;
        const hProperties = from.data.hProperties;
        if (typeof hName === "string") {
          if (result.type === "element") {
            result.tagName = hName;
          } else {
            const children = "children" in result ? result.children : [result];
            result = { type: "element", tagName: hName, properties: {}, children };
          }
        }
        if (result.type === "element" && hProperties) {
          Object.assign(result.properties, structuredClone$1(hProperties));
        }
        if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
          result.children = hChildren;
        }
      }
      return result;
    }
    function defaultUnknownHandler(state, node2) {
      const data2 = node2.data || {};
      const result = "value" in node2 && !(own$5.call(data2, "hProperties") || own$5.call(data2, "hChildren")) ? { type: "text", value: node2.value } : {
        type: "element",
        tagName: "div",
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function wrap$1(nodes, loose) {
      const result = [];
      let index2 = -1;
      if (loose) {
        result.push({ type: "text", value: "\n" });
      }
      while (++index2 < nodes.length) {
        if (index2)
          result.push({ type: "text", value: "\n" });
        result.push(nodes[index2]);
      }
      if (loose && nodes.length > 0) {
        result.push({ type: "text", value: "\n" });
      }
      return result;
    }
    function trimMarkdownSpaceStart(value) {
      let index2 = 0;
      let code2 = value.charCodeAt(index2);
      while (code2 === 9 || code2 === 32) {
        index2++;
        code2 = value.charCodeAt(index2);
      }
      return value.slice(index2);
    }
    function toHast(tree, options) {
      const state = createState(tree, options);
      const node2 = state.one(tree, void 0);
      const foot = footer(state);
      const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
      if (foot) {
        result.children.push({ type: "text", value: "\n" }, foot);
      }
      return result;
    }
    function remarkRehype(destination, options) {
      if (destination && "run" in destination) {
        return async function(tree, file) {
          const hastTree = (
            /** @type {HastRoot} */
            toHast(tree, options)
          );
          await destination.run(hastTree, file);
        };
      }
      return function(tree) {
        return (
          /** @type {HastRoot} */
          toHast(tree, options || destination)
        );
      };
    }
    function bail(error) {
      if (error) {
        throw error;
      }
    }
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty$2 = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray$2 = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject$2 = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty$2 && options.name === "__proto__") {
        defineProperty$2(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name2) {
      if (name2 === "__proto__") {
        if (!hasOwn.call(obj, name2)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name2).value;
        }
      }
      return obj[name2];
    };
    var extend$1 = function extend2() {
      var options, name2, src, copy2, copyIsArray, clone2;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name2 in options) {
            src = getProperty(target, name2);
            copy2 = getProperty(options, name2);
            if (target !== copy2) {
              if (deep && copy2 && (isPlainObject$2(copy2) || (copyIsArray = isArray$2(copy2)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray$2(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject$2(src) ? src : {};
                }
                setProperty(target, { name: name2, newValue: extend2(deep, clone2, copy2) });
              } else if (typeof copy2 !== "undefined") {
                setProperty(target, { name: name2, newValue: copy2 });
              }
            }
          }
        }
      }
      return target;
    };
    function isPlainObject$1(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
    }
    function trough() {
      const fns = [];
      const pipeline = { run, use };
      return pipeline;
      function run(...values) {
        let middlewareIndex = -1;
        const callback = values.pop();
        if (typeof callback !== "function") {
          throw new TypeError("Expected function as last argument, not " + callback);
        }
        next(null, ...values);
        function next(error, ...output) {
          const fn = fns[++middlewareIndex];
          let index2 = -1;
          if (error) {
            callback(error);
            return;
          }
          while (++index2 < values.length) {
            if (output[index2] === null || output[index2] === void 0) {
              output[index2] = values[index2];
            }
          }
          values = output;
          if (fn) {
            wrap(fn, next)(...output);
          } else {
            callback(null, ...output);
          }
        }
      }
      function use(middelware) {
        if (typeof middelware !== "function") {
          throw new TypeError(
            "Expected `middelware` to be a function, not " + middelware
          );
        }
        fns.push(middelware);
        return pipeline;
      }
    }
    function wrap(middleware, callback) {
      let called;
      return wrapped;
      function wrapped(...parameters) {
        const fnExpectsCallback = middleware.length > parameters.length;
        let result;
        if (fnExpectsCallback) {
          parameters.push(done);
        }
        try {
          result = middleware.apply(this, parameters);
        } catch (error) {
          const exception = (
            /** @type {Error} */
            error
          );
          if (fnExpectsCallback && called) {
            throw exception;
          }
          return done(exception);
        }
        if (!fnExpectsCallback) {
          if (result instanceof Promise) {
            result.then(then, done);
          } else if (result instanceof Error) {
            done(result);
          } else {
            then(result);
          }
        }
      }
      function done(error, ...output) {
        if (!called) {
          called = true;
          callback(error, ...output);
        }
      }
      function then(value) {
        done(null, value);
      }
    }
    const path$1 = { basename, dirname, extname, join, sep: "/" };
    function basename(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
      }
      assertPath$1(path2);
      let start = 0;
      let end = -1;
      let index2 = path2.length;
      let seenNonSlash;
      if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
        while (index2--) {
          if (path2.codePointAt(index2) === 47) {
            if (seenNonSlash) {
              start = index2 + 1;
              break;
            }
          } else if (end < 0) {
            seenNonSlash = true;
            end = index2 + 1;
          }
        }
        return end < 0 ? "" : path2.slice(start, end);
      }
      if (ext === path2) {
        return "";
      }
      let firstNonSlashEnd = -1;
      let extIndex = ext.length - 1;
      while (index2--) {
        if (path2.codePointAt(index2) === 47) {
          if (seenNonSlash) {
            start = index2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd < 0) {
            seenNonSlash = true;
            firstNonSlashEnd = index2 + 1;
          }
          if (extIndex > -1) {
            if (path2.codePointAt(index2) === ext.codePointAt(extIndex--)) {
              if (extIndex < 0) {
                end = index2;
              }
            } else {
              extIndex = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end < 0) {
        end = path2.length;
      }
      return path2.slice(start, end);
    }
    function dirname(path2) {
      assertPath$1(path2);
      if (path2.length === 0) {
        return ".";
      }
      let end = -1;
      let index2 = path2.length;
      let unmatchedSlash;
      while (--index2) {
        if (path2.codePointAt(index2) === 47) {
          if (unmatchedSlash) {
            end = index2;
            break;
          }
        } else if (!unmatchedSlash) {
          unmatchedSlash = true;
        }
      }
      return end < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end);
    }
    function extname(path2) {
      assertPath$1(path2);
      let index2 = path2.length;
      let end = -1;
      let startPart = 0;
      let startDot = -1;
      let preDotState = 0;
      let unmatchedSlash;
      while (index2--) {
        const code2 = path2.codePointAt(index2);
        if (code2 === 47) {
          if (unmatchedSlash) {
            startPart = index2 + 1;
            break;
          }
          continue;
        }
        if (end < 0) {
          unmatchedSlash = true;
          end = index2 + 1;
        }
        if (code2 === 46) {
          if (startDot < 0) {
            startDot = index2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot > -1) {
          preDotState = -1;
        }
      }
      if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
      preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    }
    function join(...segments) {
      let index2 = -1;
      let joined;
      while (++index2 < segments.length) {
        assertPath$1(segments[index2]);
        if (segments[index2]) {
          joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
        }
      }
      return joined === void 0 ? "." : normalize$4(joined);
    }
    function normalize$4(path2) {
      assertPath$1(path2);
      const absolute = path2.codePointAt(0) === 47;
      let value = normalizeString(path2, !absolute);
      if (value.length === 0 && !absolute) {
        value = ".";
      }
      if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
        value += "/";
      }
      return absolute ? "/" + value : value;
    }
    function normalizeString(path2, allowAboveRoot) {
      let result = "";
      let lastSegmentLength = 0;
      let lastSlash = -1;
      let dots = 0;
      let index2 = -1;
      let code2;
      let lastSlashIndex;
      while (++index2 <= path2.length) {
        if (index2 < path2.length) {
          code2 = path2.codePointAt(index2);
        } else if (code2 === 47) {
          break;
        } else {
          code2 = 47;
        }
        if (code2 === 47) {
          if (lastSlash === index2 - 1 || dots === 1)
            ;
          else if (lastSlash !== index2 - 1 && dots === 2) {
            if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
              if (result.length > 2) {
                lastSlashIndex = result.lastIndexOf("/");
                if (lastSlashIndex !== result.length - 1) {
                  if (lastSlashIndex < 0) {
                    result = "";
                    lastSegmentLength = 0;
                  } else {
                    result = result.slice(0, lastSlashIndex);
                    lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                  }
                  lastSlash = index2;
                  dots = 0;
                  continue;
                }
              } else if (result.length > 0) {
                result = "";
                lastSegmentLength = 0;
                lastSlash = index2;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              result = result.length > 0 ? result + "/.." : "..";
              lastSegmentLength = 2;
            }
          } else {
            if (result.length > 0) {
              result += "/" + path2.slice(lastSlash + 1, index2);
            } else {
              result = path2.slice(lastSlash + 1, index2);
            }
            lastSegmentLength = index2 - lastSlash - 1;
          }
          lastSlash = index2;
          dots = 0;
        } else if (code2 === 46 && dots > -1) {
          dots++;
        } else {
          dots = -1;
        }
      }
      return result;
    }
    function assertPath$1(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError(
          "Path must be a string. Received " + JSON.stringify(path2)
        );
      }
    }
    const proc = { cwd };
    function cwd() {
      return "/";
    }
    function isUrl(fileUrlOrPath) {
      return Boolean(
        fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
        fileUrlOrPath.auth === void 0
      );
    }
    function urlToPath(path2) {
      if (typeof path2 === "string") {
        path2 = new URL(path2);
      } else if (!isUrl(path2)) {
        const error = new TypeError(
          'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
        );
        error.code = "ERR_INVALID_ARG_TYPE";
        throw error;
      }
      if (path2.protocol !== "file:") {
        const error = new TypeError("The URL must be of scheme file");
        error.code = "ERR_INVALID_URL_SCHEME";
        throw error;
      }
      return getPathFromURLPosix(path2);
    }
    function getPathFromURLPosix(url) {
      if (url.hostname !== "") {
        const error = new TypeError(
          'File URL host must be "localhost" or empty on darwin'
        );
        error.code = "ERR_INVALID_FILE_URL_HOST";
        throw error;
      }
      const pathname = url.pathname;
      let index2 = -1;
      while (++index2 < pathname.length) {
        if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
          const third = pathname.codePointAt(index2 + 2);
          if (third === 70 || third === 102) {
            const error = new TypeError(
              "File URL path must not include encoded / characters"
            );
            error.code = "ERR_INVALID_FILE_URL_PATH";
            throw error;
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    const order = (
      /** @type {const} */
      [
        "history",
        "path",
        "basename",
        "stem",
        "extname",
        "dirname"
      ]
    );
    class VFile {
      /**
       * Create a new virtual file.
       *
       * `options` is treated as:
       *
       * *   `string` or `Uint8Array` — `{value: options}`
       * *   `URL` — `{path: options}`
       * *   `VFile` — shallow copies its data over to the new file
       * *   `object` — all fields are shallow copied over to the new file
       *
       * Path related fields are set in the following order (least specific to
       * most specific): `history`, `path`, `basename`, `stem`, `extname`,
       * `dirname`.
       *
       * You cannot set `dirname` or `extname` without setting either `history`,
       * `path`, `basename`, or `stem` too.
       *
       * @param {Compatible | null | undefined} [value]
       *   File value.
       * @returns
       *   New instance.
       */
      constructor(value) {
        let options;
        if (!value) {
          options = {};
        } else if (isUrl(value)) {
          options = { path: value };
        } else if (typeof value === "string" || isUint8Array$1(value)) {
          options = { value };
        } else {
          options = value;
        }
        this.cwd = proc.cwd();
        this.data = {};
        this.history = [];
        this.messages = [];
        this.value;
        this.map;
        this.result;
        this.stored;
        let index2 = -1;
        while (++index2 < order.length) {
          const prop2 = order[index2];
          if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
            this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
          }
        }
        let prop;
        for (prop in options) {
          if (!order.includes(prop)) {
            this[prop] = options[prop];
          }
        }
      }
      /**
       * Get the basename (including extname) (example: `'index.min.js'`).
       *
       * @returns {string | undefined}
       *   Basename.
       */
      get basename() {
        return typeof this.path === "string" ? path$1.basename(this.path) : void 0;
      }
      /**
       * Set basename (including extname) (`'index.min.js'`).
       *
       * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
       * on windows).
       * Cannot be nullified (use `file.path = file.dirname` instead).
       *
       * @param {string} basename
       *   Basename.
       * @returns {undefined}
       *   Nothing.
       */
      set basename(basename2) {
        assertNonEmpty(basename2, "basename");
        assertPart(basename2, "basename");
        this.path = path$1.join(this.dirname || "", basename2);
      }
      /**
       * Get the parent path (example: `'~'`).
       *
       * @returns {string | undefined}
       *   Dirname.
       */
      get dirname() {
        return typeof this.path === "string" ? path$1.dirname(this.path) : void 0;
      }
      /**
       * Set the parent path (example: `'~'`).
       *
       * Cannot be set if there’s no `path` yet.
       *
       * @param {string | undefined} dirname
       *   Dirname.
       * @returns {undefined}
       *   Nothing.
       */
      set dirname(dirname2) {
        assertPath(this.basename, "dirname");
        this.path = path$1.join(dirname2 || "", this.basename);
      }
      /**
       * Get the extname (including dot) (example: `'.js'`).
       *
       * @returns {string | undefined}
       *   Extname.
       */
      get extname() {
        return typeof this.path === "string" ? path$1.extname(this.path) : void 0;
      }
      /**
       * Set the extname (including dot) (example: `'.js'`).
       *
       * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
       * on windows).
       * Cannot be set if there’s no `path` yet.
       *
       * @param {string | undefined} extname
       *   Extname.
       * @returns {undefined}
       *   Nothing.
       */
      set extname(extname2) {
        assertPart(extname2, "extname");
        assertPath(this.dirname, "extname");
        if (extname2) {
          if (extname2.codePointAt(0) !== 46) {
            throw new Error("`extname` must start with `.`");
          }
          if (extname2.includes(".", 1)) {
            throw new Error("`extname` cannot contain multiple dots");
          }
        }
        this.path = path$1.join(this.dirname, this.stem + (extname2 || ""));
      }
      /**
       * Get the full path (example: `'~/index.min.js'`).
       *
       * @returns {string}
       *   Path.
       */
      get path() {
        return this.history[this.history.length - 1];
      }
      /**
       * Set the full path (example: `'~/index.min.js'`).
       *
       * Cannot be nullified.
       * You can set a file URL (a `URL` object with a `file:` protocol) which will
       * be turned into a path with `url.fileURLToPath`.
       *
       * @param {URL | string} path
       *   Path.
       * @returns {undefined}
       *   Nothing.
       */
      set path(path2) {
        if (isUrl(path2)) {
          path2 = urlToPath(path2);
        }
        assertNonEmpty(path2, "path");
        if (this.path !== path2) {
          this.history.push(path2);
        }
      }
      /**
       * Get the stem (basename w/o extname) (example: `'index.min'`).
       *
       * @returns {string | undefined}
       *   Stem.
       */
      get stem() {
        return typeof this.path === "string" ? path$1.basename(this.path, this.extname) : void 0;
      }
      /**
       * Set the stem (basename w/o extname) (example: `'index.min'`).
       *
       * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
       * on windows).
       * Cannot be nullified (use `file.path = file.dirname` instead).
       *
       * @param {string} stem
       *   Stem.
       * @returns {undefined}
       *   Nothing.
       */
      set stem(stem) {
        assertNonEmpty(stem, "stem");
        assertPart(stem, "stem");
        this.path = path$1.join(this.dirname || "", stem + (this.extname || ""));
      }
      // Normal prototypal methods.
      /**
       * Create a fatal message for `reason` associated with the file.
       *
       * The `fatal` field of the message is set to `true` (error; file not usable)
       * and the `file` field is set to the current file path.
       * The message is added to the `messages` field on `file`.
       *
       * > 🪦 **Note**: also has obsolete signatures.
       *
       * @overload
       * @param {string} reason
       * @param {MessageOptions | null | undefined} [options]
       * @returns {never}
       *
       * @overload
       * @param {string} reason
       * @param {Node | NodeLike | null | undefined} parent
       * @param {string | null | undefined} [origin]
       * @returns {never}
       *
       * @overload
       * @param {string} reason
       * @param {Point | Position | null | undefined} place
       * @param {string | null | undefined} [origin]
       * @returns {never}
       *
       * @overload
       * @param {string} reason
       * @param {string | null | undefined} [origin]
       * @returns {never}
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {Node | NodeLike | null | undefined} parent
       * @param {string | null | undefined} [origin]
       * @returns {never}
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {Point | Position | null | undefined} place
       * @param {string | null | undefined} [origin]
       * @returns {never}
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {string | null | undefined} [origin]
       * @returns {never}
       *
       * @param {Error | VFileMessage | string} causeOrReason
       *   Reason for message, should use markdown.
       * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
       *   Configuration (optional).
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns {never}
       *   Never.
       * @throws {VFileMessage}
       *   Message.
       */
      fail(causeOrReason, optionsOrParentOrPlace, origin) {
        const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
        message.fatal = true;
        throw message;
      }
      /**
       * Create an info message for `reason` associated with the file.
       *
       * The `fatal` field of the message is set to `undefined` (info; change
       * likely not needed) and the `file` field is set to the current file path.
       * The message is added to the `messages` field on `file`.
       *
       * > 🪦 **Note**: also has obsolete signatures.
       *
       * @overload
       * @param {string} reason
       * @param {MessageOptions | null | undefined} [options]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {string} reason
       * @param {Node | NodeLike | null | undefined} parent
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {string} reason
       * @param {Point | Position | null | undefined} place
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {string} reason
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {Node | NodeLike | null | undefined} parent
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {Point | Position | null | undefined} place
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @param {Error | VFileMessage | string} causeOrReason
       *   Reason for message, should use markdown.
       * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
       *   Configuration (optional).
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns {VFileMessage}
       *   Message.
       */
      info(causeOrReason, optionsOrParentOrPlace, origin) {
        const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
        message.fatal = void 0;
        return message;
      }
      /**
       * Create a message for `reason` associated with the file.
       *
       * The `fatal` field of the message is set to `false` (warning; change may be
       * needed) and the `file` field is set to the current file path.
       * The message is added to the `messages` field on `file`.
       *
       * > 🪦 **Note**: also has obsolete signatures.
       *
       * @overload
       * @param {string} reason
       * @param {MessageOptions | null | undefined} [options]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {string} reason
       * @param {Node | NodeLike | null | undefined} parent
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {string} reason
       * @param {Point | Position | null | undefined} place
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {string} reason
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {Node | NodeLike | null | undefined} parent
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {Point | Position | null | undefined} place
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @overload
       * @param {Error | VFileMessage} cause
       * @param {string | null | undefined} [origin]
       * @returns {VFileMessage}
       *
       * @param {Error | VFileMessage | string} causeOrReason
       *   Reason for message, should use markdown.
       * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
       *   Configuration (optional).
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns {VFileMessage}
       *   Message.
       */
      message(causeOrReason, optionsOrParentOrPlace, origin) {
        const message = new VFileMessage(
          // @ts-expect-error: the overloads are fine.
          causeOrReason,
          optionsOrParentOrPlace,
          origin
        );
        if (this.path) {
          message.name = this.path + ":" + message.name;
          message.file = this.path;
        }
        message.fatal = false;
        this.messages.push(message);
        return message;
      }
      /**
       * Serialize the file.
       *
       * > **Note**: which encodings are supported depends on the engine.
       * > For info on Node.js, see:
       * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
       *
       * @param {string | null | undefined} [encoding='utf8']
       *   Character encoding to understand `value` as when it’s a `Uint8Array`
       *   (default: `'utf-8'`).
       * @returns {string}
       *   Serialized file.
       */
      toString(encoding) {
        if (this.value === void 0) {
          return "";
        }
        if (typeof this.value === "string") {
          return this.value;
        }
        const decoder = new TextDecoder(encoding || void 0);
        return decoder.decode(this.value);
      }
    }
    function assertPart(part, name2) {
      if (part && part.includes(path$1.sep)) {
        throw new Error(
          "`" + name2 + "` cannot be a path: did not expect `" + path$1.sep + "`"
        );
      }
    }
    function assertNonEmpty(part, name2) {
      if (!part) {
        throw new Error("`" + name2 + "` cannot be empty");
      }
    }
    function assertPath(path2, name2) {
      if (!path2) {
        throw new Error("Setting `" + name2 + "` requires `path` to be set too");
      }
    }
    function isUint8Array$1(value) {
      return Boolean(
        value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
      );
    }
    const CallableInstance = (
      /**
       * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
       */
      /** @type {unknown} */
      /**
       * @this {Function}
       * @param {string | symbol} property
       * @returns {(...parameters: Array<unknown>) => unknown}
       */
      function(property2) {
        const self2 = this;
        const constr = self2.constructor;
        const proto2 = (
          /** @type {Record<string | symbol, Function>} */
          // Prototypes do exist.
          // type-coverage:ignore-next-line
          constr.prototype
        );
        const func = proto2[property2];
        const apply2 = function() {
          return func.apply(apply2, arguments);
        };
        Object.setPrototypeOf(apply2, proto2);
        const names = Object.getOwnPropertyNames(func);
        for (const p2 of names) {
          const descriptor = Object.getOwnPropertyDescriptor(func, p2);
          if (descriptor)
            Object.defineProperty(apply2, p2, descriptor);
        }
        return apply2;
      }
    );
    const own$4 = {}.hasOwnProperty;
    class Processor extends CallableInstance {
      /**
       * Create a processor.
       */
      constructor() {
        super("copy");
        this.Compiler = void 0;
        this.Parser = void 0;
        this.attachers = [];
        this.compiler = void 0;
        this.freezeIndex = -1;
        this.frozen = void 0;
        this.namespace = {};
        this.parser = void 0;
        this.transformers = trough();
      }
      /**
       * Copy a processor.
       *
       * @deprecated
       *   This is a private internal method and should not be used.
       * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
       *   New *unfrozen* processor ({@link Processor `Processor`}) that is
       *   configured to work the same as its ancestor.
       *   When the descendant processor is configured in the future it does not
       *   affect the ancestral processor.
       */
      copy() {
        const destination = (
          /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
          new Processor()
        );
        let index2 = -1;
        while (++index2 < this.attachers.length) {
          const attacher = this.attachers[index2];
          destination.use(...attacher);
        }
        destination.data(extend$1(true, {}, this.namespace));
        return destination;
      }
      /**
       * Configure the processor with info available to all plugins.
       * Information is stored in an object.
       *
       * Typically, options can be given to a specific plugin, but sometimes it
       * makes sense to have information shared with several plugins.
       * For example, a list of HTML elements that are self-closing, which is
       * needed during all phases.
       *
       * > 👉 **Note**: setting information cannot occur on *frozen* processors.
       * > Call the processor first to create a new unfrozen processor.
       *
       * > 👉 **Note**: to register custom data in TypeScript, augment the
       * > {@link Data `Data`} interface.
       *
       * @example
       *   This example show how to get and set info:
       *
       *   ```js
       *   import {unified} from 'unified'
       *
       *   const processor = unified().data('alpha', 'bravo')
       *
       *   processor.data('alpha') // => 'bravo'
       *
       *   processor.data() // => {alpha: 'bravo'}
       *
       *   processor.data({charlie: 'delta'})
       *
       *   processor.data() // => {charlie: 'delta'}
       *   ```
       *
       * @template {keyof Data} Key
       *
       * @overload
       * @returns {Data}
       *
       * @overload
       * @param {Data} dataset
       * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
       *
       * @overload
       * @param {Key} key
       * @returns {Data[Key]}
       *
       * @overload
       * @param {Key} key
       * @param {Data[Key]} value
       * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
       *
       * @param {Data | Key} [key]
       *   Key to get or set, or entire dataset to set, or nothing to get the
       *   entire dataset (optional).
       * @param {Data[Key]} [value]
       *   Value to set (optional).
       * @returns {unknown}
       *   The current processor when setting, the value at `key` when getting, or
       *   the entire dataset when getting without key.
       */
      data(key, value) {
        if (typeof key === "string") {
          if (arguments.length === 2) {
            assertUnfrozen("data", this.frozen);
            this.namespace[key] = value;
            return this;
          }
          return own$4.call(this.namespace, key) && this.namespace[key] || void 0;
        }
        if (key) {
          assertUnfrozen("data", this.frozen);
          this.namespace = key;
          return this;
        }
        return this.namespace;
      }
      /**
       * Freeze a processor.
       *
       * Frozen processors are meant to be extended and not to be configured
       * directly.
       *
       * When a processor is frozen it cannot be unfrozen.
       * New processors working the same way can be created by calling the
       * processor.
       *
       * It’s possible to freeze processors explicitly by calling `.freeze()`.
       * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
       * `.stringify()`, `.process()`, or `.processSync()` are called.
       *
       * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
       *   The current processor.
       */
      freeze() {
        if (this.frozen) {
          return this;
        }
        const self2 = (
          /** @type {Processor} */
          /** @type {unknown} */
          this
        );
        while (++this.freezeIndex < this.attachers.length) {
          const [attacher, ...options] = this.attachers[this.freezeIndex];
          if (options[0] === false) {
            continue;
          }
          if (options[0] === true) {
            options[0] = void 0;
          }
          const transformer = attacher.call(self2, ...options);
          if (typeof transformer === "function") {
            this.transformers.use(transformer);
          }
        }
        this.frozen = true;
        this.freezeIndex = Number.POSITIVE_INFINITY;
        return this;
      }
      /**
       * Parse text to a syntax tree.
       *
       * > 👉 **Note**: `parse` freezes the processor if not already *frozen*.
       *
       * > 👉 **Note**: `parse` performs the parse phase, not the run phase or other
       * > phases.
       *
       * @param {Compatible | undefined} [file]
       *   file to parse (optional); typically `string` or `VFile`; any value
       *   accepted as `x` in `new VFile(x)`.
       * @returns {ParseTree extends undefined ? Node : ParseTree}
       *   Syntax tree representing `file`.
       */
      parse(file) {
        this.freeze();
        const realFile = vfile(file);
        const parser = this.parser || this.Parser;
        assertParser("parse", parser);
        return parser(String(realFile), realFile);
      }
      /**
       * Process the given file as configured on the processor.
       *
       * > 👉 **Note**: `process` freezes the processor if not already *frozen*.
       *
       * > 👉 **Note**: `process` performs the parse, run, and stringify phases.
       *
       * @overload
       * @param {Compatible | undefined} file
       * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
       * @returns {undefined}
       *
       * @overload
       * @param {Compatible | undefined} [file]
       * @returns {Promise<VFileWithOutput<CompileResult>>}
       *
       * @param {Compatible | undefined} [file]
       *   File (optional); typically `string` or `VFile`]; any value accepted as
       *   `x` in `new VFile(x)`.
       * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
       *   Callback (optional).
       * @returns {Promise<VFile> | undefined}
       *   Nothing if `done` is given.
       *   Otherwise a promise, rejected with a fatal error or resolved with the
       *   processed file.
       *
       *   The parsed, transformed, and compiled value is available at
       *   `file.value` (see note).
       *
       *   > 👉 **Note**: unified typically compiles by serializing: most
       *   > compilers return `string` (or `Uint8Array`).
       *   > Some compilers, such as the one configured with
       *   > [`rehype-react`][rehype-react], return other values (in this case, a
       *   > React tree).
       *   > If you’re using a compiler that doesn’t serialize, expect different
       *   > result values.
       *   >
       *   > To register custom results in TypeScript, add them to
       *   > {@link CompileResultMap `CompileResultMap`}.
       *
       *   [rehype-react]: https://github.com/rehypejs/rehype-react
       */
      process(file, done) {
        const self2 = this;
        this.freeze();
        assertParser("process", this.parser || this.Parser);
        assertCompiler("process", this.compiler || this.Compiler);
        return done ? executor(void 0, done) : new Promise(executor);
        function executor(resolve, reject) {
          const realFile = vfile(file);
          const parseTree = (
            /** @type {HeadTree extends undefined ? Node : HeadTree} */
            /** @type {unknown} */
            self2.parse(realFile)
          );
          self2.run(parseTree, realFile, function(error, tree, file2) {
            if (error || !tree || !file2) {
              return realDone(error);
            }
            const compileTree = (
              /** @type {CompileTree extends undefined ? Node : CompileTree} */
              /** @type {unknown} */
              tree
            );
            const compileResult = self2.stringify(compileTree, file2);
            if (looksLikeAValue(compileResult)) {
              file2.value = compileResult;
            } else {
              file2.result = compileResult;
            }
            realDone(
              error,
              /** @type {VFileWithOutput<CompileResult>} */
              file2
            );
          });
          function realDone(error, file2) {
            if (error || !file2) {
              reject(error);
            } else if (resolve) {
              resolve(file2);
            } else {
              done(void 0, file2);
            }
          }
        }
      }
      /**
       * Process the given file as configured on the processor.
       *
       * An error is thrown if asynchronous transforms are configured.
       *
       * > 👉 **Note**: `processSync` freezes the processor if not already *frozen*.
       *
       * > 👉 **Note**: `processSync` performs the parse, run, and stringify phases.
       *
       * @param {Compatible | undefined} [file]
       *   File (optional); typically `string` or `VFile`; any value accepted as
       *   `x` in `new VFile(x)`.
       * @returns {VFileWithOutput<CompileResult>}
       *   The processed file.
       *
       *   The parsed, transformed, and compiled value is available at
       *   `file.value` (see note).
       *
       *   > 👉 **Note**: unified typically compiles by serializing: most
       *   > compilers return `string` (or `Uint8Array`).
       *   > Some compilers, such as the one configured with
       *   > [`rehype-react`][rehype-react], return other values (in this case, a
       *   > React tree).
       *   > If you’re using a compiler that doesn’t serialize, expect different
       *   > result values.
       *   >
       *   > To register custom results in TypeScript, add them to
       *   > {@link CompileResultMap `CompileResultMap`}.
       *
       *   [rehype-react]: https://github.com/rehypejs/rehype-react
       */
      processSync(file) {
        let complete = false;
        let result;
        this.freeze();
        assertParser("processSync", this.parser || this.Parser);
        assertCompiler("processSync", this.compiler || this.Compiler);
        this.process(file, realDone);
        assertDone("processSync", "process", complete);
        return result;
        function realDone(error, file2) {
          complete = true;
          bail(error);
          result = file2;
        }
      }
      /**
       * Run *transformers* on a syntax tree.
       *
       * > 👉 **Note**: `run` freezes the processor if not already *frozen*.
       *
       * > 👉 **Note**: `run` performs the run phase, not other phases.
       *
       * @overload
       * @param {HeadTree extends undefined ? Node : HeadTree} tree
       * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
       * @returns {undefined}
       *
       * @overload
       * @param {HeadTree extends undefined ? Node : HeadTree} tree
       * @param {Compatible | undefined} file
       * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
       * @returns {undefined}
       *
       * @overload
       * @param {HeadTree extends undefined ? Node : HeadTree} tree
       * @param {Compatible | undefined} [file]
       * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
       *
       * @param {HeadTree extends undefined ? Node : HeadTree} tree
       *   Tree to transform and inspect.
       * @param {(
       *   RunCallback<TailTree extends undefined ? Node : TailTree> |
       *   Compatible
       * )} [file]
       *   File associated with `node` (optional); any value accepted as `x` in
       *   `new VFile(x)`.
       * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
       *   Callback (optional).
       * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
       *   Nothing if `done` is given.
       *   Otherwise, a promise rejected with a fatal error or resolved with the
       *   transformed tree.
       */
      run(tree, file, done) {
        assertNode(tree);
        this.freeze();
        const transformers = this.transformers;
        if (!done && typeof file === "function") {
          done = file;
          file = void 0;
        }
        return done ? executor(void 0, done) : new Promise(executor);
        function executor(resolve, reject) {
          const realFile = vfile(file);
          transformers.run(tree, realFile, realDone);
          function realDone(error, outputTree, file2) {
            const resultingTree = (
              /** @type {TailTree extends undefined ? Node : TailTree} */
              outputTree || tree
            );
            if (error) {
              reject(error);
            } else if (resolve) {
              resolve(resultingTree);
            } else {
              done(void 0, resultingTree, file2);
            }
          }
        }
      }
      /**
       * Run *transformers* on a syntax tree.
       *
       * An error is thrown if asynchronous transforms are configured.
       *
       * > 👉 **Note**: `runSync` freezes the processor if not already *frozen*.
       *
       * > 👉 **Note**: `runSync` performs the run phase, not other phases.
       *
       * @param {HeadTree extends undefined ? Node : HeadTree} tree
       *   Tree to transform and inspect.
       * @param {Compatible | undefined} [file]
       *   File associated with `node` (optional); any value accepted as `x` in
       *   `new VFile(x)`.
       * @returns {TailTree extends undefined ? Node : TailTree}
       *   Transformed tree.
       */
      runSync(tree, file) {
        let complete = false;
        let result;
        this.run(tree, file, realDone);
        assertDone("runSync", "run", complete);
        return result;
        function realDone(error, tree2) {
          bail(error);
          result = tree2;
          complete = true;
        }
      }
      /**
       * Compile a syntax tree.
       *
       * > 👉 **Note**: `stringify` freezes the processor if not already *frozen*.
       *
       * > 👉 **Note**: `stringify` performs the stringify phase, not the run phase
       * > or other phases.
       *
       * @param {CompileTree extends undefined ? Node : CompileTree} tree
       *   Tree to compile.
       * @param {Compatible | undefined} [file]
       *   File associated with `node` (optional); any value accepted as `x` in
       *   `new VFile(x)`.
       * @returns {CompileResult extends undefined ? Value : CompileResult}
       *   Textual representation of the tree (see note).
       *
       *   > 👉 **Note**: unified typically compiles by serializing: most compilers
       *   > return `string` (or `Uint8Array`).
       *   > Some compilers, such as the one configured with
       *   > [`rehype-react`][rehype-react], return other values (in this case, a
       *   > React tree).
       *   > If you’re using a compiler that doesn’t serialize, expect different
       *   > result values.
       *   >
       *   > To register custom results in TypeScript, add them to
       *   > {@link CompileResultMap `CompileResultMap`}.
       *
       *   [rehype-react]: https://github.com/rehypejs/rehype-react
       */
      stringify(tree, file) {
        this.freeze();
        const realFile = vfile(file);
        const compiler2 = this.compiler || this.Compiler;
        assertCompiler("stringify", compiler2);
        assertNode(tree);
        return compiler2(tree, realFile);
      }
      /**
       * Configure the processor to use a plugin, a list of usable values, or a
       * preset.
       *
       * If the processor is already using a plugin, the previous plugin
       * configuration is changed based on the options that are passed in.
       * In other words, the plugin is not added a second time.
       *
       * > 👉 **Note**: `use` cannot be called on *frozen* processors.
       * > Call the processor first to create a new unfrozen processor.
       *
       * @example
       *   There are many ways to pass plugins to `.use()`.
       *   This example gives an overview:
       *
       *   ```js
       *   import {unified} from 'unified'
       *
       *   unified()
       *     // Plugin with options:
       *     .use(pluginA, {x: true, y: true})
       *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
       *     .use(pluginA, {y: false, z: true})
       *     // Plugins:
       *     .use([pluginB, pluginC])
       *     // Two plugins, the second with options:
       *     .use([pluginD, [pluginE, {}]])
       *     // Preset with plugins and settings:
       *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
       *     // Settings only:
       *     .use({settings: {position: false}})
       *   ```
       *
       * @template {Array<unknown>} [Parameters=[]]
       * @template {Node | string | undefined} [Input=undefined]
       * @template [Output=Input]
       *
       * @overload
       * @param {Preset | null | undefined} [preset]
       * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
       *
       * @overload
       * @param {PluggableList} list
       * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
       *
       * @overload
       * @param {Plugin<Parameters, Input, Output>} plugin
       * @param {...(Parameters | [boolean])} parameters
       * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
       *
       * @param {PluggableList | Plugin | Preset | null | undefined} value
       *   Usable value.
       * @param {...unknown} parameters
       *   Parameters, when a plugin is given as a usable value.
       * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
       *   Current processor.
       */
      use(value, ...parameters) {
        const attachers = this.attachers;
        const namespace = this.namespace;
        assertUnfrozen("use", this.frozen);
        if (value === null || value === void 0)
          ;
        else if (typeof value === "function") {
          addPlugin(value, parameters);
        } else if (typeof value === "object") {
          if (Array.isArray(value)) {
            addList(value);
          } else {
            addPreset(value);
          }
        } else {
          throw new TypeError("Expected usable value, not `" + value + "`");
        }
        return this;
        function add(value2) {
          if (typeof value2 === "function") {
            addPlugin(value2, []);
          } else if (typeof value2 === "object") {
            if (Array.isArray(value2)) {
              const [plugin, ...parameters2] = (
                /** @type {PluginTuple<Array<unknown>>} */
                value2
              );
              addPlugin(plugin, parameters2);
            } else {
              addPreset(value2);
            }
          } else {
            throw new TypeError("Expected usable value, not `" + value2 + "`");
          }
        }
        function addPreset(result) {
          if (!("plugins" in result) && !("settings" in result)) {
            throw new Error(
              "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
            );
          }
          addList(result.plugins);
          if (result.settings) {
            namespace.settings = extend$1(true, namespace.settings, result.settings);
          }
        }
        function addList(plugins) {
          let index2 = -1;
          if (plugins === null || plugins === void 0)
            ;
          else if (Array.isArray(plugins)) {
            while (++index2 < plugins.length) {
              const thing = plugins[index2];
              add(thing);
            }
          } else {
            throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
          }
        }
        function addPlugin(plugin, parameters2) {
          let index2 = -1;
          let entryIndex = -1;
          while (++index2 < attachers.length) {
            if (attachers[index2][0] === plugin) {
              entryIndex = index2;
              break;
            }
          }
          if (entryIndex === -1) {
            attachers.push([plugin, ...parameters2]);
          } else if (parameters2.length > 0) {
            let [primary, ...rest] = parameters2;
            const currentPrimary = attachers[entryIndex][1];
            if (isPlainObject$1(currentPrimary) && isPlainObject$1(primary)) {
              primary = extend$1(true, currentPrimary, primary);
            }
            attachers[entryIndex] = [plugin, primary, ...rest];
          }
        }
      }
    }
    const unified = new Processor().freeze();
    function assertParser(name2, value) {
      if (typeof value !== "function") {
        throw new TypeError("Cannot `" + name2 + "` without `parser`");
      }
    }
    function assertCompiler(name2, value) {
      if (typeof value !== "function") {
        throw new TypeError("Cannot `" + name2 + "` without `compiler`");
      }
    }
    function assertUnfrozen(name2, frozen) {
      if (frozen) {
        throw new Error(
          "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
        );
      }
    }
    function assertNode(node2) {
      if (!isPlainObject$1(node2) || typeof node2.type !== "string") {
        throw new TypeError("Expected node, got `" + node2 + "`");
      }
    }
    function assertDone(name2, asyncName, complete) {
      if (!complete) {
        throw new Error(
          "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
        );
      }
    }
    function vfile(value) {
      return looksLikeAVFile(value) ? value : new VFile(value);
    }
    function looksLikeAVFile(value) {
      return Boolean(
        value && typeof value === "object" && "message" in value && "messages" in value
      );
    }
    function looksLikeAValue(value) {
      return typeof value === "string" || isUint8Array(value);
    }
    function isUint8Array(value) {
      return Boolean(
        value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
      );
    }
    const own$3 = {}.hasOwnProperty;
    const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
    const emptyPlugins = [];
    const emptyRemarkRehypeOptions = { allowDangerousHtml: true };
    const safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
    const deprecations = [
      { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
      { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
      {
        from: "allowNode",
        id: "replace-allownode-allowedtypes-and-disallowedtypes",
        to: "allowElement"
      },
      {
        from: "allowedTypes",
        id: "replace-allownode-allowedtypes-and-disallowedtypes",
        to: "allowedElements"
      },
      {
        from: "disallowedTypes",
        id: "replace-allownode-allowedtypes-and-disallowedtypes",
        to: "disallowedElements"
      },
      { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
      { from: "includeElementIndex", id: "#remove-includeelementindex" },
      {
        from: "includeNodeIndex",
        id: "change-includenodeindex-to-includeelementindex"
      },
      { from: "linkTarget", id: "remove-linktarget" },
      { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
      { from: "rawSourcePos", id: "#remove-rawsourcepos" },
      { from: "renderers", id: "change-renderers-to-components", to: "components" },
      { from: "source", id: "change-source-to-children", to: "children" },
      { from: "sourcePos", id: "#remove-sourcepos" },
      { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
      { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
    ];
    function Markdown(options) {
      const allowedElements = options.allowedElements;
      const allowElement = options.allowElement;
      const children = options.children || "";
      const className = options.className;
      const components = options.components;
      const disallowedElements = options.disallowedElements;
      const rehypePlugins = options.rehypePlugins || emptyPlugins;
      const remarkPlugins = options.remarkPlugins || emptyPlugins;
      const remarkRehypeOptions = options.remarkRehypeOptions ? { ...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions } : emptyRemarkRehypeOptions;
      const skipHtml = options.skipHtml;
      const unwrapDisallowed = options.unwrapDisallowed;
      const urlTransform = options.urlTransform || defaultUrlTransform;
      const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
      const file = new VFile();
      if (typeof children === "string") {
        file.value = children;
      }
      for (const deprecation of deprecations) {
        if (Object.hasOwn(options, deprecation.from)) {
          unreachable(
            "Unexpected `" + deprecation.from + "` prop, " + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation.id + "> for more info)"
          );
        }
      }
      const mdastTree = processor.parse(file);
      let hastTree = processor.runSync(mdastTree, file);
      if (className) {
        hastTree = {
          type: "element",
          tagName: "div",
          properties: { className },
          // Assume no doctypes.
          children: (
            /** @type {Array<ElementContent>} */
            hastTree.type === "root" ? hastTree.children : [hastTree]
          )
        };
      }
      visit(hastTree, transform);
      return toJsxRuntime(hastTree, {
        Fragment: jsxRuntimeExports.Fragment,
        components,
        ignoreInvalidStyle: true,
        jsx: jsxRuntimeExports.jsx,
        jsxs: jsxRuntimeExports.jsxs,
        passKeys: true,
        passNode: true
      });
      function transform(node2, index2, parent) {
        if (node2.type === "raw" && parent && typeof index2 === "number") {
          if (skipHtml) {
            parent.children.splice(index2, 1);
          } else {
            parent.children[index2] = { type: "text", value: node2.value };
          }
          return index2;
        }
        if (node2.type === "element") {
          let key;
          for (key in urlAttributes) {
            if (own$3.call(urlAttributes, key) && own$3.call(node2.properties, key)) {
              const value = node2.properties[key];
              const test = urlAttributes[key];
              if (test === null || test.includes(node2.tagName)) {
                node2.properties[key] = urlTransform(String(value || ""), key, node2);
              }
            }
          }
        }
        if (node2.type === "element") {
          let remove = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
          if (!remove && allowElement && typeof index2 === "number") {
            remove = !allowElement(node2, index2, parent);
          }
          if (remove && parent && typeof index2 === "number") {
            if (unwrapDisallowed && node2.children) {
              parent.children.splice(index2, 1, ...node2.children);
            } else {
              parent.children.splice(index2, 1);
            }
            return index2;
          }
        }
      }
    }
    function defaultUrlTransform(value) {
      return sanitizeUri(value, safeProtocol);
    }
    function ccount(value, character) {
      const source = String(value);
      if (typeof character !== "string") {
        throw new TypeError("Expected character");
      }
      let count = 0;
      let index2 = source.indexOf(character);
      while (index2 !== -1) {
        count++;
        index2 = source.indexOf(character, index2 + character.length);
      }
      return count;
    }
    function escapeStringRegexp(string2) {
      if (typeof string2 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }
    function findAndReplace(tree, list2, options) {
      const settings = options || {};
      const ignored = convert(settings.ignore || []);
      const pairs = toPairs(list2);
      let pairIndex = -1;
      while (++pairIndex < pairs.length) {
        visitParents(tree, "text", visitor);
      }
      function visitor(node2, parents) {
        let index2 = -1;
        let grandparent;
        while (++index2 < parents.length) {
          const parent = parents[index2];
          const siblings = grandparent ? grandparent.children : void 0;
          if (ignored(
            parent,
            siblings ? siblings.indexOf(parent) : void 0,
            grandparent
          )) {
            return;
          }
          grandparent = parent;
        }
        if (grandparent) {
          return handler(node2, parents);
        }
      }
      function handler(node2, parents) {
        const parent = parents[parents.length - 1];
        const find2 = pairs[pairIndex][0];
        const replace2 = pairs[pairIndex][1];
        let start = 0;
        const siblings = parent.children;
        const index2 = siblings.indexOf(node2);
        let change = false;
        let nodes = [];
        find2.lastIndex = 0;
        let match = find2.exec(node2.value);
        while (match) {
          const position2 = match.index;
          const matchObject = {
            index: match.index,
            input: match.input,
            stack: [...parents, node2]
          };
          let value = replace2(...match, matchObject);
          if (typeof value === "string") {
            value = value.length > 0 ? { type: "text", value } : void 0;
          }
          if (value === false) {
            find2.lastIndex = position2 + 1;
          } else {
            if (start !== position2) {
              nodes.push({
                type: "text",
                value: node2.value.slice(start, position2)
              });
            }
            if (Array.isArray(value)) {
              nodes.push(...value);
            } else if (value) {
              nodes.push(value);
            }
            start = position2 + match[0].length;
            change = true;
          }
          if (!find2.global) {
            break;
          }
          match = find2.exec(node2.value);
        }
        if (change) {
          if (start < node2.value.length) {
            nodes.push({ type: "text", value: node2.value.slice(start) });
          }
          parent.children.splice(index2, 1, ...nodes);
        } else {
          nodes = [node2];
        }
        return index2 + nodes.length;
      }
    }
    function toPairs(tupleOrList) {
      const result = [];
      if (!Array.isArray(tupleOrList)) {
        throw new TypeError("Expected find and replace tuple or list of tuples");
      }
      const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
      let index2 = -1;
      while (++index2 < list2.length) {
        const tuple = list2[index2];
        result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
      }
      return result;
    }
    function toExpression(find2) {
      return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
    }
    function toFunction(replace2) {
      return typeof replace2 === "function" ? replace2 : function() {
        return replace2;
      };
    }
    const inConstruct = "phrasing";
    const notInConstruct = ["autolink", "link", "image", "label"];
    function gfmAutolinkLiteralFromMarkdown() {
      return {
        transforms: [transformGfmAutolinkLiterals],
        enter: {
          literalAutolink: enterLiteralAutolink,
          literalAutolinkEmail: enterLiteralAutolinkValue,
          literalAutolinkHttp: enterLiteralAutolinkValue,
          literalAutolinkWww: enterLiteralAutolinkValue
        },
        exit: {
          literalAutolink: exitLiteralAutolink,
          literalAutolinkEmail: exitLiteralAutolinkEmail,
          literalAutolinkHttp: exitLiteralAutolinkHttp,
          literalAutolinkWww: exitLiteralAutolinkWww
        }
      };
    }
    function gfmAutolinkLiteralToMarkdown() {
      return {
        unsafe: [
          {
            character: "@",
            before: "[+\\-.\\w]",
            after: "[\\-.\\w]",
            inConstruct,
            notInConstruct
          },
          {
            character: ".",
            before: "[Ww]",
            after: "[\\-.\\w]",
            inConstruct,
            notInConstruct
          },
          {
            character: ":",
            before: "[ps]",
            after: "\\/",
            inConstruct,
            notInConstruct
          }
        ]
      };
    }
    function enterLiteralAutolink(token) {
      this.enter({ type: "link", title: null, url: "", children: [] }, token);
    }
    function enterLiteralAutolinkValue(token) {
      this.config.enter.autolinkProtocol.call(this, token);
    }
    function exitLiteralAutolinkHttp(token) {
      this.config.exit.autolinkProtocol.call(this, token);
    }
    function exitLiteralAutolinkWww(token) {
      this.config.exit.data.call(this, token);
      const node2 = this.stack[this.stack.length - 1];
      ok$1(node2.type === "link");
      node2.url = "http://" + this.sliceSerialize(token);
    }
    function exitLiteralAutolinkEmail(token) {
      this.config.exit.autolinkEmail.call(this, token);
    }
    function exitLiteralAutolink(token) {
      this.exit(token);
    }
    function transformGfmAutolinkLiterals(tree) {
      findAndReplace(
        tree,
        [
          [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
          [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
        ],
        { ignore: ["link", "linkReference"] }
      );
    }
    function findUrl(_, protocol, domain2, path2, match) {
      let prefix = "";
      if (!previous(match)) {
        return false;
      }
      if (/^w/i.test(protocol)) {
        domain2 = protocol + domain2;
        protocol = "";
        prefix = "http://";
      }
      if (!isCorrectDomain(domain2)) {
        return false;
      }
      const parts = splitUrl(domain2 + path2);
      if (!parts[0])
        return false;
      const result = {
        type: "link",
        title: null,
        url: prefix + protocol + parts[0],
        children: [{ type: "text", value: protocol + parts[0] }]
      };
      if (parts[1]) {
        return [result, { type: "text", value: parts[1] }];
      }
      return result;
    }
    function findEmail(_, atext, label, match) {
      if (
        // Not an expected previous character.
        !previous(match, true) || // Label ends in not allowed character.
        /[-\d_]$/.test(label)
      ) {
        return false;
      }
      return {
        type: "link",
        title: null,
        url: "mailto:" + atext + "@" + label,
        children: [{ type: "text", value: atext + "@" + label }]
      };
    }
    function isCorrectDomain(domain2) {
      const parts = domain2.split(".");
      if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
        return false;
      }
      return true;
    }
    function splitUrl(url) {
      const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
      if (!trailExec) {
        return [url, void 0];
      }
      url = url.slice(0, trailExec.index);
      let trail2 = trailExec[0];
      let closingParenIndex = trail2.indexOf(")");
      const openingParens = ccount(url, "(");
      let closingParens = ccount(url, ")");
      while (closingParenIndex !== -1 && openingParens > closingParens) {
        url += trail2.slice(0, closingParenIndex + 1);
        trail2 = trail2.slice(closingParenIndex + 1);
        closingParenIndex = trail2.indexOf(")");
        closingParens++;
      }
      return [url, trail2];
    }
    function previous(match, email) {
      const code2 = match.input.charCodeAt(match.index - 1);
      return (match.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
    }
    footnoteReference.peek = footnoteReferencePeek;
    function gfmFootnoteFromMarkdown() {
      return {
        enter: {
          gfmFootnoteDefinition: enterFootnoteDefinition,
          gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
          gfmFootnoteCall: enterFootnoteCall,
          gfmFootnoteCallString: enterFootnoteCallString
        },
        exit: {
          gfmFootnoteDefinition: exitFootnoteDefinition,
          gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
          gfmFootnoteCall: exitFootnoteCall,
          gfmFootnoteCallString: exitFootnoteCallString
        }
      };
    }
    function gfmFootnoteToMarkdown() {
      return {
        // This is on by default already.
        unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
        handlers: { footnoteDefinition, footnoteReference }
      };
    }
    function enterFootnoteDefinition(token) {
      this.enter(
        { type: "footnoteDefinition", identifier: "", label: "", children: [] },
        token
      );
    }
    function enterFootnoteDefinitionLabelString() {
      this.buffer();
    }
    function exitFootnoteDefinitionLabelString(token) {
      const label = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      ok$1(node2.type === "footnoteDefinition");
      node2.label = label;
      node2.identifier = normalizeIdentifier(
        this.sliceSerialize(token)
      ).toLowerCase();
    }
    function exitFootnoteDefinition(token) {
      this.exit(token);
    }
    function enterFootnoteCall(token) {
      this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
    }
    function enterFootnoteCallString() {
      this.buffer();
    }
    function exitFootnoteCallString(token) {
      const label = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      ok$1(node2.type === "footnoteReference");
      node2.label = label;
      node2.identifier = normalizeIdentifier(
        this.sliceSerialize(token)
      ).toLowerCase();
    }
    function exitFootnoteCall(token) {
      this.exit(token);
    }
    function footnoteReference(node2, _, state, info2) {
      const tracker = state.createTracker(info2);
      let value = tracker.move("[^");
      const exit2 = state.enter("footnoteReference");
      const subexit = state.enter("reference");
      value += tracker.move(
        state.safe(state.associationId(node2), {
          ...tracker.current(),
          before: value,
          after: "]"
        })
      );
      subexit();
      exit2();
      value += tracker.move("]");
      return value;
    }
    function footnoteReferencePeek() {
      return "[";
    }
    function footnoteDefinition(node2, _, state, info2) {
      const tracker = state.createTracker(info2);
      let value = tracker.move("[^");
      const exit2 = state.enter("footnoteDefinition");
      const subexit = state.enter("label");
      value += tracker.move(
        state.safe(state.associationId(node2), {
          ...tracker.current(),
          before: value,
          after: "]"
        })
      );
      subexit();
      value += tracker.move(
        "]:" + (node2.children && node2.children.length > 0 ? " " : "")
      );
      tracker.shift(4);
      value += tracker.move(
        state.indentLines(state.containerFlow(node2, tracker.current()), map$2)
      );
      exit2();
      return value;
    }
    function map$2(line, index2, blank) {
      if (index2 === 0) {
        return line;
      }
      return (blank ? "" : "    ") + line;
    }
    const constructsWithoutStrikethrough = [
      "autolink",
      "destinationLiteral",
      "destinationRaw",
      "reference",
      "titleQuote",
      "titleApostrophe"
    ];
    handleDelete.peek = peekDelete;
    function gfmStrikethroughFromMarkdown() {
      return {
        canContainEols: ["delete"],
        enter: { strikethrough: enterStrikethrough },
        exit: { strikethrough: exitStrikethrough }
      };
    }
    function gfmStrikethroughToMarkdown() {
      return {
        unsafe: [
          {
            character: "~",
            inConstruct: "phrasing",
            notInConstruct: constructsWithoutStrikethrough
          }
        ],
        handlers: { delete: handleDelete }
      };
    }
    function enterStrikethrough(token) {
      this.enter({ type: "delete", children: [] }, token);
    }
    function exitStrikethrough(token) {
      this.exit(token);
    }
    function handleDelete(node2, _, state, info2) {
      const tracker = state.createTracker(info2);
      const exit2 = state.enter("strikethrough");
      let value = tracker.move("~~");
      value += state.containerPhrasing(node2, {
        ...tracker.current(),
        before: value,
        after: "~"
      });
      value += tracker.move("~~");
      exit2();
      return value;
    }
    function peekDelete() {
      return "~";
    }
    function markdownTable(table2, options = {}) {
      const align = (options.align || []).concat();
      const stringLength = options.stringLength || defaultStringLength;
      const alignments = [];
      const cellMatrix = [];
      const sizeMatrix = [];
      const longestCellByColumn = [];
      let mostCellsPerRow = 0;
      let rowIndex = -1;
      while (++rowIndex < table2.length) {
        const row2 = [];
        const sizes2 = [];
        let columnIndex2 = -1;
        if (table2[rowIndex].length > mostCellsPerRow) {
          mostCellsPerRow = table2[rowIndex].length;
        }
        while (++columnIndex2 < table2[rowIndex].length) {
          const cell = serialize(table2[rowIndex][columnIndex2]);
          if (options.alignDelimiters !== false) {
            const size = stringLength(cell);
            sizes2[columnIndex2] = size;
            if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
              longestCellByColumn[columnIndex2] = size;
            }
          }
          row2.push(cell);
        }
        cellMatrix[rowIndex] = row2;
        sizeMatrix[rowIndex] = sizes2;
      }
      let columnIndex = -1;
      if (typeof align === "object" && "length" in align) {
        while (++columnIndex < mostCellsPerRow) {
          alignments[columnIndex] = toAlignment(align[columnIndex]);
        }
      } else {
        const code2 = toAlignment(align);
        while (++columnIndex < mostCellsPerRow) {
          alignments[columnIndex] = code2;
        }
      }
      columnIndex = -1;
      const row = [];
      const sizes = [];
      while (++columnIndex < mostCellsPerRow) {
        const code2 = alignments[columnIndex];
        let before = "";
        let after = "";
        if (code2 === 99) {
          before = ":";
          after = ":";
        } else if (code2 === 108) {
          before = ":";
        } else if (code2 === 114) {
          after = ":";
        }
        let size = options.alignDelimiters === false ? 1 : Math.max(
          1,
          longestCellByColumn[columnIndex] - before.length - after.length
        );
        const cell = before + "-".repeat(size) + after;
        if (options.alignDelimiters !== false) {
          size = before.length + size + after.length;
          if (size > longestCellByColumn[columnIndex]) {
            longestCellByColumn[columnIndex] = size;
          }
          sizes[columnIndex] = size;
        }
        row[columnIndex] = cell;
      }
      cellMatrix.splice(1, 0, row);
      sizeMatrix.splice(1, 0, sizes);
      rowIndex = -1;
      const lines = [];
      while (++rowIndex < cellMatrix.length) {
        const row2 = cellMatrix[rowIndex];
        const sizes2 = sizeMatrix[rowIndex];
        columnIndex = -1;
        const line = [];
        while (++columnIndex < mostCellsPerRow) {
          const cell = row2[columnIndex] || "";
          let before = "";
          let after = "";
          if (options.alignDelimiters !== false) {
            const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
            const code2 = alignments[columnIndex];
            if (code2 === 114) {
              before = " ".repeat(size);
            } else if (code2 === 99) {
              if (size % 2) {
                before = " ".repeat(size / 2 + 0.5);
                after = " ".repeat(size / 2 - 0.5);
              } else {
                before = " ".repeat(size / 2);
                after = before;
              }
            } else {
              after = " ".repeat(size);
            }
          }
          if (options.delimiterStart !== false && !columnIndex) {
            line.push("|");
          }
          if (options.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
          // empty: there will be a closing space.
          !(options.alignDelimiters === false && cell === "") && (options.delimiterStart !== false || columnIndex)) {
            line.push(" ");
          }
          if (options.alignDelimiters !== false) {
            line.push(before);
          }
          line.push(cell);
          if (options.alignDelimiters !== false) {
            line.push(after);
          }
          if (options.padding !== false) {
            line.push(" ");
          }
          if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
            line.push("|");
          }
        }
        lines.push(
          options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
        );
      }
      return lines.join("\n");
    }
    function serialize(value) {
      return value === null || value === void 0 ? "" : String(value);
    }
    function defaultStringLength(value) {
      return value.length;
    }
    function toAlignment(value) {
      const code2 = typeof value === "string" ? value.codePointAt(0) : 0;
      return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
    }
    function blockquote(node2, _, state, info2) {
      const exit2 = state.enter("blockquote");
      const tracker = state.createTracker(info2);
      tracker.move("> ");
      tracker.shift(2);
      const value = state.indentLines(
        state.containerFlow(node2, tracker.current()),
        map$1
      );
      exit2();
      return value;
    }
    function map$1(line, _, blank) {
      return ">" + (blank ? "" : " ") + line;
    }
    function patternInScope(stack, pattern) {
      return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
    }
    function listInScope(stack, list2, none) {
      if (typeof list2 === "string") {
        list2 = [list2];
      }
      if (!list2 || list2.length === 0) {
        return none;
      }
      let index2 = -1;
      while (++index2 < list2.length) {
        if (stack.includes(list2[index2])) {
          return true;
        }
      }
      return false;
    }
    function hardBreak(_, _1, state, info2) {
      let index2 = -1;
      while (++index2 < state.unsafe.length) {
        if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
          return /[ \t]/.test(info2.before) ? "" : " ";
        }
      }
      return "\\\n";
    }
    function longestStreak(value, substring) {
      const source = String(value);
      let index2 = source.indexOf(substring);
      let expected = index2;
      let count = 0;
      let max = 0;
      if (typeof substring !== "string") {
        throw new TypeError("Expected substring");
      }
      while (index2 !== -1) {
        if (index2 === expected) {
          if (++count > max) {
            max = count;
          }
        } else {
          count = 1;
        }
        expected = index2 + substring.length;
        index2 = source.indexOf(substring, expected);
      }
      return max;
    }
    function formatCodeAsIndented(node2, state) {
      return Boolean(
        state.options.fences === false && node2.value && // If there’s no info…
        !node2.lang && // And there’s a non-whitespace character…
        /[^ \r\n]/.test(node2.value) && // And the value doesn’t start or end in a blank…
        !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
      );
    }
    function checkFence(state) {
      const marker = state.options.fence || "`";
      if (marker !== "`" && marker !== "~") {
        throw new Error(
          "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
        );
      }
      return marker;
    }
    function code$1(node2, _, state, info2) {
      const marker = checkFence(state);
      const raw = node2.value || "";
      const suffix = marker === "`" ? "GraveAccent" : "Tilde";
      if (formatCodeAsIndented(node2, state)) {
        const exit3 = state.enter("codeIndented");
        const value2 = state.indentLines(raw, map);
        exit3();
        return value2;
      }
      const tracker = state.createTracker(info2);
      const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
      const exit2 = state.enter("codeFenced");
      let value = tracker.move(sequence);
      if (node2.lang) {
        const subexit = state.enter(`codeFencedLang${suffix}`);
        value += tracker.move(
          state.safe(node2.lang, {
            before: value,
            after: " ",
            encode: ["`"],
            ...tracker.current()
          })
        );
        subexit();
      }
      if (node2.lang && node2.meta) {
        const subexit = state.enter(`codeFencedMeta${suffix}`);
        value += tracker.move(" ");
        value += tracker.move(
          state.safe(node2.meta, {
            before: value,
            after: "\n",
            encode: ["`"],
            ...tracker.current()
          })
        );
        subexit();
      }
      value += tracker.move("\n");
      if (raw) {
        value += tracker.move(raw + "\n");
      }
      value += tracker.move(sequence);
      exit2();
      return value;
    }
    function map(line, _, blank) {
      return (blank ? "" : "    ") + line;
    }
    function checkQuote(state) {
      const marker = state.options.quote || '"';
      if (marker !== '"' && marker !== "'") {
        throw new Error(
          "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
        );
      }
      return marker;
    }
    function definition(node2, _, state, info2) {
      const quote = checkQuote(state);
      const suffix = quote === '"' ? "Quote" : "Apostrophe";
      const exit2 = state.enter("definition");
      let subexit = state.enter("label");
      const tracker = state.createTracker(info2);
      let value = tracker.move("[");
      value += tracker.move(
        state.safe(state.associationId(node2), {
          before: value,
          after: "]",
          ...tracker.current()
        })
      );
      value += tracker.move("]: ");
      subexit();
      if (
        // If there’s no url, or…
        !node2.url || // If there are control characters or whitespace.
        /[\0- \u007F]/.test(node2.url)
      ) {
        subexit = state.enter("destinationLiteral");
        value += tracker.move("<");
        value += tracker.move(
          state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
        );
        value += tracker.move(">");
      } else {
        subexit = state.enter("destinationRaw");
        value += tracker.move(
          state.safe(node2.url, {
            before: value,
            after: node2.title ? " " : "\n",
            ...tracker.current()
          })
        );
      }
      subexit();
      if (node2.title) {
        subexit = state.enter(`title${suffix}`);
        value += tracker.move(" " + quote);
        value += tracker.move(
          state.safe(node2.title, {
            before: value,
            after: quote,
            ...tracker.current()
          })
        );
        value += tracker.move(quote);
        subexit();
      }
      exit2();
      return value;
    }
    function checkEmphasis(state) {
      const marker = state.options.emphasis || "*";
      if (marker !== "*" && marker !== "_") {
        throw new Error(
          "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
        );
      }
      return marker;
    }
    emphasis.peek = emphasisPeek;
    function emphasis(node2, _, state, info2) {
      const marker = checkEmphasis(state);
      const exit2 = state.enter("emphasis");
      const tracker = state.createTracker(info2);
      let value = tracker.move(marker);
      value += tracker.move(
        state.containerPhrasing(node2, {
          before: value,
          after: marker,
          ...tracker.current()
        })
      );
      value += tracker.move(marker);
      exit2();
      return value;
    }
    function emphasisPeek(_, _1, state) {
      return state.options.emphasis || "*";
    }
    function formatHeadingAsSetext(node2, state) {
      let literalWithBreak = false;
      visit(node2, function(node3) {
        if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
          literalWithBreak = true;
          return EXIT;
        }
      });
      return Boolean(
        (!node2.depth || node2.depth < 3) && toString$3(node2) && (state.options.setext || literalWithBreak)
      );
    }
    function heading(node2, _, state, info2) {
      const rank = Math.max(Math.min(6, node2.depth || 1), 1);
      const tracker = state.createTracker(info2);
      if (formatHeadingAsSetext(node2, state)) {
        const exit3 = state.enter("headingSetext");
        const subexit2 = state.enter("phrasing");
        const value2 = state.containerPhrasing(node2, {
          ...tracker.current(),
          before: "\n",
          after: "\n"
        });
        subexit2();
        exit3();
        return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
          // The whole size…
          value2.length - // Minus the position of the character after the last EOL (or
          // 0 if there is none)…
          (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
        );
      }
      const sequence = "#".repeat(rank);
      const exit2 = state.enter("headingAtx");
      const subexit = state.enter("phrasing");
      tracker.move(sequence + " ");
      let value = state.containerPhrasing(node2, {
        before: "# ",
        after: "\n",
        ...tracker.current()
      });
      if (/^[\t ]/.test(value)) {
        value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
      }
      value = value ? sequence + " " + value : sequence;
      if (state.options.closeAtx) {
        value += " " + sequence;
      }
      subexit();
      exit2();
      return value;
    }
    html$3.peek = htmlPeek;
    function html$3(node2) {
      return node2.value || "";
    }
    function htmlPeek() {
      return "<";
    }
    image.peek = imagePeek;
    function image(node2, _, state, info2) {
      const quote = checkQuote(state);
      const suffix = quote === '"' ? "Quote" : "Apostrophe";
      const exit2 = state.enter("image");
      let subexit = state.enter("label");
      const tracker = state.createTracker(info2);
      let value = tracker.move("![");
      value += tracker.move(
        state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
      );
      value += tracker.move("](");
      subexit();
      if (
        // If there’s no url but there is a title…
        !node2.url && node2.title || // If there are control characters or whitespace.
        /[\0- \u007F]/.test(node2.url)
      ) {
        subexit = state.enter("destinationLiteral");
        value += tracker.move("<");
        value += tracker.move(
          state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
        );
        value += tracker.move(">");
      } else {
        subexit = state.enter("destinationRaw");
        value += tracker.move(
          state.safe(node2.url, {
            before: value,
            after: node2.title ? " " : ")",
            ...tracker.current()
          })
        );
      }
      subexit();
      if (node2.title) {
        subexit = state.enter(`title${suffix}`);
        value += tracker.move(" " + quote);
        value += tracker.move(
          state.safe(node2.title, {
            before: value,
            after: quote,
            ...tracker.current()
          })
        );
        value += tracker.move(quote);
        subexit();
      }
      value += tracker.move(")");
      exit2();
      return value;
    }
    function imagePeek() {
      return "!";
    }
    imageReference.peek = imageReferencePeek;
    function imageReference(node2, _, state, info2) {
      const type = node2.referenceType;
      const exit2 = state.enter("imageReference");
      let subexit = state.enter("label");
      const tracker = state.createTracker(info2);
      let value = tracker.move("![");
      const alt = state.safe(node2.alt, {
        before: value,
        after: "]",
        ...tracker.current()
      });
      value += tracker.move(alt + "][");
      subexit();
      const stack = state.stack;
      state.stack = [];
      subexit = state.enter("reference");
      const reference = state.safe(state.associationId(node2), {
        before: value,
        after: "]",
        ...tracker.current()
      });
      subexit();
      state.stack = stack;
      exit2();
      if (type === "full" || !alt || alt !== reference) {
        value += tracker.move(reference + "]");
      } else if (type === "shortcut") {
        value = value.slice(0, -1);
      } else {
        value += tracker.move("]");
      }
      return value;
    }
    function imageReferencePeek() {
      return "!";
    }
    inlineCode.peek = inlineCodePeek;
    function inlineCode(node2, _, state) {
      let value = node2.value || "";
      let sequence = "`";
      let index2 = -1;
      while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
        sequence += "`";
      }
      if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
        value = " " + value + " ";
      }
      while (++index2 < state.unsafe.length) {
        const pattern = state.unsafe[index2];
        const expression = state.compilePattern(pattern);
        let match;
        if (!pattern.atBreak)
          continue;
        while (match = expression.exec(value)) {
          let position2 = match.index;
          if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
            position2--;
          }
          value = value.slice(0, position2) + " " + value.slice(match.index + 1);
        }
      }
      return sequence + value + sequence;
    }
    function inlineCodePeek() {
      return "`";
    }
    function formatLinkAsAutolink(node2, state) {
      const raw = toString$3(node2);
      return Boolean(
        !state.options.resourceLink && // If there’s a url…
        node2.url && // And there’s a no title…
        !node2.title && // And the content of `node` is a single text node…
        node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content…
        (raw === node2.url || "mailto:" + raw === node2.url) && // And that starts w/ a protocol…
        /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesn’t contain ASCII control codes (character escapes and
        // references don’t work), space, or angle brackets…
        !/[\0- <>\u007F]/.test(node2.url)
      );
    }
    link.peek = linkPeek;
    function link(node2, _, state, info2) {
      const quote = checkQuote(state);
      const suffix = quote === '"' ? "Quote" : "Apostrophe";
      const tracker = state.createTracker(info2);
      let exit2;
      let subexit;
      if (formatLinkAsAutolink(node2, state)) {
        const stack = state.stack;
        state.stack = [];
        exit2 = state.enter("autolink");
        let value2 = tracker.move("<");
        value2 += tracker.move(
          state.containerPhrasing(node2, {
            before: value2,
            after: ">",
            ...tracker.current()
          })
        );
        value2 += tracker.move(">");
        exit2();
        state.stack = stack;
        return value2;
      }
      exit2 = state.enter("link");
      subexit = state.enter("label");
      let value = tracker.move("[");
      value += tracker.move(
        state.containerPhrasing(node2, {
          before: value,
          after: "](",
          ...tracker.current()
        })
      );
      value += tracker.move("](");
      subexit();
      if (
        // If there’s no url but there is a title…
        !node2.url && node2.title || // If there are control characters or whitespace.
        /[\0- \u007F]/.test(node2.url)
      ) {
        subexit = state.enter("destinationLiteral");
        value += tracker.move("<");
        value += tracker.move(
          state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
        );
        value += tracker.move(">");
      } else {
        subexit = state.enter("destinationRaw");
        value += tracker.move(
          state.safe(node2.url, {
            before: value,
            after: node2.title ? " " : ")",
            ...tracker.current()
          })
        );
      }
      subexit();
      if (node2.title) {
        subexit = state.enter(`title${suffix}`);
        value += tracker.move(" " + quote);
        value += tracker.move(
          state.safe(node2.title, {
            before: value,
            after: quote,
            ...tracker.current()
          })
        );
        value += tracker.move(quote);
        subexit();
      }
      value += tracker.move(")");
      exit2();
      return value;
    }
    function linkPeek(node2, _, state) {
      return formatLinkAsAutolink(node2, state) ? "<" : "[";
    }
    linkReference.peek = linkReferencePeek;
    function linkReference(node2, _, state, info2) {
      const type = node2.referenceType;
      const exit2 = state.enter("linkReference");
      let subexit = state.enter("label");
      const tracker = state.createTracker(info2);
      let value = tracker.move("[");
      const text2 = state.containerPhrasing(node2, {
        before: value,
        after: "]",
        ...tracker.current()
      });
      value += tracker.move(text2 + "][");
      subexit();
      const stack = state.stack;
      state.stack = [];
      subexit = state.enter("reference");
      const reference = state.safe(state.associationId(node2), {
        before: value,
        after: "]",
        ...tracker.current()
      });
      subexit();
      state.stack = stack;
      exit2();
      if (type === "full" || !text2 || text2 !== reference) {
        value += tracker.move(reference + "]");
      } else if (type === "shortcut") {
        value = value.slice(0, -1);
      } else {
        value += tracker.move("]");
      }
      return value;
    }
    function linkReferencePeek() {
      return "[";
    }
    function checkBullet(state) {
      const marker = state.options.bullet || "*";
      if (marker !== "*" && marker !== "+" && marker !== "-") {
        throw new Error(
          "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
        );
      }
      return marker;
    }
    function checkBulletOther(state) {
      const bullet = checkBullet(state);
      const bulletOther = state.options.bulletOther;
      if (!bulletOther) {
        return bullet === "*" ? "-" : "*";
      }
      if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
        throw new Error(
          "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
        );
      }
      if (bulletOther === bullet) {
        throw new Error(
          "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
        );
      }
      return bulletOther;
    }
    function checkBulletOrdered(state) {
      const marker = state.options.bulletOrdered || ".";
      if (marker !== "." && marker !== ")") {
        throw new Error(
          "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
        );
      }
      return marker;
    }
    function checkRule(state) {
      const marker = state.options.rule || "*";
      if (marker !== "*" && marker !== "-" && marker !== "_") {
        throw new Error(
          "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
        );
      }
      return marker;
    }
    function list(node2, parent, state, info2) {
      const exit2 = state.enter("list");
      const bulletCurrent = state.bulletCurrent;
      let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
      const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
      let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
      if (!node2.ordered) {
        const firstListItem = node2.children ? node2.children[0] : void 0;
        if (
          // Bullet could be used as a thematic break marker:
          (bullet === "*" || bullet === "-") && // Empty first list item:
          firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
          state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
          state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
        ) {
          useDifferentMarker = true;
        }
        if (checkRule(state) === bullet && firstListItem) {
          let index2 = -1;
          while (++index2 < node2.children.length) {
            const item = node2.children[index2];
            if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
              useDifferentMarker = true;
              break;
            }
          }
        }
      }
      if (useDifferentMarker) {
        bullet = bulletOther;
      }
      state.bulletCurrent = bullet;
      const value = state.containerFlow(node2, info2);
      state.bulletLastUsed = bullet;
      state.bulletCurrent = bulletCurrent;
      exit2();
      return value;
    }
    function checkListItemIndent(state) {
      const style2 = state.options.listItemIndent || "one";
      if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
        throw new Error(
          "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
        );
      }
      return style2;
    }
    function listItem(node2, parent, state, info2) {
      const listItemIndent = checkListItemIndent(state);
      let bullet = state.bulletCurrent || checkBullet(state);
      if (parent && parent.type === "list" && parent.ordered) {
        bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
      }
      let size = bullet.length + 1;
      if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
        size = Math.ceil(size / 4) * 4;
      }
      const tracker = state.createTracker(info2);
      tracker.move(bullet + " ".repeat(size - bullet.length));
      tracker.shift(size);
      const exit2 = state.enter("listItem");
      const value = state.indentLines(
        state.containerFlow(node2, tracker.current()),
        map2
      );
      exit2();
      return value;
      function map2(line, index2, blank) {
        if (index2) {
          return (blank ? "" : " ".repeat(size)) + line;
        }
        return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
      }
    }
    function paragraph(node2, _, state, info2) {
      const exit2 = state.enter("paragraph");
      const subexit = state.enter("phrasing");
      const value = state.containerPhrasing(node2, info2);
      subexit();
      exit2();
      return value;
    }
    const phrasing = (
      /** @type {(node?: unknown) => node is PhrasingContent} */
      convert([
        "break",
        "delete",
        "emphasis",
        "footnote",
        "footnoteReference",
        "image",
        "imageReference",
        "inlineCode",
        "link",
        "linkReference",
        "strong",
        "text"
      ])
    );
    function root$2(node2, _, state, info2) {
      const hasPhrasing = node2.children.some(function(d) {
        return phrasing(d);
      });
      const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
      return fn.call(state, node2, info2);
    }
    function checkStrong(state) {
      const marker = state.options.strong || "*";
      if (marker !== "*" && marker !== "_") {
        throw new Error(
          "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
        );
      }
      return marker;
    }
    strong.peek = strongPeek;
    function strong(node2, _, state, info2) {
      const marker = checkStrong(state);
      const exit2 = state.enter("strong");
      const tracker = state.createTracker(info2);
      let value = tracker.move(marker + marker);
      value += tracker.move(
        state.containerPhrasing(node2, {
          before: value,
          after: marker,
          ...tracker.current()
        })
      );
      value += tracker.move(marker + marker);
      exit2();
      return value;
    }
    function strongPeek(_, _1, state) {
      return state.options.strong || "*";
    }
    function text$1(node2, _, state, info2) {
      return state.safe(node2.value, info2);
    }
    function checkRuleRepetition(state) {
      const repetition = state.options.ruleRepetition || 3;
      if (repetition < 3) {
        throw new Error(
          "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
        );
      }
      return repetition;
    }
    function thematicBreak(_, _1, state) {
      const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
      return state.options.ruleSpaces ? value.slice(0, -1) : value;
    }
    const handle = {
      blockquote,
      break: hardBreak,
      code: code$1,
      definition,
      emphasis,
      hardBreak,
      heading,
      html: html$3,
      image,
      imageReference,
      inlineCode,
      link,
      linkReference,
      list,
      listItem,
      paragraph,
      root: root$2,
      strong,
      text: text$1,
      thematicBreak
    };
    function gfmTableFromMarkdown() {
      return {
        enter: {
          table: enterTable,
          tableData: enterCell,
          tableHeader: enterCell,
          tableRow: enterRow
        },
        exit: {
          codeText: exitCodeText,
          table: exitTable,
          tableData: exit,
          tableHeader: exit,
          tableRow: exit
        }
      };
    }
    function enterTable(token) {
      const align = token._align;
      this.enter(
        {
          type: "table",
          align: align.map(function(d) {
            return d === "none" ? null : d;
          }),
          children: []
        },
        token
      );
      this.data.inTable = true;
    }
    function exitTable(token) {
      this.exit(token);
      this.data.inTable = void 0;
    }
    function enterRow(token) {
      this.enter({ type: "tableRow", children: [] }, token);
    }
    function exit(token) {
      this.exit(token);
    }
    function enterCell(token) {
      this.enter({ type: "tableCell", children: [] }, token);
    }
    function exitCodeText(token) {
      let value = this.resume();
      if (this.data.inTable) {
        value = value.replace(/\\([\\|])/g, replace);
      }
      const node2 = this.stack[this.stack.length - 1];
      ok$1(node2.type === "inlineCode");
      node2.value = value;
      this.exit(token);
    }
    function replace($0, $1) {
      return $1 === "|" ? $1 : $0;
    }
    function gfmTableToMarkdown(options) {
      const settings = options || {};
      const padding = settings.tableCellPadding;
      const alignDelimiters = settings.tablePipeAlign;
      const stringLength = settings.stringLength;
      const around = padding ? " " : "|";
      return {
        unsafe: [
          { character: "\r", inConstruct: "tableCell" },
          { character: "\n", inConstruct: "tableCell" },
          // A pipe, when followed by a tab or space (padding), or a dash or colon
          // (unpadded delimiter row), could result in a table.
          { atBreak: true, character: "|", after: "[	 :-]" },
          // A pipe in a cell must be encoded.
          { character: "|", inConstruct: "tableCell" },
          // A colon must be followed by a dash, in which case it could start a
          // delimiter row.
          { atBreak: true, character: ":", after: "-" },
          // A delimiter row can also start with a dash, when followed by more
          // dashes, a colon, or a pipe.
          // This is a stricter version than the built in check for lists, thematic
          // breaks, and setex heading underlines though:
          // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
          { atBreak: true, character: "-", after: "[:|-]" }
        ],
        handlers: {
          inlineCode: inlineCodeWithTable,
          table: handleTable,
          tableCell: handleTableCell,
          tableRow: handleTableRow
        }
      };
      function handleTable(node2, _, state, info2) {
        return serializeData(handleTableAsData(node2, state, info2), node2.align);
      }
      function handleTableRow(node2, _, state, info2) {
        const row = handleTableRowAsData(node2, state, info2);
        const value = serializeData([row]);
        return value.slice(0, value.indexOf("\n"));
      }
      function handleTableCell(node2, _, state, info2) {
        const exit2 = state.enter("tableCell");
        const subexit = state.enter("phrasing");
        const value = state.containerPhrasing(node2, {
          ...info2,
          before: around,
          after: around
        });
        subexit();
        exit2();
        return value;
      }
      function serializeData(matrix, align) {
        return markdownTable(matrix, {
          align,
          // @ts-expect-error: `markdown-table` types should support `null`.
          alignDelimiters,
          // @ts-expect-error: `markdown-table` types should support `null`.
          padding,
          // @ts-expect-error: `markdown-table` types should support `null`.
          stringLength
        });
      }
      function handleTableAsData(node2, state, info2) {
        const children = node2.children;
        let index2 = -1;
        const result = [];
        const subexit = state.enter("table");
        while (++index2 < children.length) {
          result[index2] = handleTableRowAsData(children[index2], state, info2);
        }
        subexit();
        return result;
      }
      function handleTableRowAsData(node2, state, info2) {
        const children = node2.children;
        let index2 = -1;
        const result = [];
        const subexit = state.enter("tableRow");
        while (++index2 < children.length) {
          result[index2] = handleTableCell(children[index2], node2, state, info2);
        }
        subexit();
        return result;
      }
      function inlineCodeWithTable(node2, parent, state) {
        let value = handle.inlineCode(node2, parent, state);
        if (state.stack.includes("tableCell")) {
          value = value.replace(/\|/g, "\\$&");
        }
        return value;
      }
    }
    function gfmTaskListItemFromMarkdown() {
      return {
        exit: {
          taskListCheckValueChecked: exitCheck,
          taskListCheckValueUnchecked: exitCheck,
          paragraph: exitParagraphWithTaskListItem
        }
      };
    }
    function gfmTaskListItemToMarkdown() {
      return {
        unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
        handlers: { listItem: listItemWithTaskListItem }
      };
    }
    function exitCheck(token) {
      const node2 = this.stack[this.stack.length - 2];
      ok$1(node2.type === "listItem");
      node2.checked = token.type === "taskListCheckValueChecked";
    }
    function exitParagraphWithTaskListItem(token) {
      const parent = this.stack[this.stack.length - 2];
      if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
        const node2 = this.stack[this.stack.length - 1];
        ok$1(node2.type === "paragraph");
        const head = node2.children[0];
        if (head && head.type === "text") {
          const siblings = parent.children;
          let index2 = -1;
          let firstParaghraph;
          while (++index2 < siblings.length) {
            const sibling = siblings[index2];
            if (sibling.type === "paragraph") {
              firstParaghraph = sibling;
              break;
            }
          }
          if (firstParaghraph === node2) {
            head.value = head.value.slice(1);
            if (head.value.length === 0) {
              node2.children.shift();
            } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
              head.position.start.column++;
              head.position.start.offset++;
              node2.position.start = Object.assign({}, head.position.start);
            }
          }
        }
      }
      this.exit(token);
    }
    function listItemWithTaskListItem(node2, parent, state, info2) {
      const head = node2.children[0];
      const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
      const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
      const tracker = state.createTracker(info2);
      if (checkable) {
        tracker.move(checkbox);
      }
      let value = handle.listItem(node2, parent, state, {
        ...info2,
        ...tracker.current()
      });
      if (checkable) {
        value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
      }
      return value;
      function check($0) {
        return $0 + checkbox;
      }
    }
    function gfmFromMarkdown() {
      return [
        gfmAutolinkLiteralFromMarkdown(),
        gfmFootnoteFromMarkdown(),
        gfmStrikethroughFromMarkdown(),
        gfmTableFromMarkdown(),
        gfmTaskListItemFromMarkdown()
      ];
    }
    function gfmToMarkdown(options) {
      return {
        extensions: [
          gfmAutolinkLiteralToMarkdown(),
          gfmFootnoteToMarkdown(),
          gfmStrikethroughToMarkdown(),
          gfmTableToMarkdown(options),
          gfmTaskListItemToMarkdown()
        ]
      };
    }
    const wwwPrefix = {
      tokenize: tokenizeWwwPrefix,
      partial: true
    };
    const domain = {
      tokenize: tokenizeDomain,
      partial: true
    };
    const path = {
      tokenize: tokenizePath,
      partial: true
    };
    const trail = {
      tokenize: tokenizeTrail,
      partial: true
    };
    const emailDomainDotTrail = {
      tokenize: tokenizeEmailDomainDotTrail,
      partial: true
    };
    const wwwAutolink = {
      tokenize: tokenizeWwwAutolink,
      previous: previousWww
    };
    const protocolAutolink = {
      tokenize: tokenizeProtocolAutolink,
      previous: previousProtocol
    };
    const emailAutolink = {
      tokenize: tokenizeEmailAutolink,
      previous: previousEmail
    };
    const text = {};
    function gfmAutolinkLiteral() {
      return {
        text
      };
    }
    let code = 48;
    while (code < 123) {
      text[code] = emailAutolink;
      code++;
      if (code === 58)
        code = 65;
      else if (code === 91)
        code = 97;
    }
    text[43] = emailAutolink;
    text[45] = emailAutolink;
    text[46] = emailAutolink;
    text[95] = emailAutolink;
    text[72] = [emailAutolink, protocolAutolink];
    text[104] = [emailAutolink, protocolAutolink];
    text[87] = [emailAutolink, wwwAutolink];
    text[119] = [emailAutolink, wwwAutolink];
    function tokenizeEmailAutolink(effects, ok2, nok) {
      const self2 = this;
      let dot;
      let data2;
      return start;
      function start(code2) {
        if (!gfmAtext(code2) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
          return nok(code2);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkEmail");
        return atext(code2);
      }
      function atext(code2) {
        if (gfmAtext(code2)) {
          effects.consume(code2);
          return atext;
        }
        if (code2 === 64) {
          effects.consume(code2);
          return emailDomain;
        }
        return nok(code2);
      }
      function emailDomain(code2) {
        if (code2 === 46) {
          return effects.check(
            emailDomainDotTrail,
            emailDomainAfter,
            emailDomainDot
          )(code2);
        }
        if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
          data2 = true;
          effects.consume(code2);
          return emailDomain;
        }
        return emailDomainAfter(code2);
      }
      function emailDomainDot(code2) {
        effects.consume(code2);
        dot = true;
        return emailDomain;
      }
      function emailDomainAfter(code2) {
        if (data2 && dot && asciiAlpha(self2.previous)) {
          effects.exit("literalAutolinkEmail");
          effects.exit("literalAutolink");
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    function tokenizeWwwAutolink(effects, ok2, nok) {
      const self2 = this;
      return wwwStart;
      function wwwStart(code2) {
        if (code2 !== 87 && code2 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
          return nok(code2);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkWww");
        return effects.check(
          wwwPrefix,
          effects.attempt(domain, effects.attempt(path, wwwAfter), nok),
          nok
        )(code2);
      }
      function wwwAfter(code2) {
        effects.exit("literalAutolinkWww");
        effects.exit("literalAutolink");
        return ok2(code2);
      }
    }
    function tokenizeProtocolAutolink(effects, ok2, nok) {
      const self2 = this;
      let buffer = "";
      let seen = false;
      return protocolStart;
      function protocolStart(code2) {
        if ((code2 === 72 || code2 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
          effects.enter("literalAutolink");
          effects.enter("literalAutolinkHttp");
          buffer += String.fromCodePoint(code2);
          effects.consume(code2);
          return protocolPrefixInside;
        }
        return nok(code2);
      }
      function protocolPrefixInside(code2) {
        if (asciiAlpha(code2) && buffer.length < 5) {
          buffer += String.fromCodePoint(code2);
          effects.consume(code2);
          return protocolPrefixInside;
        }
        if (code2 === 58) {
          const protocol = buffer.toLowerCase();
          if (protocol === "http" || protocol === "https") {
            effects.consume(code2);
            return protocolSlashesInside;
          }
        }
        return nok(code2);
      }
      function protocolSlashesInside(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          if (seen) {
            return afterProtocol;
          }
          seen = true;
          return protocolSlashesInside;
        }
        return nok(code2);
      }
      function afterProtocol(code2) {
        return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code2);
      }
      function protocolAfter(code2) {
        effects.exit("literalAutolinkHttp");
        effects.exit("literalAutolink");
        return ok2(code2);
      }
    }
    function tokenizeWwwPrefix(effects, ok2, nok) {
      let size = 0;
      return wwwPrefixInside;
      function wwwPrefixInside(code2) {
        if ((code2 === 87 || code2 === 119) && size < 3) {
          size++;
          effects.consume(code2);
          return wwwPrefixInside;
        }
        if (code2 === 46 && size === 3) {
          effects.consume(code2);
          return wwwPrefixAfter;
        }
        return nok(code2);
      }
      function wwwPrefixAfter(code2) {
        return code2 === null ? nok(code2) : ok2(code2);
      }
    }
    function tokenizeDomain(effects, ok2, nok) {
      let underscoreInLastSegment;
      let underscoreInLastLastSegment;
      let seen;
      return domainInside;
      function domainInside(code2) {
        if (code2 === 46 || code2 === 95) {
          return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
        }
        if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
          return domainAfter(code2);
        }
        seen = true;
        effects.consume(code2);
        return domainInside;
      }
      function domainAtPunctuation(code2) {
        if (code2 === 95) {
          underscoreInLastSegment = true;
        } else {
          underscoreInLastLastSegment = underscoreInLastSegment;
          underscoreInLastSegment = void 0;
        }
        effects.consume(code2);
        return domainInside;
      }
      function domainAfter(code2) {
        if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
          return nok(code2);
        }
        return ok2(code2);
      }
    }
    function tokenizePath(effects, ok2) {
      let sizeOpen = 0;
      let sizeClose = 0;
      return pathInside;
      function pathInside(code2) {
        if (code2 === 40) {
          sizeOpen++;
          effects.consume(code2);
          return pathInside;
        }
        if (code2 === 41 && sizeClose < sizeOpen) {
          return pathAtPunctuation(code2);
        }
        if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
          return effects.check(trail, ok2, pathAtPunctuation)(code2);
        }
        if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
          return ok2(code2);
        }
        effects.consume(code2);
        return pathInside;
      }
      function pathAtPunctuation(code2) {
        if (code2 === 41) {
          sizeClose++;
        }
        effects.consume(code2);
        return pathInside;
      }
    }
    function tokenizeTrail(effects, ok2, nok) {
      return trail2;
      function trail2(code2) {
        if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
          effects.consume(code2);
          return trail2;
        }
        if (code2 === 38) {
          effects.consume(code2);
          return trailCharRefStart;
        }
        if (code2 === 93) {
          effects.consume(code2);
          return trailBracketAfter;
        }
        if (
          // `<` is an end.
          code2 === 60 || // So is whitespace.
          code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)
        ) {
          return ok2(code2);
        }
        return nok(code2);
      }
      function trailBracketAfter(code2) {
        if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
          return ok2(code2);
        }
        return trail2(code2);
      }
      function trailCharRefStart(code2) {
        return asciiAlpha(code2) ? trailCharRefInside(code2) : nok(code2);
      }
      function trailCharRefInside(code2) {
        if (code2 === 59) {
          effects.consume(code2);
          return trail2;
        }
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return trailCharRefInside;
        }
        return nok(code2);
      }
    }
    function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.consume(code2);
        return after;
      }
      function after(code2) {
        return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
      }
    }
    function previousWww(code2) {
      return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
    }
    function previousProtocol(code2) {
      return !asciiAlpha(code2);
    }
    function previousEmail(code2) {
      return !(code2 === 47 || gfmAtext(code2));
    }
    function gfmAtext(code2) {
      return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
    }
    function previousUnbalanced(events) {
      let index2 = events.length;
      let result = false;
      while (index2--) {
        const token = events[index2][1];
        if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
          result = true;
          break;
        }
        if (token._gfmAutolinkLiteralWalkedInto) {
          result = false;
          break;
        }
      }
      if (events.length > 0 && !result) {
        events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
      }
      return result;
    }
    const indent = {
      tokenize: tokenizeIndent,
      partial: true
    };
    function gfmFootnote() {
      return {
        document: {
          [91]: {
            tokenize: tokenizeDefinitionStart,
            continuation: {
              tokenize: tokenizeDefinitionContinuation
            },
            exit: gfmFootnoteDefinitionEnd
          }
        },
        text: {
          [91]: {
            tokenize: tokenizeGfmFootnoteCall
          },
          [93]: {
            add: "after",
            tokenize: tokenizePotentialGfmFootnoteCall,
            resolveTo: resolveToPotentialGfmFootnoteCall
          }
        }
      };
    }
    function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
      const self2 = this;
      let index2 = self2.events.length;
      const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
      let labelStart;
      while (index2--) {
        const token = self2.events[index2][1];
        if (token.type === "labelImage") {
          labelStart = token;
          break;
        }
        if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
          break;
        }
      }
      return start;
      function start(code2) {
        if (!labelStart || !labelStart._balanced) {
          return nok(code2);
        }
        const id2 = normalizeIdentifier(
          self2.sliceSerialize({
            start: labelStart.end,
            end: self2.now()
          })
        );
        if (id2.codePointAt(0) !== 94 || !defined.includes(id2.slice(1))) {
          return nok(code2);
        }
        effects.enter("gfmFootnoteCallLabelMarker");
        effects.consume(code2);
        effects.exit("gfmFootnoteCallLabelMarker");
        return ok2(code2);
      }
    }
    function resolveToPotentialGfmFootnoteCall(events, context) {
      let index2 = events.length;
      while (index2--) {
        if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
          events[index2][1];
          break;
        }
      }
      events[index2 + 1][1].type = "data";
      events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
      const call = {
        type: "gfmFootnoteCall",
        start: Object.assign({}, events[index2 + 3][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
      };
      const marker = {
        type: "gfmFootnoteCallMarker",
        start: Object.assign({}, events[index2 + 3][1].end),
        end: Object.assign({}, events[index2 + 3][1].end)
      };
      marker.end.column++;
      marker.end.offset++;
      marker.end._bufferIndex++;
      const string2 = {
        type: "gfmFootnoteCallString",
        start: Object.assign({}, marker.end),
        end: Object.assign({}, events[events.length - 1][1].start)
      };
      const chunk = {
        type: "chunkString",
        contentType: "string",
        start: Object.assign({}, string2.start),
        end: Object.assign({}, string2.end)
      };
      const replacement = [
        // Take the `labelImageMarker` (now `data`, the `!`)
        events[index2 + 1],
        events[index2 + 2],
        ["enter", call, context],
        // The `[`
        events[index2 + 3],
        events[index2 + 4],
        // The `^`.
        ["enter", marker, context],
        ["exit", marker, context],
        // Everything in between.
        ["enter", string2, context],
        ["enter", chunk, context],
        ["exit", chunk, context],
        ["exit", string2, context],
        // The ending (`]`, properly parsed and labelled).
        events[events.length - 2],
        events[events.length - 1],
        ["exit", call, context]
      ];
      events.splice(index2, events.length - index2 + 1, ...replacement);
      return events;
    }
    function tokenizeGfmFootnoteCall(effects, ok2, nok) {
      const self2 = this;
      const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
      let size = 0;
      let data2;
      return start;
      function start(code2) {
        effects.enter("gfmFootnoteCall");
        effects.enter("gfmFootnoteCallLabelMarker");
        effects.consume(code2);
        effects.exit("gfmFootnoteCallLabelMarker");
        return callStart;
      }
      function callStart(code2) {
        if (code2 !== 94)
          return nok(code2);
        effects.enter("gfmFootnoteCallMarker");
        effects.consume(code2);
        effects.exit("gfmFootnoteCallMarker");
        effects.enter("gfmFootnoteCallString");
        effects.enter("chunkString").contentType = "string";
        return callData;
      }
      function callData(code2) {
        if (
          // Too long.
          size > 999 || // Closing brace with nothing.
          code2 === 93 && !data2 || // Space or tab is not supported by GFM for some reason.
          // `\n` and `[` not being supported makes sense.
          code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)
        ) {
          return nok(code2);
        }
        if (code2 === 93) {
          effects.exit("chunkString");
          const token = effects.exit("gfmFootnoteCallString");
          if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
            return nok(code2);
          }
          effects.enter("gfmFootnoteCallLabelMarker");
          effects.consume(code2);
          effects.exit("gfmFootnoteCallLabelMarker");
          effects.exit("gfmFootnoteCall");
          return ok2;
        }
        if (!markdownLineEndingOrSpace(code2)) {
          data2 = true;
        }
        size++;
        effects.consume(code2);
        return code2 === 92 ? callEscape : callData;
      }
      function callEscape(code2) {
        if (code2 === 91 || code2 === 92 || code2 === 93) {
          effects.consume(code2);
          size++;
          return callData;
        }
        return callData(code2);
      }
    }
    function tokenizeDefinitionStart(effects, ok2, nok) {
      const self2 = this;
      const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
      let identifier;
      let size = 0;
      let data2;
      return start;
      function start(code2) {
        effects.enter("gfmFootnoteDefinition")._container = true;
        effects.enter("gfmFootnoteDefinitionLabel");
        effects.enter("gfmFootnoteDefinitionLabelMarker");
        effects.consume(code2);
        effects.exit("gfmFootnoteDefinitionLabelMarker");
        return labelAtMarker;
      }
      function labelAtMarker(code2) {
        if (code2 === 94) {
          effects.enter("gfmFootnoteDefinitionMarker");
          effects.consume(code2);
          effects.exit("gfmFootnoteDefinitionMarker");
          effects.enter("gfmFootnoteDefinitionLabelString");
          effects.enter("chunkString").contentType = "string";
          return labelInside;
        }
        return nok(code2);
      }
      function labelInside(code2) {
        if (
          // Too long.
          size > 999 || // Closing brace with nothing.
          code2 === 93 && !data2 || // Space or tab is not supported by GFM for some reason.
          // `\n` and `[` not being supported makes sense.
          code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)
        ) {
          return nok(code2);
        }
        if (code2 === 93) {
          effects.exit("chunkString");
          const token = effects.exit("gfmFootnoteDefinitionLabelString");
          identifier = normalizeIdentifier(self2.sliceSerialize(token));
          effects.enter("gfmFootnoteDefinitionLabelMarker");
          effects.consume(code2);
          effects.exit("gfmFootnoteDefinitionLabelMarker");
          effects.exit("gfmFootnoteDefinitionLabel");
          return labelAfter;
        }
        if (!markdownLineEndingOrSpace(code2)) {
          data2 = true;
        }
        size++;
        effects.consume(code2);
        return code2 === 92 ? labelEscape : labelInside;
      }
      function labelEscape(code2) {
        if (code2 === 91 || code2 === 92 || code2 === 93) {
          effects.consume(code2);
          size++;
          return labelInside;
        }
        return labelInside(code2);
      }
      function labelAfter(code2) {
        if (code2 === 58) {
          effects.enter("definitionMarker");
          effects.consume(code2);
          effects.exit("definitionMarker");
          if (!defined.includes(identifier)) {
            defined.push(identifier);
          }
          return factorySpace(
            effects,
            whitespaceAfter,
            "gfmFootnoteDefinitionWhitespace"
          );
        }
        return nok(code2);
      }
      function whitespaceAfter(code2) {
        return ok2(code2);
      }
    }
    function tokenizeDefinitionContinuation(effects, ok2, nok) {
      return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
    }
    function gfmFootnoteDefinitionEnd(effects) {
      effects.exit("gfmFootnoteDefinition");
    }
    function tokenizeIndent(effects, ok2, nok) {
      const self2 = this;
      return factorySpace(
        effects,
        afterPrefix,
        "gfmFootnoteDefinitionIndent",
        4 + 1
      );
      function afterPrefix(code2) {
        const tail = self2.events[self2.events.length - 1];
        return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
      }
    }
    function gfmStrikethrough(options) {
      const options_ = options || {};
      let single = options_.singleTilde;
      const tokenizer = {
        tokenize: tokenizeStrikethrough,
        resolveAll: resolveAllStrikethrough
      };
      if (single === null || single === void 0) {
        single = true;
      }
      return {
        text: {
          [126]: tokenizer
        },
        insideSpan: {
          null: [tokenizer]
        },
        attentionMarkers: {
          null: [126]
        }
      };
      function resolveAllStrikethrough(events, context) {
        let index2 = -1;
        while (++index2 < events.length) {
          if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
            let open = index2;
            while (open--) {
              if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
              events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
                events[index2][1].type = "strikethroughSequence";
                events[open][1].type = "strikethroughSequence";
                const strikethrough2 = {
                  type: "strikethrough",
                  start: Object.assign({}, events[open][1].start),
                  end: Object.assign({}, events[index2][1].end)
                };
                const text2 = {
                  type: "strikethroughText",
                  start: Object.assign({}, events[open][1].end),
                  end: Object.assign({}, events[index2][1].start)
                };
                const nextEvents = [
                  ["enter", strikethrough2, context],
                  ["enter", events[open][1], context],
                  ["exit", events[open][1], context],
                  ["enter", text2, context]
                ];
                const insideSpan2 = context.parser.constructs.insideSpan.null;
                if (insideSpan2) {
                  splice$1(
                    nextEvents,
                    nextEvents.length,
                    0,
                    resolveAll(insideSpan2, events.slice(open + 1, index2), context)
                  );
                }
                splice$1(nextEvents, nextEvents.length, 0, [
                  ["exit", text2, context],
                  ["enter", events[index2][1], context],
                  ["exit", events[index2][1], context],
                  ["exit", strikethrough2, context]
                ]);
                splice$1(events, open - 1, index2 - open + 3, nextEvents);
                index2 = open + nextEvents.length - 2;
                break;
              }
            }
          }
        }
        index2 = -1;
        while (++index2 < events.length) {
          if (events[index2][1].type === "strikethroughSequenceTemporary") {
            events[index2][1].type = "data";
          }
        }
        return events;
      }
      function tokenizeStrikethrough(effects, ok2, nok) {
        const previous2 = this.previous;
        const events = this.events;
        let size = 0;
        return start;
        function start(code2) {
          if (previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
            return nok(code2);
          }
          effects.enter("strikethroughSequenceTemporary");
          return more(code2);
        }
        function more(code2) {
          const before = classifyCharacter(previous2);
          if (code2 === 126) {
            if (size > 1)
              return nok(code2);
            effects.consume(code2);
            size++;
            return more;
          }
          if (size < 2 && !single)
            return nok(code2);
          const token = effects.exit("strikethroughSequenceTemporary");
          const after = classifyCharacter(code2);
          token._open = !after || after === 2 && Boolean(before);
          token._close = !before || before === 2 && Boolean(after);
          return ok2(code2);
        }
      }
    }
    class EditMap {
      /**
       * Create a new edit map.
       */
      constructor() {
        this.map = [];
      }
      /**
       * Create an edit: a remove and/or add at a certain place.
       *
       * @param {number} index
       * @param {number} remove
       * @param {Array<Event>} add
       * @returns {undefined}
       */
      add(index2, remove, add) {
        addImpl(this, index2, remove, add);
      }
      // To do: add this when moving to `micromark`.
      // /**
      //  * Create an edit: but insert `add` before existing additions.
      //  *
      //  * @param {number} index
      //  * @param {number} remove
      //  * @param {Array<Event>} add
      //  * @returns {undefined}
      //  */
      // addBefore(index, remove, add) {
      //   addImpl(this, index, remove, add, true)
      // }
      /**
       * Done, change the events.
       *
       * @param {Array<Event>} events
       * @returns {undefined}
       */
      consume(events) {
        this.map.sort(function(a, b) {
          return a[0] - b[0];
        });
        if (this.map.length === 0) {
          return;
        }
        let index2 = this.map.length;
        const vecs = [];
        while (index2 > 0) {
          index2 -= 1;
          vecs.push(
            events.slice(this.map[index2][0] + this.map[index2][1]),
            this.map[index2][2]
          );
          events.length = this.map[index2][0];
        }
        vecs.push([...events]);
        events.length = 0;
        let slice = vecs.pop();
        while (slice) {
          events.push(...slice);
          slice = vecs.pop();
        }
        this.map.length = 0;
      }
    }
    function addImpl(editMap, at, remove, add) {
      let index2 = 0;
      if (remove === 0 && add.length === 0) {
        return;
      }
      while (index2 < editMap.map.length) {
        if (editMap.map[index2][0] === at) {
          editMap.map[index2][1] += remove;
          editMap.map[index2][2].push(...add);
          return;
        }
        index2 += 1;
      }
      editMap.map.push([at, remove, add]);
    }
    function gfmTableAlign(events, index2) {
      let inDelimiterRow = false;
      const align = [];
      while (index2 < events.length) {
        const event = events[index2];
        if (inDelimiterRow) {
          if (event[0] === "enter") {
            if (event[1].type === "tableContent") {
              align.push(
                events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
              );
            }
          } else if (event[1].type === "tableContent") {
            if (events[index2 - 1][1].type === "tableDelimiterMarker") {
              const alignIndex = align.length - 1;
              align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
            }
          } else if (event[1].type === "tableDelimiterRow") {
            break;
          }
        } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
          inDelimiterRow = true;
        }
        index2 += 1;
      }
      return align;
    }
    function gfmTable() {
      return {
        flow: {
          null: {
            tokenize: tokenizeTable,
            resolveAll: resolveTable
          }
        }
      };
    }
    function tokenizeTable(effects, ok2, nok) {
      const self2 = this;
      let size = 0;
      let sizeB = 0;
      let seen;
      return start;
      function start(code2) {
        let index2 = self2.events.length - 1;
        while (index2 > -1) {
          const type = self2.events[index2][1].type;
          if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
          type === "linePrefix")
            index2--;
          else
            break;
        }
        const tail = index2 > -1 ? self2.events[index2][1].type : null;
        const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
        if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
          return nok(code2);
        }
        return next(code2);
      }
      function headRowBefore(code2) {
        effects.enter("tableHead");
        effects.enter("tableRow");
        return headRowStart(code2);
      }
      function headRowStart(code2) {
        if (code2 === 124) {
          return headRowBreak(code2);
        }
        seen = true;
        sizeB += 1;
        return headRowBreak(code2);
      }
      function headRowBreak(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (markdownLineEnding(code2)) {
          if (sizeB > 1) {
            sizeB = 0;
            self2.interrupt = true;
            effects.exit("tableRow");
            effects.enter("lineEnding");
            effects.consume(code2);
            effects.exit("lineEnding");
            return headDelimiterStart;
          }
          return nok(code2);
        }
        if (markdownSpace(code2)) {
          return factorySpace(effects, headRowBreak, "whitespace")(code2);
        }
        sizeB += 1;
        if (seen) {
          seen = false;
          size += 1;
        }
        if (code2 === 124) {
          effects.enter("tableCellDivider");
          effects.consume(code2);
          effects.exit("tableCellDivider");
          seen = true;
          return headRowBreak;
        }
        effects.enter("data");
        return headRowData(code2);
      }
      function headRowData(code2) {
        if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
          effects.exit("data");
          return headRowBreak(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? headRowEscape : headRowData;
      }
      function headRowEscape(code2) {
        if (code2 === 92 || code2 === 124) {
          effects.consume(code2);
          return headRowData;
        }
        return headRowData(code2);
      }
      function headDelimiterStart(code2) {
        self2.interrupt = false;
        if (self2.parser.lazy[self2.now().line]) {
          return nok(code2);
        }
        effects.enter("tableDelimiterRow");
        seen = false;
        if (markdownSpace(code2)) {
          return factorySpace(
            effects,
            headDelimiterBefore,
            "linePrefix",
            self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
          )(code2);
        }
        return headDelimiterBefore(code2);
      }
      function headDelimiterBefore(code2) {
        if (code2 === 45 || code2 === 58) {
          return headDelimiterValueBefore(code2);
        }
        if (code2 === 124) {
          seen = true;
          effects.enter("tableCellDivider");
          effects.consume(code2);
          effects.exit("tableCellDivider");
          return headDelimiterCellBefore;
        }
        return headDelimiterNok(code2);
      }
      function headDelimiterCellBefore(code2) {
        if (markdownSpace(code2)) {
          return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code2);
        }
        return headDelimiterValueBefore(code2);
      }
      function headDelimiterValueBefore(code2) {
        if (code2 === 58) {
          sizeB += 1;
          seen = true;
          effects.enter("tableDelimiterMarker");
          effects.consume(code2);
          effects.exit("tableDelimiterMarker");
          return headDelimiterLeftAlignmentAfter;
        }
        if (code2 === 45) {
          sizeB += 1;
          return headDelimiterLeftAlignmentAfter(code2);
        }
        if (code2 === null || markdownLineEnding(code2)) {
          return headDelimiterCellAfter(code2);
        }
        return headDelimiterNok(code2);
      }
      function headDelimiterLeftAlignmentAfter(code2) {
        if (code2 === 45) {
          effects.enter("tableDelimiterFiller");
          return headDelimiterFiller(code2);
        }
        return headDelimiterNok(code2);
      }
      function headDelimiterFiller(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return headDelimiterFiller;
        }
        if (code2 === 58) {
          seen = true;
          effects.exit("tableDelimiterFiller");
          effects.enter("tableDelimiterMarker");
          effects.consume(code2);
          effects.exit("tableDelimiterMarker");
          return headDelimiterRightAlignmentAfter;
        }
        effects.exit("tableDelimiterFiller");
        return headDelimiterRightAlignmentAfter(code2);
      }
      function headDelimiterRightAlignmentAfter(code2) {
        if (markdownSpace(code2)) {
          return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code2);
        }
        return headDelimiterCellAfter(code2);
      }
      function headDelimiterCellAfter(code2) {
        if (code2 === 124) {
          return headDelimiterBefore(code2);
        }
        if (code2 === null || markdownLineEnding(code2)) {
          if (!seen || size !== sizeB) {
            return headDelimiterNok(code2);
          }
          effects.exit("tableDelimiterRow");
          effects.exit("tableHead");
          return ok2(code2);
        }
        return headDelimiterNok(code2);
      }
      function headDelimiterNok(code2) {
        return nok(code2);
      }
      function bodyRowStart(code2) {
        effects.enter("tableRow");
        return bodyRowBreak(code2);
      }
      function bodyRowBreak(code2) {
        if (code2 === 124) {
          effects.enter("tableCellDivider");
          effects.consume(code2);
          effects.exit("tableCellDivider");
          return bodyRowBreak;
        }
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("tableRow");
          return ok2(code2);
        }
        if (markdownSpace(code2)) {
          return factorySpace(effects, bodyRowBreak, "whitespace")(code2);
        }
        effects.enter("data");
        return bodyRowData(code2);
      }
      function bodyRowData(code2) {
        if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
          effects.exit("data");
          return bodyRowBreak(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? bodyRowEscape : bodyRowData;
      }
      function bodyRowEscape(code2) {
        if (code2 === 92 || code2 === 124) {
          effects.consume(code2);
          return bodyRowData;
        }
        return bodyRowData(code2);
      }
    }
    function resolveTable(events, context) {
      let index2 = -1;
      let inFirstCellAwaitingPipe = true;
      let rowKind = 0;
      let lastCell = [0, 0, 0, 0];
      let cell = [0, 0, 0, 0];
      let afterHeadAwaitingFirstBodyRow = false;
      let lastTableEnd = 0;
      let currentTable;
      let currentBody;
      let currentCell;
      const map2 = new EditMap();
      while (++index2 < events.length) {
        const event = events[index2];
        const token = event[1];
        if (event[0] === "enter") {
          if (token.type === "tableHead") {
            afterHeadAwaitingFirstBodyRow = false;
            if (lastTableEnd !== 0) {
              flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
              currentBody = void 0;
              lastTableEnd = 0;
            }
            currentTable = {
              type: "table",
              start: Object.assign({}, token.start),
              // Note: correct end is set later.
              end: Object.assign({}, token.end)
            };
            map2.add(index2, 0, [["enter", currentTable, context]]);
          } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
            inFirstCellAwaitingPipe = true;
            currentCell = void 0;
            lastCell = [0, 0, 0, 0];
            cell = [0, index2 + 1, 0, 0];
            if (afterHeadAwaitingFirstBodyRow) {
              afterHeadAwaitingFirstBodyRow = false;
              currentBody = {
                type: "tableBody",
                start: Object.assign({}, token.start),
                // Note: correct end is set later.
                end: Object.assign({}, token.end)
              };
              map2.add(index2, 0, [["enter", currentBody, context]]);
            }
            rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
          } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
            inFirstCellAwaitingPipe = false;
            if (cell[2] === 0) {
              if (lastCell[1] !== 0) {
                cell[0] = cell[1];
                currentCell = flushCell(
                  map2,
                  context,
                  lastCell,
                  rowKind,
                  void 0,
                  currentCell
                );
                lastCell = [0, 0, 0, 0];
              }
              cell[2] = index2;
            }
          } else if (token.type === "tableCellDivider") {
            if (inFirstCellAwaitingPipe) {
              inFirstCellAwaitingPipe = false;
            } else {
              if (lastCell[1] !== 0) {
                cell[0] = cell[1];
                currentCell = flushCell(
                  map2,
                  context,
                  lastCell,
                  rowKind,
                  void 0,
                  currentCell
                );
              }
              lastCell = cell;
              cell = [lastCell[1], index2, 0, 0];
            }
          }
        } else if (token.type === "tableHead") {
          afterHeadAwaitingFirstBodyRow = true;
          lastTableEnd = index2;
        } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
          lastTableEnd = index2;
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map2,
              context,
              lastCell,
              rowKind,
              index2,
              currentCell
            );
          } else if (cell[1] !== 0) {
            currentCell = flushCell(map2, context, cell, rowKind, index2, currentCell);
          }
          rowKind = 0;
        } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
          cell[3] = index2;
        }
      }
      if (lastTableEnd !== 0) {
        flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
      }
      map2.consume(context.events);
      index2 = -1;
      while (++index2 < context.events.length) {
        const event = context.events[index2];
        if (event[0] === "enter" && event[1].type === "table") {
          event[1]._align = gfmTableAlign(context.events, index2);
        }
      }
      return events;
    }
    function flushCell(map2, context, range, rowKind, rowEnd, previousCell) {
      const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
      const valueName = "tableContent";
      if (range[0] !== 0) {
        previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
        map2.add(range[0], 0, [["exit", previousCell, context]]);
      }
      const now = getPoint(context.events, range[1]);
      previousCell = {
        type: groupName,
        start: Object.assign({}, now),
        // Note: correct end is set later.
        end: Object.assign({}, now)
      };
      map2.add(range[1], 0, [["enter", previousCell, context]]);
      if (range[2] !== 0) {
        const relatedStart = getPoint(context.events, range[2]);
        const relatedEnd = getPoint(context.events, range[3]);
        const valueToken = {
          type: valueName,
          start: Object.assign({}, relatedStart),
          end: Object.assign({}, relatedEnd)
        };
        map2.add(range[2], 0, [["enter", valueToken, context]]);
        if (rowKind !== 2) {
          const start = context.events[range[2]];
          const end = context.events[range[3]];
          start[1].end = Object.assign({}, end[1].end);
          start[1].type = "chunkText";
          start[1].contentType = "text";
          if (range[3] > range[2] + 1) {
            const a = range[2] + 1;
            const b = range[3] - range[2] - 1;
            map2.add(a, b, []);
          }
        }
        map2.add(range[3] + 1, 0, [["exit", valueToken, context]]);
      }
      if (rowEnd !== void 0) {
        previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
        map2.add(rowEnd, 0, [["exit", previousCell, context]]);
        previousCell = void 0;
      }
      return previousCell;
    }
    function flushTableEnd(map2, context, index2, table2, tableBody) {
      const exits = [];
      const related = getPoint(context.events, index2);
      if (tableBody) {
        tableBody.end = Object.assign({}, related);
        exits.push(["exit", tableBody, context]);
      }
      table2.end = Object.assign({}, related);
      exits.push(["exit", table2, context]);
      map2.add(index2 + 1, 0, exits);
    }
    function getPoint(events, index2) {
      const event = events[index2];
      const side = event[0] === "enter" ? "start" : "end";
      return event[1][side];
    }
    const tasklistCheck = {
      tokenize: tokenizeTasklistCheck
    };
    function gfmTaskListItem() {
      return {
        text: {
          [91]: tasklistCheck
        }
      };
    }
    function tokenizeTasklistCheck(effects, ok2, nok) {
      const self2 = this;
      return open;
      function open(code2) {
        if (
          // Exit if there’s stuff before.
          self2.previous !== null || // Exit if not in the first content that is the first child of a list
          // item.
          !self2._gfmTasklistFirstContentOfListItem
        ) {
          return nok(code2);
        }
        effects.enter("taskListCheck");
        effects.enter("taskListCheckMarker");
        effects.consume(code2);
        effects.exit("taskListCheckMarker");
        return inside;
      }
      function inside(code2) {
        if (markdownLineEndingOrSpace(code2)) {
          effects.enter("taskListCheckValueUnchecked");
          effects.consume(code2);
          effects.exit("taskListCheckValueUnchecked");
          return close;
        }
        if (code2 === 88 || code2 === 120) {
          effects.enter("taskListCheckValueChecked");
          effects.consume(code2);
          effects.exit("taskListCheckValueChecked");
          return close;
        }
        return nok(code2);
      }
      function close(code2) {
        if (code2 === 93) {
          effects.enter("taskListCheckMarker");
          effects.consume(code2);
          effects.exit("taskListCheckMarker");
          effects.exit("taskListCheck");
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        if (markdownLineEnding(code2)) {
          return ok2(code2);
        }
        if (markdownSpace(code2)) {
          return effects.check(
            {
              tokenize: spaceThenNonSpace
            },
            ok2,
            nok
          )(code2);
        }
        return nok(code2);
      }
    }
    function spaceThenNonSpace(effects, ok2, nok) {
      return factorySpace(effects, after, "whitespace");
      function after(code2) {
        return code2 === null ? nok(code2) : ok2(code2);
      }
    }
    function gfm(options) {
      return combineExtensions([
        gfmAutolinkLiteral(),
        gfmFootnote(),
        gfmStrikethrough(options),
        gfmTable(),
        gfmTaskListItem()
      ]);
    }
    const emptyOptions = {};
    function remarkGfm(options) {
      const self2 = (
        /** @type {Processor} */
        this
      );
      const settings = options || emptyOptions;
      const data2 = self2.data();
      const micromarkExtensions = data2.micromarkExtensions || (data2.micromarkExtensions = []);
      const fromMarkdownExtensions = data2.fromMarkdownExtensions || (data2.fromMarkdownExtensions = []);
      const toMarkdownExtensions = data2.toMarkdownExtensions || (data2.toMarkdownExtensions = []);
      micromarkExtensions.push(gfm(settings));
      fromMarkdownExtensions.push(gfmFromMarkdown());
      toMarkdownExtensions.push(gfmToMarkdown(settings));
    }
    function _objectWithoutPropertiesLoose$1(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose$1(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles$1(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray$1(arr);
    }
    function _iterableToArray$1(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray$1(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray$1(o, minLen);
    }
    function _nonIterableSpread$1() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray$1(arr) {
      return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
    }
    function _typeof$4(o) {
      "@babel/helpers - typeof";
      return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof$4(o);
    }
    function _toPrimitive$1(input, hint) {
      if (_typeof$4(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof$4(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey$1(arg) {
      var key = _toPrimitive$1(arg, "string");
      return _typeof$4(key) === "symbol" ? key : String(key);
    }
    function _defineProperty$1(obj, key, value) {
      key = _toPropertyKey$1(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _extends$3() {
      _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$3.apply(this, arguments);
    }
    function ownKeys$1(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread$1(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
          _defineProperty$1(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function powerSetPermutations(arr) {
      var arrLength = arr.length;
      if (arrLength === 0 || arrLength === 1)
        return arr;
      if (arrLength === 2) {
        return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
      }
      if (arrLength === 3) {
        return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
      }
      if (arrLength >= 4) {
        return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
      }
    }
    var classNameCombinations = {};
    function getClassNameCombinations(classNames) {
      if (classNames.length === 0 || classNames.length === 1)
        return classNames;
      var key = classNames.join(".");
      if (!classNameCombinations[key]) {
        classNameCombinations[key] = powerSetPermutations(classNames);
      }
      return classNameCombinations[key];
    }
    function createStyleObject(classNames) {
      var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var stylesheet = arguments.length > 2 ? arguments[2] : void 0;
      var nonTokenClassNames = classNames.filter(function(className) {
        return className !== "token";
      });
      var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
      return classNamesCombinations.reduce(function(styleObject, className) {
        return _objectSpread$1(_objectSpread$1({}, styleObject), stylesheet[className]);
      }, elementStyle);
    }
    function createClassNameString(classNames) {
      return classNames.join(" ");
    }
    function createChildren(stylesheet, useInlineStyles) {
      var childrenCount = 0;
      return function(children) {
        childrenCount += 1;
        return children.map(function(child, i) {
          return createElement({
            node: child,
            stylesheet,
            useInlineStyles,
            key: "code-segment-".concat(childrenCount, "-").concat(i)
          });
        });
      };
    }
    function createElement(_ref) {
      var node2 = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style2 = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key;
      var properties = node2.properties, type = node2.type, TagName = node2.tagName, value = node2.value;
      if (type === "text") {
        return value;
      } else if (TagName) {
        var childrenCreator = createChildren(stylesheet, useInlineStyles);
        var props;
        if (!useInlineStyles) {
          props = _objectSpread$1(_objectSpread$1({}, properties), {}, {
            className: createClassNameString(properties.className)
          });
        } else {
          var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
            selector.split(".").forEach(function(className2) {
              if (!classes.includes(className2))
                classes.push(className2);
            });
            return classes;
          }, []);
          var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
          var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
            return !allStylesheetSelectors.includes(className2);
          }));
          props = _objectSpread$1(_objectSpread$1({}, properties), {}, {
            className: createClassNameString(className) || void 0,
            style: createStyleObject(properties.className, Object.assign({}, properties.style, style2), stylesheet)
          });
        }
        var children = childrenCreator(node2.children);
        return /* @__PURE__ */ React.createElement(TagName, _extends$3({
          key
        }, props), children);
      }
    }
    const checkForListedLanguage = function(astGenerator, language) {
      var langs = astGenerator.listLanguages();
      return langs.indexOf(language) !== -1;
    };
    var _excluded$1 = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty$1(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var newLineRegex = /\n/g;
    function getNewLines(str) {
      return str.match(newLineRegex);
    }
    function getAllLineNumbers(_ref) {
      var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style2 = _ref.style;
      return lines.map(function(_, i) {
        var number2 = i + startingLineNumber;
        return /* @__PURE__ */ React.createElement("span", {
          key: "line-".concat(i),
          className: "react-syntax-highlighter-line-number",
          style: typeof style2 === "function" ? style2(number2) : style2
        }, "".concat(number2, "\n"));
      });
    }
    function AllLineNumbers(_ref2) {
      var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
        "float": "left",
        paddingRight: "10px"
      } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
      return /* @__PURE__ */ React.createElement("code", {
        style: Object.assign({}, codeStyle, containerStyle)
      }, getAllLineNumbers({
        lines: codeString.replace(/\n$/, "").split("\n"),
        style: numberStyle,
        startingLineNumber
      }));
    }
    function getEmWidthOfNumber(num) {
      return "".concat(num.toString().length, ".25em");
    }
    function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
      return {
        type: "element",
        tagName: "span",
        properties: {
          key: "line-number--".concat(lineNumber),
          className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
          style: inlineLineNumberStyle
        },
        children: [{
          type: "text",
          value: lineNumber
        }]
      };
    }
    function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
      var defaultLineNumberStyle = {
        display: "inline-block",
        minWidth: getEmWidthOfNumber(largestLineNumber),
        paddingRight: "1em",
        textAlign: "right",
        userSelect: "none"
      };
      var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
      var assembledStyle = _objectSpread(_objectSpread({}, defaultLineNumberStyle), customLineNumberStyle);
      return assembledStyle;
    }
    function createLineElement(_ref3) {
      var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines;
      var properties = typeof lineProps === "function" ? lineProps(lineNumber) : lineProps;
      properties["className"] = className;
      if (lineNumber && showInlineLineNumbers) {
        var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
        children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
      }
      if (wrapLongLines & showLineNumbers) {
        properties.style = _objectSpread(_objectSpread({}, properties.style), {}, {
          display: "flex"
        });
      }
      return {
        type: "element",
        tagName: "span",
        properties,
        children
      };
    }
    function flattenCodeTree(tree) {
      var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      for (var i = 0; i < tree.length; i++) {
        var node2 = tree[i];
        if (node2.type === "text") {
          newTree.push(createLineElement({
            children: [node2],
            className: _toConsumableArray$1(new Set(className))
          }));
        } else if (node2.children) {
          var classNames = className.concat(node2.properties.className);
          flattenCodeTree(node2.children, classNames).forEach(function(i2) {
            return newTree.push(i2);
          });
        }
      }
      return newTree;
    }
    function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
      var _ref4;
      var tree = flattenCodeTree(codeTree.value);
      var newTree = [];
      var lastLineBreakIndex = -1;
      var index2 = 0;
      function createWrappedLine(children2, lineNumber2) {
        var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        return createLineElement({
          children: children2,
          lineNumber: lineNumber2,
          lineNumberStyle,
          largestLineNumber,
          showInlineLineNumbers,
          lineProps,
          className,
          showLineNumbers,
          wrapLongLines
        });
      }
      function createUnwrappedLine(children2, lineNumber2) {
        if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
          var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
          children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
        }
        return children2;
      }
      function createLine(children2, lineNumber2) {
        var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
      }
      var _loop = function _loop2() {
        var node2 = tree[index2];
        var value = node2.children[0].value;
        var newLines = getNewLines(value);
        if (newLines) {
          var splitValue = value.split("\n");
          splitValue.forEach(function(text2, i) {
            var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
            var newChild = {
              type: "text",
              value: "".concat(text2, "\n")
            };
            if (i === 0) {
              var _children = tree.slice(lastLineBreakIndex + 1, index2).concat(createLineElement({
                children: [newChild],
                className: node2.properties.className
              }));
              var _line = createLine(_children, lineNumber2);
              newTree.push(_line);
            } else if (i === splitValue.length - 1) {
              var stringChild = tree[index2 + 1] && tree[index2 + 1].children && tree[index2 + 1].children[0];
              var lastLineInPreviousSpan = {
                type: "text",
                value: "".concat(text2)
              };
              if (stringChild) {
                var newElem = createLineElement({
                  children: [lastLineInPreviousSpan],
                  className: node2.properties.className
                });
                tree.splice(index2 + 1, 0, newElem);
              } else {
                var _children2 = [lastLineInPreviousSpan];
                var _line2 = createLine(_children2, lineNumber2, node2.properties.className);
                newTree.push(_line2);
              }
            } else {
              var _children3 = [newChild];
              var _line3 = createLine(_children3, lineNumber2, node2.properties.className);
              newTree.push(_line3);
            }
          });
          lastLineBreakIndex = index2;
        }
        index2++;
      };
      while (index2 < tree.length) {
        _loop();
      }
      if (lastLineBreakIndex !== tree.length - 1) {
        var children = tree.slice(lastLineBreakIndex + 1, tree.length);
        if (children && children.length) {
          var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
          var line = createLine(children, lineNumber);
          newTree.push(line);
        }
      }
      return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
    }
    function defaultRenderer(_ref5) {
      var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
      return rows.map(function(node2, i) {
        return createElement({
          node: node2,
          stylesheet,
          useInlineStyles,
          key: "code-segement".concat(i)
        });
      });
    }
    function isHighlightJs(astGenerator) {
      return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
    }
    function getCodeTree(_ref6) {
      var astGenerator = _ref6.astGenerator, language = _ref6.language, code2 = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
      if (isHighlightJs(astGenerator)) {
        var hasLanguage = checkForListedLanguage(astGenerator, language);
        if (language === "text") {
          return {
            value: defaultCodeValue,
            language: "text"
          };
        } else if (hasLanguage) {
          return astGenerator.highlight(language, code2);
        } else {
          return astGenerator.highlightAuto(code2);
        }
      }
      try {
        return language && language !== "text" ? {
          value: astGenerator.highlight(code2, language)
        } : {
          value: defaultCodeValue
        };
      } catch (e) {
        return {
          value: defaultCodeValue
        };
      }
    }
    function highlight$1(defaultAstGenerator, defaultStyle2) {
      return function SyntaxHighlighter2(_ref7) {
        var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style2 = _ref7$style === void 0 ? defaultStyle2 : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
          className: language ? "language-".concat(language) : void 0,
          style: _objectSpread(_objectSpread({}, style2['code[class*="language-"]']), style2['code[class*="language-'.concat(language, '"]')])
        } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code2 = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = _objectWithoutProperties(_ref7, _excluded$1);
        astGenerator = astGenerator || defaultAstGenerator;
        var allLineNumbers = showLineNumbers ? /* @__PURE__ */ React.createElement(AllLineNumbers, {
          containerStyle: lineNumberContainerStyle,
          codeStyle: codeTagProps.style || {},
          numberStyle: lineNumberStyle,
          startingLineNumber,
          codeString: code2
        }) : null;
        var defaultPreStyle = style2.hljs || style2['pre[class*="language-"]'] || {
          backgroundColor: "#fff"
        };
        var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
        var preProps = useInlineStyles ? Object.assign({}, rest, {
          style: Object.assign({}, defaultPreStyle, customStyle)
        }) : Object.assign({}, rest, {
          className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
          style: Object.assign({}, customStyle)
        });
        if (wrapLongLines) {
          codeTagProps.style = _objectSpread(_objectSpread({}, codeTagProps.style), {}, {
            whiteSpace: "pre-wrap"
          });
        } else {
          codeTagProps.style = _objectSpread(_objectSpread({}, codeTagProps.style), {}, {
            whiteSpace: "pre"
          });
        }
        if (!astGenerator) {
          return /* @__PURE__ */ React.createElement(PreTag, preProps, allLineNumbers, /* @__PURE__ */ React.createElement(CodeTag, codeTagProps, code2));
        }
        if (wrapLines === void 0 && renderer || wrapLongLines)
          wrapLines = true;
        renderer = renderer || defaultRenderer;
        var defaultCodeValue = [{
          type: "text",
          value: code2
        }];
        var codeTree = getCodeTree({
          astGenerator,
          language,
          code: code2,
          defaultCodeValue
        });
        if (codeTree.language === null) {
          codeTree.value = defaultCodeValue;
        }
        var largestLineNumber = codeTree.value.length + startingLineNumber;
        var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
        return /* @__PURE__ */ React.createElement(PreTag, preProps, /* @__PURE__ */ React.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
          rows,
          stylesheet: style2,
          useInlineStyles
        })));
      };
    }
    const supportedLanguages = ["abap", "abnf", "actionscript", "ada", "agda", "al", "antlr4", "apacheconf", "apex", "apl", "applescript", "aql", "arduino", "arff", "asciidoc", "asm6502", "asmatmel", "aspnet", "autohotkey", "autoit", "avisynth", "avro-idl", "bash", "basic", "batch", "bbcode", "bicep", "birb", "bison", "bnf", "brainfuck", "brightscript", "bro", "bsl", "c", "cfscript", "chaiscript", "cil", "clike", "clojure", "cmake", "cobol", "coffeescript", "concurnas", "coq", "cpp", "crystal", "csharp", "cshtml", "csp", "css-extras", "css", "csv", "cypher", "d", "dart", "dataweave", "dax", "dhall", "diff", "django", "dns-zone-file", "docker", "dot", "ebnf", "editorconfig", "eiffel", "ejs", "elixir", "elm", "erb", "erlang", "etlua", "excel-formula", "factor", "false", "firestore-security-rules", "flow", "fortran", "fsharp", "ftl", "gap", "gcode", "gdscript", "gedcom", "gherkin", "git", "glsl", "gml", "gn", "go-module", "go", "graphql", "groovy", "haml", "handlebars", "haskell", "haxe", "hcl", "hlsl", "hoon", "hpkp", "hsts", "http", "ichigojam", "icon", "icu-message-format", "idris", "iecst", "ignore", "inform7", "ini", "io", "j", "java", "javadoc", "javadoclike", "javascript", "javastacktrace", "jexl", "jolie", "jq", "js-extras", "js-templates", "jsdoc", "json", "json5", "jsonp", "jsstacktrace", "jsx", "julia", "keepalived", "keyman", "kotlin", "kumir", "kusto", "latex", "latte", "less", "lilypond", "liquid", "lisp", "livescript", "llvm", "log", "lolcode", "lua", "magma", "makefile", "markdown", "markup-templating", "markup", "matlab", "maxscript", "mel", "mermaid", "mizar", "mongodb", "monkey", "moonscript", "n1ql", "n4js", "nand2tetris-hdl", "naniscript", "nasm", "neon", "nevod", "nginx", "nim", "nix", "nsis", "objectivec", "ocaml", "opencl", "openqasm", "oz", "parigp", "parser", "pascal", "pascaligo", "pcaxis", "peoplecode", "perl", "php-extras", "php", "phpdoc", "plsql", "powerquery", "powershell", "processing", "prolog", "promql", "properties", "protobuf", "psl", "pug", "puppet", "pure", "purebasic", "purescript", "python", "q", "qml", "qore", "qsharp", "r", "racket", "reason", "regex", "rego", "renpy", "rest", "rip", "roboconf", "robotframework", "ruby", "rust", "sas", "sass", "scala", "scheme", "scss", "shell-session", "smali", "smalltalk", "smarty", "sml", "solidity", "solution-file", "soy", "sparql", "splunk-spl", "sqf", "sql", "squirrel", "stan", "stylus", "swift", "systemd", "t4-cs", "t4-templating", "t4-vb", "tap", "tcl", "textile", "toml", "tremor", "tsx", "tt2", "turtle", "twig", "typescript", "typoscript", "unrealscript", "uorazor", "uri", "v", "vala", "vbnet", "velocity", "verilog", "vhdl", "vim", "visual-basic", "warpscript", "wasm", "web-idl", "wiki", "wolfram", "wren", "xeora", "xml-doc", "xojo", "xquery", "yaml", "yang", "zig"];
    var hastscriptExports = {};
    var hastscript = {
      get exports() {
        return hastscriptExports;
      },
      set exports(v2) {
        hastscriptExports = v2;
      }
    };
    var immutable = extend;
    var hasOwnProperty$d = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty$d.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
    var schema$1 = Schema$2;
    var proto$1 = Schema$2.prototype;
    proto$1.space = null;
    proto$1.normal = {};
    proto$1.property = {};
    function Schema$2(property2, normal, space2) {
      this.property = property2;
      this.normal = normal;
      if (space2) {
        this.space = space2;
      }
    }
    var xtend = immutable;
    var Schema$1 = schema$1;
    var merge_1 = merge$1;
    function merge$1(definitions) {
      var length = definitions.length;
      var property2 = [];
      var normal = [];
      var index2 = -1;
      var info2;
      var space2;
      while (++index2 < length) {
        info2 = definitions[index2];
        property2.push(info2.property);
        normal.push(info2.normal);
        space2 = info2.space;
      }
      return new Schema$1(
        xtend.apply(null, property2),
        xtend.apply(null, normal),
        space2
      );
    }
    var normalize_1 = normalize$3;
    function normalize$3(value) {
      return value.toLowerCase();
    }
    var info = Info$2;
    var proto = Info$2.prototype;
    proto.space = null;
    proto.attribute = null;
    proto.property = null;
    proto.boolean = false;
    proto.booleanish = false;
    proto.overloadedBoolean = false;
    proto.number = false;
    proto.commaSeparated = false;
    proto.spaceSeparated = false;
    proto.commaOrSpaceSeparated = false;
    proto.mustUseProperty = false;
    proto.defined = false;
    function Info$2(property2, attribute) {
      this.property = property2;
      this.attribute = attribute;
    }
    var types$3 = {};
    var powers = 0;
    types$3.boolean = increment();
    types$3.booleanish = increment();
    types$3.overloadedBoolean = increment();
    types$3.number = increment();
    types$3.spaceSeparated = increment();
    types$3.commaSeparated = increment();
    types$3.commaOrSpaceSeparated = increment();
    function increment() {
      return Math.pow(2, ++powers);
    }
    var Info$1 = info;
    var types$2 = types$3;
    var definedInfo = DefinedInfo$2;
    DefinedInfo$2.prototype = new Info$1();
    DefinedInfo$2.prototype.defined = true;
    var checks = [
      "boolean",
      "booleanish",
      "overloadedBoolean",
      "number",
      "commaSeparated",
      "spaceSeparated",
      "commaOrSpaceSeparated"
    ];
    var checksLength = checks.length;
    function DefinedInfo$2(property2, attribute, mask, space2) {
      var index2 = -1;
      var check;
      mark(this, "space", space2);
      Info$1.call(this, property2, attribute);
      while (++index2 < checksLength) {
        check = checks[index2];
        mark(this, check, (mask & types$2[check]) === types$2[check]);
      }
    }
    function mark(values, key, value) {
      if (value) {
        values[key] = value;
      }
    }
    var normalize$2 = normalize_1;
    var Schema = schema$1;
    var DefinedInfo$1 = definedInfo;
    var create_1 = create$5;
    function create$5(definition2) {
      var space2 = definition2.space;
      var mustUseProperty = definition2.mustUseProperty || [];
      var attributes2 = definition2.attributes || {};
      var props = definition2.properties;
      var transform = definition2.transform;
      var property2 = {};
      var normal = {};
      var prop;
      var info2;
      for (prop in props) {
        info2 = new DefinedInfo$1(
          prop,
          transform(attributes2, prop),
          props[prop],
          space2
        );
        if (mustUseProperty.indexOf(prop) !== -1) {
          info2.mustUseProperty = true;
        }
        property2[prop] = info2;
        normal[normalize$2(prop)] = prop;
        normal[normalize$2(info2.attribute)] = prop;
      }
      return new Schema(property2, normal, space2);
    }
    var create$4 = create_1;
    var xlink$1 = create$4({
      space: "xlink",
      transform: xlinkTransform,
      properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
      }
    });
    function xlinkTransform(_, prop) {
      return "xlink:" + prop.slice(5).toLowerCase();
    }
    var create$3 = create_1;
    var xml$1 = create$3({
      space: "xml",
      transform: xmlTransform,
      properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
      }
    });
    function xmlTransform(_, prop) {
      return "xml:" + prop.slice(3).toLowerCase();
    }
    var caseSensitiveTransform_1 = caseSensitiveTransform$1;
    function caseSensitiveTransform$1(attributes2, attribute) {
      return attribute in attributes2 ? attributes2[attribute] : attribute;
    }
    var caseSensitiveTransform = caseSensitiveTransform_1;
    var caseInsensitiveTransform_1 = caseInsensitiveTransform$2;
    function caseInsensitiveTransform$2(attributes2, property2) {
      return caseSensitiveTransform(attributes2, property2.toLowerCase());
    }
    var create$2 = create_1;
    var caseInsensitiveTransform$1 = caseInsensitiveTransform_1;
    var xmlns$1 = create$2({
      space: "xmlns",
      attributes: {
        xmlnsxlink: "xmlns:xlink"
      },
      transform: caseInsensitiveTransform$1,
      properties: {
        xmlns: null,
        xmlnsXLink: null
      }
    });
    var types$1 = types$3;
    var create$1 = create_1;
    var booleanish$1 = types$1.booleanish;
    var number$1 = types$1.number;
    var spaceSeparated$1 = types$1.spaceSeparated;
    var aria$1 = create$1({
      transform: ariaTransform,
      properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish$1,
        ariaAutoComplete: null,
        ariaBusy: booleanish$1,
        ariaChecked: booleanish$1,
        ariaColCount: number$1,
        ariaColIndex: number$1,
        ariaColSpan: number$1,
        ariaControls: spaceSeparated$1,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated$1,
        ariaDetails: null,
        ariaDisabled: booleanish$1,
        ariaDropEffect: spaceSeparated$1,
        ariaErrorMessage: null,
        ariaExpanded: booleanish$1,
        ariaFlowTo: spaceSeparated$1,
        ariaGrabbed: booleanish$1,
        ariaHasPopup: null,
        ariaHidden: booleanish$1,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated$1,
        ariaLevel: number$1,
        ariaLive: null,
        ariaModal: booleanish$1,
        ariaMultiLine: booleanish$1,
        ariaMultiSelectable: booleanish$1,
        ariaOrientation: null,
        ariaOwns: spaceSeparated$1,
        ariaPlaceholder: null,
        ariaPosInSet: number$1,
        ariaPressed: booleanish$1,
        ariaReadOnly: booleanish$1,
        ariaRelevant: null,
        ariaRequired: booleanish$1,
        ariaRoleDescription: spaceSeparated$1,
        ariaRowCount: number$1,
        ariaRowIndex: number$1,
        ariaRowSpan: number$1,
        ariaSelected: booleanish$1,
        ariaSetSize: number$1,
        ariaSort: null,
        ariaValueMax: number$1,
        ariaValueMin: number$1,
        ariaValueNow: number$1,
        ariaValueText: null,
        role: null
      }
    });
    function ariaTransform(_, prop) {
      return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
    }
    var types = types$3;
    var create = create_1;
    var caseInsensitiveTransform = caseInsensitiveTransform_1;
    var boolean = types.boolean;
    var overloadedBoolean = types.overloadedBoolean;
    var booleanish = types.booleanish;
    var number = types.number;
    var spaceSeparated = types.spaceSeparated;
    var commaSeparated = types.commaSeparated;
    var html$2 = create({
      space: "html",
      attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
      },
      transform: caseInsensitiveTransform,
      mustUseProperty: ["checked", "multiple", "muted", "selected"],
      properties: {
        // Standard Properties.
        abbr: null,
        accept: commaSeparated,
        acceptCharset: spaceSeparated,
        accessKey: spaceSeparated,
        action: null,
        allow: null,
        allowFullScreen: boolean,
        allowPaymentRequest: boolean,
        allowUserMedia: boolean,
        alt: null,
        as: null,
        async: boolean,
        autoCapitalize: null,
        autoComplete: spaceSeparated,
        autoFocus: boolean,
        autoPlay: boolean,
        capture: boolean,
        charSet: null,
        checked: boolean,
        cite: null,
        className: spaceSeparated,
        cols: number,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean,
        controlsList: spaceSeparated,
        coords: number | commaSeparated,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean,
        defer: boolean,
        dir: null,
        dirName: null,
        disabled: boolean,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean,
        formTarget: null,
        headers: spaceSeparated,
        height: number,
        hidden: boolean,
        high: number,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated,
        httpEquiv: spaceSeparated,
        id: null,
        imageSizes: null,
        imageSrcSet: commaSeparated,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean,
        itemId: null,
        itemProp: spaceSeparated,
        itemRef: spaceSeparated,
        itemScope: boolean,
        itemType: spaceSeparated,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean,
        low: number,
        manifest: null,
        max: null,
        maxLength: number,
        media: null,
        method: null,
        min: null,
        minLength: number,
        multiple: boolean,
        muted: boolean,
        name: null,
        nonce: null,
        noModule: boolean,
        noValidate: boolean,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextMenu: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean,
        optimum: number,
        pattern: null,
        ping: spaceSeparated,
        placeholder: null,
        playsInline: boolean,
        poster: null,
        preload: null,
        readOnly: boolean,
        referrerPolicy: null,
        rel: spaceSeparated,
        required: boolean,
        reversed: boolean,
        rows: number,
        rowSpan: number,
        sandbox: spaceSeparated,
        scope: null,
        scoped: boolean,
        seamless: boolean,
        selected: boolean,
        shape: null,
        size: number,
        sizes: null,
        slot: null,
        span: number,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: commaSeparated,
        start: number,
        step: null,
        style: null,
        tabIndex: number,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean,
        useMap: null,
        value: booleanish,
        width: number,
        wrap: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        // Several. Use CSS `text-align` instead,
        aLink: null,
        // `<body>`. Use CSS `a:active {color}` instead
        archive: spaceSeparated,
        // `<object>`. List of URIs to archives
        axis: null,
        // `<td>` and `<th>`. Use `scope` on `<th>`
        background: null,
        // `<body>`. Use CSS `background-image` instead
        bgColor: null,
        // `<body>` and table elements. Use CSS `background-color` instead
        border: number,
        // `<table>`. Use CSS `border-width` instead,
        borderColor: null,
        // `<table>`. Use CSS `border-color` instead,
        bottomMargin: number,
        // `<body>`
        cellPadding: null,
        // `<table>`
        cellSpacing: null,
        // `<table>`
        char: null,
        // Several table elements. When `align=char`, sets the character to align on
        charOff: null,
        // Several table elements. When `char`, offsets the alignment
        classId: null,
        // `<object>`
        clear: null,
        // `<br>`. Use CSS `clear` instead
        code: null,
        // `<object>`
        codeBase: null,
        // `<object>`
        codeType: null,
        // `<object>`
        color: null,
        // `<font>` and `<hr>`. Use CSS instead
        compact: boolean,
        // Lists. Use CSS to reduce space between items instead
        declare: boolean,
        // `<object>`
        event: null,
        // `<script>`
        face: null,
        // `<font>`. Use CSS instead
        frame: null,
        // `<table>`
        frameBorder: null,
        // `<iframe>`. Use CSS `border` instead
        hSpace: number,
        // `<img>` and `<object>`
        leftMargin: number,
        // `<body>`
        link: null,
        // `<body>`. Use CSS `a:link {color: *}` instead
        longDesc: null,
        // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
        lowSrc: null,
        // `<img>`. Use a `<picture>`
        marginHeight: number,
        // `<body>`
        marginWidth: number,
        // `<body>`
        noResize: boolean,
        // `<frame>`
        noHref: boolean,
        // `<area>`. Use no href instead of an explicit `nohref`
        noShade: boolean,
        // `<hr>`. Use background-color and height instead of borders
        noWrap: boolean,
        // `<td>` and `<th>`
        object: null,
        // `<applet>`
        profile: null,
        // `<head>`
        prompt: null,
        // `<isindex>`
        rev: null,
        // `<link>`
        rightMargin: number,
        // `<body>`
        rules: null,
        // `<table>`
        scheme: null,
        // `<meta>`
        scrolling: booleanish,
        // `<frame>`. Use overflow in the child context
        standby: null,
        // `<object>`
        summary: null,
        // `<table>`
        text: null,
        // `<body>`. Use CSS `color` instead
        topMargin: number,
        // `<body>`
        valueType: null,
        // `<param>`
        version: null,
        // `<html>`. Use a doctype.
        vAlign: null,
        // Several. Use CSS `vertical-align` instead
        vLink: null,
        // `<body>`. Use CSS `a:visited {color}` instead
        vSpace: number,
        // `<img>` and `<object>`
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean,
        disableRemotePlayback: boolean,
        prefix: null,
        property: null,
        results: number,
        security: null,
        unselectable: null
      }
    });
    var merge = merge_1;
    var xlink = xlink$1;
    var xml = xml$1;
    var xmlns = xmlns$1;
    var aria = aria$1;
    var html$1 = html$2;
    var html_1$1 = merge([xml, xlink, xmlns, aria, html$1]);
    var normalize$1 = normalize_1;
    var DefinedInfo = definedInfo;
    var Info = info;
    var data = "data";
    var find_1 = find$1;
    var valid = /^data[-\w.:]+$/i;
    var dash = /-[a-z]/g;
    var cap = /[A-Z]/g;
    function find$1(schema2, value) {
      var normal = normalize$1(value);
      var prop = value;
      var Type = Info;
      if (normal in schema2.normal) {
        return schema2.property[schema2.normal[normal]];
      }
      if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value)) {
        if (value.charAt(4) === "-") {
          prop = datasetToProperty(value);
        } else {
          value = datasetToAttribute(value);
        }
        Type = DefinedInfo;
      }
      return new Type(prop, value);
    }
    function datasetToProperty(attribute) {
      var value = attribute.slice(5).replace(dash, camelcase);
      return data + value.charAt(0).toUpperCase() + value.slice(1);
    }
    function datasetToAttribute(property2) {
      var value = property2.slice(4);
      if (dash.test(value)) {
        return property2;
      }
      value = value.replace(cap, kebab);
      if (value.charAt(0) !== "-") {
        value = "-" + value;
      }
      return data + value;
    }
    function kebab($0) {
      return "-" + $0.toLowerCase();
    }
    function camelcase($0) {
      return $0.charAt(1).toUpperCase();
    }
    var hastUtilParseSelector = parse$4;
    var search = /[#.]/g;
    function parse$4(selector, defaultTagName) {
      var value = selector || "";
      var name2 = defaultTagName || "div";
      var props = {};
      var start = 0;
      var subvalue;
      var previous2;
      var match;
      while (start < value.length) {
        search.lastIndex = start;
        match = search.exec(value);
        subvalue = value.slice(start, match ? match.index : value.length);
        if (subvalue) {
          if (!previous2) {
            name2 = subvalue;
          } else if (previous2 === "#") {
            props.id = subvalue;
          } else if (props.className) {
            props.className.push(subvalue);
          } else {
            props.className = [subvalue];
          }
          start += subvalue.length;
        }
        if (match) {
          previous2 = match[0];
          start++;
        }
      }
      return { type: "element", tagName: name2, properties: props, children: [] };
    }
    var spaceSeparatedTokens = {};
    spaceSeparatedTokens.parse = parse$3;
    spaceSeparatedTokens.stringify = stringify$3;
    var empty$1 = "";
    var space$2 = " ";
    var whiteSpace = /[ \t\n\r\f]+/g;
    function parse$3(value) {
      var input = String(value || empty$1).trim();
      return input === empty$1 ? [] : input.split(whiteSpace);
    }
    function stringify$3(values) {
      return values.join(space$2).trim();
    }
    var commaSeparatedTokens = {};
    commaSeparatedTokens.parse = parse$2;
    commaSeparatedTokens.stringify = stringify$2;
    var comma = ",";
    var space$1 = " ";
    var empty = "";
    function parse$2(value) {
      var values = [];
      var input = String(value || empty);
      var index2 = input.indexOf(comma);
      var lastIndex = 0;
      var end = false;
      var val;
      while (!end) {
        if (index2 === -1) {
          index2 = input.length;
          end = true;
        }
        val = input.slice(lastIndex, index2).trim();
        if (val || !end) {
          values.push(val);
        }
        lastIndex = index2 + 1;
        index2 = input.indexOf(comma, lastIndex);
      }
      return values;
    }
    function stringify$2(values, options) {
      var settings = options || {};
      var left = settings.padLeft === false ? empty : space$1;
      var right = settings.padRight ? space$1 : empty;
      if (values[values.length - 1] === empty) {
        values = values.concat(empty);
      }
      return values.join(right + comma + left).trim();
    }
    var find = find_1;
    var normalize = normalize_1;
    var parseSelector = hastUtilParseSelector;
    var spaces = spaceSeparatedTokens.parse;
    var commas = commaSeparatedTokens.parse;
    var factory_1 = factory$1;
    var own$2 = {}.hasOwnProperty;
    function factory$1(schema2, defaultTagName, caseSensitive) {
      var adjust = caseSensitive ? createAdjustMap(caseSensitive) : null;
      return h2;
      function h2(selector, properties) {
        var node2 = parseSelector(selector, defaultTagName);
        var children = Array.prototype.slice.call(arguments, 2);
        var name2 = node2.tagName.toLowerCase();
        var property2;
        node2.tagName = adjust && own$2.call(adjust, name2) ? adjust[name2] : name2;
        if (properties && isChildren(properties, node2)) {
          children.unshift(properties);
          properties = null;
        }
        if (properties) {
          for (property2 in properties) {
            addProperty(node2.properties, property2, properties[property2]);
          }
        }
        addChild(node2.children, children);
        if (node2.tagName === "template") {
          node2.content = { type: "root", children: node2.children };
          node2.children = [];
        }
        return node2;
      }
      function addProperty(properties, key, value) {
        var info2;
        var property2;
        var result;
        if (value === null || value === void 0 || value !== value) {
          return;
        }
        info2 = find(schema2, key);
        property2 = info2.property;
        result = value;
        if (typeof result === "string") {
          if (info2.spaceSeparated) {
            result = spaces(result);
          } else if (info2.commaSeparated) {
            result = commas(result);
          } else if (info2.commaOrSpaceSeparated) {
            result = spaces(commas(result).join(" "));
          }
        }
        if (property2 === "style" && typeof value !== "string") {
          result = style(result);
        }
        if (property2 === "className" && properties.className) {
          result = properties.className.concat(result);
        }
        properties[property2] = parsePrimitives(info2, property2, result);
      }
    }
    function isChildren(value, node2) {
      return typeof value === "string" || "length" in value || isNode(node2.tagName, value);
    }
    function isNode(tagName, value) {
      var type = value.type;
      if (tagName === "input" || !type || typeof type !== "string") {
        return false;
      }
      if (typeof value.children === "object" && "length" in value.children) {
        return true;
      }
      type = type.toLowerCase();
      if (tagName === "button") {
        return type !== "menu" && type !== "submit" && type !== "reset" && type !== "button";
      }
      return "value" in value;
    }
    function addChild(nodes, value) {
      var index2;
      var length;
      if (typeof value === "string" || typeof value === "number") {
        nodes.push({ type: "text", value: String(value) });
        return;
      }
      if (typeof value === "object" && "length" in value) {
        index2 = -1;
        length = value.length;
        while (++index2 < length) {
          addChild(nodes, value[index2]);
        }
        return;
      }
      if (typeof value !== "object" || !("type" in value)) {
        throw new Error("Expected node, nodes, or string, got `" + value + "`");
      }
      nodes.push(value);
    }
    function parsePrimitives(info2, name2, value) {
      var index2;
      var length;
      var result;
      if (typeof value !== "object" || !("length" in value)) {
        return parsePrimitive(info2, name2, value);
      }
      length = value.length;
      index2 = -1;
      result = [];
      while (++index2 < length) {
        result[index2] = parsePrimitive(info2, name2, value[index2]);
      }
      return result;
    }
    function parsePrimitive(info2, name2, value) {
      var result = value;
      if (info2.number || info2.positiveNumber) {
        if (!isNaN(result) && result !== "") {
          result = Number(result);
        }
      } else if (info2.boolean || info2.overloadedBoolean) {
        if (typeof result === "string" && (result === "" || normalize(value) === normalize(name2))) {
          result = true;
        }
      }
      return result;
    }
    function style(value) {
      var result = [];
      var key;
      for (key in value) {
        result.push([key, value[key]].join(": "));
      }
      return result.join("; ");
    }
    function createAdjustMap(values) {
      var length = values.length;
      var index2 = -1;
      var result = {};
      var value;
      while (++index2 < length) {
        value = values[index2];
        result[value.toLowerCase()] = value;
      }
      return result;
    }
    var schema = html_1$1;
    var factory = factory_1;
    var html = factory(schema, "div");
    html.displayName = "html";
    var html_1 = html;
    (function(module2) {
      module2.exports = html_1;
    })(hastscript);
    const AElig = "Æ";
    const AMP = "&";
    const Aacute = "Á";
    const Acirc = "Â";
    const Agrave = "À";
    const Aring = "Å";
    const Atilde = "Ã";
    const Auml = "Ä";
    const COPY = "©";
    const Ccedil = "Ç";
    const ETH = "Ð";
    const Eacute = "É";
    const Ecirc = "Ê";
    const Egrave = "È";
    const Euml = "Ë";
    const GT = ">";
    const Iacute = "Í";
    const Icirc = "Î";
    const Igrave = "Ì";
    const Iuml = "Ï";
    const LT = "<";
    const Ntilde = "Ñ";
    const Oacute = "Ó";
    const Ocirc = "Ô";
    const Ograve = "Ò";
    const Oslash = "Ø";
    const Otilde = "Õ";
    const Ouml = "Ö";
    const QUOT = '"';
    const REG = "®";
    const THORN = "Þ";
    const Uacute = "Ú";
    const Ucirc = "Û";
    const Ugrave = "Ù";
    const Uuml = "Ü";
    const Yacute = "Ý";
    const aacute = "á";
    const acirc = "â";
    const acute = "´";
    const aelig = "æ";
    const agrave = "à";
    const amp = "&";
    const aring = "å";
    const atilde = "ã";
    const auml = "ä";
    const brvbar = "¦";
    const ccedil = "ç";
    const cedil = "¸";
    const cent = "¢";
    const copy$1 = "©";
    const curren = "¤";
    const deg = "°";
    const divide = "÷";
    const eacute = "é";
    const ecirc = "ê";
    const egrave = "è";
    const eth = "ð";
    const euml = "ë";
    const frac12 = "½";
    const frac14 = "¼";
    const frac34 = "¾";
    const gt = ">";
    const iacute = "í";
    const icirc = "î";
    const iexcl = "¡";
    const igrave = "ì";
    const iquest = "¿";
    const iuml = "ï";
    const laquo = "«";
    const lt = "<";
    const macr = "¯";
    const micro = "µ";
    const middot = "·";
    const nbsp = " ";
    const not = "¬";
    const ntilde = "ñ";
    const oacute = "ó";
    const ocirc = "ô";
    const ograve = "ò";
    const ordf = "ª";
    const ordm = "º";
    const oslash = "ø";
    const otilde = "õ";
    const ouml = "ö";
    const para = "¶";
    const plusmn = "±";
    const pound = "£";
    const quot = '"';
    const raquo = "»";
    const reg = "®";
    const sect = "§";
    const shy = "­";
    const sup1 = "¹";
    const sup2 = "²";
    const sup3 = "³";
    const szlig = "ß";
    const thorn = "þ";
    const times = "×";
    const uacute = "ú";
    const ucirc = "û";
    const ugrave = "ù";
    const uml = "¨";
    const uuml = "ü";
    const yacute = "ý";
    const yen = "¥";
    const yuml = "ÿ";
    const require$$0 = {
      AElig,
      AMP,
      Aacute,
      Acirc,
      Agrave,
      Aring,
      Atilde,
      Auml,
      COPY,
      Ccedil,
      ETH,
      Eacute,
      Ecirc,
      Egrave,
      Euml,
      GT,
      Iacute,
      Icirc,
      Igrave,
      Iuml,
      LT,
      Ntilde,
      Oacute,
      Ocirc,
      Ograve,
      Oslash,
      Otilde,
      Ouml,
      QUOT,
      REG,
      THORN,
      Uacute,
      Ucirc,
      Ugrave,
      Uuml,
      Yacute,
      aacute,
      acirc,
      acute,
      aelig,
      agrave,
      amp,
      aring,
      atilde,
      auml,
      brvbar,
      ccedil,
      cedil,
      cent,
      copy: copy$1,
      curren,
      deg,
      divide,
      eacute,
      ecirc,
      egrave,
      eth,
      euml,
      frac12,
      frac14,
      frac34,
      gt,
      iacute,
      icirc,
      iexcl,
      igrave,
      iquest,
      iuml,
      laquo,
      lt,
      macr,
      micro,
      middot,
      nbsp,
      not,
      ntilde,
      oacute,
      ocirc,
      ograve,
      ordf,
      ordm,
      oslash,
      otilde,
      ouml,
      para,
      plusmn,
      pound,
      quot,
      raquo,
      reg,
      sect,
      shy,
      sup1,
      sup2,
      sup3,
      szlig,
      thorn,
      times,
      uacute,
      ucirc,
      ugrave,
      uml,
      uuml,
      yacute,
      yen,
      yuml
    };
    const require$$1 = {
      "0": "�",
      "128": "€",
      "130": "‚",
      "131": "ƒ",
      "132": "„",
      "133": "…",
      "134": "†",
      "135": "‡",
      "136": "ˆ",
      "137": "‰",
      "138": "Š",
      "139": "‹",
      "140": "Œ",
      "142": "Ž",
      "145": "‘",
      "146": "’",
      "147": "“",
      "148": "”",
      "149": "•",
      "150": "–",
      "151": "—",
      "152": "˜",
      "153": "™",
      "154": "š",
      "155": "›",
      "156": "œ",
      "158": "ž",
      "159": "Ÿ"
    };
    var isDecimal = decimal$2;
    function decimal$2(character) {
      var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
      return code2 >= 48 && code2 <= 57;
    }
    var isHexadecimal = hexadecimal$1;
    function hexadecimal$1(character) {
      var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
      return code2 >= 97 && code2 <= 102 || code2 >= 65 && code2 <= 70 || code2 >= 48 && code2 <= 57;
    }
    var isAlphabetical = alphabetical$1;
    function alphabetical$1(character) {
      var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
      return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
    }
    var alphabetical = isAlphabetical;
    var decimal$1 = isDecimal;
    var isAlphanumerical = alphanumerical$1;
    function alphanumerical$1(character) {
      return alphabetical(character) || decimal$1(character);
    }
    var el;
    var semicolon$1 = 59;
    var decodeEntity_browser = decodeEntity$1;
    function decodeEntity$1(characters) {
      var entity = "&" + characters + ";";
      var char;
      el = el || document.createElement("i");
      el.innerHTML = entity;
      char = el.textContent;
      if (char.charCodeAt(char.length - 1) === semicolon$1 && characters !== "semi") {
        return false;
      }
      return char === entity ? false : char;
    }
    var legacy = require$$0;
    var invalid = require$$1;
    var decimal = isDecimal;
    var hexadecimal = isHexadecimal;
    var alphanumerical = isAlphanumerical;
    var decodeEntity = decodeEntity_browser;
    var parseEntities_1 = parseEntities;
    var own$1 = {}.hasOwnProperty;
    var fromCharCode = String.fromCharCode;
    var noop$1 = Function.prototype;
    var defaults = {
      warning: null,
      reference: null,
      text: null,
      warningContext: null,
      referenceContext: null,
      textContext: null,
      position: {},
      additional: null,
      attribute: false,
      nonTerminated: true
    };
    var tab = 9;
    var lineFeed = 10;
    var formFeed = 12;
    var space = 32;
    var ampersand = 38;
    var semicolon = 59;
    var lessThan = 60;
    var equalsTo = 61;
    var numberSign = 35;
    var uppercaseX = 88;
    var lowercaseX = 120;
    var replacementCharacter = 65533;
    var name = "named";
    var hexa = "hexadecimal";
    var deci = "decimal";
    var bases = {};
    bases[hexa] = 16;
    bases[deci] = 10;
    var tests = {};
    tests[name] = alphanumerical;
    tests[deci] = decimal;
    tests[hexa] = hexadecimal;
    var namedNotTerminated = 1;
    var numericNotTerminated = 2;
    var namedEmpty = 3;
    var numericEmpty = 4;
    var namedUnknown = 5;
    var numericDisallowed = 6;
    var numericProhibited = 7;
    var messages = {};
    messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
    messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
    messages[namedEmpty] = "Named character references cannot be empty";
    messages[numericEmpty] = "Numeric character references cannot be empty";
    messages[namedUnknown] = "Named character references must be known";
    messages[numericDisallowed] = "Numeric character references cannot be disallowed";
    messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
    function parseEntities(value, options) {
      var settings = {};
      var option;
      var key;
      if (!options) {
        options = {};
      }
      for (key in defaults) {
        option = options[key];
        settings[key] = option === null || option === void 0 ? defaults[key] : option;
      }
      if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
      }
      return parse$1(value, settings);
    }
    function parse$1(value, settings) {
      var additional = settings.additional;
      var nonTerminated = settings.nonTerminated;
      var handleText = settings.text;
      var handleReference = settings.reference;
      var handleWarning = settings.warning;
      var textContext = settings.textContext;
      var referenceContext = settings.referenceContext;
      var warningContext = settings.warningContext;
      var pos = settings.position;
      var indent2 = settings.indent || [];
      var length = value.length;
      var index2 = 0;
      var lines = -1;
      var column = pos.column || 1;
      var line = pos.line || 1;
      var queue = "";
      var result = [];
      var entityCharacters;
      var namedEntity;
      var terminated;
      var characters;
      var character;
      var reference;
      var following;
      var warning2;
      var reason;
      var output;
      var entity;
      var begin;
      var start;
      var type;
      var test;
      var prev;
      var next;
      var diff;
      var end;
      if (typeof additional === "string") {
        additional = additional.charCodeAt(0);
      }
      prev = now();
      warning2 = handleWarning ? parseError : noop$1;
      index2--;
      length++;
      while (++index2 < length) {
        if (character === lineFeed) {
          column = indent2[lines] || 1;
        }
        character = value.charCodeAt(index2);
        if (character === ampersand) {
          following = value.charCodeAt(index2 + 1);
          if (following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {
            queue += fromCharCode(character);
            column++;
            continue;
          }
          start = index2 + 1;
          begin = start;
          end = start;
          if (following === numberSign) {
            end = ++begin;
            following = value.charCodeAt(end);
            if (following === uppercaseX || following === lowercaseX) {
              type = hexa;
              end = ++begin;
            } else {
              type = deci;
            }
          } else {
            type = name;
          }
          entityCharacters = "";
          entity = "";
          characters = "";
          test = tests[type];
          end--;
          while (++end < length) {
            following = value.charCodeAt(end);
            if (!test(following)) {
              break;
            }
            characters += fromCharCode(following);
            if (type === name && own$1.call(legacy, characters)) {
              entityCharacters = characters;
              entity = legacy[characters];
            }
          }
          terminated = value.charCodeAt(end) === semicolon;
          if (terminated) {
            end++;
            namedEntity = type === name ? decodeEntity(characters) : false;
            if (namedEntity) {
              entityCharacters = characters;
              entity = namedEntity;
            }
          }
          diff = 1 + end - start;
          if (!terminated && !nonTerminated)
            ;
          else if (!characters) {
            if (type !== name) {
              warning2(numericEmpty, diff);
            }
          } else if (type === name) {
            if (terminated && !entity) {
              warning2(namedUnknown, 1);
            } else {
              if (entityCharacters !== characters) {
                end = begin + entityCharacters.length;
                diff = 1 + end - begin;
                terminated = false;
              }
              if (!terminated) {
                reason = entityCharacters ? namedNotTerminated : namedEmpty;
                if (settings.attribute) {
                  following = value.charCodeAt(end);
                  if (following === equalsTo) {
                    warning2(reason, diff);
                    entity = null;
                  } else if (alphanumerical(following)) {
                    entity = null;
                  } else {
                    warning2(reason, diff);
                  }
                } else {
                  warning2(reason, diff);
                }
              }
            }
            reference = entity;
          } else {
            if (!terminated) {
              warning2(numericNotTerminated, diff);
            }
            reference = parseInt(characters, bases[type]);
            if (prohibited(reference)) {
              warning2(numericProhibited, diff);
              reference = fromCharCode(replacementCharacter);
            } else if (reference in invalid) {
              warning2(numericDisallowed, diff);
              reference = invalid[reference];
            } else {
              output = "";
              if (disallowed(reference)) {
                warning2(numericDisallowed, diff);
              }
              if (reference > 65535) {
                reference -= 65536;
                output += fromCharCode(reference >>> (10 & 1023) | 55296);
                reference = 56320 | reference & 1023;
              }
              reference = output + fromCharCode(reference);
            }
          }
          if (reference) {
            flush();
            prev = now();
            index2 = end - 1;
            column += end - start + 1;
            result.push(reference);
            next = now();
            next.offset++;
            if (handleReference) {
              handleReference.call(
                referenceContext,
                reference,
                { start: prev, end: next },
                value.slice(start - 1, end)
              );
            }
            prev = next;
          } else {
            characters = value.slice(start - 1, end);
            queue += characters;
            column += characters.length;
            index2 = end - 1;
          }
        } else {
          if (character === 10) {
            line++;
            lines++;
            column = 0;
          }
          if (character === character) {
            queue += fromCharCode(character);
            column++;
          } else {
            flush();
          }
        }
      }
      return result.join("");
      function now() {
        return {
          line,
          column,
          offset: index2 + (pos.offset || 0)
        };
      }
      function parseError(code2, offset) {
        var position2 = now();
        position2.column += offset;
        position2.offset += offset;
        handleWarning.call(warningContext, messages[code2], position2, code2);
      }
      function flush() {
        if (queue) {
          result.push(queue);
          if (handleText) {
            handleText.call(textContext, queue, { start: prev, end: now() });
          }
          queue = "";
        }
      }
    }
    function prohibited(code2) {
      return code2 >= 55296 && code2 <= 57343 || code2 > 1114111;
    }
    function disallowed(code2) {
      return code2 >= 1 && code2 <= 8 || code2 === 11 || code2 >= 13 && code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 64976 && code2 <= 65007 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534;
    }
    var prismCoreExports = {};
    var prismCore = {
      get exports() {
        return prismCoreExports;
      },
      set exports(v2) {
        prismCoreExports = v2;
      }
    };
    (function(module2) {
      var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
      /**
       * Prism: Lightweight, robust, elegant syntax highlighting
       *
       * @license MIT <https://opensource.org/licenses/MIT>
       * @author Lea Verou <https://lea.verou.me>
       * @namespace
       * @public
       */
      var Prism2 = function(_self2) {
        var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
        var uniqueId = 0;
        var plainTextGrammar = {};
        var _ = {
          /**
           * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
           * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
           * additional languages or plugins yourself.
           *
           * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
           *
           * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
           * empty Prism object into the global scope before loading the Prism script like this:
           *
           * ```js
           * window.Prism = window.Prism || {};
           * Prism.manual = true;
           * // add a new <script> to load Prism's script
           * ```
           *
           * @default false
           * @type {boolean}
           * @memberof Prism
           * @public
           */
          manual: _self2.Prism && _self2.Prism.manual,
          /**
           * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
           * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
           * own worker, you don't want it to do this.
           *
           * By setting this value to `true`, Prism will not add its own listeners to the worker.
           *
           * You obviously have to change this value before Prism executes. To do this, you can add an
           * empty Prism object into the global scope before loading the Prism script like this:
           *
           * ```js
           * window.Prism = window.Prism || {};
           * Prism.disableWorkerMessageHandler = true;
           * // Load Prism's script
           * ```
           *
           * @default false
           * @type {boolean}
           * @memberof Prism
           * @public
           */
          disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
          /**
           * A namespace for utility methods.
           *
           * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
           * change or disappear at any time.
           *
           * @namespace
           * @memberof Prism
           */
          util: {
            encode: function encode2(tokens) {
              if (tokens instanceof Token) {
                return new Token(tokens.type, encode2(tokens.content), tokens.alias);
              } else if (Array.isArray(tokens)) {
                return tokens.map(encode2);
              } else {
                return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
              }
            },
            /**
             * Returns the name of the type of the given value.
             *
             * @param {any} o
             * @returns {string}
             * @example
             * type(null)      === 'Null'
             * type(undefined) === 'Undefined'
             * type(123)       === 'Number'
             * type('foo')     === 'String'
             * type(true)      === 'Boolean'
             * type([1, 2])    === 'Array'
             * type({})        === 'Object'
             * type(String)    === 'Function'
             * type(/abc+/)    === 'RegExp'
             */
            type: function(o) {
              return Object.prototype.toString.call(o).slice(8, -1);
            },
            /**
             * Returns a unique number for the given object. Later calls will still return the same number.
             *
             * @param {Object} obj
             * @returns {number}
             */
            objId: function(obj) {
              if (!obj["__id"]) {
                Object.defineProperty(obj, "__id", { value: ++uniqueId });
              }
              return obj["__id"];
            },
            /**
             * Creates a deep clone of the given object.
             *
             * The main intended use of this function is to clone language definitions.
             *
             * @param {T} o
             * @param {Record<number, any>} [visited]
             * @returns {T}
             * @template T
             */
            clone: function deepClone(o, visited) {
              visited = visited || {};
              var clone2;
              var id2;
              switch (_.util.type(o)) {
                case "Object":
                  id2 = _.util.objId(o);
                  if (visited[id2]) {
                    return visited[id2];
                  }
                  clone2 = /** @type {Record<string, any>} */
                  {};
                  visited[id2] = clone2;
                  for (var key in o) {
                    if (o.hasOwnProperty(key)) {
                      clone2[key] = deepClone(o[key], visited);
                    }
                  }
                  return (
                    /** @type {any} */
                    clone2
                  );
                case "Array":
                  id2 = _.util.objId(o);
                  if (visited[id2]) {
                    return visited[id2];
                  }
                  clone2 = [];
                  visited[id2] = clone2;
                  /** @type {Array} */
                  /** @type {any} */
                  o.forEach(function(v2, i) {
                    clone2[i] = deepClone(v2, visited);
                  });
                  return (
                    /** @type {any} */
                    clone2
                  );
                default:
                  return o;
              }
            },
            /**
             * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
             *
             * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
             *
             * @param {Element} element
             * @returns {string}
             */
            getLanguage: function(element2) {
              while (element2) {
                var m2 = lang.exec(element2.className);
                if (m2) {
                  return m2[1].toLowerCase();
                }
                element2 = element2.parentElement;
              }
              return "none";
            },
            /**
             * Sets the Prism `language-xxxx` class of the given element.
             *
             * @param {Element} element
             * @param {string} language
             * @returns {void}
             */
            setLanguage: function(element2, language) {
              element2.className = element2.className.replace(RegExp(lang, "gi"), "");
              element2.classList.add("language-" + language);
            },
            /**
             * Returns the script element that is currently executing.
             *
             * This does __not__ work for line script element.
             *
             * @returns {HTMLScriptElement | null}
             */
            currentScript: function() {
              if (typeof document === "undefined") {
                return null;
              }
              if ("currentScript" in document && 1 < 2) {
                return (
                  /** @type {any} */
                  document.currentScript
                );
              }
              try {
                throw new Error();
              } catch (err) {
                var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                if (src) {
                  var scripts = document.getElementsByTagName("script");
                  for (var i in scripts) {
                    if (scripts[i].src == src) {
                      return scripts[i];
                    }
                  }
                }
                return null;
              }
            },
            /**
             * Returns whether a given class is active for `element`.
             *
             * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
             * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
             * given class is just the given class with a `no-` prefix.
             *
             * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
             * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
             * ancestors have the given class or the negated version of it, then the default activation will be returned.
             *
             * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
             * version of it, the class is considered active.
             *
             * @param {Element} element
             * @param {string} className
             * @param {boolean} [defaultActivation=false]
             * @returns {boolean}
             */
            isActive: function(element2, className, defaultActivation) {
              var no = "no-" + className;
              while (element2) {
                var classList = element2.classList;
                if (classList.contains(className)) {
                  return true;
                }
                if (classList.contains(no)) {
                  return false;
                }
                element2 = element2.parentElement;
              }
              return !!defaultActivation;
            }
          },
          /**
           * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
           *
           * @namespace
           * @memberof Prism
           * @public
           */
          languages: {
            /**
             * The grammar for plain, unformatted text.
             */
            plain: plainTextGrammar,
            plaintext: plainTextGrammar,
            text: plainTextGrammar,
            txt: plainTextGrammar,
            /**
             * Creates a deep copy of the language with the given id and appends the given tokens.
             *
             * If a token in `redef` also appears in the copied language, then the existing token in the copied language
             * will be overwritten at its original position.
             *
             * ## Best practices
             *
             * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
             * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
             * understand the language definition because, normally, the order of tokens matters in Prism grammars.
             *
             * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
             * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
             *
             * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
             * @param {Grammar} redef The new tokens to append.
             * @returns {Grammar} The new language created.
             * @public
             * @example
             * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
             *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
             *     // at its original position
             *     'comment': { ... },
             *     // CSS doesn't have a 'color' token, so this token will be appended
             *     'color': /\b(?:red|green|blue)\b/
             * });
             */
            extend: function(id2, redef) {
              var lang2 = _.util.clone(_.languages[id2]);
              for (var key in redef) {
                lang2[key] = redef[key];
              }
              return lang2;
            },
            /**
             * Inserts tokens _before_ another token in a language definition or any other grammar.
             *
             * ## Usage
             *
             * This helper method makes it easy to modify existing languages. For example, the CSS language definition
             * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
             * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
             * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
             * this:
             *
             * ```js
             * Prism.languages.markup.style = {
             *     // token
             * };
             * ```
             *
             * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
             * before existing tokens. For the CSS example above, you would use it like this:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'cdata', {
             *     'style': {
             *         // token
             *     }
             * });
             * ```
             *
             * ## Special cases
             *
             * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
             * will be ignored.
             *
             * This behavior can be used to insert tokens after `before`:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'comment', {
             *     'comment': Prism.languages.markup.comment,
             *     // tokens after 'comment'
             * });
             * ```
             *
             * ## Limitations
             *
             * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
             * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
             * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
             * deleting properties which is necessary to insert at arbitrary positions.
             *
             * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
             * Instead, it will create a new object and replace all references to the target object with the new one. This
             * can be done without temporarily deleting properties, so the iteration order is well-defined.
             *
             * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
             * you hold the target object in a variable, then the value of the variable will not change.
             *
             * ```js
             * var oldMarkup = Prism.languages.markup;
             * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
             *
             * assert(oldMarkup !== Prism.languages.markup);
             * assert(newMarkup === Prism.languages.markup);
             * ```
             *
             * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
             * object to be modified.
             * @param {string} before The key to insert before.
             * @param {Grammar} insert An object containing the key-value pairs to be inserted.
             * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
             * object to be modified.
             *
             * Defaults to `Prism.languages`.
             * @returns {Grammar} The new grammar object.
             * @public
             */
            insertBefore: function(inside, before, insert, root2) {
              root2 = root2 || /** @type {any} */
              _.languages;
              var grammar = root2[inside];
              var ret = {};
              for (var token in grammar) {
                if (grammar.hasOwnProperty(token)) {
                  if (token == before) {
                    for (var newToken in insert) {
                      if (insert.hasOwnProperty(newToken)) {
                        ret[newToken] = insert[newToken];
                      }
                    }
                  }
                  if (!insert.hasOwnProperty(token)) {
                    ret[token] = grammar[token];
                  }
                }
              }
              var old = root2[inside];
              root2[inside] = ret;
              _.languages.DFS(_.languages, function(key, value) {
                if (value === old && key != inside) {
                  this[key] = ret;
                }
              });
              return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o, callback, type, visited) {
              visited = visited || {};
              var objId = _.util.objId;
              for (var i in o) {
                if (o.hasOwnProperty(i)) {
                  callback.call(o, i, o[i], type || i);
                  var property2 = o[i];
                  var propertyType = _.util.type(property2);
                  if (propertyType === "Object" && !visited[objId(property2)]) {
                    visited[objId(property2)] = true;
                    DFS(property2, callback, null, visited);
                  } else if (propertyType === "Array" && !visited[objId(property2)]) {
                    visited[objId(property2)] = true;
                    DFS(property2, callback, i, visited);
                  }
                }
              }
            }
          },
          plugins: {},
          /**
           * This is the most high-level function in Prism’s API.
           * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
           * each one of them.
           *
           * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
           *
           * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
           * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
           * @memberof Prism
           * @public
           */
          highlightAll: function(async, callback) {
            _.highlightAllUnder(document, async, callback);
          },
          /**
           * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
           * {@link Prism.highlightElement} on each one of them.
           *
           * The following hooks will be run:
           * 1. `before-highlightall`
           * 2. `before-all-elements-highlight`
           * 3. All hooks of {@link Prism.highlightElement} for each element.
           *
           * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
           * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
           * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
           * @memberof Prism
           * @public
           */
          highlightAllUnder: function(container, async, callback) {
            var env2 = {
              callback,
              container,
              selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _.hooks.run("before-highlightall", env2);
            env2.elements = Array.prototype.slice.apply(env2.container.querySelectorAll(env2.selector));
            _.hooks.run("before-all-elements-highlight", env2);
            for (var i = 0, element2; element2 = env2.elements[i++]; ) {
              _.highlightElement(element2, async === true, env2.callback);
            }
          },
          /**
           * Highlights the code inside a single element.
           *
           * The following hooks will be run:
           * 1. `before-sanity-check`
           * 2. `before-highlight`
           * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
           * 4. `before-insert`
           * 5. `after-highlight`
           * 6. `complete`
           *
           * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
           * the element's language.
           *
           * @param {Element} element The element containing the code.
           * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
           * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
           * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
           * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
           *
           * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
           * asynchronous highlighting to work. You can build your own bundle on the
           * [Download page](https://prismjs.com/download.html).
           * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
           * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
           * @memberof Prism
           * @public
           */
          highlightElement: function(element2, async, callback) {
            var language = _.util.getLanguage(element2);
            var grammar = _.languages[language];
            _.util.setLanguage(element2, language);
            var parent = element2.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre") {
              _.util.setLanguage(parent, language);
            }
            var code2 = element2.textContent;
            var env2 = {
              element: element2,
              language,
              grammar,
              code: code2
            };
            function insertHighlightedCode(highlightedCode) {
              env2.highlightedCode = highlightedCode;
              _.hooks.run("before-insert", env2);
              env2.element.innerHTML = env2.highlightedCode;
              _.hooks.run("after-highlight", env2);
              _.hooks.run("complete", env2);
              callback && callback.call(env2.element);
            }
            _.hooks.run("before-sanity-check", env2);
            parent = env2.element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
              parent.setAttribute("tabindex", "0");
            }
            if (!env2.code) {
              _.hooks.run("complete", env2);
              callback && callback.call(env2.element);
              return;
            }
            _.hooks.run("before-highlight", env2);
            if (!env2.grammar) {
              insertHighlightedCode(_.util.encode(env2.code));
              return;
            }
            if (async && _self2.Worker) {
              var worker = new Worker(_.filename);
              worker.onmessage = function(evt) {
                insertHighlightedCode(evt.data);
              };
              worker.postMessage(JSON.stringify({
                language: env2.language,
                code: env2.code,
                immediateClose: true
              }));
            } else {
              insertHighlightedCode(_.highlight(env2.code, env2.grammar, env2.language));
            }
          },
          /**
           * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
           * and the language definitions to use, and returns a string with the HTML produced.
           *
           * The following hooks will be run:
           * 1. `before-tokenize`
           * 2. `after-tokenize`
           * 3. `wrap`: On each {@link Token}.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @param {string} language The name of the language definition passed to `grammar`.
           * @returns {string} The highlighted HTML.
           * @memberof Prism
           * @public
           * @example
           * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
           */
          highlight: function(text2, grammar, language) {
            var env2 = {
              code: text2,
              grammar,
              language
            };
            _.hooks.run("before-tokenize", env2);
            if (!env2.grammar) {
              throw new Error('The language "' + env2.language + '" has no grammar.');
            }
            env2.tokens = _.tokenize(env2.code, env2.grammar);
            _.hooks.run("after-tokenize", env2);
            return Token.stringify(_.util.encode(env2.tokens), env2.language);
          },
          /**
           * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
           * and the language definitions to use, and returns an array with the tokenized code.
           *
           * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
           *
           * This method could be useful in other contexts as well, as a very crude parser.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @returns {TokenStream} An array of strings and tokens, a token stream.
           * @memberof Prism
           * @public
           * @example
           * let code = `var foo = 0;`;
           * let tokens = Prism.tokenize(code, Prism.languages.javascript);
           * tokens.forEach(token => {
           *     if (token instanceof Prism.Token && token.type === 'number') {
           *         console.log(`Found numeric literal: ${token.content}`);
           *     }
           * });
           */
          tokenize: function(text2, grammar) {
            var rest = grammar.rest;
            if (rest) {
              for (var token in rest) {
                grammar[token] = rest[token];
              }
              delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text2);
            matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
            return toArray(tokenList);
          },
          /**
           * @namespace
           * @memberof Prism
           * @public
           */
          hooks: {
            all: {},
            /**
             * Adds the given callback to the list of callbacks for the given hook.
             *
             * The callback will be invoked when the hook it is registered for is run.
             * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
             *
             * One callback function can be registered to multiple hooks and the same hook multiple times.
             *
             * @param {string} name The name of the hook.
             * @param {HookCallback} callback The callback function which is given environment variables.
             * @public
             */
            add: function(name2, callback) {
              var hooks = _.hooks.all;
              hooks[name2] = hooks[name2] || [];
              hooks[name2].push(callback);
            },
            /**
             * Runs a hook invoking all registered callbacks with the given environment variables.
             *
             * Callbacks will be invoked synchronously and in the order in which they were registered.
             *
             * @param {string} name The name of the hook.
             * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
             * @public
             */
            run: function(name2, env2) {
              var callbacks = _.hooks.all[name2];
              if (!callbacks || !callbacks.length) {
                return;
              }
              for (var i = 0, callback; callback = callbacks[i++]; ) {
                callback(env2);
              }
            }
          },
          Token
        };
        _self2.Prism = _;
        function Token(type, content2, alias2, matchedStr) {
          this.type = type;
          this.content = content2;
          this.alias = alias2;
          this.length = (matchedStr || "").length | 0;
        }
        Token.stringify = function stringify2(o, language) {
          if (typeof o == "string") {
            return o;
          }
          if (Array.isArray(o)) {
            var s = "";
            o.forEach(function(e) {
              s += stringify2(e, language);
            });
            return s;
          }
          var env2 = {
            type: o.type,
            content: stringify2(o.content, language),
            tag: "span",
            classes: ["token", o.type],
            attributes: {},
            language
          };
          var aliases = o.alias;
          if (aliases) {
            if (Array.isArray(aliases)) {
              Array.prototype.push.apply(env2.classes, aliases);
            } else {
              env2.classes.push(aliases);
            }
          }
          _.hooks.run("wrap", env2);
          var attributes2 = "";
          for (var name2 in env2.attributes) {
            attributes2 += " " + name2 + '="' + (env2.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
          }
          return "<" + env2.tag + ' class="' + env2.classes.join(" ") + '"' + attributes2 + ">" + env2.content + "</" + env2.tag + ">";
        };
        function matchPattern(pattern, pos, text2, lookbehind) {
          pattern.lastIndex = pos;
          var match = pattern.exec(text2);
          if (match && lookbehind && match[1]) {
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
          }
          return match;
        }
        function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
          for (var token in grammar) {
            if (!grammar.hasOwnProperty(token) || !grammar[token]) {
              continue;
            }
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            for (var j = 0; j < patterns.length; ++j) {
              if (rematch && rematch.cause == token + "," + j) {
                return;
              }
              var patternObj = patterns[j];
              var inside = patternObj.inside;
              var lookbehind = !!patternObj.lookbehind;
              var greedy = !!patternObj.greedy;
              var alias2 = patternObj.alias;
              if (greedy && !patternObj.pattern.global) {
                var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
              }
              var pattern = patternObj.pattern || patternObj;
              for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
                if (rematch && pos >= rematch.reach) {
                  break;
                }
                var str = currentNode.value;
                if (tokenList.length > text2.length) {
                  return;
                }
                if (str instanceof Token) {
                  continue;
                }
                var removeCount = 1;
                var match;
                if (greedy) {
                  match = matchPattern(pattern, pos, text2, lookbehind);
                  if (!match || match.index >= text2.length) {
                    break;
                  }
                  var from = match.index;
                  var to = match.index + match[0].length;
                  var p2 = pos;
                  p2 += currentNode.value.length;
                  while (from >= p2) {
                    currentNode = currentNode.next;
                    p2 += currentNode.value.length;
                  }
                  p2 -= currentNode.value.length;
                  pos = p2;
                  if (currentNode.value instanceof Token) {
                    continue;
                  }
                  for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to || typeof k2.value === "string"); k2 = k2.next) {
                    removeCount++;
                    p2 += k2.value.length;
                  }
                  removeCount--;
                  str = text2.slice(pos, p2);
                  match.index -= pos;
                } else {
                  match = matchPattern(pattern, 0, str, lookbehind);
                  if (!match) {
                    continue;
                  }
                }
                var from = match.index;
                var matchStr = match[0];
                var before = str.slice(0, from);
                var after = str.slice(from + matchStr.length);
                var reach = pos + str.length;
                if (rematch && reach > rematch.reach) {
                  rematch.reach = reach;
                }
                var removeFrom = currentNode.prev;
                if (before) {
                  removeFrom = addAfter(tokenList, removeFrom, before);
                  pos += before.length;
                }
                removeRange(tokenList, removeFrom, removeCount);
                var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias2, matchStr);
                currentNode = addAfter(tokenList, removeFrom, wrapped);
                if (after) {
                  addAfter(tokenList, currentNode, after);
                }
                if (removeCount > 1) {
                  var nestedRematch = {
                    cause: token + "," + j,
                    reach
                  };
                  matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                  if (rematch && nestedRematch.reach > rematch.reach) {
                    rematch.reach = nestedRematch.reach;
                  }
                }
              }
            }
          }
        }
        function LinkedList() {
          var head = { value: null, prev: null, next: null };
          var tail = { value: null, prev: head, next: null };
          head.next = tail;
          this.head = head;
          this.tail = tail;
          this.length = 0;
        }
        function addAfter(list2, node2, value) {
          var next = node2.next;
          var newNode = { value, prev: node2, next };
          node2.next = newNode;
          next.prev = newNode;
          list2.length++;
          return newNode;
        }
        function removeRange(list2, node2, count) {
          var next = node2.next;
          for (var i = 0; i < count && next !== list2.tail; i++) {
            next = next.next;
          }
          node2.next = next;
          next.prev = node2;
          list2.length -= i;
        }
        function toArray(list2) {
          var array = [];
          var node2 = list2.head.next;
          while (node2 !== list2.tail) {
            array.push(node2.value);
            node2 = node2.next;
          }
          return array;
        }
        if (!_self2.document) {
          if (!_self2.addEventListener) {
            return _;
          }
          if (!_.disableWorkerMessageHandler) {
            _self2.addEventListener("message", function(evt) {
              var message = JSON.parse(evt.data);
              var lang2 = message.language;
              var code2 = message.code;
              var immediateClose = message.immediateClose;
              _self2.postMessage(_.highlight(code2, _.languages[lang2], lang2));
              if (immediateClose) {
                _self2.close();
              }
            }, false);
          }
          return _;
        }
        var script = _.util.currentScript();
        if (script) {
          _.filename = script.src;
          if (script.hasAttribute("data-manual")) {
            _.manual = true;
          }
        }
        function highlightAutomaticallyCallback() {
          if (!_.manual) {
            _.highlightAll();
          }
        }
        if (!_.manual) {
          var readyState = document.readyState;
          if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
            document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
          } else {
            if (window.requestAnimationFrame) {
              window.requestAnimationFrame(highlightAutomaticallyCallback);
            } else {
              window.setTimeout(highlightAutomaticallyCallback, 16);
            }
          }
        }
        return _;
      }(_self);
      if (module2.exports) {
        module2.exports = Prism2;
      }
      if (typeof commonjsGlobal !== "undefined") {
        commonjsGlobal.Prism = Prism2;
      }
    })(prismCore);
    var markup_1 = markup$1;
    markup$1.displayName = "markup";
    markup$1.aliases = ["html", "mathml", "svg", "xml", "ssml", "atom", "rss"];
    function markup$1(Prism2) {
      Prism2.languages.markup = {
        comment: {
          pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
          greedy: true
        },
        prolog: {
          pattern: /<\?[\s\S]+?\?>/,
          greedy: true
        },
        doctype: {
          // https://www.w3.org/TR/xml/#NT-doctypedecl
          pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
          greedy: true,
          inside: {
            "internal-subset": {
              pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
              lookbehind: true,
              greedy: true,
              inside: null
              // see below
            },
            string: {
              pattern: /"[^"]*"|'[^']*'/,
              greedy: true
            },
            punctuation: /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            name: /[^\s<>'"]+/
          }
        },
        cdata: {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          greedy: true
        },
        tag: {
          pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
          greedy: true,
          inside: {
            tag: {
              pattern: /^<\/?[^\s>\/]+/,
              inside: {
                punctuation: /^<\/?/,
                namespace: /^[^\s>\/:]+:/
              }
            },
            "special-attr": [],
            "attr-value": {
              pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
              inside: {
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            },
            punctuation: /\/?>/,
            "attr-name": {
              pattern: /[^\s>\/]+/,
              inside: {
                namespace: /^[^\s>\/:]+:/
              }
            }
          }
        },
        entity: [
          {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
          },
          /&#x?[\da-f]{1,8};/i
        ]
      };
      Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
      Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
      Prism2.hooks.add("wrap", function(env2) {
        if (env2.type === "entity") {
          env2.attributes["title"] = env2.content.value.replace(/&amp;/, "&");
        }
      });
      Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
        /**
         * Adds an inlined language to markup.
         *
         * An example of an inlined language is CSS with `<style>` tags.
         *
         * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addInlined('style', 'css');
         */
        value: function addInlined(tagName, lang) {
          var includedCdataInside = {};
          includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism2.languages[lang]
          };
          includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
          var inside = {
            "included-cdata": {
              pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
              inside: includedCdataInside
            }
          };
          inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: Prism2.languages[lang]
          };
          var def = {};
          def[tagName] = {
            pattern: RegExp(
              /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
                /__/g,
                function() {
                  return tagName;
                }
              ),
              "i"
            ),
            lookbehind: true,
            greedy: true,
            inside
          };
          Prism2.languages.insertBefore("markup", "cdata", def);
        }
      });
      Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
        /**
         * Adds an pattern to highlight languages embedded in HTML attributes.
         *
         * An example of an inlined language is CSS with `style` attributes.
         *
         * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addAttribute('style', 'css');
         */
        value: function(attrName, lang) {
          Prism2.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(
              /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
              "i"
            ),
            lookbehind: true,
            inside: {
              "attr-name": /^[^\s=]+/,
              "attr-value": {
                pattern: /=[\s\S]+/,
                inside: {
                  value: {
                    pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                    lookbehind: true,
                    alias: [lang, "language-" + lang],
                    inside: Prism2.languages[lang]
                  },
                  punctuation: [
                    {
                      pattern: /^=/,
                      alias: "attr-equals"
                    },
                    /"|'/
                  ]
                }
              }
            }
          });
        }
      });
      Prism2.languages.html = Prism2.languages.markup;
      Prism2.languages.mathml = Prism2.languages.markup;
      Prism2.languages.svg = Prism2.languages.markup;
      Prism2.languages.xml = Prism2.languages.extend("markup", {});
      Prism2.languages.ssml = Prism2.languages.xml;
      Prism2.languages.atom = Prism2.languages.xml;
      Prism2.languages.rss = Prism2.languages.xml;
    }
    var css_1 = css$1;
    css$1.displayName = "css";
    css$1.aliases = [];
    function css$1(Prism2) {
      (function(Prism3) {
        var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        Prism3.languages.css = {
          comment: /\/\*[\s\S]*?\*\//,
          atrule: {
            pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
            inside: {
              rule: /^@[\w-]+/,
              "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: true,
                alias: "selector"
              },
              keyword: {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: true
              }
              // See rest below
            }
          },
          url: {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp(
              "\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)",
              "i"
            ),
            greedy: true,
            inside: {
              function: /^url/i,
              punctuation: /^\(|\)$/,
              string: {
                pattern: RegExp("^" + string2.source + "$"),
                alias: "url"
              }
            }
          },
          selector: {
            pattern: RegExp(
              `(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"
            ),
            lookbehind: true
          },
          string: {
            pattern: string2,
            greedy: true
          },
          property: {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
          },
          important: /!important\b/i,
          function: {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
          },
          punctuation: /[(){};:,]/
        };
        Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
        var markup2 = Prism3.languages.markup;
        if (markup2) {
          markup2.tag.addInlined("style", "css");
          markup2.tag.addAttribute("style", "css");
        }
      })(Prism2);
    }
    var clike_1 = clike$1;
    clike$1.displayName = "clike";
    clike$1.aliases = [];
    function clike$1(Prism2) {
      Prism2.languages.clike = {
        comment: [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        string: {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
          lookbehind: true,
          inside: {
            punctuation: /[.\\]/
          }
        },
        keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
        boolean: /\b(?:false|true)\b/,
        function: /\b\w+(?=\()/,
        number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        punctuation: /[{}[\];(),.:]/
      };
    }
    var javascript_1 = javascript;
    javascript.displayName = "javascript";
    javascript.aliases = ["js"];
    function javascript(Prism2) {
      Prism2.languages.javascript = Prism2.languages.extend("clike", {
        "class-name": [
          Prism2.languages.clike["class-name"],
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
          }
        ],
        keyword: [
          {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
          },
          {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
          }
        ],
        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
        function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        number: {
          pattern: RegExp(
            /(^|[^\w$])/.source + "(?:" + // constant
            (/NaN|Infinity/.source + "|" + // binary integer
            /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
            /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
            /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
            /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
            /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
          ),
          lookbehind: true
        },
        operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
      });
      Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
      Prism2.languages.insertBefore("javascript", "keyword", {
        regex: {
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
          lookbehind: true,
          greedy: true,
          inside: {
            "regex-source": {
              pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
              lookbehind: true,
              alias: "language-regex",
              inside: Prism2.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
          }
        },
        // This must be declared before keyword because we use "function" inside the look-forward
        "function-variable": {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: "function"
        },
        parameter: [
          {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          }
        ],
        constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
      });
      Prism2.languages.insertBefore("javascript", "string", {
        hashbang: {
          pattern: /^#!.*/,
          greedy: true,
          alias: "comment"
        },
        "template-string": {
          pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
          greedy: true,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
              lookbehind: true,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: Prism2.languages.javascript
              }
            },
            string: /[\s\S]+/
          }
        },
        "string-property": {
          pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
          lookbehind: true,
          greedy: true,
          alias: "property"
        }
      });
      Prism2.languages.insertBefore("javascript", "operator", {
        "literal-property": {
          pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
          lookbehind: true,
          alias: "property"
        }
      });
      if (Prism2.languages.markup) {
        Prism2.languages.markup.tag.addInlined("script", "javascript");
        Prism2.languages.markup.tag.addAttribute(
          /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
          "javascript"
        );
      }
      Prism2.languages.js = Prism2.languages.javascript;
    }
    var ctx = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof commonjsGlobal === "object" ? commonjsGlobal : {};
    var restore = capture();
    ctx.Prism = { manual: true, disableWorkerMessageHandler: true };
    var h = hastscriptExports;
    var decode = parseEntities_1;
    var Prism = prismCoreExports;
    var markup = markup_1;
    var css = css_1;
    var clike = clike_1;
    var js = javascript_1;
    restore();
    var own = {}.hasOwnProperty;
    function Refractor() {
    }
    Refractor.prototype = Prism;
    var refract = new Refractor();
    var core = refract;
    refract.highlight = highlight;
    refract.register = register;
    refract.alias = alias;
    refract.registered = registered;
    refract.listLanguages = listLanguages;
    register(markup);
    register(css);
    register(clike);
    register(js);
    refract.util.encode = encode;
    refract.Token.stringify = stringify$1;
    function register(grammar) {
      if (typeof grammar !== "function" || !grammar.displayName) {
        throw new Error("Expected `function` for `grammar`, got `" + grammar + "`");
      }
      if (refract.languages[grammar.displayName] === void 0) {
        grammar(refract);
      }
    }
    function alias(name2, alias2) {
      var languages = refract.languages;
      var map2 = name2;
      var key;
      var list2;
      var length;
      var index2;
      if (alias2) {
        map2 = {};
        map2[name2] = alias2;
      }
      for (key in map2) {
        list2 = map2[key];
        list2 = typeof list2 === "string" ? [list2] : list2;
        length = list2.length;
        index2 = -1;
        while (++index2 < length) {
          languages[list2[index2]] = languages[key];
        }
      }
    }
    function highlight(value, name2) {
      var sup = Prism.highlight;
      var grammar;
      if (typeof value !== "string") {
        throw new Error("Expected `string` for `value`, got `" + value + "`");
      }
      if (refract.util.type(name2) === "Object") {
        grammar = name2;
        name2 = null;
      } else {
        if (typeof name2 !== "string") {
          throw new Error("Expected `string` for `name`, got `" + name2 + "`");
        }
        if (own.call(refract.languages, name2)) {
          grammar = refract.languages[name2];
        } else {
          throw new Error("Unknown language: `" + name2 + "` is not registered");
        }
      }
      return sup.call(this, value, grammar, name2);
    }
    function registered(language) {
      if (typeof language !== "string") {
        throw new Error("Expected `string` for `language`, got `" + language + "`");
      }
      return own.call(refract.languages, language);
    }
    function listLanguages() {
      var languages = refract.languages;
      var list2 = [];
      var language;
      for (language in languages) {
        if (own.call(languages, language) && typeof languages[language] === "object") {
          list2.push(language);
        }
      }
      return list2;
    }
    function stringify$1(value, language, parent) {
      var env2;
      if (typeof value === "string") {
        return { type: "text", value };
      }
      if (refract.util.type(value) === "Array") {
        return stringifyAll(value, language);
      }
      env2 = {
        type: value.type,
        content: refract.Token.stringify(value.content, language, parent),
        tag: "span",
        classes: ["token", value.type],
        attributes: {},
        language,
        parent
      };
      if (value.alias) {
        env2.classes = env2.classes.concat(value.alias);
      }
      refract.hooks.run("wrap", env2);
      return h(
        env2.tag + "." + env2.classes.join("."),
        attributes(env2.attributes),
        env2.content
      );
    }
    function stringifyAll(values, language) {
      var result = [];
      var length = values.length;
      var index2 = -1;
      var value;
      while (++index2 < length) {
        value = values[index2];
        if (value !== "" && value !== null && value !== void 0) {
          result.push(value);
        }
      }
      index2 = -1;
      length = result.length;
      while (++index2 < length) {
        value = result[index2];
        result[index2] = refract.Token.stringify(value, language, result);
      }
      return result;
    }
    function encode(tokens) {
      return tokens;
    }
    function attributes(attrs) {
      var key;
      for (key in attrs) {
        attrs[key] = decode(attrs[key]);
      }
      return attrs;
    }
    function capture() {
      var defined = "Prism" in ctx;
      var current = defined ? ctx.Prism : void 0;
      return restore2;
      function restore2() {
        if (defined) {
          ctx.Prism = current;
        } else {
          delete ctx.Prism;
        }
        defined = void 0;
        current = void 0;
      }
    }
    const defaultStyle = {
      'code[class*="language-"]': {
        "color": "black",
        "background": "none",
        "textShadow": "0 1px white",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "black",
        "background": "#f5f2f0",
        "textShadow": "0 1px white",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#f5f2f0",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "slategray"
      },
      "prolog": {
        "color": "slategray"
      },
      "doctype": {
        "color": "slategray"
      },
      "cdata": {
        "color": "slategray"
      },
      "punctuation": {
        "color": "#999"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#905"
      },
      "tag": {
        "color": "#905"
      },
      "boolean": {
        "color": "#905"
      },
      "number": {
        "color": "#905"
      },
      "constant": {
        "color": "#905"
      },
      "symbol": {
        "color": "#905"
      },
      "deleted": {
        "color": "#905"
      },
      "selector": {
        "color": "#690"
      },
      "attr-name": {
        "color": "#690"
      },
      "string": {
        "color": "#690"
      },
      "char": {
        "color": "#690"
      },
      "builtin": {
        "color": "#690"
      },
      "inserted": {
        "color": "#690"
      },
      "operator": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      "entity": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)",
        "cursor": "help"
      },
      "url": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      ".language-css .token.string": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      ".style .token.string": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      "atrule": {
        "color": "#07a"
      },
      "attr-value": {
        "color": "#07a"
      },
      "keyword": {
        "color": "#07a"
      },
      "function": {
        "color": "#DD4A68"
      },
      "class-name": {
        "color": "#DD4A68"
      },
      "regex": {
        "color": "#e90"
      },
      "important": {
        "color": "#e90",
        "fontWeight": "bold"
      },
      "variable": {
        "color": "#e90"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    var abap_1;
    var hasRequiredAbap;
    function requireAbap() {
      if (hasRequiredAbap)
        return abap_1;
      hasRequiredAbap = 1;
      abap_1 = abap;
      abap.displayName = "abap";
      abap.aliases = [];
      function abap(Prism2) {
        Prism2.languages.abap = {
          comment: /^\*.*/m,
          string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
          "string-template": {
            pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
            lookbehind: true,
            alias: "string"
          },
          /* End Of Line comments should not interfere with strings when the
          quote character occurs within them. We assume a string being highlighted
          inside an EOL comment is more acceptable than the opposite.
          */
          "eol-comment": {
            pattern: /(^|\s)".*/m,
            lookbehind: true,
            alias: "comment"
          },
          keyword: {
            pattern: /(\s|\.|^)(?:SCIENTIFIC_WITH_LEADING_ZERO|SCALE_PRESERVING_SCIENTIFIC|RMC_COMMUNICATION_FAILURE|END-ENHANCEMENT-SECTION|MULTIPLY-CORRESPONDING|SUBTRACT-CORRESPONDING|VERIFICATION-MESSAGE|DIVIDE-CORRESPONDING|ENHANCEMENT-SECTION|CURRENCY_CONVERSION|RMC_SYSTEM_FAILURE|START-OF-SELECTION|MOVE-CORRESPONDING|RMC_INVALID_STATUS|CUSTOMER-FUNCTION|END-OF-DEFINITION|ENHANCEMENT-POINT|SYSTEM-EXCEPTIONS|ADD-CORRESPONDING|SCALE_PRESERVING|SELECTION-SCREEN|CURSOR-SELECTION|END-OF-SELECTION|LOAD-OF-PROGRAM|SCROLL-BOUNDARY|SELECTION-TABLE|EXCEPTION-TABLE|IMPLEMENTATIONS|PARAMETER-TABLE|RIGHT-JUSTIFIED|UNIT_CONVERSION|AUTHORITY-CHECK|LIST-PROCESSING|SIGN_AS_POSTFIX|COL_BACKGROUND|IMPLEMENTATION|INTERFACE-POOL|TRANSFORMATION|IDENTIFICATION|ENDENHANCEMENT|LINE-SELECTION|INITIALIZATION|LEFT-JUSTIFIED|SELECT-OPTIONS|SELECTION-SETS|COMMUNICATION|CORRESPONDING|DECIMAL_SHIFT|PRINT-CONTROL|VALUE-REQUEST|CHAIN-REQUEST|FUNCTION-POOL|FIELD-SYMBOLS|FUNCTIONALITY|INVERTED-DATE|SELECTION-SET|CLASS-METHODS|OUTPUT-LENGTH|CLASS-CODING|COL_NEGATIVE|ERRORMESSAGE|FIELD-GROUPS|HELP-REQUEST|NO-EXTENSION|NO-TOPOFPAGE|REDEFINITION|DISPLAY-MODE|ENDINTERFACE|EXIT-COMMAND|FIELD-SYMBOL|NO-SCROLLING|SHORTDUMP-ID|ACCESSPOLICY|CLASS-EVENTS|COL_POSITIVE|DECLARATIONS|ENHANCEMENTS|FILTER-TABLE|SWITCHSTATES|SYNTAX-CHECK|TRANSPORTING|ASYNCHRONOUS|SYNTAX-TRACE|TOKENIZATION|USER-COMMAND|WITH-HEADING|ABAP-SOURCE|BREAK-POINT|CHAIN-INPUT|COMPRESSION|FIXED-POINT|NEW-SECTION|NON-UNICODE|OCCURRENCES|RESPONSIBLE|SYSTEM-CALL|TRACE-TABLE|ABBREVIATED|CHAR-TO-HEX|END-OF-FILE|ENDFUNCTION|ENVIRONMENT|ASSOCIATION|COL_HEADING|EDITOR-CALL|END-OF-PAGE|ENGINEERING|IMPLEMENTED|INTENSIFIED|RADIOBUTTON|SYSTEM-EXIT|TOP-OF-PAGE|TRANSACTION|APPLICATION|CONCATENATE|DESTINATION|ENHANCEMENT|IMMEDIATELY|NO-GROUPING|PRECOMPILED|REPLACEMENT|TITLE-LINES|ACTIVATION|BYTE-ORDER|CLASS-POOL|CONNECTION|CONVERSION|DEFINITION|DEPARTMENT|EXPIRATION|INHERITING|MESSAGE-ID|NO-HEADING|PERFORMING|QUEUE-ONLY|RIGHTSPACE|SCIENTIFIC|STATUSINFO|STRUCTURES|SYNCPOINTS|WITH-TITLE|ATTRIBUTES|BOUNDARIES|CLASS-DATA|COL_NORMAL|DD\/MM\/YYYY|DESCENDING|INTERFACES|LINE-COUNT|MM\/DD\/YYYY|NON-UNIQUE|PRESERVING|SELECTIONS|STATEMENTS|SUBROUTINE|TRUNCATION|TYPE-POOLS|ARITHMETIC|BACKGROUND|ENDPROVIDE|EXCEPTIONS|IDENTIFIER|INDEX-LINE|OBLIGATORY|PARAMETERS|PERCENTAGE|PUSHBUTTON|RESOLUTION|COMPONENTS|DEALLOCATE|DISCONNECT|DUPLICATES|FIRST-LINE|HEAD-LINES|NO-DISPLAY|OCCURRENCE|RESPECTING|RETURNCODE|SUBMATCHES|TRACE-FILE|ASCENDING|BYPASSING|ENDMODULE|EXCEPTION|EXCLUDING|EXPORTING|INCREMENT|MATCHCODE|PARAMETER|PARTIALLY|PREFERRED|REFERENCE|REPLACING|RETURNING|SELECTION|SEPARATED|SPECIFIED|STATEMENT|TIMESTAMP|TYPE-POOL|ACCEPTING|APPENDAGE|ASSIGNING|COL_GROUP|COMPARING|CONSTANTS|DANGEROUS|IMPORTING|INSTANCES|LEFTSPACE|LOG-POINT|QUICKINFO|READ-ONLY|SCROLLING|SQLSCRIPT|STEP-LOOP|TOP-LINES|TRANSLATE|APPENDING|AUTHORITY|CHARACTER|COMPONENT|CONDITION|DIRECTORY|DUPLICATE|MESSAGING|RECEIVING|SUBSCREEN|ACCORDING|COL_TOTAL|END-LINES|ENDMETHOD|ENDSELECT|EXPANDING|EXTENSION|INCLUDING|INFOTYPES|INTERFACE|INTERVALS|LINE-SIZE|PF-STATUS|PROCEDURE|PROTECTED|REQUESTED|RESUMABLE|RIGHTPLUS|SAP-SPOOL|SECONDARY|STRUCTURE|SUBSTRING|TABLEVIEW|NUMOFCHAR|ADJACENT|ANALYSIS|ASSIGNED|BACKWARD|CHANNELS|CHECKBOX|CONTINUE|CRITICAL|DATAINFO|DD\/MM\/YY|DURATION|ENCODING|ENDCLASS|FUNCTION|LEFTPLUS|LINEFEED|MM\/DD\/YY|OVERFLOW|RECEIVED|SKIPPING|SORTABLE|STANDARD|SUBTRACT|SUPPRESS|TABSTRIP|TITLEBAR|TRUNCATE|UNASSIGN|WHENEVER|ANALYZER|COALESCE|COMMENTS|CONDENSE|DECIMALS|DEFERRED|ENDWHILE|EXPLICIT|KEYWORDS|MESSAGES|POSITION|PRIORITY|RECEIVER|RENAMING|TIMEZONE|TRAILING|ALLOCATE|CENTERED|CIRCULAR|CONTROLS|CURRENCY|DELETING|DESCRIBE|DISTANCE|ENDCATCH|EXPONENT|EXTENDED|GENERATE|IGNORING|INCLUDES|INTERNAL|MAJOR-ID|MODIFIER|NEW-LINE|OPTIONAL|PROPERTY|ROLLBACK|STARTING|SUPPLIED|ABSTRACT|CHANGING|CONTEXTS|CREATING|CUSTOMER|DATABASE|DAYLIGHT|DEFINING|DISTINCT|DIVISION|ENABLING|ENDCHAIN|ESCAPING|HARMLESS|IMPLICIT|INACTIVE|LANGUAGE|MINOR-ID|MULTIPLY|NEW-PAGE|NO-TITLE|POS_HIGH|SEPARATE|TEXTPOOL|TRANSFER|SELECTOR|DBMAXLEN|ITERATOR|ARCHIVE|BIT-XOR|BYTE-CO|COLLECT|COMMENT|CURRENT|DEFAULT|DISPLAY|ENDFORM|EXTRACT|LEADING|LISTBOX|LOCATOR|MEMBERS|METHODS|NESTING|POS_LOW|PROCESS|PROVIDE|RAISING|RESERVE|SECONDS|SUMMARY|VISIBLE|BETWEEN|BIT-AND|BYTE-CS|CLEANUP|COMPUTE|CONTROL|CONVERT|DATASET|ENDCASE|FORWARD|HEADERS|HOTSPOT|INCLUDE|INVERSE|KEEPING|NO-ZERO|OBJECTS|OVERLAY|PADDING|PATTERN|PROGRAM|REFRESH|SECTION|SUMMING|TESTING|VERSION|WINDOWS|WITHOUT|BIT-NOT|BYTE-CA|BYTE-NA|CASTING|CONTEXT|COUNTRY|DYNAMIC|ENABLED|ENDLOOP|EXECUTE|FRIENDS|HANDLER|HEADING|INITIAL|\*-INPUT|LOGFILE|MAXIMUM|MINIMUM|NO-GAPS|NO-SIGN|PRAGMAS|PRIMARY|PRIVATE|REDUCED|REPLACE|REQUEST|RESULTS|UNICODE|WARNING|ALIASES|BYTE-CN|BYTE-NS|CALLING|COL_KEY|COLUMNS|CONNECT|ENDEXEC|ENTRIES|EXCLUDE|FILTERS|FURTHER|HELP-ID|LOGICAL|MAPPING|MESSAGE|NAMETAB|OPTIONS|PACKAGE|PERFORM|RECEIVE|STATICS|VARYING|BINDING|CHARLEN|GREATER|XSTRLEN|ACCEPT|APPEND|DETAIL|ELSEIF|ENDING|ENDTRY|FORMAT|FRAMES|GIVING|HASHED|HEADER|IMPORT|INSERT|MARGIN|MODULE|NATIVE|OBJECT|OFFSET|REMOTE|RESUME|SAVING|SIMPLE|SUBMIT|TABBED|TOKENS|UNIQUE|UNPACK|UPDATE|WINDOW|YELLOW|ACTUAL|ASPECT|CENTER|CURSOR|DELETE|DIALOG|DIVIDE|DURING|ERRORS|EVENTS|EXTEND|FILTER|HANDLE|HAVING|IGNORE|LITTLE|MEMORY|NO-GAP|OCCURS|OPTION|PERSON|PLACES|PUBLIC|REDUCE|REPORT|RESULT|SINGLE|SORTED|SWITCH|SYNTAX|TARGET|VALUES|WRITER|ASSERT|BLOCKS|BOUNDS|BUFFER|CHANGE|COLUMN|COMMIT|CONCAT|COPIES|CREATE|DDMMYY|DEFINE|ENDIAN|ESCAPE|EXPAND|KERNEL|LAYOUT|LEGACY|LEVELS|MMDDYY|NUMBER|OUTPUT|RANGES|READER|RETURN|SCREEN|SEARCH|SELECT|SHARED|SOURCE|STABLE|STATIC|SUBKEY|SUFFIX|TABLES|UNWIND|YYMMDD|ASSIGN|BACKUP|BEFORE|BINARY|BIT-OR|BLANKS|CLIENT|CODING|COMMON|DEMAND|DYNPRO|EXCEPT|EXISTS|EXPORT|FIELDS|GLOBAL|GROUPS|LENGTH|LOCALE|MEDIUM|METHOD|MODIFY|NESTED|OTHERS|REJECT|SCROLL|SUPPLY|SYMBOL|ENDFOR|STRLEN|ALIGN|BEGIN|BOUND|ENDAT|ENTRY|EVENT|FINAL|FLUSH|GRANT|INNER|SHORT|USING|WRITE|AFTER|BLACK|BLOCK|CLOCK|COLOR|COUNT|DUMMY|EMPTY|ENDDO|ENDON|GREEN|INDEX|INOUT|LEAVE|LEVEL|LINES|MODIF|ORDER|OUTER|RANGE|RESET|RETRY|RIGHT|SMART|SPLIT|STYLE|TABLE|THROW|UNDER|UNTIL|UPPER|UTF-8|WHERE|ALIAS|BLANK|CLEAR|CLOSE|EXACT|FETCH|FIRST|FOUND|GROUP|LLANG|LOCAL|OTHER|REGEX|SPOOL|TITLE|TYPES|VALID|WHILE|ALPHA|BOXED|CATCH|CHAIN|CHECK|CLASS|COVER|ENDIF|EQUIV|FIELD|FLOOR|FRAME|INPUT|LOWER|MATCH|NODES|PAGES|PRINT|RAISE|ROUND|SHIFT|SPACE|SPOTS|STAMP|STATE|TASKS|TIMES|TRMAC|ULINE|UNION|VALUE|WIDTH|EQUAL|LOG10|TRUNC|BLOB|CASE|CEIL|CLOB|COND|EXIT|FILE|GAPS|HOLD|INCL|INTO|KEEP|KEYS|LAST|LINE|LONG|LPAD|MAIL|MODE|OPEN|PINK|READ|ROWS|TEST|THEN|ZERO|AREA|BACK|BADI|BYTE|CAST|EDIT|EXEC|FAIL|FIND|FKEQ|FONT|FREE|GKEQ|HIDE|INIT|ITNO|LATE|LOOP|MAIN|MARK|MOVE|NEXT|NULL|RISK|ROLE|UNIT|WAIT|ZONE|BASE|CALL|CODE|DATA|DATE|FKGE|GKGE|HIGH|KIND|LEFT|LIST|MASK|MESH|NAME|NODE|PACK|PAGE|POOL|SEND|SIGN|SIZE|SOME|STOP|TASK|TEXT|TIME|USER|VARY|WITH|WORD|BLUE|CONV|COPY|DEEP|ELSE|FORM|FROM|HINT|ICON|JOIN|LIKE|LOAD|ONLY|PART|SCAN|SKIP|SORT|TYPE|UNIX|VIEW|WHEN|WORK|ACOS|ASIN|ATAN|COSH|EACH|FRAC|LESS|RTTI|SINH|SQRT|TANH|AVG|BIT|DIV|ISO|LET|OUT|PAD|SQL|ALL|CI_|CPI|END|LOB|LPI|MAX|MIN|NEW|OLE|RUN|SET|\?TO|YES|ABS|ADD|AND|BIG|FOR|HDB|JOB|LOW|NOT|SAP|TRY|VIA|XML|ANY|GET|IDS|KEY|MOD|OFF|PUT|RAW|RED|REF|SUM|TAB|XSD|CNT|COS|EXP|LOG|SIN|TAN|XOR|AT|CO|CP|DO|GT|ID|IF|NS|OR|BT|CA|CS|GE|NA|NB|EQ|IN|LT|NE|NO|OF|ON|PF|TO|AS|BY|CN|IS|LE|NP|UP|E|I|M|O|Z|C|X)\b/i,
            lookbehind: true
          },
          /* Numbers can be only integers. Decimal or Hex appear only as strings */
          number: /\b\d+\b/,
          /* Operators must always be surrounded by whitespace, they cannot be put
          adjacent to operands.
          */
          operator: {
            pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
            lookbehind: true
          },
          "string-operator": {
            pattern: /(\s)&&?(?=\s)/,
            lookbehind: true,
            /* The official editor highlights */
            alias: "keyword"
          },
          "token-operator": [
            {
              /* Special operators used to access structure components, class methods/attributes, etc. */
              pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
              lookbehind: true,
              alias: "punctuation"
            },
            {
              /* Special tokens used do delimit string templates */
              pattern: /[|{}]/,
              alias: "punctuation"
            }
          ],
          punctuation: /[,.:()]/
        };
      }
      return abap_1;
    }
    var abnf_1;
    var hasRequiredAbnf;
    function requireAbnf() {
      if (hasRequiredAbnf)
        return abnf_1;
      hasRequiredAbnf = 1;
      abnf_1 = abnf;
      abnf.displayName = "abnf";
      abnf.aliases = [];
      function abnf(Prism2) {
        (function(Prism3) {
          var coreRules = "(?:ALPHA|BIT|CHAR|CR|CRLF|CTL|DIGIT|DQUOTE|HEXDIG|HTAB|LF|LWSP|OCTET|SP|VCHAR|WSP)";
          Prism3.languages.abnf = {
            comment: /;.*/,
            string: {
              pattern: /(?:%[is])?"[^"\n\r]*"/,
              greedy: true,
              inside: {
                punctuation: /^%[is]/
              }
            },
            range: {
              pattern: /%(?:b[01]+-[01]+|d\d+-\d+|x[A-F\d]+-[A-F\d]+)/i,
              alias: "number"
            },
            terminal: {
              pattern: /%(?:b[01]+(?:\.[01]+)*|d\d+(?:\.\d+)*|x[A-F\d]+(?:\.[A-F\d]+)*)/i,
              alias: "number"
            },
            repetition: {
              pattern: /(^|[^\w-])(?:\d*\*\d*|\d+)/,
              lookbehind: true,
              alias: "operator"
            },
            definition: {
              pattern: /(^[ \t]*)(?:[a-z][\w-]*|<[^<>\r\n]*>)(?=\s*=)/m,
              lookbehind: true,
              alias: "keyword",
              inside: {
                punctuation: /<|>/
              }
            },
            "core-rule": {
              pattern: RegExp(
                "(?:(^|[^<\\w-])" + coreRules + "|<" + coreRules + ">)(?![\\w-])",
                "i"
              ),
              lookbehind: true,
              alias: ["rule", "constant"],
              inside: {
                punctuation: /<|>/
              }
            },
            rule: {
              pattern: /(^|[^<\w-])[a-z][\w-]*|<[^<>\r\n]*>/i,
              lookbehind: true,
              inside: {
                punctuation: /<|>/
              }
            },
            operator: /=\/?|\//,
            punctuation: /[()\[\]]/
          };
        })(Prism2);
      }
      return abnf_1;
    }
    var actionscript_1;
    var hasRequiredActionscript;
    function requireActionscript() {
      if (hasRequiredActionscript)
        return actionscript_1;
      hasRequiredActionscript = 1;
      actionscript_1 = actionscript;
      actionscript.displayName = "actionscript";
      actionscript.aliases = [];
      function actionscript(Prism2) {
        Prism2.languages.actionscript = Prism2.languages.extend("javascript", {
          keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
          operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
        });
        Prism2.languages.actionscript["class-name"].alias = "function";
        delete Prism2.languages.actionscript["parameter"];
        delete Prism2.languages.actionscript["literal-property"];
        if (Prism2.languages.markup) {
          Prism2.languages.insertBefore("actionscript", "string", {
            xml: {
              pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
              lookbehind: true,
              inside: Prism2.languages.markup
            }
          });
        }
      }
      return actionscript_1;
    }
    var ada_1;
    var hasRequiredAda;
    function requireAda() {
      if (hasRequiredAda)
        return ada_1;
      hasRequiredAda = 1;
      ada_1 = ada;
      ada.displayName = "ada";
      ada.aliases = [];
      function ada(Prism2) {
        Prism2.languages.ada = {
          comment: /--.*/,
          string: /"(?:""|[^"\r\f\n])*"/,
          number: [
            {
              pattern: /\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i
            },
            {
              pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i
            }
          ],
          "attr-name": /\b'\w+/,
          keyword: /\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|new|not|null|of|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|return|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
          boolean: /\b(?:false|true)\b/i,
          operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
          punctuation: /\.\.?|[,;():]/,
          char: /'.'/,
          variable: /\b[a-z](?:\w)*\b/i
        };
      }
      return ada_1;
    }
    var agda_1;
    var hasRequiredAgda;
    function requireAgda() {
      if (hasRequiredAgda)
        return agda_1;
      hasRequiredAgda = 1;
      agda_1 = agda;
      agda.displayName = "agda";
      agda.aliases = [];
      function agda(Prism2) {
        (function(Prism3) {
          Prism3.languages.agda = {
            comment: /\{-[\s\S]*?(?:-\}|$)|--.*/,
            string: {
              pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
              greedy: true
            },
            punctuation: /[(){}⦃⦄.;@]/,
            "class-name": {
              pattern: /((?:data|record) +)\S+/,
              lookbehind: true
            },
            function: {
              pattern: /(^[ \t]*)(?!\s)[^:\r\n]+(?=:)/m,
              lookbehind: true
            },
            operator: {
              pattern: /(^\s*|\s)(?:[=|:∀→λ\\?_]|->)(?=\s)/,
              lookbehind: true
            },
            keyword: /\b(?:Set|abstract|constructor|data|eta-equality|field|forall|hiding|import|in|inductive|infix|infixl|infixr|instance|let|macro|module|mutual|no-eta-equality|open|overlap|pattern|postulate|primitive|private|public|quote|quoteContext|quoteGoal|quoteTerm|record|renaming|rewrite|syntax|tactic|unquote|unquoteDecl|unquoteDef|using|variable|where|with)\b/
          };
        })(Prism2);
      }
      return agda_1;
    }
    var al_1;
    var hasRequiredAl;
    function requireAl() {
      if (hasRequiredAl)
        return al_1;
      hasRequiredAl = 1;
      al_1 = al2;
      al2.displayName = "al";
      al2.aliases = [];
      function al2(Prism2) {
        Prism2.languages.al = {
          comment: /\/\/.*|\/\*[\s\S]*?\*\//,
          string: {
            pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
            greedy: true
          },
          function: {
            pattern: /(\b(?:event|procedure|trigger)\s+|(?:^|[^.])\.\s*)[a-z_]\w*(?=\s*\()/i,
            lookbehind: true
          },
          keyword: [
            // keywords
            /\b(?:array|asserterror|begin|break|case|do|downto|else|end|event|exit|for|foreach|function|if|implements|in|indataset|interface|internal|local|of|procedure|program|protected|repeat|runonclient|securityfiltering|suppressdispose|temporary|then|to|trigger|until|var|while|with|withevents)\b/i,
            // objects and metadata that are used like keywords
            /\b(?:action|actions|addafter|addbefore|addfirst|addlast|area|assembly|chartpart|codeunit|column|controladdin|cuegroup|customizes|dataitem|dataset|dotnet|elements|enum|enumextension|extends|field|fieldattribute|fieldelement|fieldgroup|fieldgroups|fields|filter|fixed|grid|group|key|keys|label|labels|layout|modify|moveafter|movebefore|movefirst|movelast|page|pagecustomization|pageextension|part|profile|query|repeater|report|requestpage|schema|separator|systempart|table|tableelement|tableextension|textattribute|textelement|type|usercontrol|value|xmlport)\b/i
          ],
          number: /\b(?:0x[\da-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)(?:F|LL?|U(?:LL?)?)?\b/i,
          boolean: /\b(?:false|true)\b/i,
          variable: /\b(?:Curr(?:FieldNo|Page|Report)|x?Rec|RequestOptionsPage)\b/,
          "class-name": /\b(?:automation|biginteger|bigtext|blob|boolean|byte|char|clienttype|code|completiontriggererrorlevel|connectiontype|database|dataclassification|datascope|date|dateformula|datetime|decimal|defaultlayout|dialog|dictionary|dotnetassembly|dotnettypedeclaration|duration|errorinfo|errortype|executioncontext|executionmode|fieldclass|fieldref|fieldtype|file|filterpagebuilder|guid|httpclient|httpcontent|httpheaders|httprequestmessage|httpresponsemessage|instream|integer|joker|jsonarray|jsonobject|jsontoken|jsonvalue|keyref|list|moduledependencyinfo|moduleinfo|none|notification|notificationscope|objecttype|option|outstream|pageresult|record|recordid|recordref|reportformat|securityfilter|sessionsettings|tableconnectiontype|tablefilter|testaction|testfield|testfilterfield|testpage|testpermissions|testrequestpage|text|textbuilder|textconst|textencoding|time|transactionmodel|transactiontype|variant|verbosity|version|view|views|webserviceactioncontext|webserviceactionresultcode|xmlattribute|xmlattributecollection|xmlcdata|xmlcomment|xmldeclaration|xmldocument|xmldocumenttype|xmlelement|xmlnamespacemanager|xmlnametable|xmlnode|xmlnodelist|xmlprocessinginstruction|xmlreadoptions|xmltext|xmlwriteoptions)\b/i,
          operator: /\.\.|:[=:]|[-+*/]=?|<>|[<>]=?|=|\b(?:and|div|mod|not|or|xor)\b/i,
          punctuation: /[()\[\]{}:.;,]/
        };
      }
      return al_1;
    }
    var antlr4_1;
    var hasRequiredAntlr4;
    function requireAntlr4() {
      if (hasRequiredAntlr4)
        return antlr4_1;
      hasRequiredAntlr4 = 1;
      antlr4_1 = antlr4;
      antlr4.displayName = "antlr4";
      antlr4.aliases = ["g4"];
      function antlr4(Prism2) {
        Prism2.languages.antlr4 = {
          comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
          string: {
            pattern: /'(?:\\.|[^\\'\r\n])*'/,
            greedy: true
          },
          "character-class": {
            pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
            greedy: true,
            alias: "regex",
            inside: {
              range: {
                pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
                lookbehind: true,
                alias: "punctuation"
              },
              escape: /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
              punctuation: /[\[\]]/
            }
          },
          action: {
            pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
            greedy: true,
            inside: {
              content: {
                // this might be C, C++, Python, Java, C#, or any other language ANTLR4 compiles to
                pattern: /(\{)[\s\S]+(?=\})/,
                lookbehind: true
              },
              punctuation: /[{}]/
            }
          },
          command: {
            pattern: /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
            lookbehind: true,
            inside: {
              function: /\b\w+(?=\s*(?:[,(]|$))/,
              punctuation: /[,()]/
            }
          },
          annotation: {
            pattern: /@\w+(?:::\w+)*/,
            alias: "keyword"
          },
          label: {
            pattern: /#[ \t]*\w+/,
            alias: "punctuation"
          },
          keyword: /\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
          definition: [
            {
              pattern: /\b[a-z]\w*(?=\s*:)/,
              alias: ["rule", "class-name"]
            },
            {
              pattern: /\b[A-Z]\w*(?=\s*:)/,
              alias: ["token", "constant"]
            }
          ],
          constant: /\b[A-Z][A-Z_]*\b/,
          operator: /\.\.|->|[|~]|[*+?]\??/,
          punctuation: /[;:()=]/
        };
        Prism2.languages.g4 = Prism2.languages.antlr4;
      }
      return antlr4_1;
    }
    var apacheconf_1;
    var hasRequiredApacheconf;
    function requireApacheconf() {
      if (hasRequiredApacheconf)
        return apacheconf_1;
      hasRequiredApacheconf = 1;
      apacheconf_1 = apacheconf;
      apacheconf.displayName = "apacheconf";
      apacheconf.aliases = [];
      function apacheconf(Prism2) {
        Prism2.languages.apacheconf = {
          comment: /#.*/,
          "directive-inline": {
            pattern: /(^[\t ]*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|Type|UserFile|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|Limit(?:InternalRecursion|Request(?:Body|Fields|FieldSize|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|SRPUnknownUserSeed|SRPVerifierFile|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UserName|UseStapling|VerifyClient|VerifyDepth)|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
            lookbehind: true,
            alias: "property"
          },
          "directive-block": {
            pattern: /<\/?\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\b.*>/i,
            inside: {
              "directive-block": {
                pattern: /^<\/?\w+/,
                inside: {
                  punctuation: /^<\/?/
                },
                alias: "tag"
              },
              "directive-block-parameter": {
                pattern: /.*[^>]/,
                inside: {
                  punctuation: /:/,
                  string: {
                    pattern: /("|').*\1/,
                    inside: {
                      variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
                    }
                  }
                },
                alias: "attr-value"
              },
              punctuation: />/
            },
            alias: "tag"
          },
          "directive-flags": {
            pattern: /\[(?:[\w=],?)+\]/,
            alias: "keyword"
          },
          string: {
            pattern: /("|').*\1/,
            inside: {
              variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
            }
          },
          variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
          regex: /\^?.*\$|\^.*\$?/
        };
      }
      return apacheconf_1;
    }
    var sql_1;
    var hasRequiredSql;
    function requireSql() {
      if (hasRequiredSql)
        return sql_1;
      hasRequiredSql = 1;
      sql_1 = sql;
      sql.displayName = "sql";
      sql.aliases = [];
      function sql(Prism2) {
        Prism2.languages.sql = {
          comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
            lookbehind: true
          },
          variable: [
            {
              pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
              greedy: true
            },
            /@[\w.$]+/
          ],
          string: {
            pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
            greedy: true,
            lookbehind: true
          },
          identifier: {
            pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
            greedy: true,
            lookbehind: true,
            inside: {
              punctuation: /^`|`$/
            }
          },
          function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
          // Should we highlight user defined functions too?
          keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
          boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
          number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
          operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
          punctuation: /[;[\]()`,.]/
        };
      }
      return sql_1;
    }
    var apex_1;
    var hasRequiredApex;
    function requireApex() {
      if (hasRequiredApex)
        return apex_1;
      hasRequiredApex = 1;
      var refractorSql = requireSql();
      apex_1 = apex;
      apex.displayName = "apex";
      apex.aliases = [];
      function apex(Prism2) {
        Prism2.register(refractorSql);
        (function(Prism3) {
          var keywords = /\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i;
          var className = /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(
            /<keyword>/g,
            function() {
              return keywords.source;
            }
          );
          function insertClassName(pattern) {
            return RegExp(
              pattern.replace(/<CLASS-NAME>/g, function() {
                return className;
              }),
              "i"
            );
          }
          var classNameInside = {
            keyword: keywords,
            punctuation: /[()\[\]{};,:.<>]/
          };
          Prism3.languages.apex = {
            comment: Prism3.languages.clike.comment,
            string: Prism3.languages.clike.string,
            sql: {
              pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
              lookbehind: true,
              greedy: true,
              alias: "language-sql",
              inside: Prism3.languages.sql
            },
            annotation: {
              pattern: /@\w+\b/,
              alias: "punctuation"
            },
            "class-name": [
              {
                pattern: insertClassName(
                  /(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/.source
                ),
                lookbehind: true,
                inside: classNameInside
              },
              {
                // cast
                pattern: insertClassName(
                  /(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source
                ),
                lookbehind: true,
                inside: classNameInside
              },
              {
                // variable/parameter declaration and return types
                pattern: insertClassName(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source),
                inside: classNameInside
              }
            ],
            trigger: {
              pattern: /(\btrigger\s+)\w+\b/i,
              lookbehind: true,
              alias: "class-name"
            },
            keyword: keywords,
            function: /\b[a-z_]\w*(?=\s*\()/i,
            boolean: /\b(?:false|true)\b/i,
            number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
            operator: /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
            punctuation: /[()\[\]{};,.]/
          };
        })(Prism2);
      }
      return apex_1;
    }
    var apl_1;
    var hasRequiredApl;
    function requireApl() {
      if (hasRequiredApl)
        return apl_1;
      hasRequiredApl = 1;
      apl_1 = apl;
      apl.displayName = "apl";
      apl.aliases = [];
      function apl(Prism2) {
        Prism2.languages.apl = {
          comment: /(?:⍝|#[! ]).*$/m,
          string: {
            pattern: /'(?:[^'\r\n]|'')*'/,
            greedy: true
          },
          number: /¯?(?:\d*\.?\b\d+(?:e[+¯]?\d+)?|¯|∞)(?:j¯?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+¯]?\d+)?|¯|∞))?/i,
          statement: /:[A-Z][a-z][A-Za-z]*\b/,
          "system-function": {
            pattern: /⎕[A-Z]+/i,
            alias: "function"
          },
          constant: /[⍬⌾#⎕⍞]/,
          function: /[-+×÷⌈⌊∣|⍳⍸?*⍟○!⌹<≤=>≥≠≡≢∊⍷∪∩~∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⊆⊇⌷⍋⍒⊤⊥⍕⍎⊣⊢⍁⍂≈⍯↗¤→]/,
          "monadic-operator": {
            pattern: /[\\\/⌿⍀¨⍨⌶&∥]/,
            alias: "operator"
          },
          "dyadic-operator": {
            pattern: /[.⍣⍠⍤∘⌸@⌺⍥]/,
            alias: "operator"
          },
          assignment: {
            pattern: /←/,
            alias: "keyword"
          },
          punctuation: /[\[;\]()◇⋄]/,
          dfn: {
            pattern: /[{}⍺⍵⍶⍹∇⍫:]/,
            alias: "builtin"
          }
        };
      }
      return apl_1;
    }
    var applescript_1;
    var hasRequiredApplescript;
    function requireApplescript() {
      if (hasRequiredApplescript)
        return applescript_1;
      hasRequiredApplescript = 1;
      applescript_1 = applescript;
      applescript.displayName = "applescript";
      applescript.aliases = [];
      function applescript(Prism2) {
        Prism2.languages.applescript = {
          comment: [
            // Allow one level of nesting
            /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
            /--.+/,
            /#.+/
          ],
          string: /"(?:\\.|[^"\\\r\n])*"/,
          number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?\b/i,
          operator: [
            /[&=≠≤≥*+\-\/÷^]|[<>]=?/,
            /\b(?:(?:begin|end|start)s? with|(?:contains?|(?:does not|doesn't) contain)|(?:is|isn't|is not) (?:contained by|in)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:comes|(?:does not|doesn't) come) (?:after|before)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equal to|equals|is not|isn't)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|as|div|mod|not|or))\b/
          ],
          keyword: /\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
          "class-name": /\b(?:POSIX file|RGB color|alias|application|boolean|centimeters|centimetres|class|constant|cubic centimeters|cubic centimetres|cubic feet|cubic inches|cubic meters|cubic metres|cubic yards|date|degrees Celsius|degrees Fahrenheit|degrees Kelvin|feet|file|gallons|grams|inches|integer|kilograms|kilometers|kilometres|list|liters|litres|meters|metres|miles|number|ounces|pounds|quarts|real|record|reference|script|square feet|square kilometers|square kilometres|square meters|square metres|square miles|square yards|text|yards)\b/,
          punctuation: /[{}():,¬«»《》]/
        };
      }
      return applescript_1;
    }
    var aql_1;
    var hasRequiredAql;
    function requireAql() {
      if (hasRequiredAql)
        return aql_1;
      hasRequiredAql = 1;
      aql_1 = aql;
      aql.displayName = "aql";
      aql.aliases = [];
      function aql(Prism2) {
        Prism2.languages.aql = {
          comment: /\/\/.*|\/\*[\s\S]*?\*\//,
          property: {
            pattern: /([{,]\s*)(?:(?!\d)\w+|(["'´`])(?:(?!\2)[^\\\r\n]|\\.)*\2)(?=\s*:)/,
            lookbehind: true,
            greedy: true
          },
          string: {
            pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
            greedy: true
          },
          identifier: {
            pattern: /([´`])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
            greedy: true
          },
          variable: /@@?\w+/,
          keyword: [
            {
              pattern: /(\bWITH\s+)COUNT(?=\s+INTO\b)/i,
              lookbehind: true
            },
            /\b(?:AGGREGATE|ALL|AND|ANY|ASC|COLLECT|DESC|DISTINCT|FILTER|FOR|GRAPH|IN|INBOUND|INSERT|INTO|K_PATHS|K_SHORTEST_PATHS|LET|LIKE|LIMIT|NONE|NOT|NULL|OR|OUTBOUND|REMOVE|REPLACE|RETURN|SHORTEST_PATH|SORT|UPDATE|UPSERT|WINDOW|WITH)\b/i,
            // pseudo keywords get a lookbehind to avoid false positives
            {
              pattern: /(^|[^\w.[])(?:KEEP|PRUNE|SEARCH|TO)\b/i,
              lookbehind: true
            },
            {
              pattern: /(^|[^\w.[])(?:CURRENT|NEW|OLD)\b/,
              lookbehind: true
            },
            {
              pattern: /\bOPTIONS(?=\s*\{)/i
            }
          ],
          function: /\b(?!\d)\w+(?=\s*\()/,
          boolean: /\b(?:false|true)\b/i,
          range: {
            pattern: /\.\./,
            alias: "operator"
          },
          number: [
            /\b0b[01]+/i,
            /\b0x[0-9a-f]+/i,
            /(?:\B\.\d+|\b(?:0|[1-9]\d*)(?:\.\d+)?)(?:e[+-]?\d+)?/i
          ],
          operator: /\*{2,}|[=!]~|[!=<>]=?|&&|\|\||[-+*/%]/,
          punctuation: /::|[?.:,;()[\]{}]/
        };
      }
      return aql_1;
    }
    var c_1;
    var hasRequiredC;
    function requireC() {
      if (hasRequiredC)
        return c_1;
      hasRequiredC = 1;
      c_1 = c;
      c.displayName = "c";
      c.aliases = [];
      function c(Prism2) {
        Prism2.languages.c = Prism2.languages.extend("clike", {
          comment: {
            pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
            greedy: true
          },
          string: {
            // https://en.cppreference.com/w/c/language/string_literal
            pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
            greedy: true
          },
          "class-name": {
            pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
            lookbehind: true
          },
          keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
          function: /\b[a-z_]\w*(?=\s*\()/i,
          number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
          operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
        });
        Prism2.languages.insertBefore("c", "string", {
          char: {
            // https://en.cppreference.com/w/c/language/character_constant
            pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
            greedy: true
          }
        });
        Prism2.languages.insertBefore("c", "string", {
          macro: {
            // allow for multiline macro definitions
            // spaces after the # character compile fine with gcc
            pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
            lookbehind: true,
            greedy: true,
            alias: "property",
            inside: {
              string: [
                {
                  // highlight the path of the include statement as a string
                  pattern: /^(#\s*include\s*)<[^>]+>/,
                  lookbehind: true
                },
                Prism2.languages.c["string"]
              ],
              char: Prism2.languages.c["char"],
              comment: Prism2.languages.c["comment"],
              "macro-name": [
                {
                  pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
                  lookbehind: true
                },
                {
                  pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
                  lookbehind: true,
                  alias: "function"
                }
              ],
              // highlight macro directives as keywords
              directive: {
                pattern: /^(#\s*)[a-z]+/,
                lookbehind: true,
                alias: "keyword"
              },
              "directive-hash": /^#/,
              punctuation: /##|\\(?=[\r\n])/,
              expression: {
                pattern: /\S[\s\S]*/,
                inside: Prism2.languages.c
              }
            }
          }
        });
        Prism2.languages.insertBefore("c", "function", {
          // highlight predefined macros as constants
          constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
        });
        delete Prism2.languages.c["boolean"];
      }
      return c_1;
    }
    var cpp_1;
    var hasRequiredCpp;
    function requireCpp() {
      if (hasRequiredCpp)
        return cpp_1;
      hasRequiredCpp = 1;
      var refractorC = requireC();
      cpp_1 = cpp;
      cpp.displayName = "cpp";
      cpp.aliases = [];
      function cpp(Prism2) {
        Prism2.register(refractorC);
        (function(Prism3) {
          var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
          var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(
            /<keyword>/g,
            function() {
              return keyword.source;
            }
          );
          Prism3.languages.cpp = Prism3.languages.extend("c", {
            "class-name": [
              {
                pattern: RegExp(
                  /(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(
                    /<keyword>/g,
                    function() {
                      return keyword.source;
                    }
                  )
                ),
                lookbehind: true
              },
              // This is intended to capture the class name of method implementations like:
              //   void foo::bar() const {}
              // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
              // it starts with an uppercase letter. This approximation should give decent results.
              /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
              // This will capture the class name before destructors like:
              //   Foo::~Foo() {}
              /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
              // This also intends to capture the class name of method implementations but here the class has template
              // parameters, so it can't be a namespace (until C++ adds generic namespaces).
              /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
            ],
            keyword,
            number: {
              pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
              greedy: true
            },
            operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
            boolean: /\b(?:false|true)\b/
          });
          Prism3.languages.insertBefore("cpp", "string", {
            module: {
              // https://en.cppreference.com/w/cpp/language/modules
              pattern: RegExp(
                /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
                /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
                /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(
                  /<mod-name>/g,
                  function() {
                    return modName;
                  }
                ) + ")"
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                string: /^[<"][\s\S]+/,
                operator: /:/,
                punctuation: /\./
              }
            },
            "raw-string": {
              pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
              alias: "string",
              greedy: true
            }
          });
          Prism3.languages.insertBefore("cpp", "keyword", {
            "generic-function": {
              pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
              inside: {
                function: /^\w+/,
                generic: {
                  pattern: /<[\s\S]+/,
                  alias: "class-name",
                  inside: Prism3.languages.cpp
                }
              }
            }
          });
          Prism3.languages.insertBefore("cpp", "operator", {
            "double-colon": {
              pattern: /::/,
              alias: "punctuation"
            }
          });
          Prism3.languages.insertBefore("cpp", "class-name", {
            // the base clause is an optional list of parent classes
            // https://en.cppreference.com/w/cpp/language/class
            "base-clause": {
              pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
              lookbehind: true,
              greedy: true,
              inside: Prism3.languages.extend("cpp", {})
            }
          });
          Prism3.languages.insertBefore(
            "inside",
            "double-colon",
            {
              // All untokenized words that are not namespaces should be class names
              "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
            },
            Prism3.languages.cpp["base-clause"]
          );
        })(Prism2);
      }
      return cpp_1;
    }
    var arduino_1;
    var hasRequiredArduino;
    function requireArduino() {
      if (hasRequiredArduino)
        return arduino_1;
      hasRequiredArduino = 1;
      var refractorCpp = requireCpp();
      arduino_1 = arduino;
      arduino.displayName = "arduino";
      arduino.aliases = ["ino"];
      function arduino(Prism2) {
        Prism2.register(refractorCpp);
        Prism2.languages.arduino = Prism2.languages.extend("cpp", {
          keyword: /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
          constant: /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
          builtin: /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
        });
        Prism2.languages.ino = Prism2.languages.arduino;
      }
      return arduino_1;
    }
    var arff_1;
    var hasRequiredArff;
    function requireArff() {
      if (hasRequiredArff)
        return arff_1;
      hasRequiredArff = 1;
      arff_1 = arff;
      arff.displayName = "arff";
      arff.aliases = [];
      function arff(Prism2) {
        Prism2.languages.arff = {
          comment: /%.*/,
          string: {
            pattern: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          keyword: /@(?:attribute|data|end|relation)\b/i,
          number: /\b\d+(?:\.\d+)?\b/,
          punctuation: /[{},]/
        };
      }
      return arff_1;
    }
    var asciidoc_1;
    var hasRequiredAsciidoc;
    function requireAsciidoc() {
      if (hasRequiredAsciidoc)
        return asciidoc_1;
      hasRequiredAsciidoc = 1;
      asciidoc_1 = asciidoc;
      asciidoc.displayName = "asciidoc";
      asciidoc.aliases = ["adoc"];
      function asciidoc(Prism2) {
        (function(Prism3) {
          var attributes2 = {
            pattern: /(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\[\]\\]|\\.)*\]|[^\[\]\\"'$`]|\\.)*\]/m,
            lookbehind: true,
            inside: {
              quoted: {
                pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
                inside: {
                  punctuation: /^[$`]|[$`]$/
                }
              },
              interpreted: {
                pattern: /'(?:[^'\\]|\\.)*'/,
                inside: {
                  punctuation: /^'|'$/
                  // See rest below
                }
              },
              string: /"(?:[^"\\]|\\.)*"/,
              variable: /\w+(?==)/,
              punctuation: /^\[|\]$|,/,
              operator: /=/,
              // The negative look-ahead prevents blank matches
              "attr-value": /(?!^\s+$).+/
            }
          };
          var asciidoc2 = Prism3.languages.asciidoc = {
            "comment-block": {
              pattern: /^(\/{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1/m,
              alias: "comment"
            },
            table: {
              pattern: /^\|={3,}(?:(?:\r?\n|\r(?!\n)).*)*?(?:\r?\n|\r)\|={3,}$/m,
              inside: {
                specifiers: {
                  pattern: /(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*](?:[<^>](?:\.[<^>])?|\.[<^>])?|[<^>](?:\.[<^>])?|\.[<^>])[a-z]*|[a-z]+)(?=\|)/,
                  alias: "attr-value"
                },
                punctuation: {
                  pattern: /(^|[^\\])[|!]=*/,
                  lookbehind: true
                }
                // See rest below
              }
            },
            "passthrough-block": {
              pattern: /^(\+{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
              inside: {
                punctuation: /^\++|\++$/
                // See rest below
              }
            },
            // Literal blocks and listing blocks
            "literal-block": {
              pattern: /^(-{4,}|\.{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
              inside: {
                punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/
                // See rest below
              }
            },
            // Sidebar blocks, quote blocks, example blocks and open blocks
            "other-block": {
              pattern: /^(--|\*{4,}|_{4,}|={4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
              inside: {
                punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/
                // See rest below
              }
            },
            // list-punctuation and list-label must appear before indented-block
            "list-punctuation": {
              pattern: /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
              lookbehind: true,
              alias: "punctuation"
            },
            "list-label": {
              pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
              lookbehind: true,
              alias: "symbol"
            },
            "indented-block": {
              pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
              lookbehind: true
            },
            comment: /^\/\/.*/m,
            title: {
              pattern: /^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} .+|^\.(?![\s.]).*/m,
              alias: "important",
              inside: {
                punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/
                // See rest below
              }
            },
            "attribute-entry": {
              pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
              alias: "tag"
            },
            attributes: attributes2,
            hr: {
              pattern: /^'{3,}$/m,
              alias: "punctuation"
            },
            "page-break": {
              pattern: /^<{3,}$/m,
              alias: "punctuation"
            },
            admonition: {
              pattern: /^(?:CAUTION|IMPORTANT|NOTE|TIP|WARNING):/m,
              alias: "keyword"
            },
            callout: [
              {
                pattern: /(^[ \t]*)<?\d*>/m,
                lookbehind: true,
                alias: "symbol"
              },
              {
                pattern: /<\d+>/,
                alias: "symbol"
              }
            ],
            macro: {
              pattern: /\b[a-z\d][a-z\d-]*::?(?:[^\s\[\]]*\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
              inside: {
                function: /^[a-z\d-]+(?=:)/,
                punctuation: /^::?/,
                attributes: {
                  pattern: /(?:\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
                  inside: attributes2.inside
                }
              }
            },
            inline: {
              /*
              The initial look-behind prevents the highlighting of escaped quoted text.
              Quoted text can be multi-line but cannot span an empty line.
              All quoted text can have attributes before [foobar, 'foobar', baz="bar"].
              First, we handle the constrained quotes.
              Those must be bounded by non-word chars and cannot have spaces between the delimiter and the first char.
              They are, in order: _emphasis_, ``double quotes'', `single quotes', `monospace`, 'emphasis', *strong*, +monospace+ and #unquoted#
              Then we handle the unconstrained quotes.
              Those do not have the restrictions of the constrained quotes.
              They are, in order: __emphasis__, **strong**, ++monospace++, +++passthrough+++, ##unquoted##, $$passthrough$$, ~subscript~, ^superscript^, {attribute-reference}, [[anchor]], [[[bibliography anchor]]], <<xref>>, (((indexes))) and ((indexes))
              */
              pattern: /(^|[^\\])(?:(?:\B\[(?:[^\]\\"']|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?:[^`'\s]|\s+\S)+['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"']|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
              lookbehind: true,
              inside: {
                attributes: attributes2,
                url: {
                  pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
                  inside: {
                    punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/
                  }
                },
                "attribute-ref": {
                  pattern: /^\{.+\}$/,
                  inside: {
                    variable: {
                      pattern: /(^\{)[a-z\d,+_-]+/,
                      lookbehind: true
                    },
                    operator: /^[=?!#%@$]|!(?=[:}])/,
                    punctuation: /^\{|\}$|::?/
                  }
                },
                italic: {
                  pattern: /^(['_])[\s\S]+\1$/,
                  inside: {
                    punctuation: /^(?:''?|__?)|(?:''?|__?)$/
                  }
                },
                bold: {
                  pattern: /^\*[\s\S]+\*$/,
                  inside: {
                    punctuation: /^\*\*?|\*\*?$/
                  }
                },
                punctuation: /^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
              }
            },
            replacement: {
              pattern: /\((?:C|R|TM)\)/,
              alias: "builtin"
            },
            entity: /&#?[\da-z]{1,8};/i,
            "line-continuation": {
              pattern: /(^| )\+$/m,
              lookbehind: true,
              alias: "punctuation"
            }
          };
          function copyFromAsciiDoc(keys2) {
            keys2 = keys2.split(" ");
            var o = {};
            for (var i = 0, l2 = keys2.length; i < l2; i++) {
              o[keys2[i]] = asciidoc2[keys2[i]];
            }
            return o;
          }
          attributes2.inside["interpreted"].inside.rest = copyFromAsciiDoc(
            "macro inline replacement entity"
          );
          asciidoc2["passthrough-block"].inside.rest = copyFromAsciiDoc("macro");
          asciidoc2["literal-block"].inside.rest = copyFromAsciiDoc("callout");
          asciidoc2["table"].inside.rest = copyFromAsciiDoc(
            "comment-block passthrough-block literal-block other-block list-punctuation indented-block comment title attribute-entry attributes hr page-break admonition list-label callout macro inline replacement entity line-continuation"
          );
          asciidoc2["other-block"].inside.rest = copyFromAsciiDoc(
            "table list-punctuation indented-block comment attribute-entry attributes hr page-break admonition list-label macro inline replacement entity line-continuation"
          );
          asciidoc2["title"].inside.rest = copyFromAsciiDoc(
            "macro inline replacement entity"
          );
          Prism3.hooks.add("wrap", function(env2) {
            if (env2.type === "entity") {
              env2.attributes["title"] = env2.content.value.replace(/&amp;/, "&");
            }
          });
          Prism3.languages.adoc = Prism3.languages.asciidoc;
        })(Prism2);
      }
      return asciidoc_1;
    }
    var asm6502_1;
    var hasRequiredAsm6502;
    function requireAsm6502() {
      if (hasRequiredAsm6502)
        return asm6502_1;
      hasRequiredAsm6502 = 1;
      asm6502_1 = asm6502;
      asm6502.displayName = "asm6502";
      asm6502.aliases = [];
      function asm6502(Prism2) {
        Prism2.languages.asm6502 = {
          comment: /;.*/,
          directive: {
            pattern: /\.\w+(?= )/,
            alias: "property"
          },
          string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
          "op-code": {
            pattern: /\b(?:ADC|AND|ASL|BCC|BCS|BEQ|BIT|BMI|BNE|BPL|BRK|BVC|BVS|CLC|CLD|CLI|CLV|CMP|CPX|CPY|DEC|DEX|DEY|EOR|INC|INX|INY|JMP|JSR|LDA|LDX|LDY|LSR|NOP|ORA|PHA|PHP|PLA|PLP|ROL|ROR|RTI|RTS|SBC|SEC|SED|SEI|STA|STX|STY|TAX|TAY|TSX|TXA|TXS|TYA|adc|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|brk|bvc|bvs|clc|cld|cli|clv|cmp|cpx|cpy|dec|dex|dey|eor|inc|inx|iny|jmp|jsr|lda|ldx|ldy|lsr|nop|ora|pha|php|pla|plp|rol|ror|rti|rts|sbc|sec|sed|sei|sta|stx|sty|tax|tay|tsx|txa|txs|tya)\b/,
            alias: "keyword"
          },
          "hex-number": {
            pattern: /#?\$[\da-f]{1,4}\b/i,
            alias: "number"
          },
          "binary-number": {
            pattern: /#?%[01]+\b/,
            alias: "number"
          },
          "decimal-number": {
            pattern: /#?\b\d+\b/,
            alias: "number"
          },
          register: {
            pattern: /\b[xya]\b/i,
            alias: "variable"
          },
          punctuation: /[(),:]/
        };
      }
      return asm6502_1;
    }
    var asmatmel_1;
    var hasRequiredAsmatmel;
    function requireAsmatmel() {
      if (hasRequiredAsmatmel)
        return asmatmel_1;
      hasRequiredAsmatmel = 1;
      asmatmel_1 = asmatmel;
      asmatmel.displayName = "asmatmel";
      asmatmel.aliases = [];
      function asmatmel(Prism2) {
        Prism2.languages.asmatmel = {
          comment: {
            pattern: /;.*/,
            greedy: true
          },
          string: {
            pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          constant: /\b(?:PORT[A-Z]|DDR[A-Z]|(?:DD|P)[A-Z](?:\d|[0-2]\d|3[01]))\b/,
          directive: {
            pattern: /\.\w+(?= )/,
            alias: "property"
          },
          "r-register": {
            pattern: /\br(?:\d|[12]\d|3[01])\b/,
            alias: "variable"
          },
          "op-code": {
            pattern: /\b(?:ADC|ADD|ADIW|AND|ANDI|ASR|BCLR|BLD|BRBC|BRBS|BRCC|BRCS|BREAK|BREQ|BRGE|BRHC|BRHS|BRID|BRIE|BRLO|BRLT|BRMI|BRNE|BRPL|BRSH|BRTC|BRTS|BRVC|BRVS|BSET|BST|CALL|CBI|CBR|CLC|CLH|CLI|CLN|CLR|CLS|CLT|CLV|CLZ|COM|CP|CPC|CPI|CPSE|DEC|DES|EICALL|EIJMP|ELPM|EOR|FMUL|FMULS|FMULSU|ICALL|IJMP|IN|INC|JMP|LAC|LAS|LAT|LD|LD[A-Za-z0-9]|LPM|LSL|LSR|MOV|MOVW|MUL|MULS|MULSU|NEG|NOP|OR|ORI|OUT|POP|PUSH|RCALL|RET|RETI|RJMP|ROL|ROR|SBC|SBCI|SBI|SBIC|SBIS|SBIW|SBR|SBRC|SBRS|SEC|SEH|SEI|SEN|SER|SES|SET|SEV|SEZ|SLEEP|SPM|ST|ST[A-Z0-9]|SUB|SUBI|SWAP|TST|WDR|XCH|adc|add|adiw|and|andi|asr|bclr|bld|brbc|brbs|brcc|brcs|break|breq|brge|brhc|brhs|brid|brie|brlo|brlt|brmi|brne|brpl|brsh|brtc|brts|brvc|brvs|bset|bst|call|cbi|cbr|clc|clh|cli|cln|clr|cls|clt|clv|clz|com|cp|cpc|cpi|cpse|dec|des|eicall|eijmp|elpm|eor|fmul|fmuls|fmulsu|icall|ijmp|in|inc|jmp|lac|las|lat|ld|ld[a-z0-9]|lpm|lsl|lsr|mov|movw|mul|muls|mulsu|neg|nop|or|ori|out|pop|push|rcall|ret|reti|rjmp|rol|ror|sbc|sbci|sbi|sbic|sbis|sbiw|sbr|sbrc|sbrs|sec|seh|sei|sen|ser|ses|set|sev|sez|sleep|spm|st|st[a-zA-Z0-9]|sub|subi|swap|tst|wdr|xch)\b/,
            alias: "keyword"
          },
          "hex-number": {
            pattern: /#?\$[\da-f]{2,4}\b/i,
            alias: "number"
          },
          "binary-number": {
            pattern: /#?%[01]+\b/,
            alias: "number"
          },
          "decimal-number": {
            pattern: /#?\b\d+\b/,
            alias: "number"
          },
          register: {
            pattern: /\b[acznvshtixy]\b/i,
            alias: "variable"
          },
          operator: />>=?|<<=?|&&?|\|\|?|[-+*/%&|^!=<>?]=?/,
          punctuation: /[(),:]/
        };
      }
      return asmatmel_1;
    }
    var csharp_1;
    var hasRequiredCsharp;
    function requireCsharp() {
      if (hasRequiredCsharp)
        return csharp_1;
      hasRequiredCsharp = 1;
      csharp_1 = csharp;
      csharp.displayName = "csharp";
      csharp.aliases = ["dotnet", "cs"];
      function csharp(Prism2) {
        (function(Prism3) {
          function replace2(pattern, replacements) {
            return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
              return "(?:" + replacements[+index2] + ")";
            });
          }
          function re2(pattern, replacements, flags) {
            return RegExp(replace2(pattern, replacements), flags || "");
          }
          function nested(pattern, depthLog2) {
            for (var i = 0; i < depthLog2; i++) {
              pattern = pattern.replace(/<<self>>/g, function() {
                return "(?:" + pattern + ")";
              });
            }
            return pattern.replace(/<<self>>/g, "[^\\s\\S]");
          }
          var keywordKinds = {
            // keywords which represent a return or variable type
            type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
            // keywords which are used to declare a type
            typeDeclaration: "class enum interface record struct",
            // contextual keywords
            // ("var" and "dynamic" are missing because they are used like types)
            contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
            // all other keywords
            other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
          };
          function keywordsToPattern(words) {
            return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
          }
          var typeDeclarationKeywords = keywordsToPattern(
            keywordKinds.typeDeclaration
          );
          var keywords = RegExp(
            keywordsToPattern(
              keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other
            )
          );
          var nonTypeKeywords = keywordsToPattern(
            keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other
          );
          var nonContextualKeywords = keywordsToPattern(
            keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other
          );
          var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
          var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
          var name2 = /@?\b[A-Za-z_]\w*\b/.source;
          var genericName = replace2(/<<0>>(?:\s*<<1>>)?/.source, [name2, generic]);
          var identifier = replace2(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [
            nonTypeKeywords,
            genericName
          ]);
          var array = /\[\s*(?:,\s*)*\]/.source;
          var typeExpressionWithoutTuple = replace2(
            /<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source,
            [identifier, array]
          );
          var tupleElement = replace2(
            /[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source,
            [generic, nestedRound, array]
          );
          var tuple = replace2(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
          var typeExpression = replace2(
            /(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source,
            [tuple, identifier, array]
          );
          var typeInside = {
            keyword: keywords,
            punctuation: /[<>()?,.:[\]]/
          };
          var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
          var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
          var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
          Prism3.languages.csharp = Prism3.languages.extend("clike", {
            string: [
              {
                pattern: re2(/(^|[^$\\])<<0>>/.source, [verbatimString]),
                lookbehind: true,
                greedy: true
              },
              {
                pattern: re2(/(^|[^@$\\])<<0>>/.source, [regularString]),
                lookbehind: true,
                greedy: true
              }
            ],
            "class-name": [
              {
                // Using static
                // using static System.Math;
                pattern: re2(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [
                  identifier
                ]),
                lookbehind: true,
                inside: typeInside
              },
              {
                // Using alias (type)
                // using Project = PC.MyCompany.Project;
                pattern: re2(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
                  name2,
                  typeExpression
                ]),
                lookbehind: true,
                inside: typeInside
              },
              {
                // Using alias (alias)
                // using Project = PC.MyCompany.Project;
                pattern: re2(/(\busing\s+)<<0>>(?=\s*=)/.source, [name2]),
                lookbehind: true
              },
              {
                // Type declarations
                // class Foo<A, B>
                // interface Foo<out A, B>
                pattern: re2(/(\b<<0>>\s+)<<1>>/.source, [
                  typeDeclarationKeywords,
                  genericName
                ]),
                lookbehind: true,
                inside: typeInside
              },
              {
                // Single catch exception declaration
                // catch(Foo)
                // (things like catch(Foo e) is covered by variable declaration)
                pattern: re2(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
                lookbehind: true,
                inside: typeInside
              },
              {
                // Name of the type parameter of generic constraints
                // where Foo : class
                pattern: re2(/(\bwhere\s+)<<0>>/.source, [name2]),
                lookbehind: true
              },
              {
                // Casts and checks via as and is.
                // as Foo<A>, is Bar<B>
                // (things like if(a is Foo b) is covered by variable declaration)
                pattern: re2(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [
                  typeExpressionWithoutTuple
                ]),
                lookbehind: true,
                inside: typeInside
              },
              {
                // Variable, field and parameter declaration
                // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
                pattern: re2(
                  /\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source,
                  [typeExpression, nonContextualKeywords, name2]
                ),
                inside: typeInside
              }
            ],
            keyword: keywords,
            // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
            number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
            operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
            punctuation: /\?\.?|::|[{}[\];(),.:]/
          });
          Prism3.languages.insertBefore("csharp", "number", {
            range: {
              pattern: /\.\./,
              alias: "operator"
            }
          });
          Prism3.languages.insertBefore("csharp", "punctuation", {
            "named-parameter": {
              pattern: re2(/([(,]\s*)<<0>>(?=\s*:)/.source, [name2]),
              lookbehind: true,
              alias: "punctuation"
            }
          });
          Prism3.languages.insertBefore("csharp", "class-name", {
            namespace: {
              // namespace Foo.Bar {}
              // using Foo.Bar;
              pattern: re2(
                /(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source,
                [name2]
              ),
              lookbehind: true,
              inside: {
                punctuation: /\./
              }
            },
            "type-expression": {
              // default(Foo), typeof(Foo<Bar>), sizeof(int)
              pattern: re2(
                /(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source,
                [nestedRound]
              ),
              lookbehind: true,
              alias: "class-name",
              inside: typeInside
            },
            "return-type": {
              // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
              // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
              // int Foo => 0; int Foo { get; set } = 0;
              pattern: re2(
                /<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source,
                [typeExpression, identifier]
              ),
              inside: typeInside,
              alias: "class-name"
            },
            "constructor-invocation": {
              // new List<Foo<Bar[]>> { }
              pattern: re2(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
              lookbehind: true,
              inside: typeInside,
              alias: "class-name"
            },
            /*'explicit-implementation': {
            // int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
            pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
            inside: classNameInside,
            alias: 'class-name'
            },*/
            "generic-method": {
              // foo<Bar>()
              pattern: re2(/<<0>>\s*<<1>>(?=\s*\()/.source, [name2, generic]),
              inside: {
                function: re2(/^<<0>>/.source, [name2]),
                generic: {
                  pattern: RegExp(generic),
                  alias: "class-name",
                  inside: typeInside
                }
              }
            },
            "type-list": {
              // The list of types inherited or of generic constraints
              // class Foo<F> : Bar, IList<FooBar>
              // where F : Bar, IList<int>
              pattern: re2(
                /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
                [
                  typeDeclarationKeywords,
                  genericName,
                  name2,
                  typeExpression,
                  keywords.source,
                  nestedRound,
                  /\bnew\s*\(\s*\)/.source
                ]
              ),
              lookbehind: true,
              inside: {
                "record-arguments": {
                  pattern: re2(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [
                    genericName,
                    nestedRound
                  ]),
                  lookbehind: true,
                  greedy: true,
                  inside: Prism3.languages.csharp
                },
                keyword: keywords,
                "class-name": {
                  pattern: RegExp(typeExpression),
                  greedy: true,
                  inside: typeInside
                },
                punctuation: /[,()]/
              }
            },
            preprocessor: {
              pattern: /(^[\t ]*)#.*/m,
              lookbehind: true,
              alias: "property",
              inside: {
                // highlight preprocessor directives as keywords
                directive: {
                  pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
                  lookbehind: true,
                  alias: "keyword"
                }
              }
            }
          });
          var regularStringOrCharacter = regularString + "|" + character;
          var regularStringCharacterOrComment = replace2(
            /\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source,
            [regularStringOrCharacter]
          );
          var roundExpression = nested(
            replace2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
              regularStringCharacterOrComment
            ]),
            2
          );
          var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
          var attr = replace2(/<<0>>(?:\s*\(<<1>>*\))?/.source, [
            identifier,
            roundExpression
          ]);
          Prism3.languages.insertBefore("csharp", "class-name", {
            attribute: {
              // Attributes
              // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
              pattern: re2(
                /((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source,
                [attrTarget, attr]
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                target: {
                  pattern: re2(/^<<0>>(?=\s*:)/.source, [attrTarget]),
                  alias: "keyword"
                },
                "attribute-arguments": {
                  pattern: re2(/\(<<0>>*\)/.source, [roundExpression]),
                  inside: Prism3.languages.csharp
                },
                "class-name": {
                  pattern: RegExp(identifier),
                  inside: {
                    punctuation: /\./
                  }
                },
                punctuation: /[:,]/
              }
            }
          });
          var formatString = /:[^}\r\n]+/.source;
          var mInterpolationRound = nested(
            replace2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
              regularStringCharacterOrComment
            ]),
            2
          );
          var mInterpolation = replace2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
            mInterpolationRound,
            formatString
          ]);
          var sInterpolationRound = nested(
            replace2(
              /[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source,
              [regularStringOrCharacter]
            ),
            2
          );
          var sInterpolation = replace2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
            sInterpolationRound,
            formatString
          ]);
          function createInterpolationInside(interpolation, interpolationRound) {
            return {
              interpolation: {
                pattern: re2(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
                lookbehind: true,
                inside: {
                  "format-string": {
                    pattern: re2(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [
                      interpolationRound,
                      formatString
                    ]),
                    lookbehind: true,
                    inside: {
                      punctuation: /^:/
                    }
                  },
                  punctuation: /^\{|\}$/,
                  expression: {
                    pattern: /[\s\S]+/,
                    alias: "language-csharp",
                    inside: Prism3.languages.csharp
                  }
                }
              },
              string: /[\s\S]+/
            };
          }
          Prism3.languages.insertBefore("csharp", "string", {
            "interpolation-string": [
              {
                pattern: re2(
                  /(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source,
                  [mInterpolation]
                ),
                lookbehind: true,
                greedy: true,
                inside: createInterpolationInside(mInterpolation, mInterpolationRound)
              },
              {
                pattern: re2(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [
                  sInterpolation
                ]),
                lookbehind: true,
                greedy: true,
                inside: createInterpolationInside(sInterpolation, sInterpolationRound)
              }
            ],
            char: {
              pattern: RegExp(character),
              greedy: true
            }
          });
          Prism3.languages.dotnet = Prism3.languages.cs = Prism3.languages.csharp;
        })(Prism2);
      }
      return csharp_1;
    }
    var aspnet_1;
    var hasRequiredAspnet;
    function requireAspnet() {
      if (hasRequiredAspnet)
        return aspnet_1;
      hasRequiredAspnet = 1;
      var refractorCsharp = requireCsharp();
      aspnet_1 = aspnet;
      aspnet.displayName = "aspnet";
      aspnet.aliases = [];
      function aspnet(Prism2) {
        Prism2.register(refractorCsharp);
        Prism2.languages.aspnet = Prism2.languages.extend("markup", {
          "page-directive": {
            pattern: /<%\s*@.*%>/,
            alias: "tag",
            inside: {
              "page-directive": {
                pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
                alias: "tag"
              },
              rest: Prism2.languages.markup.tag.inside
            }
          },
          directive: {
            pattern: /<%.*%>/,
            alias: "tag",
            inside: {
              directive: {
                pattern: /<%\s*?[$=%#:]{0,2}|%>/,
                alias: "tag"
              },
              rest: Prism2.languages.csharp
            }
          }
        });
        Prism2.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
        Prism2.languages.insertBefore(
          "inside",
          "punctuation",
          {
            directive: Prism2.languages.aspnet["directive"]
          },
          Prism2.languages.aspnet.tag.inside["attr-value"]
        );
        Prism2.languages.insertBefore("aspnet", "comment", {
          "asp-comment": {
            pattern: /<%--[\s\S]*?--%>/,
            alias: ["asp", "comment"]
          }
        });
        Prism2.languages.insertBefore(
          "aspnet",
          Prism2.languages.javascript ? "script" : "tag",
          {
            "asp-script": {
              pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
              lookbehind: true,
              alias: ["asp", "script"],
              inside: Prism2.languages.csharp || {}
            }
          }
        );
      }
      return aspnet_1;
    }
    var autohotkey_1;
    var hasRequiredAutohotkey;
    function requireAutohotkey() {
      if (hasRequiredAutohotkey)
        return autohotkey_1;
      hasRequiredAutohotkey = 1;
      autohotkey_1 = autohotkey;
      autohotkey.displayName = "autohotkey";
      autohotkey.aliases = [];
      function autohotkey(Prism2) {
        Prism2.languages.autohotkey = {
          comment: [
            {
              pattern: /(^|\s);.*/,
              lookbehind: true
            },
            {
              pattern: /(^[\t ]*)\/\*(?:[\r\n](?![ \t]*\*\/)|[^\r\n])*(?:[\r\n][ \t]*\*\/)?/m,
              lookbehind: true,
              greedy: true
            }
          ],
          tag: {
            // labels
            pattern: /^([ \t]*)[^\s,`":]+(?=:[ \t]*$)/m,
            lookbehind: true
          },
          string: /"(?:[^"\n\r]|"")*"/,
          variable: /%\w+%/,
          number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          operator: /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
          boolean: /\b(?:false|true)\b/,
          selector: /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetRegView|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
          constant: /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_fileencoding|a_formatfloat|a_formatinteger|a_gui|a_guicontrol|a_guicontrolevent|a_guievent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_is64bitos|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|a_priorkey|a_programfiles|a_programs|a_programscommon|a_ptrsize|a_regview|a_screendpi|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scripthwnd|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel|programfiles)\b/i,
          builtin: /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|comobjactive|comobjarray|comobjconnect|comobjcreate|comobjerror|comobjflags|comobjget|comobjquery|comobjtype|comobjvalue|cos|dllcall|exp|fileexist|Fileopen|floor|format|il_add|il_create|il_destroy|instr|isfunc|islabel|IsObject|ln|log|ltrim|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|numget|numput|onmessage|regexmatch|regexreplace|registercallback|round|rtrim|sb_seticon|sb_setparts|sb_settext|sin|sqrt|strlen|strreplace|strsplit|substr|tan|tv_add|tv_delete|tv_get|tv_getchild|tv_getcount|tv_getnext|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__Call|__Get|__New|__Set)\b/i,
          symbol: /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
          important: /#\b(?:AllowSameLineComments|ClipboardTimeout|CommentFlag|DerefChar|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|If|IfTimeout|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InputLevel|InstallKeybdHook|InstallMouseHook|KeyHistory|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|MenuMaskKey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|Warn|WinActivateForce)\b/i,
          keyword: /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_exe|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Catch|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|Finally|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|Region|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Throw|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|Try|TryAgain|Type|UnCheck|underline|Unicode|Unlock|Until|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i,
          function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+(?=\()/,
          punctuation: /[{}[\]():,]/
        };
      }
      return autohotkey_1;
    }
    var autoit_1;
    var hasRequiredAutoit;
    function requireAutoit() {
      if (hasRequiredAutoit)
        return autoit_1;
      hasRequiredAutoit = 1;
      autoit_1 = autoit;
      autoit.displayName = "autoit";
      autoit.aliases = [];
      function autoit(Prism2) {
        Prism2.languages.autoit = {
          comment: [
            /;.*/,
            {
              // The multi-line comments delimiters can actually be commented out with ";"
              pattern: /(^[\t ]*)#(?:comments-start|cs)[\s\S]*?^[ \t]*#(?:ce|comments-end)/m,
              lookbehind: true
            }
          ],
          url: {
            pattern: /(^[\t ]*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
            lookbehind: true
          },
          string: {
            pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
            greedy: true,
            inside: {
              variable: /([%$@])\w+\1/
            }
          },
          directive: {
            pattern: /(^[\t ]*)#[\w-]+/m,
            lookbehind: true,
            alias: "keyword"
          },
          function: /\b\w+(?=\()/,
          // Variables and macros
          variable: /[$@]\w+/,
          keyword: /\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
          number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
          boolean: /\b(?:False|True)\b/i,
          operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Not|Or)\b/i,
          punctuation: /[\[\]().,:]/
        };
      }
      return autoit_1;
    }
    var avisynth_1;
    var hasRequiredAvisynth;
    function requireAvisynth() {
      if (hasRequiredAvisynth)
        return avisynth_1;
      hasRequiredAvisynth = 1;
      avisynth_1 = avisynth;
      avisynth.displayName = "avisynth";
      avisynth.aliases = ["avs"];
      function avisynth(Prism2) {
        (function(Prism3) {
          function replace2(pattern, replacements) {
            return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
              return replacements[+index2];
            });
          }
          function re2(pattern, replacements, flags) {
            return RegExp(replace2(pattern, replacements), flags || "");
          }
          var types2 = /bool|clip|float|int|string|val/.source;
          var internals = [
            // bools
            /is(?:bool|clip|float|int|string)|defined|(?:(?:internal)?function|var)?exists?/.source,
            // control
            /apply|assert|default|eval|import|nop|select|undefined/.source,
            // global
            /opt_(?:allowfloataudio|avipadscanlines|dwchannelmask|enable_(?:b64a|planartopackedrgb|v210|y3_10_10|y3_10_16)|usewaveextensible|vdubplanarhack)|set(?:cachemode|maxcpu|memorymax|planarlegacyalignment|workingdir)/.source,
            // conv
            /hex(?:value)?|value/.source,
            // numeric
            /abs|ceil|continued(?:denominator|numerator)?|exp|floor|fmod|frac|log(?:10)?|max|min|muldiv|pi|pow|rand|round|sign|spline|sqrt/.source,
            // trig
            /a?sinh?|a?cosh?|a?tan[2h]?/.source,
            // bit
            /(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/.source,
            // runtime
            /average(?:[bgr]|chroma[uv]|luma)|(?:[rgb]|chroma[uv]|luma|rgb|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/.source,
            // script
            /getprocessinfo|logmsg|script(?:dir(?:utf8)?|file(?:utf8)?|name(?:utf8)?)|setlogparams/.source,
            // string
            /chr|(?:fill|find|left|mid|replace|rev|right)str|format|[lu]case|ord|str(?:cmpi?|fromutf8|len|toutf8)|time|trim(?:all|left|right)/.source,
            // version
            /isversionorgreater|version(?:number|string)/.source,
            // helper
            /buildpixeltype|colorspacenametopixeltype/.source,
            // avsplus
            /addautoloaddir|on(?:cpu|cuda)|prefetch|setfiltermtmode/.source
          ].join("|");
          var properties = [
            // content
            /has(?:audio|video)/.source,
            // resolution
            /height|width/.source,
            // framerate
            /frame(?:count|rate)|framerate(?:denominator|numerator)/.source,
            // interlacing
            /getparity|is(?:field|frame)based/.source,
            // color format
            /bitspercomponent|componentsize|hasalpha|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:va?|y2))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|numcomponents|pixeltype/.source,
            // audio
            /audio(?:bits|channels|duration|length(?:[fs]|hi|lo)?|rate)|isaudio(?:float|int)/.source
          ].join("|");
          var filters = [
            // source
            /avi(?:file)?source|directshowsource|image(?:reader|source|sourceanim)|opendmlsource|segmented(?:avisource|directshowsource)|wavsource/.source,
            // color
            /coloryuv|convertbacktoyuy2|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:411|420|422|444)|YUY2)|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:chroma|luma)|rgbadjust|show(?:alpha|blue|green|red)|swapuv|tweak|[uv]toy8?|ytouv/.source,
            // overlay
            /(?:colorkey|reset)mask|layer|mask(?:hs)?|merge|overlay|subtract/.source,
            // geometry
            /addborders|(?:bicubic|bilinear|blackman|gauss|lanczos4|lanczos|point|sinc|spline(?:16|36|64))resize|crop(?:bottom)?|flip(?:horizontal|vertical)|(?:horizontal|vertical)?reduceby2|letterbox|skewrows|turn(?:180|left|right)/.source,
            // pixel
            /blur|fixbrokenchromaupsampling|generalconvolution|(?:spatial|temporal)soften|sharpen/.source,
            // timeline
            /trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|io|out)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/.source,
            // interlace
            /assume[bt]ff|assume(?:field|frame)based|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|fields|rows)|swapfields|weave(?:columns|rows)?/.source,
            // audio
            /amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|ssrc|supereq|timestretch/.source,
            // conditional
            /animate|applyrange|conditional(?:filter|reader|select)|frameevaluate|scriptclip|tcp(?:server|source)|writefile(?:end|if|start)?/.source,
            // export
            /imagewriter/.source,
            // debug
            /blackness|blankclip|colorbars(?:hd)?|compare|dumpfiltergraph|echo|histogram|info|messageclip|preroll|setgraphanalysis|show(?:framenumber|smpte|time)|showfiveversions|stack(?:horizontal|vertical)|subtitle|tone|version/.source
          ].join("|");
          var allinternals = [internals, properties, filters].join("|");
          Prism3.languages.avisynth = {
            comment: [
              {
                // Matches [* *] nestable block comments, but only supports 1 level of nested comments
                // /\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|<self>)*\*\]/
                pattern: /(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
                lookbehind: true,
                greedy: true
              },
              {
                // Matches /* */ block comments
                pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                lookbehind: true,
                greedy: true
              },
              {
                // Matches # comments
                pattern: /(^|[^\\$])#.*/,
                lookbehind: true,
                greedy: true
              }
            ],
            // Handle before strings because optional arguments are surrounded by double quotes
            argument: {
              pattern: re2(/\b(?:<<0>>)\s+("?)\w+\1/.source, [types2], "i"),
              inside: {
                keyword: /^\w+/
              }
            },
            // Optional argument assignment
            "argument-label": {
              pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
              lookbehind: true,
              inside: {
                "argument-name": {
                  pattern: /^\w+/,
                  alias: "punctuation"
                },
                punctuation: /=$/
              }
            },
            string: [
              {
                // triple double-quoted
                pattern: /"""[\s\S]*?"""/,
                greedy: true
              },
              {
                // single double-quoted
                pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
                greedy: true,
                inside: {
                  constant: {
                    // These *are* case-sensitive!
                    pattern: /\b(?:DEFAULT_MT_MODE|(?:MAINSCRIPT|PROGRAM|SCRIPT)DIR|(?:MACHINE|USER)_(?:CLASSIC|PLUS)_PLUGINS)\b/
                  }
                }
              }
            ],
            // The special "last" variable that takes the value of the last implicitly returned clip
            variable: /\b(?:last)\b/i,
            boolean: /\b(?:false|no|true|yes)\b/i,
            keyword: /\b(?:catch|else|for|function|global|if|return|try|while|__END__)\b/i,
            constant: /\bMT_(?:MULTI_INSTANCE|NICE_FILTER|SERIALIZED|SPECIAL_MT)\b/,
            // AviSynth's internal functions, filters, and properties
            "builtin-function": {
              pattern: re2(/\b(?:<<0>>)\b/.source, [allinternals], "i"),
              alias: "function"
            },
            "type-cast": {
              pattern: re2(/\b(?:<<0>>)(?=\s*\()/.source, [types2], "i"),
              alias: "keyword"
            },
            // External/user-defined filters
            function: {
              pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
              lookbehind: true
            },
            // Matches a \ as the first or last character on a line
            "line-continuation": {
              pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
              lookbehind: true,
              alias: "punctuation"
            },
            number: /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
            operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
            punctuation: /[{}\[\]();,.]/
          };
          Prism3.languages.avs = Prism3.languages.avisynth;
        })(Prism2);
      }
      return avisynth_1;
    }
    var avroIdl_1;
    var hasRequiredAvroIdl;
    function requireAvroIdl() {
      if (hasRequiredAvroIdl)
        return avroIdl_1;
      hasRequiredAvroIdl = 1;
      avroIdl_1 = avroIdl;
      avroIdl.displayName = "avroIdl";
      avroIdl.aliases = [];
      function avroIdl(Prism2) {
        Prism2.languages["avro-idl"] = {
          comment: {
            pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
            greedy: true
          },
          string: {
            pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
            lookbehind: true,
            greedy: true
          },
          annotation: {
            pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
            greedy: true,
            alias: "function"
          },
          "function-identifier": {
            pattern: /`[^\r\n`]+`(?=\s*\()/,
            greedy: true,
            alias: "function"
          },
          identifier: {
            pattern: /`[^\r\n`]+`/,
            greedy: true
          },
          "class-name": {
            pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
            lookbehind: true,
            greedy: true
          },
          keyword: /\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
          function: /\b[a-z_]\w*(?=\s*\()/i,
          number: [
            {
              pattern: /(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
              lookbehind: true
            },
            /-?\b(?:Infinity|NaN)\b/
          ],
          operator: /=/,
          punctuation: /[()\[\]{}<>.:,;-]/
        };
        Prism2.languages.avdl = Prism2.languages["avro-idl"];
      }
      return avroIdl_1;
    }
    var bash_1;
    var hasRequiredBash;
    function requireBash() {
      if (hasRequiredBash)
        return bash_1;
      hasRequiredBash = 1;
      bash_1 = bash;
      bash.displayName = "bash";
      bash.aliases = ["shell"];
      function bash(Prism2) {
        (function(Prism3) {
          var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
          var commandAfterHeredoc = {
            pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
            lookbehind: true,
            alias: "punctuation",
            // this looks reasonably well in all themes
            inside: null
            // see below
          };
          var insideString = {
            bash: commandAfterHeredoc,
            environment: {
              pattern: RegExp("\\$" + envVars),
              alias: "constant"
            },
            variable: [
              // [0]: Arithmetic Environment
              {
                pattern: /\$?\(\([\s\S]+?\)\)/,
                greedy: true,
                inside: {
                  // If there is a $ sign at the beginning highlight $(( and )) as variable
                  variable: [
                    {
                      pattern: /(^\$\(\([\s\S]+)\)\)/,
                      lookbehind: true
                    },
                    /^\$\(\(/
                  ],
                  number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                  // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
                  operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
                  // If there is no $ sign at the beginning highlight (( and )) as punctuation
                  punctuation: /\(\(?|\)\)?|,|;/
                }
              },
              // [1]: Command Substitution
              {
                pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
                greedy: true,
                inside: {
                  variable: /^\$\(|^`|\)$|`$/
                }
              },
              // [2]: Brace expansion
              {
                pattern: /\$\{[^}]+\}/,
                greedy: true,
                inside: {
                  operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                  punctuation: /[\[\]]/,
                  environment: {
                    pattern: RegExp("(\\{)" + envVars),
                    lookbehind: true,
                    alias: "constant"
                  }
                }
              },
              /\$(?:\w+|[#?*!@$])/
            ],
            // Escape sequences from echo and printf's manuals, and escaped quotes.
            entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
          };
          Prism3.languages.bash = {
            shebang: {
              pattern: /^#!\s*\/.*/,
              alias: "important"
            },
            comment: {
              pattern: /(^|[^"{\\$])#.*/,
              lookbehind: true
            },
            "function-name": [
              // a) function foo {
              // b) foo() {
              // c) function foo() {
              // but not “foo {”
              {
                // a) and c)
                pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
                lookbehind: true,
                alias: "function"
              },
              {
                // b)
                pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
                alias: "function"
              }
            ],
            // Highlight variable names as variables in for and select beginnings.
            "for-or-select": {
              pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
              alias: "variable",
              lookbehind: true
            },
            // Highlight variable names as variables in the left-hand part
            // of assignments (“=” and “+=”).
            "assign-left": {
              pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
              inside: {
                environment: {
                  pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
                  lookbehind: true,
                  alias: "constant"
                }
              },
              alias: "variable",
              lookbehind: true
            },
            string: [
              // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
              {
                pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
                lookbehind: true,
                greedy: true,
                inside: insideString
              },
              // Here-document with quotes around the tag
              // → No expansion (so no “inside”).
              {
                pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
                lookbehind: true,
                greedy: true,
                inside: {
                  bash: commandAfterHeredoc
                }
              },
              // “Normal” string
              {
                // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
                pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
                lookbehind: true,
                greedy: true,
                inside: insideString
              },
              {
                // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
                pattern: /(^|[^$\\])'[^']*'/,
                lookbehind: true,
                greedy: true
              },
              {
                // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
                pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
                greedy: true,
                inside: {
                  entity: insideString.entity
                }
              }
            ],
            environment: {
              pattern: RegExp("\\$?" + envVars),
              alias: "constant"
            },
            variable: insideString.variable,
            function: {
              pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
              lookbehind: true
            },
            keyword: {
              pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
              lookbehind: true
            },
            // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
            builtin: {
              pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
              lookbehind: true,
              // Alias added to make those easier to distinguish from strings.
              alias: "class-name"
            },
            boolean: {
              pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
              lookbehind: true
            },
            "file-descriptor": {
              pattern: /\B&\d\b/,
              alias: "important"
            },
            operator: {
              // Lots of redirections here, but not just that.
              pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
              inside: {
                "file-descriptor": {
                  pattern: /^\d/,
                  alias: "important"
                }
              }
            },
            punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
            number: {
              pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
              lookbehind: true
            }
          };
          commandAfterHeredoc.inside = Prism3.languages.bash;
          var toBeCopied = [
            "comment",
            "function-name",
            "for-or-select",
            "assign-left",
            "string",
            "environment",
            "function",
            "keyword",
            "builtin",
            "boolean",
            "file-descriptor",
            "operator",
            "punctuation",
            "number"
          ];
          var inside = insideString.variable[1].inside;
          for (var i = 0; i < toBeCopied.length; i++) {
            inside[toBeCopied[i]] = Prism3.languages.bash[toBeCopied[i]];
          }
          Prism3.languages.shell = Prism3.languages.bash;
        })(Prism2);
      }
      return bash_1;
    }
    var basic_1;
    var hasRequiredBasic;
    function requireBasic() {
      if (hasRequiredBasic)
        return basic_1;
      hasRequiredBasic = 1;
      basic_1 = basic;
      basic.displayName = "basic";
      basic.aliases = [];
      function basic(Prism2) {
        Prism2.languages.basic = {
          comment: {
            pattern: /(?:!|REM\b).+/i,
            inside: {
              keyword: /^REM/i
            }
          },
          string: {
            pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
            greedy: true
          },
          number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
          keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
          function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
          operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
          punctuation: /[,;:()]/
        };
      }
      return basic_1;
    }
    var batch_1;
    var hasRequiredBatch;
    function requireBatch() {
      if (hasRequiredBatch)
        return batch_1;
      hasRequiredBatch = 1;
      batch_1 = batch;
      batch.displayName = "batch";
      batch.aliases = [];
      function batch(Prism2) {
        (function(Prism3) {
          var variable = /%%?[~:\w]+%?|!\S+!/;
          var parameter = {
            pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
            alias: "attr-name",
            inside: {
              punctuation: /:/
            }
          };
          var string2 = /"(?:[\\"]"|[^"])*"(?!")/;
          var number2 = /(?:\b|-)\d+\b/;
          Prism3.languages.batch = {
            comment: [
              /^::.*/m,
              {
                pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
                lookbehind: true
              }
            ],
            label: {
              pattern: /^:.*/m,
              alias: "property"
            },
            command: [
              {
                // FOR command
                pattern: /((?:^|[&(])[ \t]*)for(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* \S+ in \([^)]+\) do/im,
                lookbehind: true,
                inside: {
                  keyword: /\b(?:do|in)\b|^for\b/i,
                  string: string2,
                  parameter,
                  variable,
                  number: number2,
                  punctuation: /[()',]/
                }
              },
              {
                // IF command
                pattern: /((?:^|[&(])[ \t]*)if(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|(?!")(?:(?!==)\S)+)?(?:==| (?:equ|geq|gtr|leq|lss|neq) )(?:"[^"]*"|[^\s"]\S*))/im,
                lookbehind: true,
                inside: {
                  keyword: /\b(?:cmdextversion|defined|errorlevel|exist|not)\b|^if\b/i,
                  string: string2,
                  parameter,
                  variable,
                  number: number2,
                  operator: /\^|==|\b(?:equ|geq|gtr|leq|lss|neq)\b/i
                }
              },
              {
                // ELSE command
                pattern: /((?:^|[&()])[ \t]*)else\b/im,
                lookbehind: true,
                inside: {
                  keyword: /^else\b/i
                }
              },
              {
                // SET command
                pattern: /((?:^|[&(])[ \t]*)set(?: \/[a-z](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
                lookbehind: true,
                inside: {
                  keyword: /^set\b/i,
                  string: string2,
                  parameter,
                  variable: [variable, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],
                  number: number2,
                  operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
                  punctuation: /[()',]/
                }
              },
              {
                // Other commands
                pattern: /((?:^|[&(])[ \t]*@?)\w+\b(?:"(?:[\\"]"|[^"])*"(?!")|[^"^&)\r\n]|\^(?:\r\n|[\s\S]))*/m,
                lookbehind: true,
                inside: {
                  keyword: /^\w+\b/,
                  string: string2,
                  parameter,
                  label: {
                    pattern: /(^\s*):\S+/m,
                    lookbehind: true,
                    alias: "property"
                  },
                  variable,
                  number: number2,
                  operator: /\^/
                }
              }
            ],
            operator: /[&@]/,
            punctuation: /[()']/
          };
        })(Prism2);
      }
      return batch_1;
    }
    var bbcode_1;
    var hasRequiredBbcode;
    function requireBbcode() {
      if (hasRequiredBbcode)
        return bbcode_1;
      hasRequiredBbcode = 1;
      bbcode_1 = bbcode;
      bbcode.displayName = "bbcode";
      bbcode.aliases = ["shortcode"];
      function bbcode(Prism2) {
        Prism2.languages.bbcode = {
          tag: {
            pattern: /\[\/?[^\s=\]]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))?(?:\s+[^\s=\]]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))*\s*\]/,
            inside: {
              tag: {
                pattern: /^\[\/?[^\s=\]]+/,
                inside: {
                  punctuation: /^\[\/?/
                }
              },
              "attr-value": {
                pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+)/,
                inside: {
                  punctuation: [
                    /^=/,
                    {
                      pattern: /^(\s*)["']|["']$/,
                      lookbehind: true
                    }
                  ]
                }
              },
              punctuation: /\]/,
              "attr-name": /[^\s=\]]+/
            }
          }
        };
        Prism2.languages.shortcode = Prism2.languages.bbcode;
      }
      return bbcode_1;
    }
    var bicep_1;
    var hasRequiredBicep;
    function requireBicep() {
      if (hasRequiredBicep)
        return bicep_1;
      hasRequiredBicep = 1;
      bicep_1 = bicep;
      bicep.displayName = "bicep";
      bicep.aliases = [];
      function bicep(Prism2) {
        Prism2.languages.bicep = {
          comment: [
            {
              // multiline comments eg /* ASDF */
              pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
              lookbehind: true,
              greedy: true
            },
            {
              // singleline comments eg // ASDF
              pattern: /(^|[^\\:])\/\/.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          property: [
            {
              pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i,
              lookbehind: true
            },
            {
              pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
              lookbehind: true,
              greedy: true
            }
          ],
          string: [
            {
              pattern: /'''[^'][\s\S]*?'''/,
              greedy: true
            },
            {
              pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
              lookbehind: true,
              greedy: true
            }
          ],
          "interpolated-string": {
            pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
            lookbehind: true,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /\$\{[^{}\r\n]*\}/,
                inside: {
                  expression: {
                    pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                    lookbehind: true
                  },
                  punctuation: /^\$\{|\}$/
                }
              },
              string: /[\s\S]+/
            }
          },
          datatype: {
            pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
            lookbehind: true,
            alias: "class-name"
          },
          boolean: /\b(?:false|true)\b/,
          // https://github.com/Azure/bicep/blob/114a3251b4e6e30082a58729f19a8cc4e374ffa6/src/textmate/bicep.tmlanguage#L184
          keyword: /\b(?:existing|for|if|in|module|null|output|param|resource|targetScope|var)\b/,
          decorator: /@\w+\b/,
          function: /\b[a-z_]\w*(?=[ \t]*\()/i,
          number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
          operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
          punctuation: /[{}[\];(),.:]/
        };
        Prism2.languages.bicep["interpolated-string"].inside["interpolation"].inside["expression"].inside = Prism2.languages.bicep;
      }
      return bicep_1;
    }
    var birb_1;
    var hasRequiredBirb;
    function requireBirb() {
      if (hasRequiredBirb)
        return birb_1;
      hasRequiredBirb = 1;
      birb_1 = birb;
      birb.displayName = "birb";
      birb.aliases = [];
      function birb(Prism2) {
        Prism2.languages.birb = Prism2.languages.extend("clike", {
          string: {
            pattern: /r?("|')(?:\\.|(?!\1)[^\\])*\1/,
            greedy: true
          },
          "class-name": [
            /\b[A-Z](?:[\d_]*[a-zA-Z]\w*)?\b/,
            // matches variable and function return types (parameters as well).
            /\b(?:[A-Z]\w*|(?!(?:var|void)\b)[a-z]\w*)(?=\s+\w+\s*[;,=()])/
          ],
          keyword: /\b(?:assert|break|case|class|const|default|else|enum|final|follows|for|grab|if|nest|new|next|noSeeb|return|static|switch|throw|var|void|while)\b/,
          operator: /\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?|:/,
          variable: /\b[a-z_]\w*\b/
        });
        Prism2.languages.insertBefore("birb", "function", {
          metadata: {
            pattern: /<\w+>/,
            greedy: true,
            alias: "symbol"
          }
        });
      }
      return birb_1;
    }
    var bison_1;
    var hasRequiredBison;
    function requireBison() {
      if (hasRequiredBison)
        return bison_1;
      hasRequiredBison = 1;
      var refractorC = requireC();
      bison_1 = bison;
      bison.displayName = "bison";
      bison.aliases = [];
      function bison(Prism2) {
        Prism2.register(refractorC);
        Prism2.languages.bison = Prism2.languages.extend("c", {});
        Prism2.languages.insertBefore("bison", "comment", {
          bison: {
            // This should match all the beginning of the file
            // including the prologue(s), the bison declarations and
            // the grammar rules.
            pattern: /^(?:[^%]|%(?!%))*%%[\s\S]*?%%/,
            inside: {
              c: {
                // Allow for one level of nested braces
                pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
                inside: {
                  delimiter: {
                    pattern: /^%?\{|%?\}$/,
                    alias: "punctuation"
                  },
                  "bison-variable": {
                    pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
                    alias: "variable",
                    inside: {
                      punctuation: /<|>/
                    }
                  },
                  rest: Prism2.languages.c
                }
              },
              comment: Prism2.languages.c.comment,
              string: Prism2.languages.c.string,
              property: /\S+(?=:)/,
              keyword: /%\w+/,
              number: {
                pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i,
                lookbehind: true
              },
              punctuation: /%[%?]|[|:;\[\]<>]/
            }
          }
        });
      }
      return bison_1;
    }
    var bnf_1;
    var hasRequiredBnf;
    function requireBnf() {
      if (hasRequiredBnf)
        return bnf_1;
      hasRequiredBnf = 1;
      bnf_1 = bnf;
      bnf.displayName = "bnf";
      bnf.aliases = ["rbnf"];
      function bnf(Prism2) {
        Prism2.languages.bnf = {
          string: {
            pattern: /"[^\r\n"]*"|'[^\r\n']*'/
          },
          definition: {
            pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
            alias: ["rule", "keyword"],
            inside: {
              punctuation: /^<|>$/
            }
          },
          rule: {
            pattern: /<[^<>\r\n\t]+>/,
            inside: {
              punctuation: /^<|>$/
            }
          },
          operator: /::=|[|()[\]{}*+?]|\.{3}/
        };
        Prism2.languages.rbnf = Prism2.languages.bnf;
      }
      return bnf_1;
    }
    var brainfuck_1;
    var hasRequiredBrainfuck;
    function requireBrainfuck() {
      if (hasRequiredBrainfuck)
        return brainfuck_1;
      hasRequiredBrainfuck = 1;
      brainfuck_1 = brainfuck;
      brainfuck.displayName = "brainfuck";
      brainfuck.aliases = [];
      function brainfuck(Prism2) {
        Prism2.languages.brainfuck = {
          pointer: {
            pattern: /<|>/,
            alias: "keyword"
          },
          increment: {
            pattern: /\+/,
            alias: "inserted"
          },
          decrement: {
            pattern: /-/,
            alias: "deleted"
          },
          branching: {
            pattern: /\[|\]/,
            alias: "important"
          },
          operator: /[.,]/,
          comment: /\S+/
        };
      }
      return brainfuck_1;
    }
    var brightscript_1;
    var hasRequiredBrightscript;
    function requireBrightscript() {
      if (hasRequiredBrightscript)
        return brightscript_1;
      hasRequiredBrightscript = 1;
      brightscript_1 = brightscript;
      brightscript.displayName = "brightscript";
      brightscript.aliases = [];
      function brightscript(Prism2) {
        Prism2.languages.brightscript = {
          comment: /(?:\brem|').*/i,
          "directive-statement": {
            pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
            lookbehind: true,
            alias: "property",
            inside: {
              "error-message": {
                pattern: /(^#error).+/,
                lookbehind: true
              },
              directive: {
                pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
                alias: "keyword"
              },
              expression: {
                pattern: /[\s\S]+/,
                inside: null
                // see below
              }
            }
          },
          property: {
            pattern: /([\r\n{,][\t ]*)(?:(?!\d)\w+|"(?:[^"\r\n]|"")*"(?!"))(?=[ \t]*:)/,
            lookbehind: true,
            greedy: true
          },
          string: {
            pattern: /"(?:[^"\r\n]|"")*"(?!")/,
            greedy: true
          },
          "class-name": {
            pattern: /(\bAs[\t ]+)\w+/i,
            lookbehind: true
          },
          keyword: /\b(?:As|Dim|Each|Else|Elseif|End|Exit|For|Function|Goto|If|In|Print|Return|Step|Stop|Sub|Then|To|While)\b/i,
          boolean: /\b(?:false|true)\b/i,
          function: /\b(?!\d)\w+(?=[\t ]*\()/,
          number: /(?:\b\d+(?:\.\d+)?(?:[ed][+-]\d+)?|&h[a-f\d]+)\b[%&!#]?/i,
          operator: /--|\+\+|>>=?|<<=?|<>|[-+*/\\<>]=?|[:^=?]|\b(?:and|mod|not|or)\b/i,
          punctuation: /[.,;()[\]{}]/,
          constant: /\b(?:LINE_NUM)\b/i
        };
        Prism2.languages.brightscript["directive-statement"].inside.expression.inside = Prism2.languages.brightscript;
      }
      return brightscript_1;
    }
    var bro_1;
    var hasRequiredBro;
    function requireBro() {
      if (hasRequiredBro)
        return bro_1;
      hasRequiredBro = 1;
      bro_1 = bro;
      bro.displayName = "bro";
      bro.aliases = [];
      function bro(Prism2) {
        Prism2.languages.bro = {
          comment: {
            pattern: /(^|[^\\$])#.*/,
            lookbehind: true,
            inside: {
              italic: /\b(?:FIXME|TODO|XXX)\b/
            }
          },
          string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          boolean: /\b[TF]\b/,
          function: {
            pattern: /(\b(?:event|function|hook)[ \t]+)\w+(?:::\w+)?/,
            lookbehind: true
          },
          builtin: /(?:@(?:load(?:-(?:plugin|sigs))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:add_func|create_expire|default|delete_func|encrypt|error_handler|expire_func|group|log|mergeable|optional|persistent|priority|raw_output|read_expire|redef|rotate_interval|rotate_size|synchronized|type_column|write_expire))/,
          constant: {
            pattern: /(\bconst[ \t]+)\w+/i,
            lookbehind: true
          },
          keyword: /\b(?:add|addr|alarm|any|bool|break|const|continue|count|delete|double|else|enum|event|export|file|for|function|global|hook|if|in|int|interval|local|module|next|of|opaque|pattern|port|print|record|return|schedule|set|string|subnet|table|time|timeout|using|vector|when)\b/,
          operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
          number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
          punctuation: /[{}[\];(),.:]/
        };
      }
      return bro_1;
    }
    var bsl_1;
    var hasRequiredBsl;
    function requireBsl() {
      if (hasRequiredBsl)
        return bsl_1;
      hasRequiredBsl = 1;
      bsl_1 = bsl;
      bsl.displayName = "bsl";
      bsl.aliases = [];
      function bsl(Prism2) {
        Prism2.languages.bsl = {
          comment: /\/\/.*/,
          string: [
            // Строки
            // Strings
            {
              pattern: /"(?:[^"]|"")*"(?!")/,
              greedy: true
            },
            // Дата и время
            // Date & time
            {
              pattern: /'(?:[^'\r\n\\]|\\.)*'/
            }
          ],
          keyword: [
            {
              // RU
              pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:пока|для|новый|прервать|попытка|исключение|вызватьисключение|иначе|конецпопытки|неопределено|функция|перем|возврат|конецфункции|если|иначеесли|процедура|конецпроцедуры|тогда|знач|экспорт|конецесли|из|каждого|истина|ложь|по|цикл|конеццикла|выполнить)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
              lookbehind: true
            },
            {
              // EN
              pattern: /\b(?:break|do|each|else|elseif|enddo|endfunction|endif|endprocedure|endtry|except|execute|export|false|for|function|if|in|new|null|procedure|raise|return|then|to|true|try|undefined|val|var|while)\b/i
            }
          ],
          number: {
            pattern: /(^(?=\d)|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:\d+(?:\.\d*)?|\.\d+)(?:E[+-]?\d+)?/i,
            lookbehind: true
          },
          operator: [
            /[<>+\-*/]=?|[%=]/,
            // RU
            {
              pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:и|или|не)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
              lookbehind: true
            },
            // EN
            {
              pattern: /\b(?:and|not|or)\b/i
            }
          ],
          punctuation: /\(\.|\.\)|[()\[\]:;,.]/,
          directive: [
            // Теги препроцессора вида &Клиент, &Сервер, ...
            // Preprocessor tags of the type &Client, &Server, ...
            {
              pattern: /^([ \t]*)&.*/m,
              lookbehind: true,
              greedy: true,
              alias: "important"
            },
            // Инструкции препроцессора вида:
            // #Если Сервер Тогда
            // ...
            // #КонецЕсли
            // Preprocessor instructions of the form:
            // #If Server Then
            // ...
            // #EndIf
            {
              pattern: /^([ \t]*)#.*/gm,
              lookbehind: true,
              greedy: true,
              alias: "important"
            }
          ]
        };
        Prism2.languages.oscript = Prism2.languages["bsl"];
      }
      return bsl_1;
    }
    var cfscript_1;
    var hasRequiredCfscript;
    function requireCfscript() {
      if (hasRequiredCfscript)
        return cfscript_1;
      hasRequiredCfscript = 1;
      cfscript_1 = cfscript;
      cfscript.displayName = "cfscript";
      cfscript.aliases = [];
      function cfscript(Prism2) {
        Prism2.languages.cfscript = Prism2.languages.extend("clike", {
          comment: [
            {
              pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
              lookbehind: true,
              inside: {
                annotation: {
                  pattern: /(?:^|[^.])@[\w\.]+/,
                  alias: "punctuation"
                }
              }
            },
            {
              pattern: /(^|[^\\:])\/\/.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          keyword: /\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
          operator: [
            /\+\+|--|&&|\|\||::|=>|[!=]==|<=?|>=?|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|[?:]/,
            /\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/
          ],
          scope: {
            pattern: /\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
            alias: "global"
          },
          type: {
            pattern: /\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
            alias: "builtin"
          }
        });
        Prism2.languages.insertBefore("cfscript", "keyword", {
          // This must be declared before keyword because we use "function" inside the lookahead
          "function-variable": {
            pattern: /[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
            alias: "function"
          }
        });
        delete Prism2.languages.cfscript["class-name"];
        Prism2.languages.cfc = Prism2.languages["cfscript"];
      }
      return cfscript_1;
    }
    var chaiscript_1;
    var hasRequiredChaiscript;
    function requireChaiscript() {
      if (hasRequiredChaiscript)
        return chaiscript_1;
      hasRequiredChaiscript = 1;
      var refractorCpp = requireCpp();
      chaiscript_1 = chaiscript;
      chaiscript.displayName = "chaiscript";
      chaiscript.aliases = [];
      function chaiscript(Prism2) {
        Prism2.register(refractorCpp);
        Prism2.languages.chaiscript = Prism2.languages.extend("clike", {
          string: {
            pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
            lookbehind: true,
            greedy: true
          },
          "class-name": [
            {
              // e.g. class Rectangle { ... }
              pattern: /(\bclass\s+)\w+/,
              lookbehind: true
            },
            {
              // e.g. attr Rectangle::height, def Rectangle::area() { ... }
              pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/,
              lookbehind: true
            }
          ],
          keyword: /\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
          number: [Prism2.languages.cpp.number, /\b(?:Infinity|NaN)\b/],
          operator: />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
        });
        Prism2.languages.insertBefore("chaiscript", "operator", {
          "parameter-type": {
            // e.g. def foo(int x, Vector y) {...}
            pattern: /([,(]\s*)\w+(?=\s+\w)/,
            lookbehind: true,
            alias: "class-name"
          }
        });
        Prism2.languages.insertBefore("chaiscript", "string", {
          "string-interpolation": {
            pattern: /(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
            lookbehind: true,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
                lookbehind: true,
                inside: {
                  "interpolation-expression": {
                    pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                    lookbehind: true,
                    inside: Prism2.languages.chaiscript
                  },
                  "interpolation-punctuation": {
                    pattern: /^\$\{|\}$/,
                    alias: "punctuation"
                  }
                }
              },
              string: /[\s\S]+/
            }
          }
        });
      }
      return chaiscript_1;
    }
    var cil_1;
    var hasRequiredCil;
    function requireCil() {
      if (hasRequiredCil)
        return cil_1;
      hasRequiredCil = 1;
      cil_1 = cil;
      cil.displayName = "cil";
      cil.aliases = [];
      function cil(Prism2) {
        Prism2.languages.cil = {
          comment: /\/\/.*/,
          string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          directive: {
            pattern: /(^|\W)\.[a-z]+(?=\s)/,
            lookbehind: true,
            alias: "class-name"
          },
          // Actually an assembly reference
          variable: /\[[\w\.]+\]/,
          keyword: /\b(?:abstract|ansi|assembly|auto|autochar|beforefieldinit|bool|bstr|byvalstr|catch|char|cil|class|currency|date|decimal|default|enum|error|explicit|extends|extern|famandassem|family|famorassem|final(?:ly)?|float32|float64|hidebysig|u?int(?:8|16|32|64)?|iant|idispatch|implements|import|initonly|instance|interface|iunknown|literal|lpstr|lpstruct|lptstr|lpwstr|managed|method|native(?:Type)?|nested|newslot|object(?:ref)?|pinvokeimpl|private|privatescope|public|reqsecobj|rtspecialname|runtime|sealed|sequential|serializable|specialname|static|string|struct|syschar|tbstr|unicode|unmanagedexp|unsigned|value(?:type)?|variant|virtual|void)\b/,
          function: /\b(?:(?:constrained|no|readonly|tail|unaligned|volatile)\.)?(?:conv\.(?:[iu][1248]?|ovf\.[iu][1248]?(?:\.un)?|r\.un|r4|r8)|ldc\.(?:i4(?:\.\d+|\.[mM]1|\.s)?|i8|r4|r8)|ldelem(?:\.[iu][1248]?|\.r[48]|\.ref|a)?|ldind\.(?:[iu][1248]?|r[48]|ref)|stelem\.?(?:i[1248]?|r[48]|ref)?|stind\.(?:i[1248]?|r[48]|ref)?|end(?:fault|filter|finally)|ldarg(?:\.[0-3s]|a(?:\.s)?)?|ldloc(?:\.\d+|\.s)?|sub(?:\.ovf(?:\.un)?)?|mul(?:\.ovf(?:\.un)?)?|add(?:\.ovf(?:\.un)?)?|stloc(?:\.[0-3s])?|refany(?:type|val)|blt(?:\.un)?(?:\.s)?|ble(?:\.un)?(?:\.s)?|bgt(?:\.un)?(?:\.s)?|bge(?:\.un)?(?:\.s)?|unbox(?:\.any)?|init(?:blk|obj)|call(?:i|virt)?|brfalse(?:\.s)?|bne\.un(?:\.s)?|ldloca(?:\.s)?|brzero(?:\.s)?|brtrue(?:\.s)?|brnull(?:\.s)?|brinst(?:\.s)?|starg(?:\.s)?|leave(?:\.s)?|shr(?:\.un)?|rem(?:\.un)?|div(?:\.un)?|clt(?:\.un)?|alignment|castclass|ldvirtftn|beq(?:\.s)?|ckfinite|ldsflda|ldtoken|localloc|mkrefany|rethrow|cgt\.un|arglist|switch|stsfld|sizeof|newobj|newarr|ldsfld|ldnull|ldflda|isinst|throw|stobj|stfld|ldstr|ldobj|ldlen|ldftn|ldfld|cpobj|cpblk|break|br\.s|xor|shl|ret|pop|not|nop|neg|jmp|dup|cgt|ceq|box|and|or|br)\b/,
          boolean: /\b(?:false|true)\b/,
          number: /\b-?(?:0x[0-9a-f]+|\d+)(?:\.[0-9a-f]+)?\b/i,
          punctuation: /[{}[\];(),:=]|IL_[0-9A-Za-z]+/
        };
      }
      return cil_1;
    }
    var clojure_1;
    var hasRequiredClojure;
    function requireClojure() {
      if (hasRequiredClojure)
        return clojure_1;
      hasRequiredClojure = 1;
      clojure_1 = clojure;
      clojure.displayName = "clojure";
      clojure.aliases = [];
      function clojure(Prism2) {
        Prism2.languages.clojure = {
          comment: {
            pattern: /;.*/,
            greedy: true
          },
          string: {
            pattern: /"(?:[^"\\]|\\.)*"/,
            greedy: true
          },
          char: /\\\w+/,
          symbol: {
            pattern: /(^|[\s()\[\]{},])::?[\w*+!?'<>=/.-]+/,
            lookbehind: true
          },
          keyword: {
            pattern: /(\()(?:-|->|->>|\.|\.\.|\*|\/|\+|<|<=|=|==|>|>=|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|cond|conj|cons|constantly|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|declare|def|def-|definline|definterface|defmacro|defmethod|defmulti|defn|defn-|defonce|defproject|defprotocol|defrecord|defstruct|deftype|deref|difference|disj|dissoc|distinct|do|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|fn|fnseq|for|frest|gensym|get|get-proxy-class|hash-map|hash-set|identical\?|identity|if|if-let|if-not|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|let|line-seq|list|list\*|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|monitor-enter|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|quote|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|recur|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|set!|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|throw|time|to-array|to-array-2d|tree-seq|true\?|try|union|up|update-proxy|val|vals|var|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[\s)]|$)/,
            lookbehind: true
          },
          boolean: /\b(?:false|nil|true)\b/,
          number: {
            pattern: /(^|[^\w$@])(?:\d+(?:[/.]\d+)?(?:e[+-]?\d+)?|0x[a-f0-9]+|[1-9]\d?r[a-z0-9]+)[lmn]?(?![\w$@])/i,
            lookbehind: true
          },
          function: {
            pattern: /((?:^|[^'])\()[\w*+!?'<>=/.-]+(?=[\s)]|$)/,
            lookbehind: true
          },
          operator: /[#@^`~]/,
          punctuation: /[{}\[\](),]/
        };
      }
      return clojure_1;
    }
    var cmake_1;
    var hasRequiredCmake;
    function requireCmake() {
      if (hasRequiredCmake)
        return cmake_1;
      hasRequiredCmake = 1;
      cmake_1 = cmake;
      cmake.displayName = "cmake";
      cmake.aliases = [];
      function cmake(Prism2) {
        Prism2.languages.cmake = {
          comment: /#.*/,
          string: {
            pattern: /"(?:[^\\"]|\\.)*"/,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
                inside: {
                  punctuation: /\$\{|\}/,
                  variable: /\w+/
                }
              }
            }
          },
          variable: /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_(?:BINARY_DIR|DESCRIPTION|HOMEPAGE_URL|NAME|SOURCE_DIR|VERSION|VERSION_(?:MAJOR|MINOR|PATCH|TWEAK))|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE|XCODE_VERSION))\b/,
          property: /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|GLOBAL_KEYWORD|GLOBAL_PROJECT_TYPES|GLOBAL_ROOTNAMESPACE|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
          keyword: /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
          boolean: /\b(?:FALSE|OFF|ON|TRUE)\b/,
          namespace: /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
          operator: /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
          inserted: {
            pattern: /\b\w+::\w+\b/,
            alias: "class-name"
          },
          number: /\b\d+(?:\.\d+)*\b/,
          function: /\b[a-z_]\w*(?=\s*\()\b/i,
          punctuation: /[()>}]|\$[<{]/
        };
      }
      return cmake_1;
    }
    var cobol_1;
    var hasRequiredCobol;
    function requireCobol() {
      if (hasRequiredCobol)
        return cobol_1;
      hasRequiredCobol = 1;
      cobol_1 = cobol;
      cobol.displayName = "cobol";
      cobol.aliases = [];
      function cobol(Prism2) {
        Prism2.languages.cobol = {
          comment: {
            pattern: /\*>.*|(^[ \t]*)\*.*/m,
            lookbehind: true,
            greedy: true
          },
          string: {
            pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
            greedy: true
          },
          level: {
            pattern: /(^[ \t]*)\d+\b/m,
            lookbehind: true,
            greedy: true,
            alias: "number"
          },
          "class-name": {
            // https://github.com/antlr/grammars-v4/blob/42edd5b687d183b5fa679e858a82297bd27141e7/cobol85/Cobol85.g4#L1015
            pattern: /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
            lookbehind: true,
            inside: {
              number: {
                pattern: /(\()\d+/,
                lookbehind: true
              },
              punctuation: /[()]/
            }
          },
          keyword: {
            pattern: /(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOTTOM|BOUNDS|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COL|COLLATING|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOL|EOP|EOS|ERASE|ERROR|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTION-POINTER|FUNCTIONNAME|GENERATE|GIVING|GLOBAL|GO|GOBACK|GRID|GROUP|HEADING|HIGH-VALUE|HIGH-VALUES|HIGHLIGHT|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINE-COUNTER|LINES|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOW-VALUE|LOW-VALUES|LOWER|LOWLIGHT|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|PORT|POSITION|POSITIVE|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|RD|READ|READER|REAL|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOTE|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|RESET|RETURN|RETURN-CODE|RETURNING|REVERSE-VIDEO|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TAPE|TASK|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYDDD|YYYYMMDD|ZERO-FILL|ZEROES|ZEROS)(?![\w-])/i,
            lookbehind: true
          },
          boolean: {
            pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i,
            lookbehind: true
          },
          number: {
            pattern: /(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
            lookbehind: true
          },
          operator: [
            /<>|[<>]=?|[=+*/&]/,
            {
              pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
              lookbehind: true
            }
          ],
          punctuation: /[.:,()]/
        };
      }
      return cobol_1;
    }
    var coffeescript_1;
    var hasRequiredCoffeescript;
    function requireCoffeescript() {
      if (hasRequiredCoffeescript)
        return coffeescript_1;
      hasRequiredCoffeescript = 1;
      coffeescript_1 = coffeescript;
      coffeescript.displayName = "coffeescript";
      coffeescript.aliases = ["coffee"];
      function coffeescript(Prism2) {
        (function(Prism3) {
          var comment = /#(?!\{).+/;
          var interpolation = {
            pattern: /#\{[^}]+\}/,
            alias: "variable"
          };
          Prism3.languages.coffeescript = Prism3.languages.extend("javascript", {
            comment,
            string: [
              // Strings are multiline
              {
                pattern: /'(?:\\[\s\S]|[^\\'])*'/,
                greedy: true
              },
              {
                // Strings are multiline
                pattern: /"(?:\\[\s\S]|[^\\"])*"/,
                greedy: true,
                inside: {
                  interpolation
                }
              }
            ],
            keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
            "class-member": {
              pattern: /@(?!\d)\w+/,
              alias: "variable"
            }
          });
          Prism3.languages.insertBefore("coffeescript", "comment", {
            "multiline-comment": {
              pattern: /###[\s\S]+?###/,
              alias: "comment"
            },
            // Block regexp can contain comments and interpolation
            "block-regex": {
              pattern: /\/{3}[\s\S]*?\/{3}/,
              alias: "regex",
              inside: {
                comment,
                interpolation
              }
            }
          });
          Prism3.languages.insertBefore("coffeescript", "string", {
            "inline-javascript": {
              pattern: /`(?:\\[\s\S]|[^\\`])*`/,
              inside: {
                delimiter: {
                  pattern: /^`|`$/,
                  alias: "punctuation"
                },
                script: {
                  pattern: /[\s\S]+/,
                  alias: "language-javascript",
                  inside: Prism3.languages.javascript
                }
              }
            },
            // Block strings
            "multiline-string": [
              {
                pattern: /'''[\s\S]*?'''/,
                greedy: true,
                alias: "string"
              },
              {
                pattern: /"""[\s\S]*?"""/,
                greedy: true,
                alias: "string",
                inside: {
                  interpolation
                }
              }
            ]
          });
          Prism3.languages.insertBefore("coffeescript", "keyword", {
            // Object property
            property: /(?!\d)\w+(?=\s*:(?!:))/
          });
          delete Prism3.languages.coffeescript["template-string"];
          Prism3.languages.coffee = Prism3.languages.coffeescript;
        })(Prism2);
      }
      return coffeescript_1;
    }
    var concurnas_1;
    var hasRequiredConcurnas;
    function requireConcurnas() {
      if (hasRequiredConcurnas)
        return concurnas_1;
      hasRequiredConcurnas = 1;
      concurnas_1 = concurnas;
      concurnas.displayName = "concurnas";
      concurnas.aliases = ["conc"];
      function concurnas(Prism2) {
        Prism2.languages.concurnas = {
          comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
            lookbehind: true,
            greedy: true
          },
          langext: {
            pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
            greedy: true,
            inside: {
              "class-name": /^\w+/,
              string: {
                pattern: /(^\s*\|\|)[\s\S]+(?=\|\|$)/,
                lookbehind: true
              },
              punctuation: /\|\|/
            }
          },
          function: {
            pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
            lookbehind: true
          },
          keyword: /\b(?:abstract|actor|also|annotation|assert|async|await|bool|boolean|break|byte|case|catch|changed|char|class|closed|constant|continue|def|default|del|double|elif|else|enum|every|extends|false|finally|float|for|from|global|gpudef|gpukernel|if|import|in|init|inject|int|lambda|local|long|loop|match|new|nodefault|null|of|onchange|open|out|override|package|parfor|parforsync|post|pre|private|protected|provide|provider|public|return|shared|short|single|size_t|sizeof|super|sync|this|throw|trait|trans|transient|true|try|typedef|unchecked|using|val|var|void|while|with)\b/,
          boolean: /\b(?:false|true)\b/,
          number: /\b0b[01][01_]*L?\b|\b0x(?:[\da-f_]*\.)?[\da-f_p+-]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfls]?/i,
          punctuation: /[{}[\];(),.:]/,
          operator: /<==|>==|=>|->|<-|<>|&==|&<>|\?:?|\.\?|\+\+|--|[-+*/=<>]=?|[!^~]|\b(?:and|as|band|bor|bxor|comp|is|isnot|mod|or)\b=?/,
          annotation: {
            pattern: /@(?:\w+:)?(?:\w+|\[[^\]]+\])?/,
            alias: "builtin"
          }
        };
        Prism2.languages.insertBefore("concurnas", "langext", {
          "regex-literal": {
            pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: true,
                inside: Prism2.languages.concurnas
              },
              regex: /[\s\S]+/
            }
          },
          "string-literal": {
            pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: true,
                inside: Prism2.languages.concurnas
              },
              string: /[\s\S]+/
            }
          }
        });
        Prism2.languages.conc = Prism2.languages.concurnas;
      }
      return concurnas_1;
    }
    var coq_1;
    var hasRequiredCoq;
    function requireCoq() {
      if (hasRequiredCoq)
        return coq_1;
      hasRequiredCoq = 1;
      coq_1 = coq;
      coq.displayName = "coq";
      coq.aliases = [];
      function coq(Prism2) {
        (function(Prism3) {
          var commentSource = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source;
          for (var i = 0; i < 2; i++) {
            commentSource = commentSource.replace(/<self>/g, function() {
              return commentSource;
            });
          }
          commentSource = commentSource.replace(/<self>/g, "[]");
          Prism3.languages.coq = {
            comment: RegExp(commentSource),
            string: {
              pattern: /"(?:[^"]|"")*"(?!")/,
              greedy: true
            },
            attribute: [
              {
                pattern: RegExp(
                  /#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(
                    /<comment>/g,
                    function() {
                      return commentSource;
                    }
                  )
                ),
                greedy: true,
                alias: "attr-name",
                inside: {
                  comment: RegExp(commentSource),
                  string: {
                    pattern: /"(?:[^"]|"")*"(?!")/,
                    greedy: true
                  },
                  operator: /=/,
                  punctuation: /^#\[|\]$|[,()]/
                }
              },
              {
                pattern: /\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
                alias: "attr-name"
              }
            ],
            keyword: /\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\b/,
            number: /\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
            punct: {
              pattern: /@\{|\{\||\[=|:>/,
              alias: "punctuation"
            },
            operator: /\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
            punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
          };
        })(Prism2);
      }
      return coq_1;
    }
    var ruby_1;
    var hasRequiredRuby;
    function requireRuby() {
      if (hasRequiredRuby)
        return ruby_1;
      hasRequiredRuby = 1;
      ruby_1 = ruby;
      ruby.displayName = "ruby";
      ruby.aliases = ["rb"];
      function ruby(Prism2) {
        (function(Prism3) {
          Prism3.languages.ruby = Prism3.languages.extend("clike", {
            comment: {
              pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
              greedy: true
            },
            "class-name": {
              pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
              lookbehind: true,
              inside: {
                punctuation: /[.\\]/
              }
            },
            keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
            operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
            punctuation: /[(){}[\].,;]/
          });
          Prism3.languages.insertBefore("ruby", "operator", {
            "double-colon": {
              pattern: /::/,
              alias: "punctuation"
            }
          });
          var interpolation = {
            pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
            lookbehind: true,
            inside: {
              content: {
                pattern: /^(#\{)[\s\S]+(?=\}$)/,
                lookbehind: true,
                inside: Prism3.languages.ruby
              },
              delimiter: {
                pattern: /^#\{|\}$/,
                alias: "punctuation"
              }
            }
          };
          delete Prism3.languages.ruby.function;
          var percentExpression = "(?:" + [
            /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
            /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
            /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
            /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
            /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
          ].join("|") + ")";
          var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
          Prism3.languages.insertBefore("ruby", "keyword", {
            "regex-literal": [
              {
                pattern: RegExp(
                  /%r/.source + percentExpression + /[egimnosux]{0,6}/.source
                ),
                greedy: true,
                inside: {
                  interpolation,
                  regex: /[\s\S]+/
                }
              },
              {
                pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
                lookbehind: true,
                greedy: true,
                inside: {
                  interpolation,
                  regex: /[\s\S]+/
                }
              }
            ],
            variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
            symbol: [
              {
                pattern: RegExp(/(^|[^:]):/.source + symbolName),
                lookbehind: true,
                greedy: true
              },
              {
                pattern: RegExp(
                  /([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source
                ),
                lookbehind: true,
                greedy: true
              }
            ],
            "method-definition": {
              pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
              lookbehind: true,
              inside: {
                function: /\b\w+$/,
                keyword: /^self\b/,
                "class-name": /^\w+/,
                punctuation: /\./
              }
            }
          });
          Prism3.languages.insertBefore("ruby", "string", {
            "string-literal": [
              {
                pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
                greedy: true,
                inside: {
                  interpolation,
                  string: /[\s\S]+/
                }
              },
              {
                pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
                greedy: true,
                inside: {
                  interpolation,
                  string: /[\s\S]+/
                }
              },
              {
                pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
                alias: "heredoc-string",
                greedy: true,
                inside: {
                  delimiter: {
                    pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
                    inside: {
                      symbol: /\b\w+/,
                      punctuation: /^<<[-~]?/
                    }
                  },
                  interpolation,
                  string: /[\s\S]+/
                }
              },
              {
                pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
                alias: "heredoc-string",
                greedy: true,
                inside: {
                  delimiter: {
                    pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
                    inside: {
                      symbol: /\b\w+/,
                      punctuation: /^<<[-~]?'|'$/
                    }
                  },
                  string: /[\s\S]+/
                }
              }
            ],
            "command-literal": [
              {
                pattern: RegExp(/%x/.source + percentExpression),
                greedy: true,
                inside: {
                  interpolation,
                  command: {
                    pattern: /[\s\S]+/,
                    alias: "string"
                  }
                }
              },
              {
                pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
                greedy: true,
                inside: {
                  interpolation,
                  command: {
                    pattern: /[\s\S]+/,
                    alias: "string"
                  }
                }
              }
            ]
          });
          delete Prism3.languages.ruby.string;
          Prism3.languages.insertBefore("ruby", "number", {
            builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
            constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
          });
          Prism3.languages.rb = Prism3.languages.ruby;
        })(Prism2);
      }
      return ruby_1;
    }
    var crystal_1;
    var hasRequiredCrystal;
    function requireCrystal() {
      if (hasRequiredCrystal)
        return crystal_1;
      hasRequiredCrystal = 1;
      var refractorRuby = requireRuby();
      crystal_1 = crystal;
      crystal.displayName = "crystal";
      crystal.aliases = [];
      function crystal(Prism2) {
        Prism2.register(refractorRuby);
        (function(Prism3) {
          Prism3.languages.crystal = Prism3.languages.extend("ruby", {
            keyword: [
              /\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/,
              {
                pattern: /(\.\s*)(?:is_a|responds_to)\?/,
                lookbehind: true
              }
            ],
            number: /\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[\da-fA-F_]*[\da-fA-F]|(?:\d(?:[\d_]*\d)?)(?:\.[\d_]*\d)?(?:[eE][+-]?[\d_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/,
            operator: [/->/, Prism3.languages.ruby.operator],
            punctuation: /[(){}[\].,;\\]/
          });
          Prism3.languages.insertBefore("crystal", "string-literal", {
            attribute: {
              pattern: /@\[.*?\]/,
              inside: {
                delimiter: {
                  pattern: /^@\[|\]$/,
                  alias: "punctuation"
                },
                attribute: {
                  pattern: /^(\s*)\w+/,
                  lookbehind: true,
                  alias: "class-name"
                },
                args: {
                  pattern: /\S(?:[\s\S]*\S)?/,
                  inside: Prism3.languages.crystal
                }
              }
            },
            expansion: {
              pattern: /\{(?:\{.*?\}|%.*?%)\}/,
              inside: {
                content: {
                  pattern: /^(\{.)[\s\S]+(?=.\}$)/,
                  lookbehind: true,
                  inside: Prism3.languages.crystal
                },
                delimiter: {
                  pattern: /^\{[\{%]|[\}%]\}$/,
                  alias: "operator"
                }
              }
            },
            char: {
              pattern: /'(?:[^\\\r\n]{1,2}|\\(?:.|u(?:[A-Fa-f0-9]{1,4}|\{[A-Fa-f0-9]{1,6}\})))'/,
              greedy: true
            }
          });
        })(Prism2);
      }
      return crystal_1;
    }
    var cshtml_1;
    var hasRequiredCshtml;
    function requireCshtml() {
      if (hasRequiredCshtml)
        return cshtml_1;
      hasRequiredCshtml = 1;
      var refractorCsharp = requireCsharp();
      cshtml_1 = cshtml;
      cshtml.displayName = "cshtml";
      cshtml.aliases = ["razor"];
      function cshtml(Prism2) {
        Prism2.register(refractorCsharp);
        (function(Prism3) {
          var commentLike = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source;
          var stringLike = /@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source + "|" + /'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
          function nested(pattern, depthLog2) {
            for (var i = 0; i < depthLog2; i++) {
              pattern = pattern.replace(/<self>/g, function() {
                return "(?:" + pattern + ")";
              });
            }
            return pattern.replace(/<self>/g, "[^\\s\\S]").replace(/<str>/g, "(?:" + stringLike + ")").replace(/<comment>/g, "(?:" + commentLike + ")");
          }
          var round = nested(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2);
          var square = nested(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 2);
          var curly = nested(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2);
          var angle = nested(/<(?:[^<>'"@/]|<str>|<comment>|<self>)*>/.source, 2);
          var tagAttrs = /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?/.source;
          var tagContent = /(?!\d)[^\s>\/=$<%]+/.source + tagAttrs + /\s*\/?>/.source;
          var tagRegion = /\B@?/.source + "(?:" + /<([a-zA-Z][\w:]*)/.source + tagAttrs + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
          // eslint-disable-next-line regexp/strict
          /<\/?(?!\1\b)/.source + tagContent + "|" + // nested start tag
          nested(
            // eslint-disable-next-line regexp/strict
            /<\1/.source + tagAttrs + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
            // eslint-disable-next-line regexp/strict
            /<\/?(?!\1\b)/.source + tagContent + "|<self>") + ")*" + // eslint-disable-next-line regexp/strict
            /<\/\1\s*>/.source,
            2
          )) + ")*" + // eslint-disable-next-line regexp/strict
          /<\/\1\s*>/.source + "|" + /</.source + tagContent + ")";
          Prism3.languages.cshtml = Prism3.languages.extend("markup", {});
          var csharpWithHtml = Prism3.languages.insertBefore(
            "csharp",
            "string",
            {
              html: {
                pattern: RegExp(tagRegion),
                greedy: true,
                inside: Prism3.languages.cshtml
              }
            },
            {
              csharp: Prism3.languages.extend("csharp", {})
            }
          );
          var cs = {
            pattern: /\S[\s\S]*/,
            alias: "language-csharp",
            inside: csharpWithHtml
          };
          Prism3.languages.insertBefore("cshtml", "prolog", {
            "razor-comment": {
              pattern: /@\*[\s\S]*?\*@/,
              greedy: true,
              alias: "comment"
            },
            block: {
              pattern: RegExp(
                /(^|[^@])@/.source + "(?:" + [
                  // @{ ... }
                  curly,
                  // @code{ ... }
                  /(?:code|functions)\s*/.source + curly,
                  // @for (...) { ... }
                  /(?:for|foreach|lock|switch|using|while)\s*/.source + round + /\s*/.source + curly,
                  // @do { ... } while (...);
                  /do\s*/.source + curly + /\s*while\s*/.source + round + /(?:\s*;)?/.source,
                  // @try { ... } catch (...) { ... } finally { ... }
                  /try\s*/.source + curly + /\s*catch\s*/.source + round + /\s*/.source + curly + /\s*finally\s*/.source + curly,
                  // @if (...) {...} else if (...) {...} else {...}
                  /if\s*/.source + round + /\s*/.source + curly + "(?:" + /\s*else/.source + "(?:" + /\s+if\s*/.source + round + ")?" + /\s*/.source + curly + ")*"
                ].join("|") + ")"
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                keyword: /^@\w*/,
                csharp: cs
              }
            },
            directive: {
              pattern: /^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
              lookbehind: true,
              greedy: true,
              inside: {
                keyword: /^@\w+/,
                csharp: cs
              }
            },
            value: {
              pattern: RegExp(
                /(^|[^@])@/.source + /(?:await\b\s*)?/.source + "(?:" + /\w+\b/.source + "|" + round + ")(?:" + /[?!]?\.\w+\b/.source + "|" + round + "|" + square + "|" + angle + round + ")*"
              ),
              lookbehind: true,
              greedy: true,
              alias: "variable",
              inside: {
                keyword: /^@/,
                csharp: cs
              }
            },
            "delegate-operator": {
              pattern: /(^|[^@])@(?=<)/,
              lookbehind: true,
              alias: "operator"
            }
          });
          Prism3.languages.razor = Prism3.languages.cshtml;
        })(Prism2);
      }
      return cshtml_1;
    }
    var csp_1;
    var hasRequiredCsp;
    function requireCsp() {
      if (hasRequiredCsp)
        return csp_1;
      hasRequiredCsp = 1;
      csp_1 = csp;
      csp.displayName = "csp";
      csp.aliases = [];
      function csp(Prism2) {
        (function(Prism3) {
          function value(source) {
            return RegExp(
              /([ \t])/.source + "(?:" + source + ")" + /(?=[\s;]|$)/.source,
              "i"
            );
          }
          Prism3.languages.csp = {
            directive: {
              pattern: /(^|[\s;])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[\s;]|$)/i,
              lookbehind: true,
              alias: "property"
            },
            scheme: {
              pattern: value(/[a-z][a-z0-9.+-]*:/.source),
              lookbehind: true
            },
            none: {
              pattern: value(/'none'/.source),
              lookbehind: true,
              alias: "keyword"
            },
            nonce: {
              pattern: value(/'nonce-[-+/\w=]+'/.source),
              lookbehind: true,
              alias: "number"
            },
            hash: {
              pattern: value(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
              lookbehind: true,
              alias: "number"
            },
            host: {
              pattern: value(
                /[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source + "|" + /\*[^\s;,']*/.source + "|" + /[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source
              ),
              lookbehind: true,
              alias: "url",
              inside: {
                important: /\*/
              }
            },
            keyword: [
              {
                pattern: value(/'unsafe-[a-z-]+'/.source),
                lookbehind: true,
                alias: "unsafe"
              },
              {
                pattern: value(/'[a-z-]+'/.source),
                lookbehind: true,
                alias: "safe"
              }
            ],
            punctuation: /;/
          };
        })(Prism2);
      }
      return csp_1;
    }
    var cssExtras_1;
    var hasRequiredCssExtras;
    function requireCssExtras() {
      if (hasRequiredCssExtras)
        return cssExtras_1;
      hasRequiredCssExtras = 1;
      cssExtras_1 = cssExtras;
      cssExtras.displayName = "cssExtras";
      cssExtras.aliases = [];
      function cssExtras(Prism2) {
        (function(Prism3) {
          var string2 = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
          var selectorInside;
          Prism3.languages.css.selector = {
            pattern: Prism3.languages.css.selector.pattern,
            lookbehind: true,
            inside: selectorInside = {
              "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
              "pseudo-class": /:[-\w]+/,
              class: /\.[-\w]+/,
              id: /#[-\w]+/,
              attribute: {
                pattern: RegExp(`\\[(?:[^[\\]"']|` + string2.source + ")*\\]"),
                greedy: true,
                inside: {
                  punctuation: /^\[|\]$/,
                  "case-sensitivity": {
                    pattern: /(\s)[si]$/i,
                    lookbehind: true,
                    alias: "keyword"
                  },
                  namespace: {
                    pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
                    lookbehind: true,
                    inside: {
                      punctuation: /\|$/
                    }
                  },
                  "attr-name": {
                    pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
                    lookbehind: true
                  },
                  "attr-value": [
                    string2,
                    {
                      pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
                      lookbehind: true
                    }
                  ],
                  operator: /[|~*^$]?=/
                }
              },
              "n-th": [
                {
                  pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
                  lookbehind: true,
                  inside: {
                    number: /[\dn]+/,
                    operator: /[+-]/
                  }
                },
                {
                  pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
                  lookbehind: true
                }
              ],
              combinator: />|\+|~|\|\|/,
              // the `tag` token has been existed and removed.
              // because we can't find a perfect tokenize to match it.
              // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
              punctuation: /[(),]/
            }
          };
          Prism3.languages.css["atrule"].inside["selector-function-argument"].inside = selectorInside;
          Prism3.languages.insertBefore("css", "property", {
            variable: {
              pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
              lookbehind: true
            }
          });
          var unit = {
            pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
            lookbehind: true
          };
          var number2 = {
            pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
            lookbehind: true
          };
          Prism3.languages.insertBefore("css", "function", {
            operator: {
              pattern: /(\s)[+\-*\/](?=\s)/,
              lookbehind: true
            },
            // CAREFUL!
            // Previewers and Inline color use hexcode and color.
            hexcode: {
              pattern: /\B#[\da-f]{3,8}\b/i,
              alias: "color"
            },
            color: [
              {
                pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
                lookbehind: true
              },
              {
                pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
                inside: {
                  unit,
                  number: number2,
                  function: /[\w-]+(?=\()/,
                  punctuation: /[(),]/
                }
              }
            ],
            // it's important that there is no boundary assertion after the hex digits
            entity: /\\[\da-f]{1,8}/i,
            unit,
            number: number2
          });
        })(Prism2);
      }
      return cssExtras_1;
    }
    var csv_1;
    var hasRequiredCsv;
    function requireCsv() {
      if (hasRequiredCsv)
        return csv_1;
      hasRequiredCsv = 1;
      csv_1 = csv;
      csv.displayName = "csv";
      csv.aliases = [];
      function csv(Prism2) {
        Prism2.languages.csv = {
          value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
          punctuation: /,/
        };
      }
      return csv_1;
    }
    var cypher_1;
    var hasRequiredCypher;
    function requireCypher() {
      if (hasRequiredCypher)
        return cypher_1;
      hasRequiredCypher = 1;
      cypher_1 = cypher;
      cypher.displayName = "cypher";
      cypher.aliases = [];
      function cypher(Prism2) {
        Prism2.languages.cypher = {
          // https://neo4j.com/docs/cypher-manual/current/syntax/comments/
          comment: /\/\/.*/,
          string: {
            pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/,
            greedy: true
          },
          "class-name": {
            pattern: /(:\s*)(?:\w+|`(?:[^`\\\r\n])*`)(?=\s*[{):])/,
            lookbehind: true,
            greedy: true
          },
          relationship: {
            pattern: /(-\[\s*(?:\w+\s*|`(?:[^`\\\r\n])*`\s*)?:\s*|\|\s*:\s*)(?:\w+|`(?:[^`\\\r\n])*`)/,
            lookbehind: true,
            greedy: true,
            alias: "property"
          },
          identifier: {
            pattern: /`(?:[^`\\\r\n])*`/,
            greedy: true
          },
          variable: /\$\w+/,
          // https://neo4j.com/docs/cypher-manual/current/syntax/reserved/
          keyword: /\b(?:ADD|ALL|AND|AS|ASC|ASCENDING|ASSERT|BY|CALL|CASE|COMMIT|CONSTRAINT|CONTAINS|CREATE|CSV|DELETE|DESC|DESCENDING|DETACH|DISTINCT|DO|DROP|ELSE|END|ENDS|EXISTS|FOR|FOREACH|IN|INDEX|IS|JOIN|KEY|LIMIT|LOAD|MANDATORY|MATCH|MERGE|NODE|NOT|OF|ON|OPTIONAL|OR|ORDER(?=\s+BY)|PERIODIC|REMOVE|REQUIRE|RETURN|SCALAR|SCAN|SET|SKIP|START|STARTS|THEN|UNION|UNIQUE|UNWIND|USING|WHEN|WHERE|WITH|XOR|YIELD)\b/i,
          function: /\b\w+\b(?=\s*\()/,
          boolean: /\b(?:false|null|true)\b/i,
          number: /\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
          // https://neo4j.com/docs/cypher-manual/current/syntax/operators/
          operator: /:|<--?|--?>?|<>|=~?|[<>]=?|[+*/%^|]|\.\.\.?/,
          punctuation: /[()[\]{},;.]/
        };
      }
      return cypher_1;
    }
    var d_1;
    var hasRequiredD;
    function requireD() {
      if (hasRequiredD)
        return d_1;
      hasRequiredD = 1;
      d_1 = d;
      d.displayName = "d";
      d.aliases = [];
      function d(Prism2) {
        Prism2.languages.d = Prism2.languages.extend("clike", {
          comment: [
            {
              // Shebang
              pattern: /^\s*#!.+/,
              greedy: true
            },
            {
              pattern: RegExp(
                /(^|[^\\])/.source + "(?:" + [
                  // /+ comment +/
                  // Allow one level of nesting
                  /\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source,
                  // // comment
                  /\/\/.*/.source,
                  // /* comment */
                  /\/\*[\s\S]*?\*\//.source
                ].join("|") + ")"
              ),
              lookbehind: true,
              greedy: true
            }
          ],
          string: [
            {
              pattern: RegExp(
                [
                  // r"", x""
                  /\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source,
                  // q"[]", q"()", q"<>", q"{}"
                  /\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source,
                  // q"IDENT
                  // ...
                  // IDENT"
                  /\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source,
                  // q"//", q"||", etc.
                  // eslint-disable-next-line regexp/strict
                  /\bq"(.)[\s\S]*?\2"/.source,
                  // eslint-disable-next-line regexp/strict
                  /(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
                ].join("|"),
                "m"
              ),
              greedy: true
            },
            {
              pattern: /\bq\{(?:\{[^{}]*\}|[^{}])*\}/,
              greedy: true,
              alias: "token-string"
            }
          ],
          // In order: $, keywords and special tokens, globally defined symbols
          keyword: /\$|\b(?:__(?:(?:DATE|EOF|FILE|FUNCTION|LINE|MODULE|PRETTY_FUNCTION|TIMESTAMP|TIME|VENDOR|VERSION)__|gshared|parameters|traits|vector)|abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|dstring|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|ptrdiff_t|public|pure|real|ref|return|scope|shared|short|size_t|static|string|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|wstring)\b/,
          number: [
            // The lookbehind and the negative look-ahead try to prevent bad highlighting of the .. operator
            // Hexadecimal numbers must be handled separately to avoid problems with exponent "e"
            /\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]{0,4}/i,
            {
              pattern: /((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]{0,4}/i,
              lookbehind: true
            }
          ],
          operator: /\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
        });
        Prism2.languages.insertBefore("d", "string", {
          // Characters
          // 'a', '\\', '\n', '\xFF', '\377', '\uFFFF', '\U0010FFFF', '\quot'
          char: /'(?:\\(?:\W|\w+)|[^\\])'/
        });
        Prism2.languages.insertBefore("d", "keyword", {
          property: /\B@\w*/
        });
        Prism2.languages.insertBefore("d", "function", {
          register: {
            // Iasm registers
            pattern: /\b(?:[ABCD][LHX]|E?(?:BP|DI|SI|SP)|[BS]PL|[ECSDGF]S|CR[0234]|[DS]IL|DR[012367]|E[ABCD]X|X?MM[0-7]|R(?:1[0-5]|[89])[BWD]?|R[ABCD]X|R[BS]P|R[DS]I|TR[3-7]|XMM(?:1[0-5]|[89])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
            alias: "variable"
          }
        });
      }
      return d_1;
    }
    var dart_1;
    var hasRequiredDart;
    function requireDart() {
      if (hasRequiredDart)
        return dart_1;
      hasRequiredDart = 1;
      dart_1 = dart;
      dart.displayName = "dart";
      dart.aliases = [];
      function dart(Prism2) {
        (function(Prism3) {
          var keywords = [
            /\b(?:async|sync|yield)\*/,
            /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/
          ];
          var packagePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
          var className = {
            pattern: RegExp(packagePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
            lookbehind: true,
            inside: {
              namespace: {
                pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
                inside: {
                  punctuation: /\./
                }
              }
            }
          };
          Prism3.languages.dart = Prism3.languages.extend("clike", {
            "class-name": [
              className,
              {
                // variables and parameters
                // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
                pattern: RegExp(
                  packagePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source
                ),
                lookbehind: true,
                inside: className.inside
              }
            ],
            keyword: keywords,
            operator: /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
          });
          Prism3.languages.insertBefore("dart", "string", {
            "string-literal": {
              pattern: /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
              greedy: true,
              inside: {
                interpolation: {
                  pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
                  lookbehind: true,
                  inside: {
                    punctuation: /^\$\{?|\}$/,
                    expression: {
                      pattern: /[\s\S]+/,
                      inside: Prism3.languages.dart
                    }
                  }
                },
                string: /[\s\S]+/
              }
            },
            string: void 0
          });
          Prism3.languages.insertBefore("dart", "class-name", {
            metadata: {
              pattern: /@\w+/,
              alias: "function"
            }
          });
          Prism3.languages.insertBefore("dart", "class-name", {
            generics: {
              pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
              inside: {
                "class-name": className,
                keyword: keywords,
                punctuation: /[<>(),.:]/,
                operator: /[?&|]/
              }
            }
          });
        })(Prism2);
      }
      return dart_1;
    }
    var dataweave_1;
    var hasRequiredDataweave;
    function requireDataweave() {
      if (hasRequiredDataweave)
        return dataweave_1;
      hasRequiredDataweave = 1;
      dataweave_1 = dataweave;
      dataweave.displayName = "dataweave";
      dataweave.aliases = [];
      function dataweave(Prism2) {
        (function(Prism3) {
          Prism3.languages.dataweave = {
            url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
            property: {
              pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
              greedy: true
            },
            string: {
              pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
              greedy: true
            },
            "mime-type": /\b(?:application|audio|image|multipart|text|video)\/[\w+-]+/,
            date: {
              pattern: /\|[\w:+-]+\|/,
              greedy: true
            },
            comment: [
              {
                pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                lookbehind: true,
                greedy: true
              },
              {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
              }
            ],
            regex: {
              pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//,
              greedy: true
            },
            keyword: /\b(?:and|as|at|case|do|else|fun|if|input|is|match|not|ns|null|or|output|type|unless|update|using|var)\b/,
            function: /\b[A-Z_]\w*(?=\s*\()/i,
            number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
            punctuation: /[{}[\];(),.:@]/,
            operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
            boolean: /\b(?:false|true)\b/
          };
        })(Prism2);
      }
      return dataweave_1;
    }
    var dax_1;
    var hasRequiredDax;
    function requireDax() {
      if (hasRequiredDax)
        return dax_1;
      hasRequiredDax = 1;
      dax_1 = dax;
      dax.displayName = "dax";
      dax.aliases = [];
      function dax(Prism2) {
        Prism2.languages.dax = {
          comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/).*)/,
            lookbehind: true
          },
          "data-field": {
            pattern: /'(?:[^']|'')*'(?!')(?:\[[ \w\xA0-\uFFFF]+\])?|\w+\[[ \w\xA0-\uFFFF]+\]/,
            alias: "symbol"
          },
          measure: {
            pattern: /\[[ \w\xA0-\uFFFF]+\]/,
            alias: "constant"
          },
          string: {
            pattern: /"(?:[^"]|"")*"(?!")/,
            greedy: true
          },
          function: /\b(?:ABS|ACOS|ACOSH|ACOT|ACOTH|ADDCOLUMNS|ADDMISSINGITEMS|ALL|ALLCROSSFILTERED|ALLEXCEPT|ALLNOBLANKROW|ALLSELECTED|AND|APPROXIMATEDISTINCTCOUNT|ASIN|ASINH|ATAN|ATANH|AVERAGE|AVERAGEA|AVERAGEX|BETA\.DIST|BETA\.INV|BLANK|CALCULATE|CALCULATETABLE|CALENDAR|CALENDARAUTO|CEILING|CHISQ\.DIST|CHISQ\.DIST\.RT|CHISQ\.INV|CHISQ\.INV\.RT|CLOSINGBALANCEMONTH|CLOSINGBALANCEQUARTER|CLOSINGBALANCEYEAR|COALESCE|COMBIN|COMBINA|COMBINEVALUES|CONCATENATE|CONCATENATEX|CONFIDENCE\.NORM|CONFIDENCE\.T|CONTAINS|CONTAINSROW|CONTAINSSTRING|CONTAINSSTRINGEXACT|CONVERT|COS|COSH|COT|COTH|COUNT|COUNTA|COUNTAX|COUNTBLANK|COUNTROWS|COUNTX|CROSSFILTER|CROSSJOIN|CURRENCY|CURRENTGROUP|CUSTOMDATA|DATATABLE|DATE|DATEADD|DATEDIFF|DATESBETWEEN|DATESINPERIOD|DATESMTD|DATESQTD|DATESYTD|DATEVALUE|DAY|DEGREES|DETAILROWS|DISTINCT|DISTINCTCOUNT|DISTINCTCOUNTNOBLANK|DIVIDE|EARLIER|EARLIEST|EDATE|ENDOFMONTH|ENDOFQUARTER|ENDOFYEAR|EOMONTH|ERROR|EVEN|EXACT|EXCEPT|EXP|EXPON\.DIST|FACT|FALSE|FILTER|FILTERS|FIND|FIRSTDATE|FIRSTNONBLANK|FIRSTNONBLANKVALUE|FIXED|FLOOR|FORMAT|GCD|GENERATE|GENERATEALL|GENERATESERIES|GEOMEAN|GEOMEANX|GROUPBY|HASONEFILTER|HASONEVALUE|HOUR|IF|IF\.EAGER|IFERROR|IGNORE|INT|INTERSECT|ISBLANK|ISCROSSFILTERED|ISEMPTY|ISERROR|ISEVEN|ISFILTERED|ISINSCOPE|ISLOGICAL|ISNONTEXT|ISNUMBER|ISO\.CEILING|ISODD|ISONORAFTER|ISSELECTEDMEASURE|ISSUBTOTAL|ISTEXT|KEEPFILTERS|KEYWORDMATCH|LASTDATE|LASTNONBLANK|LASTNONBLANKVALUE|LCM|LEFT|LEN|LN|LOG|LOG10|LOOKUPVALUE|LOWER|MAX|MAXA|MAXX|MEDIAN|MEDIANX|MID|MIN|MINA|MINUTE|MINX|MOD|MONTH|MROUND|NATURALINNERJOIN|NATURALLEFTOUTERJOIN|NEXTDAY|NEXTMONTH|NEXTQUARTER|NEXTYEAR|NONVISUAL|NORM\.DIST|NORM\.INV|NORM\.S\.DIST|NORM\.S\.INV|NOT|NOW|ODD|OPENINGBALANCEMONTH|OPENINGBALANCEQUARTER|OPENINGBALANCEYEAR|OR|PARALLELPERIOD|PATH|PATHCONTAINS|PATHITEM|PATHITEMREVERSE|PATHLENGTH|PERCENTILE\.EXC|PERCENTILE\.INC|PERCENTILEX\.EXC|PERCENTILEX\.INC|PERMUT|PI|POISSON\.DIST|POWER|PREVIOUSDAY|PREVIOUSMONTH|PREVIOUSQUARTER|PREVIOUSYEAR|PRODUCT|PRODUCTX|QUARTER|QUOTIENT|RADIANS|RAND|RANDBETWEEN|RANK\.EQ|RANKX|RELATED|RELATEDTABLE|REMOVEFILTERS|REPLACE|REPT|RIGHT|ROLLUP|ROLLUPADDISSUBTOTAL|ROLLUPGROUP|ROLLUPISSUBTOTAL|ROUND|ROUNDDOWN|ROUNDUP|ROW|SAMEPERIODLASTYEAR|SAMPLE|SEARCH|SECOND|SELECTCOLUMNS|SELECTEDMEASURE|SELECTEDMEASUREFORMATSTRING|SELECTEDMEASURENAME|SELECTEDVALUE|SIGN|SIN|SINH|SQRT|SQRTPI|STARTOFMONTH|STARTOFQUARTER|STARTOFYEAR|STDEV\.P|STDEV\.S|STDEVX\.P|STDEVX\.S|SUBSTITUTE|SUBSTITUTEWITHINDEX|SUM|SUMMARIZE|SUMMARIZECOLUMNS|SUMX|SWITCH|T\.DIST|T\.DIST\.2T|T\.DIST\.RT|T\.INV|T\.INV\.2T|TAN|TANH|TIME|TIMEVALUE|TODAY|TOPN|TOPNPERLEVEL|TOPNSKIP|TOTALMTD|TOTALQTD|TOTALYTD|TREATAS|TRIM|TRUE|TRUNC|UNICHAR|UNICODE|UNION|UPPER|USERELATIONSHIP|USERNAME|USEROBJECTID|USERPRINCIPALNAME|UTCNOW|UTCTODAY|VALUE|VALUES|VAR\.P|VAR\.S|VARX\.P|VARX\.S|WEEKDAY|WEEKNUM|XIRR|XNPV|YEAR|YEARFRAC)(?=\s*\()/i,
          keyword: /\b(?:DEFINE|EVALUATE|MEASURE|ORDER\s+BY|RETURN|VAR|START\s+AT|ASC|DESC)\b/i,
          boolean: {
            pattern: /\b(?:FALSE|NULL|TRUE)\b/i,
            alias: "constant"
          },
          number: /\b\d+(?:\.\d*)?|\B\.\d+\b/,
          operator: /:=|[-+*\/=^]|&&?|\|\||<(?:=>?|<|>)?|>[>=]?|\b(?:IN|NOT)\b/i,
          punctuation: /[;\[\](){}`,.]/
        };
      }
      return dax_1;
    }
    var dhall_1;
    var hasRequiredDhall;
    function requireDhall() {
      if (hasRequiredDhall)
        return dhall_1;
      hasRequiredDhall = 1;
      dhall_1 = dhall;
      dhall.displayName = "dhall";
      dhall.aliases = [];
      function dhall(Prism2) {
        Prism2.languages.dhall = {
          // Multi-line comments can be nested. E.g. {- foo {- bar -} -}
          // The multi-line pattern is essentially this:
          //   \{-(?:[^-{]|-(?!\})|\{(?!-)|<SELF>)*-\}
          comment: /--.*|\{-(?:[^-{]|-(?!\})|\{(?!-)|\{-(?:[^-{]|-(?!\})|\{(?!-))*-\})*-\}/,
          string: {
            pattern: /"(?:[^"\\]|\\.)*"|''(?:[^']|'(?!')|'''|''\$\{)*''(?!'|\$)/,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /\$\{[^{}]*\}/,
                inside: {
                  expression: {
                    pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                    lookbehind: true,
                    alias: "language-dhall",
                    inside: null
                    // see blow
                  },
                  punctuation: /\$\{|\}/
                }
              }
            }
          },
          label: {
            pattern: /`[^`]*`/,
            greedy: true
          },
          url: {
            // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L596
            pattern: /\bhttps?:\/\/[\w.:%!$&'*+;=@~-]+(?:\/[\w.:%!$&'*+;=@~-]*)*(?:\?[/?\w.:%!$&'*+;=@~-]*)?/,
            greedy: true
          },
          env: {
            // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L661
            pattern: /\benv:(?:(?!\d)\w+|"(?:[^"\\=]|\\.)*")/,
            greedy: true,
            inside: {
              function: /^env/,
              operator: /^:/,
              variable: /[\s\S]+/
            }
          },
          hash: {
            // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L725
            pattern: /\bsha256:[\da-fA-F]{64}\b/,
            inside: {
              function: /sha256/,
              operator: /:/,
              number: /[\da-fA-F]{64}/
            }
          },
          // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L359
          keyword: /\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\b|\u2200/,
          builtin: /\b(?:None|Some)\b/,
          boolean: /\b(?:False|True)\b/,
          number: /\bNaN\b|-?\bInfinity\b|[+-]?\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/,
          operator: /\/\\|\/\/\\\\|&&|\|\||===|[!=]=|\/\/|->|\+\+|::|[+*#@=:?<>|\\\u2227\u2a53\u2261\u2afd\u03bb\u2192]/,
          punctuation: /\.\.|[{}\[\](),./]/,
          // we'll just assume that every capital word left is a type name
          "class-name": /\b[A-Z]\w*\b/
        };
        Prism2.languages.dhall.string.inside.interpolation.inside.expression.inside = Prism2.languages.dhall;
      }
      return dhall_1;
    }
    var diff_1;
    var hasRequiredDiff;
    function requireDiff() {
      if (hasRequiredDiff)
        return diff_1;
      hasRequiredDiff = 1;
      diff_1 = diff;
      diff.displayName = "diff";
      diff.aliases = [];
      function diff(Prism2) {
        (function(Prism3) {
          Prism3.languages.diff = {
            coord: [
              // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
              /^(?:\*{3}|-{3}|\+{3}).*$/m,
              // Match "@@ ... @@" coord lines in unified diff.
              /^@@.*@@$/m,
              // Match coord lines in normal diff (starts with a number).
              /^\d.*$/m
            ]
            // deleted, inserted, unchanged, diff
          };
          var PREFIXES = {
            "deleted-sign": "-",
            "deleted-arrow": "<",
            "inserted-sign": "+",
            "inserted-arrow": ">",
            unchanged: " ",
            diff: "!"
          };
          Object.keys(PREFIXES).forEach(function(name2) {
            var prefix = PREFIXES[name2];
            var alias2 = [];
            if (!/^\w+$/.test(name2)) {
              alias2.push(/\w+/.exec(name2)[0]);
            }
            if (name2 === "diff") {
              alias2.push("bold");
            }
            Prism3.languages.diff[name2] = {
              pattern: RegExp(
                "^(?:[" + prefix + "].*(?:\r\n?|\n|(?![\\s\\S])))+",
                "m"
              ),
              alias: alias2,
              inside: {
                line: {
                  pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
                  lookbehind: true
                },
                prefix: {
                  pattern: /[\s\S]/,
                  alias: /\w+/.exec(name2)[0]
                }
              }
            };
          });
          Object.defineProperty(Prism3.languages.diff, "PREFIXES", {
            value: PREFIXES
          });
        })(Prism2);
      }
      return diff_1;
    }
    var markupTemplating_1;
    var hasRequiredMarkupTemplating;
    function requireMarkupTemplating() {
      if (hasRequiredMarkupTemplating)
        return markupTemplating_1;
      hasRequiredMarkupTemplating = 1;
      markupTemplating_1 = markupTemplating;
      markupTemplating.displayName = "markupTemplating";
      markupTemplating.aliases = [];
      function markupTemplating(Prism2) {
        (function(Prism3) {
          function getPlaceholder(language, index2) {
            return "___" + language.toUpperCase() + index2 + "___";
          }
          Object.defineProperties(Prism3.languages["markup-templating"] = {}, {
            buildPlaceholders: {
              /**
               * Tokenize all inline templating expressions matching `placeholderPattern`.
               *
               * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
               * `true` will be replaced.
               *
               * @param {object} env The environment of the `before-tokenize` hook.
               * @param {string} language The language id.
               * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
               * @param {(match: string) => boolean} [replaceFilter]
               */
              value: function(env2, language, placeholderPattern, replaceFilter) {
                if (env2.language !== language) {
                  return;
                }
                var tokenStack = env2.tokenStack = [];
                env2.code = env2.code.replace(placeholderPattern, function(match) {
                  if (typeof replaceFilter === "function" && !replaceFilter(match)) {
                    return match;
                  }
                  var i = tokenStack.length;
                  var placeholder;
                  while (env2.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {
                    ++i;
                  }
                  tokenStack[i] = match;
                  return placeholder;
                });
                env2.grammar = Prism3.languages.markup;
              }
            },
            tokenizePlaceholders: {
              /**
               * Replace placeholders with proper tokens after tokenizing.
               *
               * @param {object} env The environment of the `after-tokenize` hook.
               * @param {string} language The language id.
               */
              value: function(env2, language) {
                if (env2.language !== language || !env2.tokenStack) {
                  return;
                }
                env2.grammar = Prism3.languages[language];
                var j = 0;
                var keys2 = Object.keys(env2.tokenStack);
                function walkTokens(tokens) {
                  for (var i = 0; i < tokens.length; i++) {
                    if (j >= keys2.length) {
                      break;
                    }
                    var token = tokens[i];
                    if (typeof token === "string" || token.content && typeof token.content === "string") {
                      var k2 = keys2[j];
                      var t2 = env2.tokenStack[k2];
                      var s = typeof token === "string" ? token : token.content;
                      var placeholder = getPlaceholder(language, k2);
                      var index2 = s.indexOf(placeholder);
                      if (index2 > -1) {
                        ++j;
                        var before = s.substring(0, index2);
                        var middle = new Prism3.Token(
                          language,
                          Prism3.tokenize(t2, env2.grammar),
                          "language-" + language,
                          t2
                        );
                        var after = s.substring(index2 + placeholder.length);
                        var replacement = [];
                        if (before) {
                          replacement.push.apply(replacement, walkTokens([before]));
                        }
                        replacement.push(middle);
                        if (after) {
                          replacement.push.apply(replacement, walkTokens([after]));
                        }
                        if (typeof token === "string") {
                          tokens.splice.apply(tokens, [i, 1].concat(replacement));
                        } else {
                          token.content = replacement;
                        }
                      }
                    } else if (token.content) {
                      walkTokens(token.content);
                    }
                  }
                  return tokens;
                }
                walkTokens(env2.tokens);
              }
            }
          });
        })(Prism2);
      }
      return markupTemplating_1;
    }
    var django_1;
    var hasRequiredDjango;
    function requireDjango() {
      if (hasRequiredDjango)
        return django_1;
      hasRequiredDjango = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      django_1 = django;
      django.displayName = "django";
      django.aliases = ["jinja2"];
      function django(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        (function(Prism3) {
          Prism3.languages.django = {
            comment: /^\{#[\s\S]*?#\}$/,
            tag: {
              pattern: /(^\{%[+-]?\s*)\w+/,
              lookbehind: true,
              alias: "keyword"
            },
            delimiter: {
              pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/,
              alias: "punctuation"
            },
            string: {
              pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
              greedy: true
            },
            filter: {
              pattern: /(\|)\w+/,
              lookbehind: true,
              alias: "function"
            },
            test: {
              pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
              lookbehind: true,
              alias: "function"
            },
            function: /\b[a-z_]\w+(?=\s*\()/i,
            keyword: /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
            operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
            number: /\b\d+(?:\.\d+)?\b/,
            boolean: /[Ff]alse|[Nn]one|[Tt]rue/,
            variable: /\b\w+\b/,
            punctuation: /[{}[\](),.:;]/
          };
          var pattern = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g;
          var markupTemplating = Prism3.languages["markup-templating"];
          Prism3.hooks.add("before-tokenize", function(env2) {
            markupTemplating.buildPlaceholders(env2, "django", pattern);
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            markupTemplating.tokenizePlaceholders(env2, "django");
          });
          Prism3.languages.jinja2 = Prism3.languages.django;
          Prism3.hooks.add("before-tokenize", function(env2) {
            markupTemplating.buildPlaceholders(env2, "jinja2", pattern);
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            markupTemplating.tokenizePlaceholders(env2, "jinja2");
          });
        })(Prism2);
      }
      return django_1;
    }
    var dnsZoneFile_1;
    var hasRequiredDnsZoneFile;
    function requireDnsZoneFile() {
      if (hasRequiredDnsZoneFile)
        return dnsZoneFile_1;
      hasRequiredDnsZoneFile = 1;
      dnsZoneFile_1 = dnsZoneFile;
      dnsZoneFile.displayName = "dnsZoneFile";
      dnsZoneFile.aliases = [];
      function dnsZoneFile(Prism2) {
        Prism2.languages["dns-zone-file"] = {
          comment: /;.*/,
          string: {
            pattern: /"(?:\\.|[^"\\\r\n])*"/,
            greedy: true
          },
          variable: [
            {
              pattern: /(^\$ORIGIN[ \t]+)\S+/m,
              lookbehind: true
            },
            {
              pattern: /(^|\s)@(?=\s|$)/,
              lookbehind: true
            }
          ],
          keyword: /^\$(?:INCLUDE|ORIGIN|TTL)(?=\s|$)/m,
          class: {
            // https://tools.ietf.org/html/rfc1035#page-13
            pattern: /(^|\s)(?:CH|CS|HS|IN)(?=\s|$)/,
            lookbehind: true,
            alias: "keyword"
          },
          type: {
            // https://en.wikipedia.org/wiki/List_of_DNS_record_types
            pattern: /(^|\s)(?:A|A6|AAAA|AFSDB|APL|ATMA|CAA|CDNSKEY|CDS|CERT|CNAME|DHCID|DLV|DNAME|DNSKEY|DS|EID|GID|GPOS|HINFO|HIP|IPSECKEY|ISDN|KEY|KX|LOC|MAILA|MAILB|MB|MD|MF|MG|MINFO|MR|MX|NAPTR|NB|NBSTAT|NIMLOC|NINFO|NS|NSAP|NSAP-PTR|NSEC|NSEC3|NSEC3PARAM|NULL|NXT|OPENPGPKEY|PTR|PX|RKEY|RP|RRSIG|RT|SIG|SINK|SMIMEA|SOA|SPF|SRV|SSHFP|TA|TKEY|TLSA|TSIG|TXT|UID|UINFO|UNSPEC|URI|WKS|X25)(?=\s|$)/,
            lookbehind: true,
            alias: "keyword"
          },
          punctuation: /[()]/
        };
        Prism2.languages["dns-zone"] = Prism2.languages["dns-zone-file"];
      }
      return dnsZoneFile_1;
    }
    var docker_1;
    var hasRequiredDocker;
    function requireDocker() {
      if (hasRequiredDocker)
        return docker_1;
      hasRequiredDocker = 1;
      docker_1 = docker;
      docker.displayName = "docker";
      docker.aliases = ["dockerfile"];
      function docker(Prism2) {
        (function(Prism3) {
          var spaceAfterBackSlash = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source;
          var space2 = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(
            /<SP_BS>/g,
            function() {
              return spaceAfterBackSlash;
            }
          );
          var string2 = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source;
          var option = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(
            /<STR>/g,
            function() {
              return string2;
            }
          );
          var stringRule = {
            pattern: RegExp(string2),
            greedy: true
          };
          var commentRule = {
            pattern: /(^[ \t]*)#.*/m,
            lookbehind: true,
            greedy: true
          };
          function re2(source, flags) {
            source = source.replace(/<OPT>/g, function() {
              return option;
            }).replace(/<SP>/g, function() {
              return space2;
            });
            return RegExp(source, flags);
          }
          Prism3.languages.docker = {
            instruction: {
              pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
              lookbehind: true,
              greedy: true,
              inside: {
                options: {
                  pattern: re2(
                    /(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source,
                    "i"
                  ),
                  lookbehind: true,
                  greedy: true,
                  inside: {
                    property: {
                      pattern: /(^|\s)--[\w-]+/,
                      lookbehind: true
                    },
                    string: [
                      stringRule,
                      {
                        pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
                        lookbehind: true
                      }
                    ],
                    operator: /\\$/m,
                    punctuation: /=/
                  }
                },
                keyword: [
                  {
                    // https://docs.docker.com/engine/reference/builder/#healthcheck
                    pattern: re2(
                      /(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source,
                      "i"
                    ),
                    lookbehind: true,
                    greedy: true
                  },
                  {
                    // https://docs.docker.com/engine/reference/builder/#from
                    pattern: re2(
                      /(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source,
                      "i"
                    ),
                    lookbehind: true,
                    greedy: true
                  },
                  {
                    // https://docs.docker.com/engine/reference/builder/#onbuild
                    pattern: re2(/(^ONBUILD<SP>)\w+/.source, "i"),
                    lookbehind: true,
                    greedy: true
                  },
                  {
                    pattern: /^\w+/,
                    greedy: true
                  }
                ],
                comment: commentRule,
                string: stringRule,
                variable: /\$(?:\w+|\{[^{}"'\\]*\})/,
                operator: /\\$/m
              }
            },
            comment: commentRule
          };
          Prism3.languages.dockerfile = Prism3.languages.docker;
        })(Prism2);
      }
      return docker_1;
    }
    var dot_1;
    var hasRequiredDot;
    function requireDot() {
      if (hasRequiredDot)
        return dot_1;
      hasRequiredDot = 1;
      dot_1 = dot;
      dot.displayName = "dot";
      dot.aliases = ["gv"];
      function dot(Prism2) {
        (function(Prism3) {
          var ID = "(?:" + [
            // an identifier
            /[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
            // a number
            /-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
            // a double-quoted string
            /"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
            // HTML-like string
            /<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
          ].join("|") + ")";
          var IDInside = {
            markup: {
              pattern: /(^<)[\s\S]+(?=>$)/,
              lookbehind: true,
              alias: ["language-markup", "language-html", "language-xml"],
              inside: Prism3.languages.markup
            }
          };
          function withID(source, flags) {
            return RegExp(
              source.replace(/<ID>/g, function() {
                return ID;
              }),
              flags
            );
          }
          Prism3.languages.dot = {
            comment: {
              pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
              greedy: true
            },
            "graph-name": {
              pattern: withID(
                /(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source,
                "i"
              ),
              lookbehind: true,
              greedy: true,
              alias: "class-name",
              inside: IDInside
            },
            "attr-value": {
              pattern: withID(/(=[ \t\r\n]*)<ID>/.source),
              lookbehind: true,
              greedy: true,
              inside: IDInside
            },
            "attr-name": {
              pattern: withID(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
              lookbehind: true,
              greedy: true,
              inside: IDInside
            },
            keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
            "compass-point": {
              pattern: /(:[ \t\r\n]*)(?:[ewc_]|[ns][ew]?)(?![\w\x80-\uFFFF])/,
              lookbehind: true,
              alias: "builtin"
            },
            node: {
              pattern: withID(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
              lookbehind: true,
              greedy: true,
              inside: IDInside
            },
            operator: /[=:]|-[->]/,
            punctuation: /[\[\]{};,]/
          };
          Prism3.languages.gv = Prism3.languages.dot;
        })(Prism2);
      }
      return dot_1;
    }
    var ebnf_1;
    var hasRequiredEbnf;
    function requireEbnf() {
      if (hasRequiredEbnf)
        return ebnf_1;
      hasRequiredEbnf = 1;
      ebnf_1 = ebnf;
      ebnf.displayName = "ebnf";
      ebnf.aliases = [];
      function ebnf(Prism2) {
        Prism2.languages.ebnf = {
          comment: /\(\*[\s\S]*?\*\)/,
          string: {
            pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
            greedy: true
          },
          special: {
            pattern: /\?[^?\r\n]*\?/,
            greedy: true,
            alias: "class-name"
          },
          definition: {
            pattern: /^([\t ]*)[a-z]\w*(?:[ \t]+[a-z]\w*)*(?=\s*=)/im,
            lookbehind: true,
            alias: ["rule", "keyword"]
          },
          rule: /\b[a-z]\w*(?:[ \t]+[a-z]\w*)*\b/i,
          punctuation: /\([:/]|[:/]\)|[.,;()[\]{}]/,
          operator: /[-=|*/!]/
        };
      }
      return ebnf_1;
    }
    var editorconfig_1;
    var hasRequiredEditorconfig;
    function requireEditorconfig() {
      if (hasRequiredEditorconfig)
        return editorconfig_1;
      hasRequiredEditorconfig = 1;
      editorconfig_1 = editorconfig;
      editorconfig.displayName = "editorconfig";
      editorconfig.aliases = [];
      function editorconfig(Prism2) {
        Prism2.languages.editorconfig = {
          // https://editorconfig-specification.readthedocs.io
          comment: /[;#].*/,
          section: {
            pattern: /(^[ \t]*)\[.+\]/m,
            lookbehind: true,
            alias: "selector",
            inside: {
              regex: /\\\\[\[\]{},!?.*]/,
              // Escape special characters with '\\'
              operator: /[!?]|\.\.|\*{1,2}/,
              punctuation: /[\[\]{},]/
            }
          },
          key: {
            pattern: /(^[ \t]*)[^\s=]+(?=[ \t]*=)/m,
            lookbehind: true,
            alias: "attr-name"
          },
          value: {
            pattern: /=.*/,
            alias: "attr-value",
            inside: {
              punctuation: /^=/
            }
          }
        };
      }
      return editorconfig_1;
    }
    var eiffel_1;
    var hasRequiredEiffel;
    function requireEiffel() {
      if (hasRequiredEiffel)
        return eiffel_1;
      hasRequiredEiffel = 1;
      eiffel_1 = eiffel;
      eiffel.displayName = "eiffel";
      eiffel.aliases = [];
      function eiffel(Prism2) {
        Prism2.languages.eiffel = {
          comment: /--.*/,
          string: [
            // Aligned-verbatim-strings
            {
              pattern: /"([^[]*)\[[\s\S]*?\]\1"/,
              greedy: true
            },
            // Non-aligned-verbatim-strings
            {
              pattern: /"([^{]*)\{[\s\S]*?\}\1"/,
              greedy: true
            },
            // Single-line string
            {
              pattern: /"(?:%(?:(?!\n)\s)*\n\s*%|%\S|[^%"\r\n])*"/,
              greedy: true
            }
          ],
          // normal char | special char | char code
          char: /'(?:%.|[^%'\r\n])+'/,
          keyword: /\b(?:across|agent|alias|all|and|as|assign|attached|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
          boolean: /\b(?:False|True)\b/i,
          // Convention: class-names are always all upper-case characters
          "class-name": /\b[A-Z][\dA-Z_]*\b/,
          number: [
            // hexa | octal | bin
            /\b0[xcb][\da-f](?:_*[\da-f])*\b/i,
            // Decimal
            /(?:\b\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?e[+-]?)?\d(?:_*\d)*\b|\b\d(?:_*\d)*\b\.?/i
          ],
          punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
          operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
        };
      }
      return eiffel_1;
    }
    var ejs_1;
    var hasRequiredEjs;
    function requireEjs() {
      if (hasRequiredEjs)
        return ejs_1;
      hasRequiredEjs = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      ejs_1 = ejs;
      ejs.displayName = "ejs";
      ejs.aliases = ["eta"];
      function ejs(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        (function(Prism3) {
          Prism3.languages.ejs = {
            delimiter: {
              pattern: /^<%[-_=]?|[-_]?%>$/,
              alias: "punctuation"
            },
            comment: /^#[\s\S]*/,
            "language-javascript": {
              pattern: /[\s\S]+/,
              inside: Prism3.languages.javascript
            }
          };
          Prism3.hooks.add("before-tokenize", function(env2) {
            var ejsPattern = /<%(?!%)[\s\S]+?%>/g;
            Prism3.languages["markup-templating"].buildPlaceholders(
              env2,
              "ejs",
              ejsPattern
            );
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            Prism3.languages["markup-templating"].tokenizePlaceholders(env2, "ejs");
          });
          Prism3.languages.eta = Prism3.languages.ejs;
        })(Prism2);
      }
      return ejs_1;
    }
    var elixir_1;
    var hasRequiredElixir;
    function requireElixir() {
      if (hasRequiredElixir)
        return elixir_1;
      hasRequiredElixir = 1;
      elixir_1 = elixir;
      elixir.displayName = "elixir";
      elixir.aliases = [];
      function elixir(Prism2) {
        Prism2.languages.elixir = {
          doc: {
            pattern: /@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
            inside: {
              attribute: /^@\w+/,
              string: /['"][\s\S]+/
            }
          },
          comment: {
            pattern: /#.*/,
            greedy: true
          },
          // ~r"""foo""" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r"foo", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>
          regex: {
            pattern: /~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
            greedy: true
          },
          string: [
            {
              // ~s"""foo""" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s"foo", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>
              pattern: /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
              greedy: true,
              inside: {
                // See interpolation below
              }
            },
            {
              pattern: /("""|''')[\s\S]*?\1/,
              greedy: true,
              inside: {
                // See interpolation below
              }
            },
            {
              // Multi-line strings are allowed
              pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
              greedy: true,
              inside: {
                // See interpolation below
              }
            }
          ],
          atom: {
            // Look-behind prevents bad highlighting of the :: operator
            pattern: /(^|[^:]):\w+/,
            lookbehind: true,
            alias: "symbol"
          },
          module: {
            pattern: /\b[A-Z]\w*\b/,
            alias: "class-name"
          },
          // Look-ahead prevents bad highlighting of the :: operator
          "attr-name": /\b\w+\??:(?!:)/,
          argument: {
            // Look-behind prevents bad highlighting of the && operator
            pattern: /(^|[^&])&\d+/,
            lookbehind: true,
            alias: "variable"
          },
          attribute: {
            pattern: /@\w+/,
            alias: "variable"
          },
          function: /\b[_a-zA-Z]\w*[?!]?(?:(?=\s*(?:\.\s*)?\()|(?=\/\d))/,
          number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
          keyword: /\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\b/,
          boolean: /\b(?:false|nil|true)\b/,
          operator: [
            /\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,
            {
              // We don't want to match <<
              pattern: /([^<])<(?!<)/,
              lookbehind: true
            },
            {
              // We don't want to match >>
              pattern: /([^>])>(?!>)/,
              lookbehind: true
            }
          ],
          punctuation: /<<|>>|[.,%\[\]{}()]/
        };
        Prism2.languages.elixir.string.forEach(function(o) {
          o.inside = {
            interpolation: {
              pattern: /#\{[^}]+\}/,
              inside: {
                delimiter: {
                  pattern: /^#\{|\}$/,
                  alias: "punctuation"
                },
                rest: Prism2.languages.elixir
              }
            }
          };
        });
      }
      return elixir_1;
    }
    var elm_1;
    var hasRequiredElm;
    function requireElm() {
      if (hasRequiredElm)
        return elm_1;
      hasRequiredElm = 1;
      elm_1 = elm;
      elm.displayName = "elm";
      elm.aliases = [];
      function elm(Prism2) {
        Prism2.languages.elm = {
          comment: /--.*|\{-[\s\S]*?-\}/,
          char: {
            pattern: /'(?:[^\\'\r\n]|\\(?:[abfnrtv\\']|\d+|x[0-9a-fA-F]+|u\{[0-9a-fA-F]+\}))'/,
            greedy: true
          },
          string: [
            {
              // Multiline strings are wrapped in triple ". Quotes may appear unescaped.
              pattern: /"""[\s\S]*?"""/,
              greedy: true
            },
            {
              pattern: /"(?:[^\\"\r\n]|\\.)*"/,
              greedy: true
            }
          ],
          "import-statement": {
            // The imported or hidden names are not included in this import
            // statement. This is because we want to highlight those exactly like
            // we do for the names in the program.
            pattern: /(^[\t ]*)import\s+[A-Z]\w*(?:\.[A-Z]\w*)*(?:\s+as\s+(?:[A-Z]\w*)(?:\.[A-Z]\w*)*)?(?:\s+exposing\s+)?/m,
            lookbehind: true,
            inside: {
              keyword: /\b(?:as|exposing|import)\b/
            }
          },
          keyword: /\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\b/,
          // These are builtin variables only. Constructors are highlighted later as a constant.
          builtin: /\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\b/,
          // decimal integers and floating point numbers | hexadecimal integers
          number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[0-9a-f]+)\b/i,
          // Most of this is needed because of the meaning of a single '.'.
          // If it stands alone freely, it is the function composition.
          // It may also be a separator between a module name and an identifier => no
          // operator. If it comes together with other special characters it is an
          // operator too.
          // Valid operator characters in 0.18: +-/*=.$<>:&|^?%#@~!
          // Ref: https://groups.google.com/forum/#!msg/elm-dev/0AHSnDdkSkQ/E0SVU70JEQAJ
          operator: /\s\.\s|[+\-/*=.$<>:&|^?%#@~!]{2,}|[+\-/*=$<>:&|^?%#@~!]/,
          // In Elm, nearly everything is a variable, do not highlight these.
          hvariable: /\b(?:[A-Z]\w*\.)*[a-z]\w*\b/,
          constant: /\b(?:[A-Z]\w*\.)*[A-Z]\w*\b/,
          punctuation: /[{}[\]|(),.:]/
        };
      }
      return elm_1;
    }
    var erb_1;
    var hasRequiredErb;
    function requireErb() {
      if (hasRequiredErb)
        return erb_1;
      hasRequiredErb = 1;
      var refractorRuby = requireRuby();
      var refractorMarkupTemplating = requireMarkupTemplating();
      erb_1 = erb;
      erb.displayName = "erb";
      erb.aliases = [];
      function erb(Prism2) {
        Prism2.register(refractorRuby);
        Prism2.register(refractorMarkupTemplating);
        (function(Prism3) {
          Prism3.languages.erb = {
            delimiter: {
              pattern: /^(\s*)<%=?|%>(?=\s*$)/,
              lookbehind: true,
              alias: "punctuation"
            },
            ruby: {
              pattern: /\s*\S[\s\S]*/,
              alias: "language-ruby",
              inside: Prism3.languages.ruby
            }
          };
          Prism3.hooks.add("before-tokenize", function(env2) {
            var erbPattern = /<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g;
            Prism3.languages["markup-templating"].buildPlaceholders(
              env2,
              "erb",
              erbPattern
            );
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            Prism3.languages["markup-templating"].tokenizePlaceholders(env2, "erb");
          });
        })(Prism2);
      }
      return erb_1;
    }
    var erlang_1;
    var hasRequiredErlang;
    function requireErlang() {
      if (hasRequiredErlang)
        return erlang_1;
      hasRequiredErlang = 1;
      erlang_1 = erlang;
      erlang.displayName = "erlang";
      erlang.aliases = [];
      function erlang(Prism2) {
        Prism2.languages.erlang = {
          comment: /%.+/,
          string: {
            pattern: /"(?:\\.|[^\\"\r\n])*"/,
            greedy: true
          },
          "quoted-function": {
            pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
            alias: "function"
          },
          "quoted-atom": {
            pattern: /'(?:\\.|[^\\'\r\n])+'/,
            alias: "atom"
          },
          boolean: /\b(?:false|true)\b/,
          keyword: /\b(?:after|case|catch|end|fun|if|of|receive|try|when)\b/,
          number: [
            /\$\\?./,
            /\b\d+#[a-z0-9]+/i,
            /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i
          ],
          function: /\b[a-z][\w@]*(?=\()/,
          variable: {
            // Look-behind is used to prevent wrong highlighting of atoms containing "@"
            pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
            lookbehind: true
          },
          operator: [
            /[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/,
            {
              // We don't want to match <<
              pattern: /(^|[^<])<(?!<)/,
              lookbehind: true
            },
            {
              // We don't want to match >>
              pattern: /(^|[^>])>(?!>)/,
              lookbehind: true
            }
          ],
          atom: /\b[a-z][\w@]*/,
          punctuation: /[()[\]{}:;,.#|]|<<|>>/
        };
      }
      return erlang_1;
    }
    var lua_1;
    var hasRequiredLua;
    function requireLua() {
      if (hasRequiredLua)
        return lua_1;
      hasRequiredLua = 1;
      lua_1 = lua;
      lua.displayName = "lua";
      lua.aliases = [];
      function lua(Prism2) {
        Prism2.languages.lua = {
          comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
          // \z may be used to skip the following space
          string: {
            pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
            greedy: true
          },
          number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
          keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
          function: /(?!\d)\w+(?=\s*(?:[({]))/,
          operator: [
            /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
            {
              // Match ".." but don't break "..."
              pattern: /(^|[^.])\.\.(?!\.)/,
              lookbehind: true
            }
          ],
          punctuation: /[\[\](){},;]|\.+|:+/
        };
      }
      return lua_1;
    }
    var etlua_1;
    var hasRequiredEtlua;
    function requireEtlua() {
      if (hasRequiredEtlua)
        return etlua_1;
      hasRequiredEtlua = 1;
      var refractorLua = requireLua();
      var refractorMarkupTemplating = requireMarkupTemplating();
      etlua_1 = etlua;
      etlua.displayName = "etlua";
      etlua.aliases = [];
      function etlua(Prism2) {
        Prism2.register(refractorLua);
        Prism2.register(refractorMarkupTemplating);
        (function(Prism3) {
          Prism3.languages.etlua = {
            delimiter: {
              pattern: /^<%[-=]?|-?%>$/,
              alias: "punctuation"
            },
            "language-lua": {
              pattern: /[\s\S]+/,
              inside: Prism3.languages.lua
            }
          };
          Prism3.hooks.add("before-tokenize", function(env2) {
            var pattern = /<%[\s\S]+?%>/g;
            Prism3.languages["markup-templating"].buildPlaceholders(
              env2,
              "etlua",
              pattern
            );
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            Prism3.languages["markup-templating"].tokenizePlaceholders(env2, "etlua");
          });
        })(Prism2);
      }
      return etlua_1;
    }
    var excelFormula_1;
    var hasRequiredExcelFormula;
    function requireExcelFormula() {
      if (hasRequiredExcelFormula)
        return excelFormula_1;
      hasRequiredExcelFormula = 1;
      excelFormula_1 = excelFormula;
      excelFormula.displayName = "excelFormula";
      excelFormula.aliases = [];
      function excelFormula(Prism2) {
        Prism2.languages["excel-formula"] = {
          comment: {
            pattern: /(\bN\(\s*)"(?:[^"]|"")*"(?=\s*\))/i,
            lookbehind: true,
            greedy: true
          },
          string: {
            pattern: /"(?:[^"]|"")*"(?!")/,
            greedy: true
          },
          reference: {
            // https://www.ablebits.com/office-addins-blog/2015/12/08/excel-reference-another-sheet-workbook/
            // Sales!B2
            // 'Winter sales'!B2
            // [Sales.xlsx]Jan!B2:B5
            // D:\Reports\[Sales.xlsx]Jan!B2:B5
            // '[Sales.xlsx]Jan sales'!B2:B5
            // 'D:\Reports\[Sales.xlsx]Jan sales'!B2:B5
            pattern: /(?:'[^']*'|(?:[^\s()[\]{}<>*?"';,$&]*\[[^^\s()[\]{}<>*?"']+\])?\w+)!/,
            greedy: true,
            alias: "string",
            inside: {
              operator: /!$/,
              punctuation: /'/,
              sheet: {
                pattern: /[^[\]]+$/,
                alias: "function"
              },
              file: {
                pattern: /\[[^[\]]+\]$/,
                inside: {
                  punctuation: /[[\]]/
                }
              },
              path: /[\s\S]+/
            }
          },
          "function-name": {
            pattern: /\b[A-Z]\w*(?=\()/i,
            alias: "keyword"
          },
          range: {
            pattern: /\$?\b(?:[A-Z]+\$?\d+:\$?[A-Z]+\$?\d+|[A-Z]+:\$?[A-Z]+|\d+:\$?\d+)\b/i,
            alias: "property",
            inside: {
              operator: /:/,
              cell: /\$?[A-Z]+\$?\d+/i,
              column: /\$?[A-Z]+/i,
              row: /\$?\d+/
            }
          },
          cell: {
            // Excel is case insensitive, so the string "foo1" could be either a variable or a cell.
            // To combat this, we match cells case insensitive, if the contain at least one "$", and case sensitive otherwise.
            pattern: /\b[A-Z]+\d+\b|\$[A-Za-z]+\$?\d+\b|\b[A-Za-z]+\$\d+\b/,
            alias: "property"
          },
          number: /(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?\b/i,
          boolean: /\b(?:FALSE|TRUE)\b/i,
          operator: /[-+*/^%=&,]|<[=>]?|>=?/,
          punctuation: /[[\]();{}|]/
        };
        Prism2.languages["xlsx"] = Prism2.languages["xls"] = Prism2.languages["excel-formula"];
      }
      return excelFormula_1;
    }
    var factor_1;
    var hasRequiredFactor;
    function requireFactor() {
      if (hasRequiredFactor)
        return factor_1;
      hasRequiredFactor = 1;
      factor_1 = factor;
      factor.displayName = "factor";
      factor.aliases = [];
      function factor(Prism2) {
        (function(Prism3) {
          var comment_inside = {
            function: /\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\?{2,}|!{2,})\b/
          };
          var string_inside = {
            number: /\\[^\s']|%\w/
          };
          var factor2 = {
            comment: [
              {
                // ! single-line exclamation point comments with whitespace after/around the !
                pattern: /(^|\s)(?:! .*|!$)/,
                lookbehind: true,
                inside: comment_inside
              },
              /* from basis/multiline: */
              {
                // /* comment */, /* comment*/
                pattern: /(^|\s)\/\*\s[\s\S]*?\*\/(?=\s|$)/,
                lookbehind: true,
                greedy: true,
                inside: comment_inside
              },
              {
                // ![[ comment ]] , ![===[ comment]===]
                pattern: /(^|\s)!\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
                lookbehind: true,
                greedy: true,
                inside: comment_inside
              }
            ],
            number: [
              {
                // basic base 10 integers 9, -9
                pattern: /(^|\s)[+-]?\d+(?=\s|$)/,
                lookbehind: true
              },
              {
                // base prefix integers 0b010 0o70 0xad 0d10 0XAD -0xa9
                pattern: /(^|\s)[+-]?0(?:b[01]+|o[0-7]+|d\d+|x[\dA-F]+)(?=\s|$)/i,
                lookbehind: true
              },
              {
                // fractional ratios 1/5 -1/5 and the literal float approximations 1/5. -1/5.
                pattern: /(^|\s)[+-]?\d+\/\d+\.?(?=\s|$)/,
                lookbehind: true
              },
              {
                // positive mixed numbers 23+1/5 +23+1/5
                pattern: /(^|\s)\+?\d+\+\d+\/\d+(?=\s|$)/,
                lookbehind: true
              },
              {
                // negative mixed numbers -23-1/5
                pattern: /(^|\s)-\d+-\d+\/\d+(?=\s|$)/,
                lookbehind: true
              },
              {
                // basic decimal floats -0.01 0. .0 .1 -.1 -1. -12.13 +12.13
                // and scientific notation with base 10 exponents 3e4 3e-4 .3e-4
                pattern: /(^|\s)[+-]?(?:\d*\.\d+|\d+\.\d*|\d+)(?:e[+-]?\d+)?(?=\s|$)/i,
                lookbehind: true
              },
              {
                // NAN literal syntax NAN: 80000deadbeef, NAN: a
                pattern: /(^|\s)NAN:\s+[\da-fA-F]+(?=\s|$)/,
                lookbehind: true
              },
              {
                /*
                base prefix floats 0x1.0p3 (8.0) 0b1.010p2 (5.0) 0x1.p1 0b1.11111111p11111...
                "The normalized hex form ±0x1.MMMMMMMMMMMMM[pP]±EEEE allows any floating-point number to be specified precisely.
                The values of MMMMMMMMMMMMM and EEEE map directly to the mantissa and exponent fields of the binary IEEE 754 representation."
                <https://docs.factorcode.org/content/article-syntax-floats.html>
                */
                pattern: /(^|\s)[+-]?0(?:b1\.[01]*|o1\.[0-7]*|d1\.\d*|x1\.[\dA-F]*)p\d+(?=\s|$)/i,
                lookbehind: true
              }
            ],
            // R/ regexp?\/\\/
            regexp: {
              pattern: /(^|\s)R\/\s(?:\\\S|[^\\/])*\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\s|$)/,
              lookbehind: true,
              alias: "number",
              inside: {
                variable: /\\\S/,
                keyword: /[+?*\[\]^$(){}.|]/,
                operator: {
                  pattern: /(\/)[idmsr]+(?:-[idmsr]+)?/,
                  lookbehind: true
                }
              }
            },
            boolean: {
              pattern: /(^|\s)[tf](?=\s|$)/,
              lookbehind: true
            },
            // SBUF" asd", URL" ://...", P" /etc/"
            "custom-string": {
              pattern: /(^|\s)[A-Z0-9\-]+"\s(?:\\\S|[^"\\])*"/,
              lookbehind: true,
              greedy: true,
              alias: "string",
              inside: {
                number: /\\\S|%\w|\//
              }
            },
            "multiline-string": [
              {
                // STRING: name \n content \n ; -> CONSTANT: name "content" (symbol)
                pattern: /(^|\s)STRING:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*;(?=\s|$)/,
                lookbehind: true,
                greedy: true,
                alias: "string",
                inside: {
                  number: string_inside.number,
                  // trailing semicolon on its own line
                  "semicolon-or-setlocal": {
                    pattern: /([\r\n][ \t]*);(?=\s|$)/,
                    lookbehind: true,
                    alias: "function"
                  }
                }
              },
              {
                // HEREDOC: marker \n content \n marker ; -> "content" (immediate)
                pattern: /(^|\s)HEREDOC:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*\S+(?=\s|$)/,
                lookbehind: true,
                greedy: true,
                alias: "string",
                inside: string_inside
              },
              {
                // [[ string ]], [==[ string]==]
                pattern: /(^|\s)\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
                lookbehind: true,
                greedy: true,
                alias: "string",
                inside: string_inside
              }
            ],
            "special-using": {
              pattern: /(^|\s)USING:(?:\s\S+)*(?=\s+;(?:\s|$))/,
              lookbehind: true,
              alias: "function",
              inside: {
                // this is essentially a regex for vocab names, which i don't want to specify
                // but the USING: gets picked up as a vocab name
                string: {
                  pattern: /(\s)[^:\s]+/,
                  lookbehind: true
                }
              }
            },
            /* this description of stack effect literal syntax is not complete and not as specific as theoretically possible
            trying to do better is more work and regex-computation-time than it's worth though.
            - we'd like to have the "delimiter" parts of the stack effect [ (, --, and ) ] be a different (less-important or comment-like) colour to the stack effect contents
            - we'd like if nested stack effects were treated as such rather than just appearing flat (with `inside`)
            - we'd like if the following variable name conventions were recognised specifically:
            special row variables = ..a b..
            type and stack effect annotations end with a colon = ( quot: ( a: ( -- ) -- b ) -- x ), ( x: number -- )
            word throws unconditional error = *
            any other word-like variable name = a ? q' etc
            https://docs.factorcode.org/content/article-effects.html
            these are pretty complicated to highlight properly without a real parser, and therefore out of scope
            the old pattern, which may be later useful, was: (^|\s)(?:call|execute|eval)?\((?:\s+[^"\r\n\t ]\S*)*?\s+--(?:\s+[^"\n\t ]\S*)*?\s+\)(?=\s|$)
            */
            // current solution is not great
            "stack-effect-delimiter": [
              {
                // opening parenthesis
                pattern: /(^|\s)(?:call|eval|execute)?\((?=\s)/,
                lookbehind: true,
                alias: "operator"
              },
              {
                // middle --
                pattern: /(\s)--(?=\s)/,
                lookbehind: true,
                alias: "operator"
              },
              {
                // closing parenthesis
                pattern: /(\s)\)(?=\s|$)/,
                lookbehind: true,
                alias: "operator"
              }
            ],
            combinators: {
              pattern: null,
              lookbehind: true,
              alias: "keyword"
            },
            "kernel-builtin": {
              pattern: null,
              lookbehind: true,
              alias: "variable"
            },
            "sequences-builtin": {
              pattern: null,
              lookbehind: true,
              alias: "variable"
            },
            "math-builtin": {
              pattern: null,
              lookbehind: true,
              alias: "variable"
            },
            "constructor-word": {
              // <array> but not <=>
              pattern: /(^|\s)<(?!=+>|-+>)\S+>(?=\s|$)/,
              lookbehind: true,
              alias: "keyword"
            },
            "other-builtin-syntax": {
              pattern: null,
              lookbehind: true,
              alias: "operator"
            },
            /*
            full list of supported word naming conventions: (the convention appears outside of the [brackets])
            set-[x]
            change-[x]
            with-[x]
            new-[x]
            >[string]
            [base]>
            [string]>[number]
            +[symbol]+
            [boolean-word]?
            ?[of]
            [slot-reader]>>
            >>[slot-setter]
            [slot-writer]<<
            ([implementation-detail])
            [mutater]!
            [variant]*
            [prettyprint].
            $[help-markup]
            <constructors>, SYNTAX:, etc are supported by their own patterns.
            `with` and `new` from `kernel` are their own builtins.
            see <https://docs.factorcode.org/content/article-conventions.html>
            */
            "conventionally-named-word": {
              pattern: /(^|\s)(?!")(?:(?:change|new|set|with)-\S+|\$\S+|>[^>\s]+|[^:>\s]+>|[^>\s]+>[^>\s]+|\+[^+\s]+\+|[^?\s]+\?|\?[^?\s]+|[^>\s]+>>|>>[^>\s]+|[^<\s]+<<|\([^()\s]+\)|[^!\s]+!|[^*\s]\S*\*|[^.\s]\S*\.)(?=\s|$)/,
              lookbehind: true,
              alias: "keyword"
            },
            "colon-syntax": {
              pattern: /(^|\s)(?:[A-Z0-9\-]+#?)?:{1,2}\s+(?:;\S+|(?!;)\S+)(?=\s|$)/,
              lookbehind: true,
              greedy: true,
              alias: "function"
            },
            "semicolon-or-setlocal": {
              pattern: /(\s)(?:;|:>)(?=\s|$)/,
              lookbehind: true,
              alias: "function"
            },
            // do not highlight leading } or trailing X{ at the begin/end of the file as it's invalid syntax
            "curly-brace-literal-delimiter": [
              {
                // opening
                pattern: /(^|\s)[a-z]*\{(?=\s)/i,
                lookbehind: true,
                alias: "operator"
              },
              {
                // closing
                pattern: /(\s)\}(?=\s|$)/,
                lookbehind: true,
                alias: "operator"
              }
            ],
            // do not highlight leading ] or trailing [ at the begin/end of the file as it's invalid syntax
            "quotation-delimiter": [
              {
                // opening
                pattern: /(^|\s)\[(?=\s)/,
                lookbehind: true,
                alias: "operator"
              },
              {
                // closing
                pattern: /(\s)\](?=\s|$)/,
                lookbehind: true,
                alias: "operator"
              }
            ],
            "normal-word": {
              pattern: /(^|\s)[^"\s]\S*(?=\s|$)/,
              lookbehind: true
            },
            /*
            basic first-class string "a"
            with escaped double-quote "a\""
            escaped backslash "\\"
            and general escapes since Factor has so many "\N"
            syntax that works in the reference implementation that isn't fully
            supported because it's an implementation detail:
            "string 1""string 2" -> 2 strings (works anyway)
            "string"5 -> string, 5
            "string"[ ] -> string, quotation
            { "a"} -> array<string>
            the rest of those examples all properly recognise the string, but not
            the other object (number, quotation, etc)
            this is fine for a regex-only implementation.
            */
            string: {
              pattern: /"(?:\\\S|[^"\\])*"/,
              greedy: true,
              inside: string_inside
            }
          };
          var escape2 = function(str) {
            return (str + "").replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
          };
          var arrToWordsRegExp = function(arr) {
            return new RegExp("(^|\\s)(?:" + arr.map(escape2).join("|") + ")(?=\\s|$)");
          };
          var builtins = {
            "kernel-builtin": [
              "or",
              "2nipd",
              "4drop",
              "tuck",
              "wrapper",
              "nip",
              "wrapper?",
              "callstack>array",
              "die",
              "dupd",
              "callstack",
              "callstack?",
              "3dup",
              "hashcode",
              "pick",
              "4nip",
              "build",
              ">boolean",
              "nipd",
              "clone",
              "5nip",
              "eq?",
              "?",
              "=",
              "swapd",
              "2over",
              "clear",
              "2dup",
              "get-retainstack",
              "not",
              "tuple?",
              "dup",
              "3nipd",
              "call",
              "-rotd",
              "object",
              "drop",
              "assert=",
              "assert?",
              "-rot",
              "execute",
              "boa",
              "get-callstack",
              "curried?",
              "3drop",
              "pickd",
              "overd",
              "over",
              "roll",
              "3nip",
              "swap",
              "and",
              "2nip",
              "rotd",
              "throw",
              "(clone)",
              "hashcode*",
              "spin",
              "reach",
              "4dup",
              "equal?",
              "get-datastack",
              "assert",
              "2drop",
              "<wrapper>",
              "boolean?",
              "identity-hashcode",
              "identity-tuple?",
              "null",
              "composed?",
              "new",
              "5drop",
              "rot",
              "-roll",
              "xor",
              "identity-tuple",
              "boolean"
            ],
            "other-builtin-syntax": [
              // syntax
              "=======",
              "recursive",
              "flushable",
              ">>",
              "<<<<<<",
              "M\\",
              "B",
              "PRIVATE>",
              "\\",
              "======",
              "final",
              "inline",
              "delimiter",
              "deprecated",
              "<PRIVATE",
              ">>>>>>",
              "<<<<<<<",
              "parse-complex",
              "malformed-complex",
              "read-only",
              ">>>>>>>",
              "call-next-method",
              "<<",
              "foldable",
              // literals
              "$",
              "$[",
              "${"
            ],
            "sequences-builtin": [
              "member-eq?",
              "mismatch",
              "append",
              "assert-sequence=",
              "longer",
              "repetition",
              "clone-like",
              "3sequence",
              "assert-sequence?",
              "last-index-from",
              "reversed",
              "index-from",
              "cut*",
              "pad-tail",
              "join-as",
              "remove-eq!",
              "concat-as",
              "but-last",
              "snip",
              "nths",
              "nth",
              "sequence",
              "longest",
              "slice?",
              "<slice>",
              "remove-nth",
              "tail-slice",
              "empty?",
              "tail*",
              "member?",
              "virtual-sequence?",
              "set-length",
              "drop-prefix",
              "iota",
              "unclip",
              "bounds-error?",
              "unclip-last-slice",
              "non-negative-integer-expected",
              "non-negative-integer-expected?",
              "midpoint@",
              "longer?",
              "?set-nth",
              "?first",
              "rest-slice",
              "prepend-as",
              "prepend",
              "fourth",
              "sift",
              "subseq-start",
              "new-sequence",
              "?last",
              "like",
              "first4",
              "1sequence",
              "reverse",
              "slice",
              "virtual@",
              "repetition?",
              "set-last",
              "index",
              "4sequence",
              "max-length",
              "set-second",
              "immutable-sequence",
              "first2",
              "first3",
              "supremum",
              "unclip-slice",
              "suffix!",
              "insert-nth",
              "tail",
              "3append",
              "short",
              "suffix",
              "concat",
              "flip",
              "immutable?",
              "reverse!",
              "2sequence",
              "sum",
              "delete-all",
              "indices",
              "snip-slice",
              "<iota>",
              "check-slice",
              "sequence?",
              "head",
              "append-as",
              "halves",
              "sequence=",
              "collapse-slice",
              "?second",
              "slice-error?",
              "product",
              "bounds-check?",
              "bounds-check",
              "immutable",
              "virtual-exemplar",
              "harvest",
              "remove",
              "pad-head",
              "last",
              "set-fourth",
              "cartesian-product",
              "remove-eq",
              "shorten",
              "shorter",
              "reversed?",
              "shorter?",
              "shortest",
              "head-slice",
              "pop*",
              "tail-slice*",
              "but-last-slice",
              "iota?",
              "append!",
              "cut-slice",
              "new-resizable",
              "head-slice*",
              "sequence-hashcode",
              "pop",
              "set-nth",
              "?nth",
              "second",
              "join",
              "immutable-sequence?",
              "<reversed>",
              "3append-as",
              "virtual-sequence",
              "subseq?",
              "remove-nth!",
              "length",
              "last-index",
              "lengthen",
              "assert-sequence",
              "copy",
              "move",
              "third",
              "first",
              "tail?",
              "set-first",
              "prefix",
              "bounds-error",
              "<repetition>",
              "exchange",
              "surround",
              "cut",
              "min-length",
              "set-third",
              "push-all",
              "head?",
              "subseq-start-from",
              "delete-slice",
              "rest",
              "sum-lengths",
              "head*",
              "infimum",
              "remove!",
              "glue",
              "slice-error",
              "subseq",
              "push",
              "replace-slice",
              "subseq-as",
              "unclip-last"
            ],
            "math-builtin": [
              "number=",
              "next-power-of-2",
              "?1+",
              "fp-special?",
              "imaginary-part",
              "float>bits",
              "number?",
              "fp-infinity?",
              "bignum?",
              "fp-snan?",
              "denominator",
              "gcd",
              "*",
              "+",
              "fp-bitwise=",
              "-",
              "u>=",
              "/",
              ">=",
              "bitand",
              "power-of-2?",
              "log2-expects-positive",
              "neg?",
              "<",
              "log2",
              ">",
              "integer?",
              "number",
              "bits>double",
              "2/",
              "zero?",
              "bits>float",
              "float?",
              "shift",
              "ratio?",
              "rect>",
              "even?",
              "ratio",
              "fp-sign",
              "bitnot",
              ">fixnum",
              "complex?",
              "/i",
              "integer>fixnum",
              "/f",
              "sgn",
              ">bignum",
              "next-float",
              "u<",
              "u>",
              "mod",
              "recip",
              "rational",
              ">float",
              "2^",
              "integer",
              "fixnum?",
              "neg",
              "fixnum",
              "sq",
              "bignum",
              ">rect",
              "bit?",
              "fp-qnan?",
              "simple-gcd",
              "complex",
              "<fp-nan>",
              "real",
              ">fraction",
              "double>bits",
              "bitor",
              "rem",
              "fp-nan-payload",
              "real-part",
              "log2-expects-positive?",
              "prev-float",
              "align",
              "unordered?",
              "float",
              "fp-nan?",
              "abs",
              "bitxor",
              "integer>fixnum-strict",
              "u<=",
              "odd?",
              "<=",
              "/mod",
              ">integer",
              "real?",
              "rational?",
              "numerator"
            ]
            // that's all for now
          };
          Object.keys(builtins).forEach(function(k2) {
            factor2[k2].pattern = arrToWordsRegExp(builtins[k2]);
          });
          var combinators = [
            // kernel
            "2bi",
            "while",
            "2tri",
            "bi*",
            "4dip",
            "both?",
            "same?",
            "tri@",
            "curry",
            "prepose",
            "3bi",
            "?if",
            "tri*",
            "2keep",
            "3keep",
            "curried",
            "2keepd",
            "when",
            "2bi*",
            "2tri*",
            "4keep",
            "bi@",
            "keepdd",
            "do",
            "unless*",
            "tri-curry",
            "if*",
            "loop",
            "bi-curry*",
            "when*",
            "2bi@",
            "2tri@",
            "with",
            "2with",
            "either?",
            "bi",
            "until",
            "3dip",
            "3curry",
            "tri-curry*",
            "tri-curry@",
            "bi-curry",
            "keepd",
            "compose",
            "2dip",
            "if",
            "3tri",
            "unless",
            "tuple",
            "keep",
            "2curry",
            "tri",
            "most",
            "while*",
            "dip",
            "composed",
            "bi-curry@",
            // sequences
            "find-last-from",
            "trim-head-slice",
            "map-as",
            "each-from",
            "none?",
            "trim-tail",
            "partition",
            "if-empty",
            "accumulate*",
            "reject!",
            "find-from",
            "accumulate-as",
            "collector-for-as",
            "reject",
            "map",
            "map-sum",
            "accumulate!",
            "2each-from",
            "follow",
            "supremum-by",
            "map!",
            "unless-empty",
            "collector",
            "padding",
            "reduce-index",
            "replicate-as",
            "infimum-by",
            "trim-tail-slice",
            "count",
            "find-index",
            "filter",
            "accumulate*!",
            "reject-as",
            "map-integers",
            "map-find",
            "reduce",
            "selector",
            "interleave",
            "2map",
            "filter-as",
            "binary-reduce",
            "map-index-as",
            "find",
            "produce",
            "filter!",
            "replicate",
            "cartesian-map",
            "cartesian-each",
            "find-index-from",
            "map-find-last",
            "3map-as",
            "3map",
            "find-last",
            "selector-as",
            "2map-as",
            "2map-reduce",
            "accumulate",
            "each",
            "each-index",
            "accumulate*-as",
            "when-empty",
            "all?",
            "collector-as",
            "push-either",
            "new-like",
            "collector-for",
            "2selector",
            "push-if",
            "2all?",
            "map-reduce",
            "3each",
            "any?",
            "trim-slice",
            "2reduce",
            "change-nth",
            "produce-as",
            "2each",
            "trim",
            "trim-head",
            "cartesian-find",
            "map-index",
            // math
            "if-zero",
            "each-integer",
            "unless-zero",
            "(find-integer)",
            "when-zero",
            "find-last-integer",
            "(all-integers?)",
            "times",
            "(each-integer)",
            "find-integer",
            "all-integers?",
            // math.combinators
            "unless-negative",
            "if-positive",
            "when-positive",
            "when-negative",
            "unless-positive",
            "if-negative",
            // combinators
            "case",
            "2cleave",
            "cond>quot",
            "case>quot",
            "3cleave",
            "wrong-values",
            "to-fixed-point",
            "alist>quot",
            "cond",
            "cleave",
            "call-effect",
            "recursive-hashcode",
            "spread",
            "deep-spread>quot",
            // combinators.short-circuit
            "2||",
            "0||",
            "n||",
            "0&&",
            "2&&",
            "3||",
            "1||",
            "1&&",
            "n&&",
            "3&&",
            // combinators.smart
            "smart-unless*",
            "keep-inputs",
            "reduce-outputs",
            "smart-when*",
            "cleave>array",
            "smart-with",
            "smart-apply",
            "smart-if",
            "inputs/outputs",
            "output>sequence-n",
            "map-outputs",
            "map-reduce-outputs",
            "dropping",
            "output>array",
            "smart-map-reduce",
            "smart-2map-reduce",
            "output>array-n",
            "nullary",
            "input<sequence",
            "append-outputs",
            "drop-inputs",
            "inputs",
            "smart-2reduce",
            "drop-outputs",
            "smart-reduce",
            "preserving",
            "smart-when",
            "outputs",
            "append-outputs-as",
            "smart-unless",
            "smart-if*",
            "sum-outputs",
            "input<sequence-unsafe",
            "output>sequence"
            // tafn
          ];
          factor2.combinators.pattern = arrToWordsRegExp(combinators);
          Prism3.languages.factor = factor2;
        })(Prism2);
      }
      return factor_1;
    }
    var _false;
    var hasRequired_false;
    function require_false() {
      if (hasRequired_false)
        return _false;
      hasRequired_false = 1;
      _false = $false;
      $false.displayName = "$false";
      $false.aliases = [];
      function $false(Prism2) {
        (function(Prism3) {
          Prism3.languages["false"] = {
            comment: {
              pattern: /\{[^}]*\}/
            },
            string: {
              pattern: /"[^"]*"/,
              greedy: true
            },
            "character-code": {
              pattern: /'(?:[^\r]|\r\n?)/,
              alias: "number"
            },
            "assembler-code": {
              pattern: /\d+`/,
              alias: "important"
            },
            number: /\d+/,
            operator: /[-!#$%&'*+,./:;=>?@\\^_`|~ßø]/,
            punctuation: /\[|\]/,
            variable: /[a-z]/,
            "non-standard": {
              pattern: /[()<BDO®]/,
              alias: "bold"
            }
          };
        })(Prism2);
      }
      return _false;
    }
    var firestoreSecurityRules_1;
    var hasRequiredFirestoreSecurityRules;
    function requireFirestoreSecurityRules() {
      if (hasRequiredFirestoreSecurityRules)
        return firestoreSecurityRules_1;
      hasRequiredFirestoreSecurityRules = 1;
      firestoreSecurityRules_1 = firestoreSecurityRules;
      firestoreSecurityRules.displayName = "firestoreSecurityRules";
      firestoreSecurityRules.aliases = [];
      function firestoreSecurityRules(Prism2) {
        Prism2.languages["firestore-security-rules"] = Prism2.languages.extend(
          "clike",
          {
            comment: /\/\/.*/,
            keyword: /\b(?:allow|function|if|match|null|return|rules_version|service)\b/,
            operator: /&&|\|\||[<>!=]=?|[-+*/%]|\b(?:in|is)\b/
          }
        );
        delete Prism2.languages["firestore-security-rules"]["class-name"];
        Prism2.languages.insertBefore("firestore-security-rules", "keyword", {
          path: {
            pattern: /(^|[\s(),])(?:\/(?:[\w\xA0-\uFFFF]+|\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)))+/,
            lookbehind: true,
            greedy: true,
            inside: {
              variable: {
                pattern: /\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)/,
                inside: {
                  operator: /=/,
                  keyword: /\*\*/,
                  punctuation: /[.$(){}]/
                }
              },
              punctuation: /\//
            }
          },
          method: {
            // to make the pattern shorter, the actual method names are omitted
            pattern: /(\ballow\s+)[a-z]+(?:\s*,\s*[a-z]+)*(?=\s*[:;])/,
            lookbehind: true,
            alias: "builtin",
            inside: {
              punctuation: /,/
            }
          }
        });
      }
      return firestoreSecurityRules_1;
    }
    var flow_1;
    var hasRequiredFlow;
    function requireFlow() {
      if (hasRequiredFlow)
        return flow_1;
      hasRequiredFlow = 1;
      flow_1 = flow2;
      flow2.displayName = "flow";
      flow2.aliases = [];
      function flow2(Prism2) {
        (function(Prism3) {
          Prism3.languages.flow = Prism3.languages.extend("javascript", {});
          Prism3.languages.insertBefore("flow", "keyword", {
            type: [
              {
                pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|any|mixed|null|void)\b/,
                alias: "tag"
              }
            ]
          });
          Prism3.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i;
          delete Prism3.languages.flow["parameter"];
          Prism3.languages.insertBefore("flow", "operator", {
            "flow-punctuation": {
              pattern: /\{\||\|\}/,
              alias: "punctuation"
            }
          });
          if (!Array.isArray(Prism3.languages.flow.keyword)) {
            Prism3.languages.flow.keyword = [Prism3.languages.flow.keyword];
          }
          Prism3.languages.flow.keyword.unshift(
            {
              pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
              lookbehind: true
            },
            {
              pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,
              lookbehind: true
            }
          );
        })(Prism2);
      }
      return flow_1;
    }
    var fortran_1;
    var hasRequiredFortran;
    function requireFortran() {
      if (hasRequiredFortran)
        return fortran_1;
      hasRequiredFortran = 1;
      fortran_1 = fortran;
      fortran.displayName = "fortran";
      fortran.aliases = [];
      function fortran(Prism2) {
        Prism2.languages.fortran = {
          "quoted-number": {
            pattern: /[BOZ](['"])[A-F0-9]+\1/i,
            alias: "number"
          },
          string: {
            pattern: /(?:\b\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:[ \t]*!.*(?:\r\n?|\n)|(?![ \t]*!))|(?!\1).)*(?:\1|&)/,
            inside: {
              comment: {
                pattern: /(&(?:\r\n?|\n)\s*)!.*/,
                lookbehind: true
              }
            }
          },
          comment: {
            pattern: /!.*/,
            greedy: true
          },
          boolean: /\.(?:FALSE|TRUE)\.(?:_\w+)?/i,
          number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
          keyword: [
            // Types
            /\b(?:CHARACTER|COMPLEX|DOUBLE ?PRECISION|INTEGER|LOGICAL|REAL)\b/i,
            // END statements
            /\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,
            // Statements
            /\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,
            // Others
            /\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEIF|ELSEWHERE|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
          ],
          operator: [
            /\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.[A-Z]+\./i,
            {
              // Use lookbehind to prevent confusion with (/ /)
              pattern: /(^|(?!\().)\/(?!\))/,
              lookbehind: true
            }
          ],
          punctuation: /\(\/|\/\)|[(),;:&]/
        };
      }
      return fortran_1;
    }
    var fsharp_1;
    var hasRequiredFsharp;
    function requireFsharp() {
      if (hasRequiredFsharp)
        return fsharp_1;
      hasRequiredFsharp = 1;
      fsharp_1 = fsharp;
      fsharp.displayName = "fsharp";
      fsharp.aliases = [];
      function fsharp(Prism2) {
        Prism2.languages.fsharp = Prism2.languages.extend("clike", {
          comment: [
            {
              pattern: /(^|[^\\])\(\*(?!\))[\s\S]*?\*\)/,
              lookbehind: true,
              greedy: true
            },
            {
              pattern: /(^|[^\\:])\/\/.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          string: {
            pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|"(?:\\[\s\S]|[^\\"])*")B?/,
            greedy: true
          },
          "class-name": {
            pattern: /(\b(?:exception|inherit|interface|new|of|type)\s+|\w\s*:\s*|\s:\??>\s*)[.\w]+\b(?:\s*(?:->|\*)\s*[.\w]+\b)*(?!\s*[:.])/,
            lookbehind: true,
            inside: {
              operator: /->|\*/,
              punctuation: /\./
            }
          },
          keyword: /\b(?:let|return|use|yield)(?:!\B|\b)|\b(?:abstract|and|as|asr|assert|atomic|base|begin|break|checked|class|component|const|constraint|constructor|continue|default|delegate|do|done|downcast|downto|eager|elif|else|end|event|exception|extern|external|false|finally|fixed|for|fun|function|functor|global|if|in|include|inherit|inline|interface|internal|land|lazy|lor|lsl|lsr|lxor|match|member|method|mixin|mod|module|mutable|namespace|new|not|null|object|of|open|or|override|parallel|private|process|protected|public|pure|rec|sealed|select|sig|static|struct|tailcall|then|to|trait|true|try|type|upcast|val|virtual|void|volatile|when|while|with)\b/,
          number: [
            /\b0x[\da-fA-F]+(?:LF|lf|un)?\b/,
            /\b0b[01]+(?:uy|y)?\b/,
            /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[fm]|e[+-]?\d+)?\b/i,
            /\b\d+(?:[IlLsy]|UL|u[lsy]?)?\b/
          ],
          operator: /([<>~&^])\1\1|([*.:<>&])\2|<-|->|[!=:]=|<?\|{1,3}>?|\??(?:<=|>=|<>|[-+*/%=<>])\??|[!?^&]|~[+~-]|:>|:\?>?/
        });
        Prism2.languages.insertBefore("fsharp", "keyword", {
          preprocessor: {
            pattern: /(^[\t ]*)#.*/m,
            lookbehind: true,
            alias: "property",
            inside: {
              directive: {
                pattern: /(^#)\b(?:else|endif|if|light|line|nowarn)\b/,
                lookbehind: true,
                alias: "keyword"
              }
            }
          }
        });
        Prism2.languages.insertBefore("fsharp", "punctuation", {
          "computation-expression": {
            pattern: /\b[_a-z]\w*(?=\s*\{)/i,
            alias: "keyword"
          }
        });
        Prism2.languages.insertBefore("fsharp", "string", {
          annotation: {
            pattern: /\[<.+?>\]/,
            greedy: true,
            inside: {
              punctuation: /^\[<|>\]$/,
              "class-name": {
                pattern: /^\w+$|(^|;\s*)[A-Z]\w*(?=\()/,
                lookbehind: true
              },
              "annotation-content": {
                pattern: /[\s\S]+/,
                inside: Prism2.languages.fsharp
              }
            }
          },
          char: {
            pattern: /'(?:[^\\']|\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8}))'B?/,
            greedy: true
          }
        });
      }
      return fsharp_1;
    }
    var ftl_1;
    var hasRequiredFtl;
    function requireFtl() {
      if (hasRequiredFtl)
        return ftl_1;
      hasRequiredFtl = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      ftl_1 = ftl;
      ftl.displayName = "ftl";
      ftl.aliases = [];
      function ftl(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        (function(Prism3) {
          var FTL_EXPR = /[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/.source;
          for (var i = 0; i < 2; i++) {
            FTL_EXPR = FTL_EXPR.replace(/<expr>/g, function() {
              return FTL_EXPR;
            });
          }
          FTL_EXPR = FTL_EXPR.replace(/<expr>/g, /[^\s\S]/.source);
          var ftl2 = {
            comment: /<#--[\s\S]*?-->/,
            string: [
              {
                // raw string
                pattern: /\br("|')(?:(?!\1)[^\\]|\\.)*\1/,
                greedy: true
              },
              {
                pattern: RegExp(
                  /("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(
                    /<expr>/g,
                    function() {
                      return FTL_EXPR;
                    }
                  )
                ),
                greedy: true,
                inside: {
                  interpolation: {
                    pattern: RegExp(
                      /((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(
                        /<expr>/g,
                        function() {
                          return FTL_EXPR;
                        }
                      )
                    ),
                    lookbehind: true,
                    inside: {
                      "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                      },
                      rest: null
                    }
                  }
                }
              }
            ],
            keyword: /\b(?:as)\b/,
            boolean: /\b(?:false|true)\b/,
            "builtin-function": {
              pattern: /((?:^|[^?])\?\s*)\w+/,
              lookbehind: true,
              alias: "function"
            },
            function: /\b\w+(?=\s*\()/,
            number: /\b\d+(?:\.\d+)?\b/,
            operator: /\.\.[<*!]?|->|--|\+\+|&&|\|\||\?{1,2}|[-+*/%!=<>]=?|\b(?:gt|gte|lt|lte)\b/,
            punctuation: /[,;.:()[\]{}]/
          };
          ftl2.string[1].inside.interpolation.inside.rest = ftl2;
          Prism3.languages.ftl = {
            "ftl-comment": {
              // the pattern is shortened to be more efficient
              pattern: /^<#--[\s\S]*/,
              alias: "comment"
            },
            "ftl-directive": {
              pattern: /^<[\s\S]+>$/,
              inside: {
                directive: {
                  pattern: /(^<\/?)[#@][a-z]\w*/i,
                  lookbehind: true,
                  alias: "keyword"
                },
                punctuation: /^<\/?|\/?>$/,
                content: {
                  pattern: /\s*\S[\s\S]*/,
                  alias: "ftl",
                  inside: ftl2
                }
              }
            },
            "ftl-interpolation": {
              pattern: /^\$\{[\s\S]*\}$/,
              inside: {
                punctuation: /^\$\{|\}$/,
                content: {
                  pattern: /\s*\S[\s\S]*/,
                  alias: "ftl",
                  inside: ftl2
                }
              }
            }
          };
          Prism3.hooks.add("before-tokenize", function(env2) {
            var pattern = RegExp(
              /<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(
                /<expr>/g,
                function() {
                  return FTL_EXPR;
                }
              ),
              "gi"
            );
            Prism3.languages["markup-templating"].buildPlaceholders(
              env2,
              "ftl",
              pattern
            );
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            Prism3.languages["markup-templating"].tokenizePlaceholders(env2, "ftl");
          });
        })(Prism2);
      }
      return ftl_1;
    }
    var gap_1;
    var hasRequiredGap;
    function requireGap() {
      if (hasRequiredGap)
        return gap_1;
      hasRequiredGap = 1;
      gap_1 = gap;
      gap.displayName = "gap";
      gap.aliases = [];
      function gap(Prism2) {
        Prism2.languages.gap = {
          shell: {
            pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
            greedy: true,
            inside: {
              gap: {
                pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
                lookbehind: true,
                inside: null
                // see below
              },
              punctuation: /^gap>/
            }
          },
          comment: {
            pattern: /#.*/,
            greedy: true
          },
          string: {
            pattern: /(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
            lookbehind: true,
            greedy: true,
            inside: {
              continuation: {
                pattern: /([\r\n])>/,
                lookbehind: true,
                alias: "punctuation"
              }
            }
          },
          keyword: /\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
          boolean: /\b(?:false|true)\b/,
          function: /\b[a-z_]\w*(?=\s*\()/i,
          number: {
            pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
            lookbehind: true
          },
          continuation: {
            pattern: /([\r\n])>/,
            lookbehind: true,
            alias: "punctuation"
          },
          operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
          punctuation: /[()[\]{},;.:]/
        };
        Prism2.languages.gap.shell.inside.gap.inside = Prism2.languages.gap;
      }
      return gap_1;
    }
    var gcode_1;
    var hasRequiredGcode;
    function requireGcode() {
      if (hasRequiredGcode)
        return gcode_1;
      hasRequiredGcode = 1;
      gcode_1 = gcode;
      gcode.displayName = "gcode";
      gcode.aliases = [];
      function gcode(Prism2) {
        Prism2.languages.gcode = {
          comment: /;.*|\B\(.*?\)\B/,
          string: {
            pattern: /"(?:""|[^"])*"/,
            greedy: true
          },
          keyword: /\b[GM]\d+(?:\.\d+)?\b/,
          property: /\b[A-Z]/,
          checksum: {
            pattern: /(\*)\d+/,
            lookbehind: true,
            alias: "number"
          },
          // T0:0:0
          punctuation: /[:*]/
        };
      }
      return gcode_1;
    }
    var gdscript_1;
    var hasRequiredGdscript;
    function requireGdscript() {
      if (hasRequiredGdscript)
        return gdscript_1;
      hasRequiredGdscript = 1;
      gdscript_1 = gdscript;
      gdscript.displayName = "gdscript";
      gdscript.aliases = [];
      function gdscript(Prism2) {
        Prism2.languages.gdscript = {
          comment: /#.*/,
          string: {
            pattern: /@?(?:("|')(?:(?!\1)[^\n\\]|\\[\s\S])*\1(?!"|')|"""(?:[^\\]|\\[\s\S])*?""")/,
            greedy: true
          },
          "class-name": {
            // class_name Foo, extends Bar, class InnerClass
            // export(int) var baz, export(int, 0) var i
            // as Node
            // const FOO: int = 9, var bar: bool = true
            // func add(reference: Item, amount: int) -> Item:
            pattern: /(^(?:class|class_name|extends)[ \t]+|^export\([ \t]*|\bas[ \t]+|(?:\b(?:const|var)[ \t]|[,(])[ \t]*\w+[ \t]*:[ \t]*|->[ \t]*)[a-zA-Z_]\w*/m,
            lookbehind: true
          },
          keyword: /\b(?:and|as|assert|break|breakpoint|class|class_name|const|continue|elif|else|enum|export|extends|for|func|if|in|is|master|mastersync|match|not|null|onready|or|pass|preload|puppet|puppetsync|remote|remotesync|return|self|setget|signal|static|tool|var|while|yield)\b/,
          function: /\b[a-z_]\w*(?=[ \t]*\()/i,
          variable: /\$\w+/,
          number: [
            /\b0b[01_]+\b|\b0x[\da-fA-F_]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.[\d_]+)(?:e[+-]?[\d_]+)?\b/,
            /\b(?:INF|NAN|PI|TAU)\b/
          ],
          constant: /\b[A-Z][A-Z_\d]*\b/,
          boolean: /\b(?:false|true)\b/,
          operator: /->|:=|&&|\|\||<<|>>|[-+*/%&|!<>=]=?|[~^]/,
          punctuation: /[.:,;()[\]{}]/
        };
      }
      return gdscript_1;
    }
    var gedcom_1;
    var hasRequiredGedcom;
    function requireGedcom() {
      if (hasRequiredGedcom)
        return gedcom_1;
      hasRequiredGedcom = 1;
      gedcom_1 = gedcom;
      gedcom.displayName = "gedcom";
      gedcom.aliases = [];
      function gedcom(Prism2) {
        Prism2.languages.gedcom = {
          "line-value": {
            // Preceded by level, optional pointer, and tag
            pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?\w+ ).+/m,
            lookbehind: true,
            inside: {
              pointer: {
                pattern: /^@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@$/,
                alias: "variable"
              }
            }
          },
          tag: {
            // Preceded by level and optional pointer
            pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?)\w+/m,
            lookbehind: true,
            alias: "string"
          },
          level: {
            pattern: /(^[\t ]*)\d+/m,
            lookbehind: true,
            alias: "number"
          },
          pointer: {
            pattern: /@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@/,
            alias: "variable"
          }
        };
      }
      return gedcom_1;
    }
    var gherkin_1;
    var hasRequiredGherkin;
    function requireGherkin() {
      if (hasRequiredGherkin)
        return gherkin_1;
      hasRequiredGherkin = 1;
      gherkin_1 = gherkin;
      gherkin.displayName = "gherkin";
      gherkin.aliases = [];
      function gherkin(Prism2) {
        (function(Prism3) {
          var tableRow2 = /(?:\r?\n|\r)[ \t]*\|.+\|(?:(?!\|).)*/.source;
          Prism3.languages.gherkin = {
            pystring: {
              pattern: /("""|''')[\s\S]+?\1/,
              alias: "string"
            },
            comment: {
              pattern: /(^[ \t]*)#.*/m,
              lookbehind: true
            },
            tag: {
              pattern: /(^[ \t]*)@\S*/m,
              lookbehind: true
            },
            feature: {
              pattern: /((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Característica|Egenskab|Egenskap|Eiginleiki|Feature|Fīča|Fitur|Fonctionnalité|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcţionalitate|Funcționalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitāte|Funkcionalnost|Funkcja|Funksie|Funktionalität|Funktionalitéit|Funzionalità|Hwaet|Hwæt|Jellemző|Karakteristik|Lastnost|Mak|Mogucnost|laH|Mogućnost|Moznosti|Možnosti|OH HAI|Omadus|Ominaisuus|Osobina|Özellik|Potrzeba biznesowa|perbogh|poQbogh malja'|Požadavek|Požiadavka|Pretty much|Qap|Qu'meH 'ut|Savybė|Tính năng|Trajto|Vermoë|Vlastnosť|Właściwość|Značilnost|Δυνατότητα|Λειτουργία|Могућност|Мөмкинлек|Особина|Свойство|Үзенчәлеклелек|Функционал|Функционалност|Функция|Функціонал|תכונה|خاصية|خصوصیت|صلاحیت|کاروبار کی ضرورت|وِیژگی|रूप लेख|ਖਾਸੀਅਤ|ਨਕਸ਼ ਨੁਹਾਰ|ਮੁਹਾਂਦਰਾ|గుణము|ಹೆಚ್ಚಳ|ความต้องการทางธุรกิจ|ความสามารถ|โครงหลัก|기능|フィーチャ|功能|機能):(?:[^:\r\n]+(?:\r?\n|\r|$))*/,
              lookbehind: true,
              inside: {
                important: {
                  pattern: /(:)[^\r\n]+/,
                  lookbehind: true
                },
                keyword: /[^:\r\n]+:/
              }
            },
            scenario: {
              pattern: /(^[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|Ær|Agtergrond|All y'all|Antecedentes|Antecedents|Atburðarás|Atburðarásir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bối cảnh|Cefndir|Cenario|Cenário|Cenario de Fundo|Cenário de Fundo|Cenarios|Cenários|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dæmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineação do Cenário|Dis is what went down|Dữ liệu|Dyagram Senaryo|Dyagram senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenário|EXAMPLZ|Examples|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatókönyv|Forgatókönyv vázlat|Fundo|Geçmiş|Grundlage|Hannergrond|ghantoH|Háttér|Heave to|Istorik|Juhtumid|Keadaan|Khung kịch bản|Khung tình huống|Kịch bản|Koncept|Konsep skenario|Kontèks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut chovnatlh|lut|lutmey|Lýsing Atburðarásar|Lýsing Dæma|MISHUN SRSLY|MISHUN|Menggariskan Senario|mo'|Náčrt Scenára|Náčrt Scénáře|Náčrt Scenáru|Oris scenarija|Örnekler|Osnova|Osnova Scenára|Osnova scénáře|Osnutek|Ozadje|Paraugs|Pavyzdžiai|Példák|Piemēri|Plan du scénario|Plan du Scénario|Plan Senaryo|Plan senaryo|Plang vum Szenario|Pozadí|Pozadie|Pozadina|Príklady|Příklady|Primer|Primeri|Primjeri|Przykłady|Raamstsenaarium|Reckon it's like|Rerefons|Scenár|Scénář|Scenarie|Scenarij|Scenarijai|Scenarijaus šablonas|Scenariji|Scenārijs|Scenārijs pēc parauga|Scenarijus|Scenario|Scénario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se ðe|Se the|Se þe|Senario|Senaryo Deskripsyon|Senaryo deskripsyon|Senaryo|Senaryo taslağı|Shiver me timbers|Situācija|Situai|Situasie Uiteensetting|Situasie|Skenario konsep|Skenario|Skica|Structura scenariu|Structură scenariu|Struktura scenarija|Stsenaarium|Swa hwaer swa|Swa|Swa hwær swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tình huống|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo-ho-ho|You'll wanna|Założenia|Παραδείγματα|Περιγραφή Σεναρίου|Σενάρια|Σενάριο|Υπόβαθρο|Кереш|Контекст|Концепт|Мисаллар|Мисоллар|Основа|Передумова|Позадина|Предистория|Предыстория|Приклади|Пример|Примери|Примеры|Рамка на сценарий|Скица|Структура сценарија|Структура сценария|Структура сценарію|Сценарий|Сценарий структураси|Сценарийның төзелеше|Сценарији|Сценарио|Сценарій|Тарих|Үрнәкләр|דוגמאות|רקע|תבנית תרחיש|תרחיש|الخلفية|الگوی سناریو|امثلة|پس منظر|زمینه|سناریو|سيناريو|سيناريو مخطط|مثالیں|منظر نامے کا خاکہ|منظرنامہ|نمونه ها|उदाहरण|परिदृश्य|परिदृश्य रूपरेखा|पृष्ठभूमि|ਉਦਾਹਰਨਾਂ|ਪਟਕਥਾ|ਪਟਕਥਾ ਢਾਂਚਾ|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਿਛੋਕੜ|ఉదాహరణలు|కథనం|నేపథ్యం|సన్నివేశం|ಉದಾಹರಣೆಗಳು|ಕಥಾಸಾರಾಂಶ|ವಿವರಣೆ|ಹಿನ್ನೆಲೆ|โครงสร้างของเหตุการณ์|ชุดของตัวอย่าง|ชุดของเหตุการณ์|แนวคิด|สรุปเหตุการณ์|เหตุการณ์|배경|시나리오|시나리오 개요|예|サンプル|シナリオ|シナリオアウトライン|シナリオテンプレ|シナリオテンプレート|テンプレ|例|例子|剧本|剧本大纲|劇本|劇本大綱|场景|场景大纲|場景|場景大綱|背景):[^:\r\n]*/m,
              lookbehind: true,
              inside: {
                important: {
                  pattern: /(:)[^\r\n]*/,
                  lookbehind: true
                },
                keyword: /[^:\r\n]+:/
              }
            },
            "table-body": {
              // Look-behind is used to skip the table head, which has the same format as any table row
              pattern: RegExp("(" + tableRow2 + ")(?:" + tableRow2 + ")+"),
              lookbehind: true,
              inside: {
                outline: {
                  pattern: /<[^>]+>/,
                  alias: "variable"
                },
                td: {
                  pattern: /\s*[^\s|][^|]*/,
                  alias: "string"
                },
                punctuation: /\|/
              }
            },
            "table-head": {
              pattern: RegExp(tableRow2),
              inside: {
                th: {
                  pattern: /\s*[^\s|][^|]*/,
                  alias: "variable"
                },
                punctuation: /\|/
              }
            },
            atrule: {
              pattern: /(^[ \t]+)(?:'a|'ach|'ej|7|a|A také|A taktiež|A tiež|A zároveň|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Atès|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Biết|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Când|Cand|Cando|Ce|Cuando|Če|Ða ðe|Ða|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Daţi fiind|Dați fiind|DEN|Dato|De|Den youse gotta|Dengan|Diberi|Diyelim ki|Donada|Donat|Donitaĵo|Do|Dun|Duota|Ðurh|Eeldades|Ef|Eğer ki|Entao|Então|Entón|E|En|Entonces|Epi|És|Etant donnée|Etant donné|Et|Étant données|Étant donnée|Étant donné|Etant données|Etant donnés|Étant donnés|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeśli|Jeżeli|Kad|Kada|Kadar|Kai|Kaj|Když|Keď|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|Lè sa a|Lè|Logo|Lorsqu'<|Lorsque|mä|Maar|Mais|Mając|Ma|Majd|Maka|Manawa|Mas|Men|Menawa|Mutta|Nalika|Nalikaning|Nanging|Når|När|Nato|Nhưng|Niin|Njuk|O zaman|Och|Og|Oletetaan|Ond|Onda|Oraz|Pak|Pero|Però|Podano|Pokiaľ|Pokud|Potem|Potom|Privzeto|Pryd|Quan|Quand|Quando|qaSDI'|Så|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|Şi|Și|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Thì|Thurh|Toda|Too right|Un|Und|ugeholl|Và|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za předpokladu|Zadan|Zadani|Zadano|Zadate|Zadato|Zakładając|Zaradi|Zatati|Þa þe|Þa|Þá|Þegar|Þurh|Αλλά|Δεδομένου|Και|Όταν|Τότε|А також|Агар|Але|Али|Аммо|А|Әгәр|Әйтик|Әмма|Бирок|Ва|Вә|Дадено|Дано|Допустим|Если|Задате|Задати|Задато|И|І|К тому же|Када|Кад|Когато|Когда|Коли|Ләкин|Лекин|Нәтиҗәдә|Нехай|Но|Онда|Припустимо, що|Припустимо|Пусть|Также|Та|Тогда|Тоді|То|Унда|Һәм|Якщо|אבל|אזי|אז|בהינתן|וגם|כאשר|آنگاه|اذاً|اگر|اما|اور|با فرض|بالفرض|بفرض|پھر|تب|ثم|جب|عندما|فرض کیا|لكن|لیکن|متى|هنگامی|و|अगर|और|कदा|किन्तु|चूंकि|जब|तथा|तदा|तब|परन्तु|पर|यदि|ਅਤੇ|ਜਦੋਂ|ਜਿਵੇਂ ਕਿ|ਜੇਕਰ|ਤਦ|ਪਰ|అప్పుడు|ఈ పరిస్థితిలో|కాని|చెప్పబడినది|మరియు|ಆದರೆ|ನಂತರ|ನೀಡಿದ|ಮತ್ತು|ಸ್ಥಿತಿಯನ್ನು|กำหนดให้|ดังนั้น|แต่|เมื่อ|และ|그러면<|그리고<|단<|만약<|만일<|먼저<|조건<|하지만<|かつ<|しかし<|ただし<|ならば<|もし<|並且<|但し<|但是<|假如<|假定<|假設<|假设<|前提<|同时<|同時<|并且<|当<|當<|而且<|那么<|那麼<)(?=[ \t])/m,
              lookbehind: true
            },
            string: {
              pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
              inside: {
                outline: {
                  pattern: /<[^>]+>/,
                  alias: "variable"
                }
              }
            },
            outline: {
              pattern: /<[^>]+>/,
              alias: "variable"
            }
          };
        })(Prism2);
      }
      return gherkin_1;
    }
    var git_1;
    var hasRequiredGit;
    function requireGit() {
      if (hasRequiredGit)
        return git_1;
      hasRequiredGit = 1;
      git_1 = git;
      git.displayName = "git";
      git.aliases = [];
      function git(Prism2) {
        Prism2.languages.git = {
          /*
           * A simple one line comment like in a git status command
           * For instance:
           * $ git status
           * # On branch infinite-scroll
           * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
           * # and have 1 and 2 different commits each, respectively.
           * nothing to commit (working directory clean)
           */
          comment: /^#.*/m,
          /*
           * Regexp to match the changed lines in a git diff output. Check the example below.
           */
          deleted: /^[-–].*/m,
          inserted: /^\+.*/m,
          /*
           * a string (double and simple quote)
           */
          string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
          /*
           * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
           * For instance:
           * $ git add file.txt
           */
          command: {
            pattern: /^.*\$ git .*$/m,
            inside: {
              /*
               * A git command can contain a parameter starting by a single or a double dash followed by a string
               * For instance:
               * $ git diff --cached
               * $ git log -p
               */
              parameter: /\s--?\w+/
            }
          },
          /*
           * Coordinates displayed in a git diff command
           * For instance:
           * $ git diff
           * diff --git file.txt file.txt
           * index 6214953..1d54a52 100644
           * --- file.txt
           * +++ file.txt
           * @@ -1 +1,2 @@
           * -Here's my tetx file
           * +Here's my text file
           * +And this is the second line
           */
          coord: /^@@.*@@$/m,
          /*
           * Match a "commit [SHA1]" line in a git log output.
           * For instance:
           * $ git log
           * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
           * Author: lgiraudel
           * Date:   Mon Feb 17 11:18:34 2014 +0100
           *
           *     Add of a new line
           */
          "commit-sha1": /^commit \w{40}$/m
        };
      }
      return git_1;
    }
    var glsl_1;
    var hasRequiredGlsl;
    function requireGlsl() {
      if (hasRequiredGlsl)
        return glsl_1;
      hasRequiredGlsl = 1;
      var refractorC = requireC();
      glsl_1 = glsl;
      glsl.displayName = "glsl";
      glsl.aliases = [];
      function glsl(Prism2) {
        Prism2.register(refractorC);
        Prism2.languages.glsl = Prism2.languages.extend("c", {
          keyword: /\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/
        });
      }
      return glsl_1;
    }
    var gml_1;
    var hasRequiredGml;
    function requireGml() {
      if (hasRequiredGml)
        return gml_1;
      hasRequiredGml = 1;
      gml_1 = gml;
      gml.displayName = "gml";
      gml.aliases = [];
      function gml(Prism2) {
        Prism2.languages.gamemakerlanguage = Prism2.languages.gml = Prism2.languages.extend("clike", {
          keyword: /\b(?:break|case|continue|default|do|else|enum|exit|for|globalvar|if|repeat|return|switch|until|var|while)\b/,
          number: /(?:\b0x[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ulf]{0,4}/i,
          operator: /--|\+\+|[-+%/=]=?|!=|\*\*?=?|<[<=>]?|>[=>]?|&&?|\^\^?|\|\|?|~|\b(?:and|at|not|or|with|xor)\b/,
          constant: /\b(?:GM_build_date|GM_version|action_(?:continue|restart|reverse|stop)|all|gamespeed_(?:fps|microseconds)|global|local|noone|other|pi|pointer_(?:invalid|null)|self|timezone_(?:local|utc)|undefined|ev_(?:create|destroy|step|alarm|keyboard|mouse|collision|other|draw|draw_(?:begin|end|post|pre)|keypress|keyrelease|trigger|(?:left|middle|no|right)_button|(?:left|middle|right)_press|(?:left|middle|right)_release|mouse_(?:enter|leave|wheel_down|wheel_up)|global_(?:left|middle|right)_button|global_(?:left|middle|right)_press|global_(?:left|middle|right)_release|joystick(?:1|2)_(?:button1|button2|button3|button4|button5|button6|button7|button8|down|left|right|up)|outside|boundary|game_start|game_end|room_start|room_end|no_more_lives|animation_end|end_of_path|no_more_health|user\d|gui|gui_begin|gui_end|step_(?:begin|end|normal))|vk_(?:alt|anykey|backspace|control|delete|down|end|enter|escape|home|insert|left|nokey|pagedown|pageup|pause|printscreen|return|right|shift|space|tab|up|f\d|numpad\d|add|decimal|divide|lalt|lcontrol|lshift|multiply|ralt|rcontrol|rshift|subtract)|achievement_(?:filter_(?:all_players|favorites_only|friends_only)|friends_info|info|leaderboard_info|our_info|pic_loaded|show_(?:achievement|bank|friend_picker|leaderboard|profile|purchase_prompt|ui)|type_challenge|type_score_challenge)|asset_(?:font|object|path|room|script|shader|sound|sprite|tiles|timeline|unknown)|audio_(?:3d|falloff_(?:exponent_distance|exponent_distance_clamped|inverse_distance|inverse_distance_clamped|linear_distance|linear_distance_clamped|none)|mono|new_system|old_system|stereo)|bm_(?:add|complex|dest_alpha|dest_color|dest_colour|inv_dest_alpha|inv_dest_color|inv_dest_colour|inv_src_alpha|inv_src_color|inv_src_colour|max|normal|one|src_alpha|src_alpha_sat|src_color|src_colour|subtract|zero)|browser_(?:chrome|firefox|ie|ie_mobile|not_a_browser|opera|safari|safari_mobile|tizen|unknown|windows_store)|buffer_(?:bool|f16|f32|f64|fast|fixed|generalerror|grow|invalidtype|network|outofbounds|outofspace|s16|s32|s8|seek_end|seek_relative|seek_start|string|text|u16|u32|u64|u8|vbuffer|wrap)|c_(?:aqua|black|blue|dkgray|fuchsia|gray|green|lime|ltgray|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)|cmpfunc_(?:always|equal|greater|greaterequal|less|lessequal|never|notequal)|cr_(?:appstart|arrow|beam|cross|default|drag|handpoint|hourglass|none|size_all|size_nesw|size_ns|size_nwse|size_we|uparrow)|cull_(?:clockwise|counterclockwise|noculling)|device_(?:emulator|tablet)|device_ios_(?:ipad|ipad_retina|iphone|iphone5|iphone6|iphone6plus|iphone_retina|unknown)|display_(?:landscape|landscape_flipped|portrait|portrait_flipped)|dll_(?:cdecl|cdel|stdcall)|ds_type_(?:grid|list|map|priority|queue|stack)|ef_(?:cloud|ellipse|explosion|firework|flare|rain|ring|smoke|smokeup|snow|spark|star)|fa_(?:archive|bottom|center|directory|hidden|left|middle|readonly|right|sysfile|top|volumeid)|fb_login_(?:default|fallback_to_webview|forcing_safari|forcing_webview|no_fallback_to_webview|use_system_account)|iap_(?:available|canceled|ev_consume|ev_product|ev_purchase|ev_restore|ev_storeload|failed|purchased|refunded|status_available|status_loading|status_processing|status_restoring|status_unavailable|status_uninitialised|storeload_failed|storeload_ok|unavailable)|leaderboard_type_(?:number|time_mins_secs)|lighttype_(?:dir|point)|matrix_(?:projection|view|world)|mb_(?:any|left|middle|none|right)|network_(?:config_(?:connect_timeout|disable_reliable_udp|enable_reliable_udp|use_non_blocking_socket)|socket_(?:bluetooth|tcp|udp)|type_(?:connect|data|disconnect|non_blocking_connect))|of_challenge_(?:lose|tie|win)|os_(?:android|ios|linux|macosx|ps3|ps4|psvita|unknown|uwp|win32|win8native|windows|winphone|xboxone)|phy_debug_render_(?:aabb|collision_pairs|coms|core_shapes|joints|obb|shapes)|phy_joint_(?:anchor_1_x|anchor_1_y|anchor_2_x|anchor_2_y|angle|angle_limits|damping_ratio|frequency|length_1|length_2|lower_angle_limit|max_force|max_length|max_motor_force|max_motor_torque|max_torque|motor_force|motor_speed|motor_torque|reaction_force_x|reaction_force_y|reaction_torque|speed|translation|upper_angle_limit)|phy_particle_data_flag_(?:category|color|colour|position|typeflags|velocity)|phy_particle_flag_(?:colormixing|colourmixing|elastic|powder|spring|tensile|viscous|wall|water|zombie)|phy_particle_group_flag_(?:rigid|solid)|pr_(?:linelist|linestrip|pointlist|trianglefan|trianglelist|trianglestrip)|ps_(?:distr|shape)_(?:diamond|ellipse|gaussian|invgaussian|line|linear|rectangle)|pt_shape_(?:circle|cloud|disk|explosion|flare|line|pixel|ring|smoke|snow|spark|sphere|square|star)|ty_(?:real|string)|gp_(?:face\d|axislh|axislv|axisrh|axisrv|padd|padl|padr|padu|select|shoulderl|shoulderlb|shoulderr|shoulderrb|start|stickl|stickr)|lb_disp_(?:none|numeric|time_ms|time_sec)|lb_sort_(?:ascending|descending|none)|ov_(?:achievements|community|friends|gamegroup|players|settings)|ugc_(?:filetype_(?:community|microtrans)|list_(?:Favorited|Followed|Published|Subscribed|UsedOrPlayed|VotedDown|VotedOn|VotedUp|WillVoteLater)|match_(?:AllGuides|Artwork|Collections|ControllerBindings|IntegratedGuides|Items|Items_Mtx|Items_ReadyToUse|Screenshots|UsableInGame|Videos|WebGuides)|query_(?:AcceptedForGameRankedByAcceptanceDate|CreatedByFriendsRankedByPublicationDate|FavoritedByFriendsRankedByPublicationDate|NotYetRated)|query_RankedBy(?:NumTimesReported|PublicationDate|TextSearch|TotalVotesAsc|Trend|Vote|VotesUp)|result_success|sortorder_CreationOrder(?:Asc|Desc)|sortorder_(?:ForModeration|LastUpdatedDesc|SubscriptionDateDesc|TitleAsc|VoteScoreDesc)|visibility_(?:friends_only|private|public))|vertex_usage_(?:binormal|blendindices|blendweight|color|colour|depth|fog|normal|position|psize|sample|tangent|texcoord|textcoord)|vertex_type_(?:float\d|color|colour|ubyte4)|input_type|layerelementtype_(?:background|instance|oldtilemap|particlesystem|sprite|tile|tilemap|undefined)|se_(?:chorus|compressor|echo|equalizer|flanger|gargle|none|reverb)|text_type|tile_(?:flip|index_mask|mirror|rotate)|(?:obj|rm|scr|spr)\w+)\b/,
          variable: /\b(?:alarm|application_surface|async_load|background_(?:alpha|blend|color|colour|foreground|height|hspeed|htiled|index|showcolor|showcolour|visible|vspeed|vtiled|width|x|xscale|y|yscale)|bbox_(?:bottom|left|right|top)|browser_(?:height|width)|caption_(?:health|lives|score)|current_(?:day|hour|minute|month|second|time|weekday|year)|cursor_sprite|debug_mode|delta_time|direction|display_aa|error_(?:last|occurred)|event_(?:action|number|object|type)|fps|fps_real|friction|game_(?:display|project|save)_(?:id|name)|gamemaker_(?:pro|registered|version)|gravity|gravity_direction|(?:h|v)speed|health|iap_data|id|image_(?:alpha|angle|blend|depth|index|number|speed|xscale|yscale)|instance_(?:count|id)|keyboard_(?:key|lastchar|lastkey|string)|layer|lives|mask_index|mouse_(?:button|lastbutton|x|y)|object_index|os_(?:browser|device|type|version)|path_(?:endaction|index|orientation|position|positionprevious|scale|speed)|persistent|phy_(?:rotation|(?:col_normal|collision|com|linear_velocity|position|speed)_(?:x|y)|angular_(?:damping|velocity)|position_(?:x|y)previous|speed|linear_damping|bullet|fixed_rotation|active|mass|inertia|dynamic|kinematic|sleeping|collision_points)|pointer_(?:invalid|null)|room|room_(?:caption|first|height|last|persistent|speed|width)|score|secure_mode|show_(?:health|lives|score)|solid|speed|sprite_(?:height|index|width|xoffset|yoffset)|temp_directory|timeline_(?:index|loop|position|running|speed)|transition_(?:color|kind|steps)|undefined|view_(?:angle|current|enabled|(?:h|v)(?:border|speed)|(?:h|w|x|y)port|(?:h|w|x|y)view|object|surface_id|visible)|visible|webgl_enabled|working_directory|(?:x|y)(?:previous|start)|x|y|argument(?:_relitive|_count|\d)|argument|global|local|other|self)\b/
        });
      }
      return gml_1;
    }
    var gn_1;
    var hasRequiredGn;
    function requireGn() {
      if (hasRequiredGn)
        return gn_1;
      hasRequiredGn = 1;
      gn_1 = gn;
      gn.displayName = "gn";
      gn.aliases = ["gni"];
      function gn(Prism2) {
        Prism2.languages.gn = {
          comment: {
            pattern: /#.*/,
            greedy: true
          },
          "string-literal": {
            pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
            lookbehind: true,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
                lookbehind: true,
                inside: {
                  number: /^\$0x[\s\S]{2}$/,
                  variable: /^\$\w+$/,
                  "interpolation-punctuation": {
                    pattern: /^\$\{|\}$/,
                    alias: "punctuation"
                  },
                  expression: {
                    pattern: /[\s\S]+/,
                    inside: null
                    // see below
                  }
                }
              },
              string: /[\s\S]+/
            }
          },
          keyword: /\b(?:else|if)\b/,
          boolean: /\b(?:false|true)\b/,
          "builtin-function": {
            // a few functions get special highlighting to improve readability
            pattern: /\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
            alias: "keyword"
          },
          function: /\b[a-z_]\w*(?=\s*\()/i,
          constant: /\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_os|target_out_dir)\b/,
          number: /-?\b\d+\b/,
          operator: /[-+!=<>]=?|&&|\|\|/,
          punctuation: /[(){}[\],.]/
        };
        Prism2.languages.gn["string-literal"].inside["interpolation"].inside["expression"].inside = Prism2.languages.gn;
        Prism2.languages.gni = Prism2.languages.gn;
      }
      return gn_1;
    }
    var goModule_1;
    var hasRequiredGoModule;
    function requireGoModule() {
      if (hasRequiredGoModule)
        return goModule_1;
      hasRequiredGoModule = 1;
      goModule_1 = goModule;
      goModule.displayName = "goModule";
      goModule.aliases = [];
      function goModule(Prism2) {
        Prism2.languages["go-mod"] = Prism2.languages["go-module"] = {
          comment: {
            pattern: /\/\/.*/,
            greedy: true
          },
          version: {
            pattern: /(^|[\s()[\],])v\d+\.\d+\.\d+(?:[+-][-+.\w]*)?(?![^\s()[\],])/,
            lookbehind: true,
            alias: "number"
          },
          "go-version": {
            pattern: /((?:^|\s)go\s+)\d+(?:\.\d+){1,2}/,
            lookbehind: true,
            alias: "number"
          },
          keyword: {
            pattern: /^([ \t]*)(?:exclude|go|module|replace|require|retract)\b/m,
            lookbehind: true
          },
          operator: /=>/,
          punctuation: /[()[\],]/
        };
      }
      return goModule_1;
    }
    var go_1;
    var hasRequiredGo;
    function requireGo() {
      if (hasRequiredGo)
        return go_1;
      hasRequiredGo = 1;
      go_1 = go;
      go.displayName = "go";
      go.aliases = [];
      function go(Prism2) {
        Prism2.languages.go = Prism2.languages.extend("clike", {
          string: {
            pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
            lookbehind: true,
            greedy: true
          },
          keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
          boolean: /\b(?:_|false|iota|nil|true)\b/,
          number: [
            // binary and octal integers
            /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
            // hexadecimal integers and floats
            /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
            // decimal integers and floats
            /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
          ],
          operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
          builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
        });
        Prism2.languages.insertBefore("go", "string", {
          char: {
            pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
            greedy: true
          }
        });
        delete Prism2.languages.go["class-name"];
      }
      return go_1;
    }
    var graphql_1;
    var hasRequiredGraphql;
    function requireGraphql() {
      if (hasRequiredGraphql)
        return graphql_1;
      hasRequiredGraphql = 1;
      graphql_1 = graphql;
      graphql.displayName = "graphql";
      graphql.aliases = [];
      function graphql(Prism2) {
        Prism2.languages.graphql = {
          comment: /#.*/,
          description: {
            pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
            greedy: true,
            alias: "string",
            inside: {
              "language-markdown": {
                pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
                lookbehind: true,
                inside: Prism2.languages.markdown
              }
            }
          },
          string: {
            pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
            greedy: true
          },
          number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
          boolean: /\b(?:false|true)\b/,
          variable: /\$[a-z_]\w*/i,
          directive: {
            pattern: /@[a-z_]\w*/i,
            alias: "function"
          },
          "attr-name": {
            pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
            greedy: true
          },
          "atom-input": {
            pattern: /\b[A-Z]\w*Input\b/,
            alias: "class-name"
          },
          scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
          constant: /\b[A-Z][A-Z_\d]*\b/,
          "class-name": {
            pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
            lookbehind: true
          },
          fragment: {
            pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
            lookbehind: true,
            alias: "function"
          },
          "definition-mutation": {
            pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
            lookbehind: true,
            alias: "function"
          },
          "definition-query": {
            pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
            lookbehind: true,
            alias: "function"
          },
          keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
          operator: /[!=|&]|\.{3}/,
          "property-query": /\w+(?=\s*\()/,
          object: /\w+(?=\s*\{)/,
          punctuation: /[!(){}\[\]:=,]/,
          property: /\w+/
        };
        Prism2.hooks.add("after-tokenize", function afterTokenizeGraphql(env2) {
          if (env2.language !== "graphql") {
            return;
          }
          var validTokens = env2.tokens.filter(function(token) {
            return typeof token !== "string" && token.type !== "comment" && token.type !== "scalar";
          });
          var currentIndex = 0;
          function getToken(offset) {
            return validTokens[currentIndex + offset];
          }
          function isTokenType(types2, offset) {
            offset = offset || 0;
            for (var i2 = 0; i2 < types2.length; i2++) {
              var token = getToken(i2 + offset);
              if (!token || token.type !== types2[i2]) {
                return false;
              }
            }
            return true;
          }
          function findClosingBracket(open, close) {
            var stackHeight = 1;
            for (var i2 = currentIndex; i2 < validTokens.length; i2++) {
              var token = validTokens[i2];
              var content2 = token.content;
              if (token.type === "punctuation" && typeof content2 === "string") {
                if (open.test(content2)) {
                  stackHeight++;
                } else if (close.test(content2)) {
                  stackHeight--;
                  if (stackHeight === 0) {
                    return i2;
                  }
                }
              }
            }
            return -1;
          }
          function addAlias(token, alias2) {
            var aliases = token.alias;
            if (!aliases) {
              token.alias = aliases = [];
            } else if (!Array.isArray(aliases)) {
              token.alias = aliases = [aliases];
            }
            aliases.push(alias2);
          }
          for (; currentIndex < validTokens.length; ) {
            var startToken = validTokens[currentIndex++];
            if (startToken.type === "keyword" && startToken.content === "mutation") {
              var inputVariables = [];
              if (isTokenType(["definition-mutation", "punctuation"]) && getToken(1).content === "(") {
                currentIndex += 2;
                var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
                if (definitionEnd === -1) {
                  continue;
                }
                for (; currentIndex < definitionEnd; currentIndex++) {
                  var t2 = getToken(0);
                  if (t2.type === "variable") {
                    addAlias(t2, "variable-input");
                    inputVariables.push(t2.content);
                  }
                }
                currentIndex = definitionEnd + 1;
              }
              if (isTokenType(["punctuation", "property-query"]) && getToken(0).content === "{") {
                currentIndex++;
                addAlias(getToken(0), "property-mutation");
                if (inputVariables.length > 0) {
                  var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
                  if (mutationEnd === -1) {
                    continue;
                  }
                  for (var i = currentIndex; i < mutationEnd; i++) {
                    var varToken = validTokens[i];
                    if (varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0) {
                      addAlias(varToken, "variable-input");
                    }
                  }
                }
              }
            }
          }
        });
      }
      return graphql_1;
    }
    var groovy_1;
    var hasRequiredGroovy;
    function requireGroovy() {
      if (hasRequiredGroovy)
        return groovy_1;
      hasRequiredGroovy = 1;
      groovy_1 = groovy;
      groovy.displayName = "groovy";
      groovy.aliases = [];
      function groovy(Prism2) {
        Prism2.languages.groovy = Prism2.languages.extend("clike", {
          string: [
            {
              // https://groovy-lang.org/syntax.html#_dollar_slashy_string
              pattern: /("""|''')(?:[^\\]|\\[\s\S])*?\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
              greedy: true
            },
            {
              // TODO: Slash strings (e.g. /foo/) can contain line breaks but this will cause a lot of trouble with
              // simple division (see JS regex), so find a fix maybe?
              pattern: /(["'/])(?:\\.|(?!\1)[^\\\r\n])*\1/,
              greedy: true
            }
          ],
          keyword: /\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
          number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
          operator: {
            pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
            lookbehind: true
          },
          punctuation: /\.+|[{}[\];(),:$]/
        });
        Prism2.languages.insertBefore("groovy", "string", {
          shebang: {
            pattern: /#!.+/,
            alias: "comment"
          }
        });
        Prism2.languages.insertBefore("groovy", "punctuation", {
          "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/
        });
        Prism2.languages.insertBefore("groovy", "function", {
          annotation: {
            pattern: /(^|[^.])@\w+/,
            lookbehind: true,
            alias: "punctuation"
          }
        });
        Prism2.hooks.add("wrap", function(env2) {
          if (env2.language === "groovy" && env2.type === "string") {
            var delimiter = env2.content.value[0];
            if (delimiter != "'") {
              var pattern = /([^\\])(?:\$(?:\{.*?\}|[\w.]+))/;
              if (delimiter === "$") {
                pattern = /([^\$])(?:\$(?:\{.*?\}|[\w.]+))/;
              }
              env2.content.value = env2.content.value.replace(/&lt;/g, "<").replace(/&amp;/g, "&");
              env2.content = Prism2.highlight(env2.content.value, {
                expression: {
                  pattern,
                  lookbehind: true,
                  inside: Prism2.languages.groovy
                }
              });
              env2.classes.push(delimiter === "/" ? "regex" : "gstring");
            }
          }
        });
      }
      return groovy_1;
    }
    var haml_1;
    var hasRequiredHaml;
    function requireHaml() {
      if (hasRequiredHaml)
        return haml_1;
      hasRequiredHaml = 1;
      var refractorRuby = requireRuby();
      haml_1 = haml;
      haml.displayName = "haml";
      haml.aliases = [];
      function haml(Prism2) {
        Prism2.register(refractorRuby);
        (function(Prism3) {
          Prism3.languages.haml = {
            // Multiline stuff should appear before the rest
            "multiline-comment": {
              pattern: /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ].+)*/,
              lookbehind: true,
              alias: "comment"
            },
            "multiline-code": [
              {
                pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
                lookbehind: true,
                inside: Prism3.languages.ruby
              },
              {
                pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
                lookbehind: true,
                inside: Prism3.languages.ruby
              }
            ],
            // See at the end of the file for known filters
            filter: {
              pattern: /((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/,
              lookbehind: true,
              inside: {
                "filter-name": {
                  pattern: /^:[\w-]+/,
                  alias: "symbol"
                }
              }
            },
            markup: {
              pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
              lookbehind: true,
              inside: Prism3.languages.markup
            },
            doctype: {
              pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
              lookbehind: true
            },
            tag: {
              // Allows for one nested group of braces
              pattern: /((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^{}])+\}|\[[^\]]+\])*[\/<>]*/,
              lookbehind: true,
              inside: {
                attributes: [
                  {
                    // Lookbehind tries to prevent interpolations from breaking it all
                    // Allows for one nested group of braces
                    pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
                    lookbehind: true,
                    inside: Prism3.languages.ruby
                  },
                  {
                    pattern: /\([^)]+\)/,
                    inside: {
                      "attr-value": {
                        pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
                        lookbehind: true
                      },
                      "attr-name": /[\w:-]+(?=\s*!?=|\s*[,)])/,
                      punctuation: /[=(),]/
                    }
                  },
                  {
                    pattern: /\[[^\]]+\]/,
                    inside: Prism3.languages.ruby
                  }
                ],
                punctuation: /[<>]/
              }
            },
            code: {
              pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
              lookbehind: true,
              inside: Prism3.languages.ruby
            },
            // Interpolations in plain text
            interpolation: {
              pattern: /#\{[^}]+\}/,
              inside: {
                delimiter: {
                  pattern: /^#\{|\}$/,
                  alias: "punctuation"
                },
                ruby: {
                  pattern: /[\s\S]+/,
                  inside: Prism3.languages.ruby
                }
              }
            },
            punctuation: {
              pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
              lookbehind: true
            }
          };
          var filter_pattern = "((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+";
          var filters = [
            "css",
            {
              filter: "coffee",
              language: "coffeescript"
            },
            "erb",
            "javascript",
            "less",
            "markdown",
            "ruby",
            "scss",
            "textile"
          ];
          var all_filters = {};
          for (var i = 0, l2 = filters.length; i < l2; i++) {
            var filter = filters[i];
            filter = typeof filter === "string" ? {
              filter,
              language: filter
            } : filter;
            if (Prism3.languages[filter.language]) {
              all_filters["filter-" + filter.filter] = {
                pattern: RegExp(
                  filter_pattern.replace("{{filter_name}}", function() {
                    return filter.filter;
                  })
                ),
                lookbehind: true,
                inside: {
                  "filter-name": {
                    pattern: /^:[\w-]+/,
                    alias: "symbol"
                  },
                  text: {
                    pattern: /[\s\S]+/,
                    alias: [filter.language, "language-" + filter.language],
                    inside: Prism3.languages[filter.language]
                  }
                }
              };
            }
          }
          Prism3.languages.insertBefore("haml", "filter", all_filters);
        })(Prism2);
      }
      return haml_1;
    }
    var handlebars_1;
    var hasRequiredHandlebars;
    function requireHandlebars() {
      if (hasRequiredHandlebars)
        return handlebars_1;
      hasRequiredHandlebars = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      handlebars_1 = handlebars;
      handlebars.displayName = "handlebars";
      handlebars.aliases = ["hbs"];
      function handlebars(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        (function(Prism3) {
          Prism3.languages.handlebars = {
            comment: /\{\{![\s\S]*?\}\}/,
            delimiter: {
              pattern: /^\{\{\{?|\}\}\}?$/,
              alias: "punctuation"
            },
            string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
            boolean: /\b(?:false|true)\b/,
            block: {
              pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
              lookbehind: true,
              alias: "keyword"
            },
            brackets: {
              pattern: /\[[^\]]+\]/,
              inside: {
                punctuation: /\[|\]/,
                variable: /[\s\S]+/
              }
            },
            punctuation: /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
            variable: /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
          };
          Prism3.hooks.add("before-tokenize", function(env2) {
            var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
            Prism3.languages["markup-templating"].buildPlaceholders(
              env2,
              "handlebars",
              handlebarsPattern
            );
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            Prism3.languages["markup-templating"].tokenizePlaceholders(
              env2,
              "handlebars"
            );
          });
          Prism3.languages.hbs = Prism3.languages.handlebars;
        })(Prism2);
      }
      return handlebars_1;
    }
    var haskell_1;
    var hasRequiredHaskell;
    function requireHaskell() {
      if (hasRequiredHaskell)
        return haskell_1;
      hasRequiredHaskell = 1;
      haskell_1 = haskell;
      haskell.displayName = "haskell";
      haskell.aliases = ["hs"];
      function haskell(Prism2) {
        Prism2.languages.haskell = {
          comment: {
            pattern: /(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\/].*|$)|\{-[\s\S]*?-\})/m,
            lookbehind: true
          },
          char: {
            pattern: /'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|ACK|BEL|BS|CAN|CR|DC1|DC2|DC3|DC4|DEL|DLE|EM|ENQ|EOT|ESC|ETB|ETX|FF|FS|GS|HT|LF|NAK|NUL|RS|SI|SO|SOH|SP|STX|SUB|SYN|US|VT|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
            alias: "string"
          },
          string: {
            pattern: /"(?:[^\\"]|\\(?:\S|\s+\\))*"/,
            greedy: true
          },
          keyword: /\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
          "import-statement": {
            // The imported or hidden names are not included in this import
            // statement. This is because we want to highlight those exactly like
            // we do for the names in the program.
            pattern: /(^[\t ]*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
            lookbehind: true,
            inside: {
              keyword: /\b(?:as|hiding|import|qualified)\b/,
              punctuation: /\./
            }
          },
          // These are builtin variables only. Constructors are highlighted later as a constant.
          builtin: /\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
          // decimal integers and floating point numbers | octal integers | hexadecimal integers
          number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
          operator: [
            {
              // infix operator
              pattern: /`(?:[A-Z][\w']*\.)*[_a-z][\w']*`/,
              greedy: true
            },
            {
              // function composition
              pattern: /(\s)\.(?=\s)/,
              lookbehind: true
            },
            // Most of this is needed because of the meaning of a single '.'.
            // If it stands alone freely, it is the function composition.
            // It may also be a separator between a module name and an identifier => no
            // operator. If it comes together with other special characters it is an
            // operator too.
            //
            // This regex means: /[-!#$%*+=?&@|~.:<>^\\\/]+/ without /\./.
            /[-!#$%*+=?&@|~:<>^\\\/][-!#$%*+=?&@|~.:<>^\\\/]*|\.[-!#$%*+=?&@|~.:<>^\\\/]+/
          ],
          // In Haskell, nearly everything is a variable, do not highlight these.
          hvariable: {
            pattern: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*/,
            inside: {
              punctuation: /\./
            }
          },
          constant: {
            pattern: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*/,
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[{}[\];(),.:]/
        };
        Prism2.languages.hs = Prism2.languages.haskell;
      }
      return haskell_1;
    }
    var haxe_1;
    var hasRequiredHaxe;
    function requireHaxe() {
      if (hasRequiredHaxe)
        return haxe_1;
      hasRequiredHaxe = 1;
      haxe_1 = haxe;
      haxe.displayName = "haxe";
      haxe.aliases = [];
      function haxe(Prism2) {
        Prism2.languages.haxe = Prism2.languages.extend("clike", {
          string: {
            // Strings can be multi-line
            pattern: /"(?:[^"\\]|\\[\s\S])*"/,
            greedy: true
          },
          "class-name": [
            {
              pattern: /(\b(?:abstract|class|enum|extends|implements|interface|new|typedef)\s+)[A-Z_]\w*/,
              lookbehind: true
            },
            // based on naming convention
            /\b[A-Z]\w*/
          ],
          // The final look-ahead prevents highlighting of keywords if expressions such as "haxe.macro.Expr"
          keyword: /\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|final|for|from|function|if|implements|import|in|inline|interface|macro|new|null|operator|overload|override|package|private|public|return|static|super|switch|throw|to|try|typedef|untyped|using|var|while)(?!\.)\b/,
          function: {
            pattern: /\b[a-z_]\w*(?=\s*(?:<[^<>]*>\s*)?\()/i,
            greedy: true
          },
          operator: /\.{3}|\+\+|--|&&|\|\||->|=>|(?:<<?|>{1,3}|[-+*/%!=&|^])=?|[?:~]/
        });
        Prism2.languages.insertBefore("haxe", "string", {
          "string-interpolation": {
            pattern: /'(?:[^'\\]|\\[\s\S])*'/,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /(^|[^\\])\$(?:\w+|\{[^{}]+\})/,
                lookbehind: true,
                inside: {
                  "interpolation-punctuation": {
                    pattern: /^\$\{?|\}$/,
                    alias: "punctuation"
                  },
                  expression: {
                    pattern: /[\s\S]+/,
                    inside: Prism2.languages.haxe
                  }
                }
              },
              string: /[\s\S]+/
            }
          }
        });
        Prism2.languages.insertBefore("haxe", "class-name", {
          regex: {
            pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[a-z]*/,
            greedy: true,
            inside: {
              "regex-flags": /\b[a-z]+$/,
              "regex-source": {
                pattern: /^(~\/)[\s\S]+(?=\/$)/,
                lookbehind: true,
                alias: "language-regex",
                inside: Prism2.languages.regex
              },
              "regex-delimiter": /^~\/|\/$/
            }
          }
        });
        Prism2.languages.insertBefore("haxe", "keyword", {
          preprocessor: {
            pattern: /#(?:else|elseif|end|if)\b.*/,
            alias: "property"
          },
          metadata: {
            pattern: /@:?[\w.]+/,
            alias: "symbol"
          },
          reification: {
            pattern: /\$(?:\w+|(?=\{))/,
            alias: "important"
          }
        });
      }
      return haxe_1;
    }
    var hcl_1;
    var hasRequiredHcl;
    function requireHcl() {
      if (hasRequiredHcl)
        return hcl_1;
      hasRequiredHcl = 1;
      hcl_1 = hcl;
      hcl.displayName = "hcl";
      hcl.aliases = [];
      function hcl(Prism2) {
        Prism2.languages.hcl = {
          comment: /(?:\/\/|#).*|\/\*[\s\S]*?(?:\*\/|$)/,
          heredoc: {
            pattern: /<<-?(\w+\b)[\s\S]*?^[ \t]*\1/m,
            greedy: true,
            alias: "string"
          },
          keyword: [
            {
              pattern: /(?:data|resource)\s+(?:"(?:\\[\s\S]|[^\\"])*")(?=\s+"[\w-]+"\s+\{)/i,
              inside: {
                type: {
                  pattern: /(resource|data|\s+)(?:"(?:\\[\s\S]|[^\\"])*")/i,
                  lookbehind: true,
                  alias: "variable"
                }
              }
            },
            {
              pattern: /(?:backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+(?=\{)/i,
              inside: {
                type: {
                  pattern: /(backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+/i,
                  lookbehind: true,
                  alias: "variable"
                }
              }
            },
            /[\w-]+(?=\s+\{)/
          ],
          property: [/[-\w\.]+(?=\s*=(?!=))/, /"(?:\\[\s\S]|[^\\"])+"(?=\s*[:=])/],
          string: {
            pattern: /"(?:[^\\$"]|\\[\s\S]|\$(?:(?=")|\$+(?!\$)|[^"${])|\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\})*"/,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /(^|[^$])\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\}/,
                lookbehind: true,
                inside: {
                  type: {
                    pattern: /(\b(?:count|data|local|module|path|self|terraform|var)\b\.)[\w\*]+/i,
                    lookbehind: true,
                    alias: "variable"
                  },
                  keyword: /\b(?:count|data|local|module|path|self|terraform|var)\b/i,
                  function: /\w+(?=\()/,
                  string: {
                    pattern: /"(?:\\[\s\S]|[^\\"])*"/,
                    greedy: true
                  },
                  number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
                  punctuation: /[!\$#%&'()*+,.\/;<=>@\[\\\]^`{|}~?:]/
                }
              }
            }
          },
          number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
          boolean: /\b(?:false|true)\b/i,
          punctuation: /[=\[\]{}]/
        };
      }
      return hcl_1;
    }
    var hlsl_1;
    var hasRequiredHlsl;
    function requireHlsl() {
      if (hasRequiredHlsl)
        return hlsl_1;
      hasRequiredHlsl = 1;
      var refractorC = requireC();
      hlsl_1 = hlsl;
      hlsl.displayName = "hlsl";
      hlsl.aliases = [];
      function hlsl(Prism2) {
        Prism2.register(refractorC);
        Prism2.languages.hlsl = Prism2.languages.extend("c", {
          // Regarding keywords and class names:
          // The list of all keywords was split into 'keyword' and 'class-name' tokens based on whether they are capitalized.
          // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-keywords
          // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-reserved-words
          "class-name": [
            Prism2.languages.c["class-name"],
            /\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\b/
          ],
          keyword: [
            // HLSL keyword
            /\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\b/,
            // scalar, vector, and matrix types
            /\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\b/
          ],
          // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-grammar#floating-point-numbers
          number: /(?:(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?|\b0x[\da-fA-F]+)[fFhHlLuU]?\b/,
          boolean: /\b(?:false|true)\b/
        });
      }
      return hlsl_1;
    }
    var hoon_1;
    var hasRequiredHoon;
    function requireHoon() {
      if (hasRequiredHoon)
        return hoon_1;
      hasRequiredHoon = 1;
      hoon_1 = hoon;
      hoon.displayName = "hoon";
      hoon.aliases = [];
      function hoon(Prism2) {
        Prism2.languages.hoon = {
          comment: {
            pattern: /::.*/,
            greedy: true
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          constant: /%(?:\.[ny]|[\w-]+)/,
          "class-name": /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
          function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
          keyword: /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
        };
      }
      return hoon_1;
    }
    var hpkp_1;
    var hasRequiredHpkp;
    function requireHpkp() {
      if (hasRequiredHpkp)
        return hpkp_1;
      hasRequiredHpkp = 1;
      hpkp_1 = hpkp;
      hpkp.displayName = "hpkp";
      hpkp.aliases = [];
      function hpkp(Prism2) {
        Prism2.languages.hpkp = {
          directive: {
            pattern: /\b(?:includeSubDomains|max-age|pin-sha256|preload|report-to|report-uri|strict)(?=[\s;=]|$)/i,
            alias: "property"
          },
          operator: /=/,
          punctuation: /;/
        };
      }
      return hpkp_1;
    }
    var hsts_1;
    var hasRequiredHsts;
    function requireHsts() {
      if (hasRequiredHsts)
        return hsts_1;
      hasRequiredHsts = 1;
      hsts_1 = hsts;
      hsts.displayName = "hsts";
      hsts.aliases = [];
      function hsts(Prism2) {
        Prism2.languages.hsts = {
          directive: {
            pattern: /\b(?:includeSubDomains|max-age|preload)(?=[\s;=]|$)/i,
            alias: "property"
          },
          operator: /=/,
          punctuation: /;/
        };
      }
      return hsts_1;
    }
    var http_1;
    var hasRequiredHttp;
    function requireHttp() {
      if (hasRequiredHttp)
        return http_1;
      hasRequiredHttp = 1;
      http_1 = http;
      http.displayName = "http";
      http.aliases = [];
      function http(Prism2) {
        (function(Prism3) {
          function headerValueOf(name2) {
            return RegExp("(^(?:" + name2 + "):[ 	]*(?![ 	]))[^]+", "i");
          }
          Prism3.languages.http = {
            "request-line": {
              pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
              inside: {
                // HTTP Method
                method: {
                  pattern: /^[A-Z]+\b/,
                  alias: "property"
                },
                // Request Target e.g. http://example.com, /path/to/file
                "request-target": {
                  pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
                  lookbehind: true,
                  alias: "url",
                  inside: Prism3.languages.uri
                },
                // HTTP Version
                "http-version": {
                  pattern: /^(\s)HTTP\/[\d.]+/,
                  lookbehind: true,
                  alias: "property"
                }
              }
            },
            "response-status": {
              pattern: /^HTTP\/[\d.]+ \d+ .+/m,
              inside: {
                // HTTP Version
                "http-version": {
                  pattern: /^HTTP\/[\d.]+/,
                  alias: "property"
                },
                // Status Code
                "status-code": {
                  pattern: /^(\s)\d+(?=\s)/,
                  lookbehind: true,
                  alias: "number"
                },
                // Reason Phrase
                "reason-phrase": {
                  pattern: /^(\s).+/,
                  lookbehind: true,
                  alias: "string"
                }
              }
            },
            header: {
              pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
              inside: {
                "header-value": [
                  {
                    pattern: headerValueOf(/Content-Security-Policy/.source),
                    lookbehind: true,
                    alias: ["csp", "languages-csp"],
                    inside: Prism3.languages.csp
                  },
                  {
                    pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),
                    lookbehind: true,
                    alias: ["hpkp", "languages-hpkp"],
                    inside: Prism3.languages.hpkp
                  },
                  {
                    pattern: headerValueOf(/Strict-Transport-Security/.source),
                    lookbehind: true,
                    alias: ["hsts", "languages-hsts"],
                    inside: Prism3.languages.hsts
                  },
                  {
                    pattern: headerValueOf(/[^:]+/.source),
                    lookbehind: true
                  }
                ],
                "header-name": {
                  pattern: /^[^:]+/,
                  alias: "keyword"
                },
                punctuation: /^:/
              }
            }
          };
          var langs = Prism3.languages;
          var httpLanguages = {
            "application/javascript": langs.javascript,
            "application/json": langs.json || langs.javascript,
            "application/xml": langs.xml,
            "text/xml": langs.xml,
            "text/html": langs.html,
            "text/css": langs.css,
            "text/plain": langs.plain
          };
          var suffixTypes = {
            "application/json": true,
            "application/xml": true
          };
          function getSuffixPattern(contentType2) {
            var suffix = contentType2.replace(/^[a-z]+\//, "");
            var suffixPattern = "\\w+/(?:[\\w.-]+\\+)+" + suffix + "(?![+\\w.-])";
            return "(?:" + contentType2 + "|" + suffixPattern + ")";
          }
          var options;
          for (var contentType in httpLanguages) {
            if (httpLanguages[contentType]) {
              options = options || {};
              var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;
              options[contentType.replace(/\//g, "-")] = {
                pattern: RegExp(
                  "(" + /content-type:\s*/.source + pattern + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // This is a little interesting:
                  // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
                  // However, when writing code by hand (e.g. to display on a website) people can forget about this,
                  // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
                  // the body does not start with a [\w-] character (as headers do).
                  /[^ \t\w-][\s\S]*/.source,
                  "i"
                ),
                lookbehind: true,
                inside: httpLanguages[contentType]
              };
            }
          }
          if (options) {
            Prism3.languages.insertBefore("http", "header", options);
          }
        })(Prism2);
      }
      return http_1;
    }
    var ichigojam_1;
    var hasRequiredIchigojam;
    function requireIchigojam() {
      if (hasRequiredIchigojam)
        return ichigojam_1;
      hasRequiredIchigojam = 1;
      ichigojam_1 = ichigojam;
      ichigojam.displayName = "ichigojam";
      ichigojam.aliases = [];
      function ichigojam(Prism2) {
        Prism2.languages.ichigojam = {
          comment: /(?:\B'|REM)(?:[^\n\r]*)/i,
          string: {
            pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
            greedy: true
          },
          number: /\B#[0-9A-F]+|\B`[01]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
          keyword: /\b(?:BEEP|BPS|CASE|CLEAR|CLK|CLO|CLP|CLS|CLT|CLV|CONT|COPY|ELSE|END|FILE|FILES|FOR|GOSUB|GOTO|GSB|IF|INPUT|KBD|LED|LET|LIST|LOAD|LOCATE|LRUN|NEW|NEXT|OUT|PLAY|POKE|PRINT|PWM|REM|RENUM|RESET|RETURN|RIGHT|RTN|RUN|SAVE|SCROLL|SLEEP|SRND|STEP|STOP|SUB|TEMPO|THEN|TO|UART|VIDEO|WAIT)(?:\$|\b)/i,
          function: /\b(?:ABS|ANA|ASC|BIN|BTN|DEC|END|FREE|HELP|HEX|I2CR|I2CW|IN|INKEY|LEN|LINE|PEEK|RND|SCR|SOUND|STR|TICK|USR|VER|VPEEK|ZER)(?:\$|\b)/i,
          label: /(?:\B@\S+)/,
          operator: /<[=>]?|>=?|\|\||&&|[+\-*\/=|&^~!]|\b(?:AND|NOT|OR)\b/i,
          punctuation: /[\[,;:()\]]/
        };
      }
      return ichigojam_1;
    }
    var icon_1;
    var hasRequiredIcon;
    function requireIcon() {
      if (hasRequiredIcon)
        return icon_1;
      hasRequiredIcon = 1;
      icon_1 = icon;
      icon.displayName = "icon";
      icon.aliases = [];
      function icon(Prism2) {
        Prism2.languages.icon = {
          comment: /#.*/,
          string: {
            pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
            greedy: true
          },
          number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
          "builtin-keyword": {
            pattern: /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
            alias: "variable"
          },
          directive: {
            pattern: /\$\w+/,
            alias: "builtin"
          },
          keyword: /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
          function: /\b(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
          operator: /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
          punctuation: /[\[\](){},;]/
        };
      }
      return icon_1;
    }
    var icuMessageFormat_1;
    var hasRequiredIcuMessageFormat;
    function requireIcuMessageFormat() {
      if (hasRequiredIcuMessageFormat)
        return icuMessageFormat_1;
      hasRequiredIcuMessageFormat = 1;
      icuMessageFormat_1 = icuMessageFormat;
      icuMessageFormat.displayName = "icuMessageFormat";
      icuMessageFormat.aliases = [];
      function icuMessageFormat(Prism2) {
        (function(Prism3) {
          function nested(source, level) {
            if (level <= 0) {
              return /[]/.source;
            } else {
              return source.replace(/<SELF>/g, function() {
                return nested(source, level - 1);
              });
            }
          }
          var stringPattern = /'[{}:=,](?:[^']|'')*'(?!')/;
          var escape2 = {
            pattern: /''/,
            greedy: true,
            alias: "operator"
          };
          var string2 = {
            pattern: stringPattern,
            greedy: true,
            inside: {
              escape: escape2
            }
          };
          var argumentSource = nested(
            /\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(
              /<STR>/g,
              function() {
                return stringPattern.source;
              }
            ),
            8
          );
          var nestedMessage = {
            pattern: RegExp(argumentSource),
            inside: {
              message: {
                pattern: /^(\{)[\s\S]+(?=\}$)/,
                lookbehind: true,
                inside: null
                // see below
              },
              "message-delimiter": {
                pattern: /./,
                alias: "punctuation"
              }
            }
          };
          Prism3.languages["icu-message-format"] = {
            argument: {
              pattern: RegExp(argumentSource),
              greedy: true,
              inside: {
                content: {
                  pattern: /^(\{)[\s\S]+(?=\}$)/,
                  lookbehind: true,
                  inside: {
                    "argument-name": {
                      pattern: /^(\s*)[^{}:=,\s]+/,
                      lookbehind: true
                    },
                    "choice-style": {
                      // https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1ChoiceFormat.html#details
                      pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
                      lookbehind: true,
                      inside: {
                        punctuation: /\|/,
                        range: {
                          pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
                          lookbehind: true,
                          inside: {
                            operator: /[<#\u2264]/,
                            number: /\S+/
                          }
                        },
                        rest: null
                        // see below
                      }
                    },
                    "plural-style": {
                      // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/PluralFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                      pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
                      lookbehind: true,
                      inside: {
                        offset: /^offset:\s*\d+/,
                        "nested-message": nestedMessage,
                        selector: {
                          pattern: /=\d+|[^{}:=,\s]+/,
                          inside: {
                            keyword: /^(?:few|many|one|other|two|zero)$/
                          }
                        }
                      }
                    },
                    "select-style": {
                      // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/SelectFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                      pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
                      lookbehind: true,
                      inside: {
                        "nested-message": nestedMessage,
                        selector: {
                          pattern: /[^{}:=,\s]+/,
                          inside: {
                            keyword: /^other$/
                          }
                        }
                      }
                    },
                    keyword: /\b(?:choice|plural|select|selectordinal)\b/,
                    "arg-type": {
                      pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/,
                      alias: "keyword"
                    },
                    "arg-skeleton": {
                      pattern: /(,\s*)::[^{}:=,\s]+/,
                      lookbehind: true
                    },
                    "arg-style": {
                      pattern: /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/,
                      lookbehind: true
                    },
                    "arg-style-text": {
                      pattern: RegExp(
                        /(^\s*,\s*(?=\S))/.source + nested(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) + "$"
                      ),
                      lookbehind: true,
                      alias: "string"
                    },
                    punctuation: /,/
                  }
                },
                "argument-delimiter": {
                  pattern: /./,
                  alias: "operator"
                }
              }
            },
            escape: escape2,
            string: string2
          };
          nestedMessage.inside.message.inside = Prism3.languages["icu-message-format"];
          Prism3.languages["icu-message-format"].argument.inside.content.inside["choice-style"].inside.rest = Prism3.languages["icu-message-format"];
        })(Prism2);
      }
      return icuMessageFormat_1;
    }
    var idris_1;
    var hasRequiredIdris;
    function requireIdris() {
      if (hasRequiredIdris)
        return idris_1;
      hasRequiredIdris = 1;
      var refractorHaskell = requireHaskell();
      idris_1 = idris;
      idris.displayName = "idris";
      idris.aliases = ["idr"];
      function idris(Prism2) {
        Prism2.register(refractorHaskell);
        Prism2.languages.idris = Prism2.languages.extend("haskell", {
          comment: {
            pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m
          },
          keyword: /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
          builtin: void 0
        });
        Prism2.languages.insertBefore("idris", "keyword", {
          "import-statement": {
            pattern: /(^\s*import\s+)(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
            lookbehind: true,
            inside: {
              punctuation: /\./
            }
          }
        });
        Prism2.languages.idr = Prism2.languages.idris;
      }
      return idris_1;
    }
    var iecst_1;
    var hasRequiredIecst;
    function requireIecst() {
      if (hasRequiredIecst)
        return iecst_1;
      hasRequiredIecst = 1;
      iecst_1 = iecst;
      iecst.displayName = "iecst";
      iecst.aliases = [];
      function iecst(Prism2) {
        Prism2.languages.iecst = {
          comment: [
            {
              pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\(\*[\s\S]*?(?:\*\)|$)|\{[\s\S]*?(?:\}|$))/,
              lookbehind: true,
              greedy: true
            },
            {
              pattern: /(^|[^\\:])\/\/.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          keyword: [
            /\b(?:END_)?(?:PROGRAM|CONFIGURATION|INTERFACE|FUNCTION_BLOCK|FUNCTION|ACTION|TRANSITION|TYPE|STRUCT|(?:INITIAL_)?STEP|NAMESPACE|LIBRARY|CHANNEL|FOLDER|RESOURCE|VAR_(?:ACCESS|CONFIG|EXTERNAL|GLOBAL|INPUT|IN_OUT|OUTPUT|TEMP)|VAR|METHOD|PROPERTY)\b/i,
            /\b(?:AT|BY|(?:END_)?(?:CASE|FOR|IF|REPEAT|WHILE)|CONSTANT|CONTINUE|DO|ELSE|ELSIF|EXIT|EXTENDS|FROM|GET|GOTO|IMPLEMENTS|JMP|NON_RETAIN|OF|PRIVATE|PROTECTED|PUBLIC|RETAIN|RETURN|SET|TASK|THEN|TO|UNTIL|USING|WITH|__CATCH|__ENDTRY|__FINALLY|__TRY)\b/
          ],
          "class-name": /\b(?:ANY|ARRAY|BOOL|BYTE|U?(?:D|L|S)?INT|(?:D|L)?WORD|DATE(?:_AND_TIME)?|DT|L?REAL|POINTER|STRING|TIME(?:_OF_DAY)?|TOD)\b/,
          address: {
            pattern: /%[IQM][XBWDL][\d.]*|%[IQ][\d.]*/,
            alias: "symbol"
          },
          number: /\b(?:16#[\da-f]+|2#[01_]+|0x[\da-f]+)\b|\b(?:D|DT|T|TOD)#[\d_shmd:]*|\b[A-Z]*#[\d.,_]*|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
          boolean: /\b(?:FALSE|NULL|TRUE)\b/,
          operator: /S?R?:?=>?|&&?|\*\*?|<[=>]?|>=?|[-:^/+#]|\b(?:AND|EQ|EXPT|GE|GT|LE|LT|MOD|NE|NOT|OR|XOR)\b/,
          function: /\b[a-z_]\w*(?=\s*\()/i,
          punctuation: /[()[\].,;]/
        };
      }
      return iecst_1;
    }
    var ignore_1;
    var hasRequiredIgnore;
    function requireIgnore() {
      if (hasRequiredIgnore)
        return ignore_1;
      hasRequiredIgnore = 1;
      ignore_1 = ignore2;
      ignore2.displayName = "ignore";
      ignore2.aliases = ["gitignore", "hgignore", "npmignore"];
      function ignore2(Prism2) {
        (function(Prism3) {
          Prism3.languages.ignore = {
            // https://git-scm.com/docs/gitignore
            comment: /^#.*/m,
            entry: {
              pattern: /\S(?:.*(?:(?:\\ )|\S))?/,
              alias: "string",
              inside: {
                operator: /^!|\*\*?|\?/,
                regex: {
                  pattern: /(^|[^\\])\[[^\[\]]*\]/,
                  lookbehind: true
                },
                punctuation: /\//
              }
            }
          };
          Prism3.languages.gitignore = Prism3.languages.ignore;
          Prism3.languages.hgignore = Prism3.languages.ignore;
          Prism3.languages.npmignore = Prism3.languages.ignore;
        })(Prism2);
      }
      return ignore_1;
    }
    var inform7_1;
    var hasRequiredInform7;
    function requireInform7() {
      if (hasRequiredInform7)
        return inform7_1;
      hasRequiredInform7 = 1;
      inform7_1 = inform7;
      inform7.displayName = "inform7";
      inform7.aliases = [];
      function inform7(Prism2) {
        Prism2.languages.inform7 = {
          string: {
            pattern: /"[^"]*"/,
            inside: {
              substitution: {
                pattern: /\[[^\[\]]+\]/,
                inside: {
                  delimiter: {
                    pattern: /\[|\]/,
                    alias: "punctuation"
                  }
                  // See rest below
                }
              }
            }
          },
          comment: {
            pattern: /\[[^\[\]]+\]/,
            greedy: true
          },
          title: {
            pattern: /^[ \t]*(?:book|chapter|part(?! of)|section|table|volume)\b.+/im,
            alias: "important"
          },
          number: {
            pattern: /(^|[^-])(?:\b\d+(?:\.\d+)?(?:\^\d+)?(?:(?!\d)\w+)?|\b(?:eight|eleven|five|four|nine|one|seven|six|ten|three|twelve|two))\b(?!-)/i,
            lookbehind: true
          },
          verb: {
            pattern: /(^|[^-])\b(?:answering|applying to|are|asking|attacking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:ing|s)?|consulting|contain(?:ing|s)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:s|ve|ving)|hold(?:ing|s)?|impl(?:ies|y)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:ing|s)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:ing|s)?|setting|showing|singing|sleeping|smelling|squeezing|support(?:ing|s)?|swearing|switching|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:ing|s)?|var(?:ies|y|ying)|waiting|waking|waving|wear(?:ing|s)?)\b(?!-)/i,
            lookbehind: true,
            alias: "operator"
          },
          keyword: {
            pattern: /(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|the story|unless)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
            lookbehind: true
          },
          property: {
            pattern: /(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: off| on)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
            lookbehind: true,
            alias: "symbol"
          },
          position: {
            pattern: /(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
            lookbehind: true,
            alias: "keyword"
          },
          type: {
            pattern: /(^|[^-])\b(?:actions?|activit(?:ies|y)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
            lookbehind: true,
            alias: "variable"
          },
          punctuation: /[.,:;(){}]/
        };
        Prism2.languages.inform7["string"].inside["substitution"].inside.rest = Prism2.languages.inform7;
        Prism2.languages.inform7["string"].inside["substitution"].inside.rest.text = {
          pattern: /\S(?:\s*\S)*/,
          alias: "comment"
        };
      }
      return inform7_1;
    }
    var ini_1;
    var hasRequiredIni;
    function requireIni() {
      if (hasRequiredIni)
        return ini_1;
      hasRequiredIni = 1;
      ini_1 = ini;
      ini.displayName = "ini";
      ini.aliases = [];
      function ini(Prism2) {
        Prism2.languages.ini = {
          /**
           * The component mimics the behavior of the Win32 API parser.
           *
           * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
           */
          comment: {
            pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
            lookbehind: true
          },
          section: {
            pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
            lookbehind: true,
            inside: {
              "section-name": {
                pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
                lookbehind: true,
                alias: "selector"
              },
              punctuation: /\[|\]/
            }
          },
          key: {
            pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
            lookbehind: true,
            alias: "attr-name"
          },
          value: {
            pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
            lookbehind: true,
            alias: "attr-value",
            inside: {
              "inner-value": {
                pattern: /^("|').+(?=\1$)/,
                lookbehind: true
              }
            }
          },
          punctuation: /=/
        };
      }
      return ini_1;
    }
    var io_1;
    var hasRequiredIo;
    function requireIo() {
      if (hasRequiredIo)
        return io_1;
      hasRequiredIo = 1;
      io_1 = io;
      io.displayName = "io";
      io.aliases = [];
      function io(Prism2) {
        Prism2.languages.io = {
          comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*|#.*)/,
            lookbehind: true,
            greedy: true
          },
          "triple-quoted-string": {
            pattern: /"""(?:\\[\s\S]|(?!""")[^\\])*"""/,
            greedy: true,
            alias: "string"
          },
          string: {
            pattern: /"(?:\\.|[^\\\r\n"])*"/,
            greedy: true
          },
          keyword: /\b(?:activate|activeCoroCount|asString|block|break|call|catch|clone|collectGarbage|compileString|continue|do|doFile|doMessage|doString|else|elseif|exit|for|foreach|forward|getEnvironmentVariable|getSlot|hasSlot|if|ifFalse|ifNil|ifNilEval|ifTrue|isActive|isNil|isResumable|list|message|method|parent|pass|pause|perform|performWithArgList|print|println|proto|raise|raiseResumable|removeSlot|resend|resume|schedulerSleepSeconds|self|sender|setSchedulerSleepSeconds|setSlot|shallowCopy|slotNames|super|system|then|thisBlock|thisContext|try|type|uniqueId|updateSlot|wait|while|write|yield)\b/,
          builtin: /\b(?:Array|AudioDevice|AudioMixer|BigNum|Block|Box|Buffer|CFunction|CGI|Color|Curses|DBM|DNSResolver|DOConnection|DOProxy|DOServer|Date|Directory|Duration|DynLib|Error|Exception|FFT|File|Fnmatch|Font|Future|GL|GLE|GLScissor|GLU|GLUCylinder|GLUQuadric|GLUSphere|GLUT|Host|Image|Importer|LinkList|List|Lobby|Locals|MD5|MP3Decoder|MP3Encoder|Map|Message|Movie|Notification|Number|Object|OpenGL|Point|Protos|Random|Regex|SGML|SGMLElement|SGMLParser|SQLite|Sequence|Server|ShowMessage|SleepyCat|SleepyCatCursor|Socket|SocketManager|Sound|Soup|Store|String|Tree|UDPSender|UPDReceiver|URL|User|Warning|WeakLink)\b/,
          boolean: /\b(?:false|nil|true)\b/,
          number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?/i,
          operator: /[=!*/%+\-^&|]=|>>?=?|<<?=?|:?:?=|\+\+?|--?|\*\*?|\/\/?|%|\|\|?|&&?|\b(?:and|not|or|return)\b|@@?|\?\??|\.\./,
          punctuation: /[{}[\];(),.:]/
        };
      }
      return io_1;
    }
    var j_1;
    var hasRequiredJ;
    function requireJ() {
      if (hasRequiredJ)
        return j_1;
      hasRequiredJ = 1;
      j_1 = j;
      j.displayName = "j";
      j.aliases = [];
      function j(Prism2) {
        Prism2.languages.j = {
          comment: {
            pattern: /\bNB\..*/,
            greedy: true
          },
          string: {
            pattern: /'(?:''|[^'\r\n])*'/,
            greedy: true
          },
          keyword: /\b(?:(?:CR|LF|adverb|conjunction|def|define|dyad|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
          verb: {
            // Negative look-ahead prevents bad highlighting
            // of ^: ;. =. =: !. !:
            pattern: /(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
            alias: "keyword"
          },
          number: /\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:ad|ar|[ejpx])_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_\b(?!\.))/,
          adverb: {
            pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,
            alias: "builtin"
          },
          operator: /[=a][.:]|_\./,
          conjunction: {
            pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
            alias: "variable"
          },
          punctuation: /[()]/
        };
      }
      return j_1;
    }
    var java_1;
    var hasRequiredJava;
    function requireJava() {
      if (hasRequiredJava)
        return java_1;
      hasRequiredJava = 1;
      java_1 = java;
      java.displayName = "java";
      java.aliases = [];
      function java(Prism2) {
        (function(Prism3) {
          var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
          var classNamePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
          var className = {
            pattern: RegExp(classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
            lookbehind: true,
            inside: {
              namespace: {
                pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
                inside: {
                  punctuation: /\./
                }
              },
              punctuation: /\./
            }
          };
          Prism3.languages.java = Prism3.languages.extend("clike", {
            string: {
              pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
              lookbehind: true,
              greedy: true
            },
            "class-name": [
              className,
              {
                // variables and parameters
                // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
                pattern: RegExp(
                  classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source
                ),
                lookbehind: true,
                inside: className.inside
              }
            ],
            keyword: keywords,
            function: [
              Prism3.languages.clike.function,
              {
                pattern: /(::\s*)[a-z_]\w*/,
                lookbehind: true
              }
            ],
            number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
            operator: {
              pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
              lookbehind: true
            }
          });
          Prism3.languages.insertBefore("java", "string", {
            "triple-quoted-string": {
              // http://openjdk.java.net/jeps/355#Description
              pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
              greedy: true,
              alias: "string"
            },
            char: {
              pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
              greedy: true
            }
          });
          Prism3.languages.insertBefore("java", "class-name", {
            annotation: {
              pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
              lookbehind: true,
              alias: "punctuation"
            },
            generics: {
              pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
              inside: {
                "class-name": className,
                keyword: keywords,
                punctuation: /[<>(),.:]/,
                operator: /[?&|]/
              }
            },
            namespace: {
              pattern: RegExp(
                /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
                  /<keyword>/g,
                  function() {
                    return keywords.source;
                  }
                )
              ),
              lookbehind: true,
              inside: {
                punctuation: /\./
              }
            }
          });
        })(Prism2);
      }
      return java_1;
    }
    var javadoclike_1;
    var hasRequiredJavadoclike;
    function requireJavadoclike() {
      if (hasRequiredJavadoclike)
        return javadoclike_1;
      hasRequiredJavadoclike = 1;
      javadoclike_1 = javadoclike;
      javadoclike.displayName = "javadoclike";
      javadoclike.aliases = [];
      function javadoclike(Prism2) {
        (function(Prism3) {
          var javaDocLike = Prism3.languages.javadoclike = {
            parameter: {
              pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
              lookbehind: true
            },
            keyword: {
              // keywords are the first word in a line preceded be an `@` or surrounded by curly braces.
              // @word, {@word}
              pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
              lookbehind: true
            },
            punctuation: /[{}]/
          };
          function docCommentSupport(lang, callback) {
            var tokenName = "doc-comment";
            var grammar = Prism3.languages[lang];
            if (!grammar) {
              return;
            }
            var token = grammar[tokenName];
            if (!token) {
              var definition2 = {};
              definition2[tokenName] = {
                pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
                lookbehind: true,
                alias: "comment"
              };
              grammar = Prism3.languages.insertBefore(lang, "comment", definition2);
              token = grammar[tokenName];
            }
            if (token instanceof RegExp) {
              token = grammar[tokenName] = {
                pattern: token
              };
            }
            if (Array.isArray(token)) {
              for (var i = 0, l2 = token.length; i < l2; i++) {
                if (token[i] instanceof RegExp) {
                  token[i] = {
                    pattern: token[i]
                  };
                }
                callback(token[i]);
              }
            } else {
              callback(token);
            }
          }
          function addSupport(languages, docLanguage) {
            if (typeof languages === "string") {
              languages = [languages];
            }
            languages.forEach(function(lang) {
              docCommentSupport(lang, function(pattern) {
                if (!pattern.inside) {
                  pattern.inside = {};
                }
                pattern.inside.rest = docLanguage;
              });
            });
          }
          Object.defineProperty(javaDocLike, "addSupport", {
            value: addSupport
          });
          javaDocLike.addSupport(["java", "javascript", "php"], javaDocLike);
        })(Prism2);
      }
      return javadoclike_1;
    }
    var javadoc_1;
    var hasRequiredJavadoc;
    function requireJavadoc() {
      if (hasRequiredJavadoc)
        return javadoc_1;
      hasRequiredJavadoc = 1;
      var refractorJava = requireJava();
      var refractorJavadoclike = requireJavadoclike();
      javadoc_1 = javadoc;
      javadoc.displayName = "javadoc";
      javadoc.aliases = [];
      function javadoc(Prism2) {
        Prism2.register(refractorJava);
        Prism2.register(refractorJavadoclike);
        (function(Prism3) {
          var codeLinePattern = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m;
          var memberReference = /#\s*\w+(?:\s*\([^()]*\))?/.source;
          var reference = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(
            /<mem>/g,
            function() {
              return memberReference;
            }
          );
          Prism3.languages.javadoc = Prism3.languages.extend("javadoclike", {});
          Prism3.languages.insertBefore("javadoc", "keyword", {
            reference: {
              pattern: RegExp(
                /(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/.source + "(?:" + reference + ")"
              ),
              lookbehind: true,
              inside: {
                function: {
                  pattern: /(#\s*)\w+(?=\s*\()/,
                  lookbehind: true
                },
                field: {
                  pattern: /(#\s*)\w+/,
                  lookbehind: true
                },
                namespace: {
                  pattern: /\b(?:[a-z]\w*\s*\.\s*)+/,
                  inside: {
                    punctuation: /\./
                  }
                },
                "class-name": /\b[A-Z]\w*/,
                keyword: Prism3.languages.java.keyword,
                punctuation: /[#()[\],.]/
              }
            },
            "class-name": {
              // @param <T> the first generic type parameter
              pattern: /(@param\s+)<[A-Z]\w*>/,
              lookbehind: true,
              inside: {
                punctuation: /[.<>]/
              }
            },
            "code-section": [
              {
                pattern: /(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/,
                lookbehind: true,
                inside: {
                  code: {
                    // there can't be any HTML inside of {@code} tags
                    pattern: codeLinePattern,
                    lookbehind: true,
                    inside: Prism3.languages.java,
                    alias: "language-java"
                  }
                }
              },
              {
                pattern: /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/,
                lookbehind: true,
                inside: {
                  line: {
                    pattern: codeLinePattern,
                    lookbehind: true,
                    inside: {
                      // highlight HTML tags and entities
                      tag: Prism3.languages.markup.tag,
                      entity: Prism3.languages.markup.entity,
                      code: {
                        // everything else is Java code
                        pattern: /.+/,
                        inside: Prism3.languages.java,
                        alias: "language-java"
                      }
                    }
                  }
                }
              }
            ],
            tag: Prism3.languages.markup.tag,
            entity: Prism3.languages.markup.entity
          });
          Prism3.languages.javadoclike.addSupport("java", Prism3.languages.javadoc);
        })(Prism2);
      }
      return javadoc_1;
    }
    var javastacktrace_1;
    var hasRequiredJavastacktrace;
    function requireJavastacktrace() {
      if (hasRequiredJavastacktrace)
        return javastacktrace_1;
      hasRequiredJavastacktrace = 1;
      javastacktrace_1 = javastacktrace;
      javastacktrace.displayName = "javastacktrace";
      javastacktrace.aliases = [];
      function javastacktrace(Prism2) {
        Prism2.languages.javastacktrace = {
          // java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
          // Caused by: java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
          // Caused by: com.example.myproject.MyProjectServletException
          // Caused by: MidLevelException: LowLevelException
          // Suppressed: Resource$CloseFailException: Resource ID = 0
          summary: {
            pattern: /^([\t ]*)(?:(?:Caused by:|Suppressed:|Exception in thread "[^"]*")[\t ]+)?[\w$.]+(?::.*)?$/m,
            lookbehind: true,
            inside: {
              keyword: {
                pattern: /^([\t ]*)(?:(?:Caused by|Suppressed)(?=:)|Exception in thread)/m,
                lookbehind: true
              },
              // the current thread if the summary starts with 'Exception in thread'
              string: {
                pattern: /^(\s*)"[^"]*"/,
                lookbehind: true
              },
              exceptions: {
                pattern: /^(:?\s*)[\w$.]+(?=:|$)/,
                lookbehind: true,
                inside: {
                  "class-name": /[\w$]+$/,
                  namespace: /\b[a-z]\w*\b/,
                  punctuation: /\./
                }
              },
              message: {
                pattern: /(:\s*)\S.*/,
                lookbehind: true,
                alias: "string"
              },
              punctuation: /:/
            }
          },
          // at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)
          // at org.hsqldb.jdbc.Util.throwError(Unknown Source) here could be some notes
          // at java.base/java.lang.Class.forName0(Native Method)
          // at Util.<init>(Unknown Source)
          // at com.foo.loader/foo@9.0/com.foo.Main.run(Main.java:101)
          // at com.foo.loader//com.foo.bar.App.run(App.java:12)
          // at acme@2.1/org.acme.Lib.test(Lib.java:80)
          // at MyClass.mash(MyClass.java:9)
          //
          // More information:
          // https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/StackTraceElement.html#toString()
          //
          // A valid Java module name is defined as:
          //   "A module name consists of one or more Java identifiers (§3.8) separated by "." tokens."
          // https://docs.oracle.com/javase/specs/jls/se9/html/jls-6.html#jls-ModuleName
          //
          // A Java module version is defined by this class:
          // https://docs.oracle.com/javase/9/docs/api/java/lang/module/ModuleDescriptor.Version.html
          // This is the implementation of the `parse` method in JDK13:
          // https://github.com/matcdac/jdk/blob/2305df71d1b7710266ae0956d73927a225132c0f/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java#L1108
          // However, to keep this simple, a version will be matched by the pattern /@[\w$.+-]*/.
          "stack-frame": {
            pattern: /^([\t ]*)at (?:[\w$./]|@[\w$.+-]*\/)+(?:<init>)?\([^()]*\)/m,
            lookbehind: true,
            inside: {
              keyword: {
                pattern: /^(\s*)at(?= )/,
                lookbehind: true
              },
              source: [
                // (Main.java:15)
                // (Main.scala:15)
                {
                  pattern: /(\()\w+\.\w+:\d+(?=\))/,
                  lookbehind: true,
                  inside: {
                    file: /^\w+\.\w+/,
                    punctuation: /:/,
                    "line-number": {
                      pattern: /\b\d+\b/,
                      alias: "number"
                    }
                  }
                },
                // (Unknown Source)
                // (Native Method)
                // (...something...)
                {
                  pattern: /(\()[^()]*(?=\))/,
                  lookbehind: true,
                  inside: {
                    keyword: /^(?:Native Method|Unknown Source)$/
                  }
                }
              ],
              "class-name": /[\w$]+(?=\.(?:<init>|[\w$]+)\()/,
              function: /(?:<init>|[\w$]+)(?=\()/,
              "class-loader": {
                pattern: /(\s)[a-z]\w*(?:\.[a-z]\w*)*(?=\/[\w@$.]*\/)/,
                lookbehind: true,
                alias: "namespace",
                inside: {
                  punctuation: /\./
                }
              },
              module: {
                pattern: /([\s/])[a-z]\w*(?:\.[a-z]\w*)*(?:@[\w$.+-]*)?(?=\/)/,
                lookbehind: true,
                inside: {
                  version: {
                    pattern: /(@)[\s\S]+/,
                    lookbehind: true,
                    alias: "number"
                  },
                  punctuation: /[@.]/
                }
              },
              namespace: {
                pattern: /(?:\b[a-z]\w*\.)+/,
                inside: {
                  punctuation: /\./
                }
              },
              punctuation: /[()/.]/
            }
          },
          // ... 32 more
          // ... 32 common frames omitted
          more: {
            pattern: /^([\t ]*)\.{3} \d+ [a-z]+(?: [a-z]+)*/m,
            lookbehind: true,
            inside: {
              punctuation: /\.{3}/,
              number: /\d+/,
              keyword: /\b[a-z]+(?: [a-z]+)*\b/
            }
          }
        };
      }
      return javastacktrace_1;
    }
    var jexl_1;
    var hasRequiredJexl;
    function requireJexl() {
      if (hasRequiredJexl)
        return jexl_1;
      hasRequiredJexl = 1;
      jexl_1 = jexl;
      jexl.displayName = "jexl";
      jexl.aliases = [];
      function jexl(Prism2) {
        Prism2.languages.jexl = {
          string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
          transform: {
            pattern: /(\|\s*)[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
            alias: "function",
            lookbehind: true
          },
          function: /[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
          number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
          operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
          boolean: /\b(?:false|true)\b/,
          keyword: /\bin\b/,
          punctuation: /[{}[\](),.]/
        };
      }
      return jexl_1;
    }
    var jolie_1;
    var hasRequiredJolie;
    function requireJolie() {
      if (hasRequiredJolie)
        return jolie_1;
      hasRequiredJolie = 1;
      jolie_1 = jolie;
      jolie.displayName = "jolie";
      jolie.aliases = [];
      function jolie(Prism2) {
        Prism2.languages.jolie = Prism2.languages.extend("clike", {
          string: {
            pattern: /(^|[^\\])"(?:\\[\s\S]|[^"\\])*"/,
            lookbehind: true,
            greedy: true
          },
          "class-name": {
            pattern: /((?:\b(?:as|courier|embed|in|inputPort|outputPort|service)\b|@)[ \t]*)\w+/,
            lookbehind: true
          },
          keyword: /\b(?:as|cH|comp|concurrent|constants|courier|cset|csets|default|define|else|embed|embedded|execution|exit|extender|for|foreach|forward|from|global|if|import|in|include|init|inputPort|install|instanceof|interface|is_defined|linkIn|linkOut|main|new|nullProcess|outputPort|over|private|provide|public|scope|sequential|service|single|spawn|synchronized|this|throw|throws|type|undef|until|while|with)\b/,
          function: /\b[a-z_]\w*(?=[ \t]*[@(])/i,
          number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?l?/i,
          operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[?\/%^@|]/,
          punctuation: /[()[\]{},;.:]/,
          builtin: /\b(?:Byte|any|bool|char|double|enum|float|int|length|long|ranges|regex|string|undefined|void)\b/
        });
        Prism2.languages.insertBefore("jolie", "keyword", {
          aggregates: {
            pattern: /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
            lookbehind: true,
            inside: {
              keyword: /\bwith\b/,
              "class-name": /\w+/,
              punctuation: /,/
            }
          },
          redirects: {
            pattern: /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
            lookbehind: true,
            inside: {
              punctuation: /,/,
              "class-name": /\w+/,
              operator: /=>/
            }
          },
          property: {
            pattern: /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
          }
        });
      }
      return jolie_1;
    }
    var jq_1;
    var hasRequiredJq;
    function requireJq() {
      if (hasRequiredJq)
        return jq_1;
      hasRequiredJq = 1;
      jq_1 = jq;
      jq.displayName = "jq";
      jq.aliases = [];
      function jq(Prism2) {
        (function(Prism3) {
          var interpolation = /\\\((?:[^()]|\([^()]*\))*\)/.source;
          var string2 = RegExp(
            /(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(
              /__/g,
              function() {
                return interpolation;
              }
            )
          );
          var stringInterpolation = {
            interpolation: {
              pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + interpolation),
              lookbehind: true,
              inside: {
                content: {
                  pattern: /^(\\\()[\s\S]+(?=\)$)/,
                  lookbehind: true,
                  inside: null
                  // see below
                },
                punctuation: /^\\\(|\)$/
              }
            }
          };
          var jq2 = Prism3.languages.jq = {
            comment: /#.*/,
            property: {
              pattern: RegExp(string2.source + /(?=\s*:(?!:))/.source),
              lookbehind: true,
              greedy: true,
              inside: stringInterpolation
            },
            string: {
              pattern: string2,
              lookbehind: true,
              greedy: true,
              inside: stringInterpolation
            },
            function: {
              pattern: /(\bdef\s+)[a-z_]\w+/i,
              lookbehind: true
            },
            variable: /\B\$\w+/,
            "property-literal": {
              pattern: /\b[a-z_]\w*(?=\s*:(?!:))/i,
              alias: "property"
            },
            keyword: /\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/,
            boolean: /\b(?:false|true)\b/,
            number: /(?:\b\d+\.|\B\.)?\b\d+(?:[eE][+-]?\d+)?\b/,
            operator: [
              {
                pattern: /\|=?/,
                alias: "pipe"
              },
              /\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|not|or)\b/
            ],
            "c-style-function": {
              pattern: /\b[a-z_]\w*(?=\s*\()/i,
              alias: "function"
            },
            punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/,
            dot: {
              pattern: /\./,
              alias: "important"
            }
          };
          stringInterpolation.interpolation.inside.content.inside = jq2;
        })(Prism2);
      }
      return jq_1;
    }
    var jsExtras_1;
    var hasRequiredJsExtras;
    function requireJsExtras() {
      if (hasRequiredJsExtras)
        return jsExtras_1;
      hasRequiredJsExtras = 1;
      jsExtras_1 = jsExtras;
      jsExtras.displayName = "jsExtras";
      jsExtras.aliases = [];
      function jsExtras(Prism2) {
        (function(Prism3) {
          Prism3.languages.insertBefore("javascript", "function-variable", {
            "method-variable": {
              pattern: RegExp(
                "(\\.\\s*)" + Prism3.languages.javascript["function-variable"].pattern.source
              ),
              lookbehind: true,
              alias: ["function-variable", "method", "function", "property-access"]
            }
          });
          Prism3.languages.insertBefore("javascript", "function", {
            method: {
              pattern: RegExp(
                "(\\.\\s*)" + Prism3.languages.javascript["function"].source
              ),
              lookbehind: true,
              alias: ["function", "property-access"]
            }
          });
          Prism3.languages.insertBefore("javascript", "constant", {
            "known-class-name": [
              {
                // standard built-ins
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
                pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
                alias: "class-name"
              },
              {
                // errors
                pattern: /\b(?:[A-Z]\w*)Error\b/,
                alias: "class-name"
              }
            ]
          });
          function withId(source, flags) {
            return RegExp(
              source.replace(/<ID>/g, function() {
                return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
              }),
              flags
            );
          }
          Prism3.languages.insertBefore("javascript", "keyword", {
            imports: {
              // https://tc39.es/ecma262/#sec-imports
              pattern: withId(
                /(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source
              ),
              lookbehind: true,
              inside: Prism3.languages.javascript
            },
            exports: {
              // https://tc39.es/ecma262/#sec-exports
              pattern: withId(
                /(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source
              ),
              lookbehind: true,
              inside: Prism3.languages.javascript
            }
          });
          Prism3.languages.javascript["keyword"].unshift(
            {
              pattern: /\b(?:as|default|export|from|import)\b/,
              alias: "module"
            },
            {
              pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
              alias: "control-flow"
            },
            {
              pattern: /\bnull\b/,
              alias: ["null", "nil"]
            },
            {
              pattern: /\bundefined\b/,
              alias: "nil"
            }
          );
          Prism3.languages.insertBefore("javascript", "operator", {
            spread: {
              pattern: /\.{3}/,
              alias: "operator"
            },
            arrow: {
              pattern: /=>/,
              alias: "operator"
            }
          });
          Prism3.languages.insertBefore("javascript", "punctuation", {
            "property-access": {
              pattern: withId(/(\.\s*)#?<ID>/.source),
              lookbehind: true
            },
            "maybe-class-name": {
              pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
              lookbehind: true
            },
            dom: {
              // this contains only a few commonly used DOM variables
              pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
              alias: "variable"
            },
            console: {
              pattern: /\bconsole(?=\s*\.)/,
              alias: "class-name"
            }
          });
          var maybeClassNameTokens = [
            "function",
            "function-variable",
            "method",
            "method-variable",
            "property-access"
          ];
          for (var i = 0; i < maybeClassNameTokens.length; i++) {
            var token = maybeClassNameTokens[i];
            var value = Prism3.languages.javascript[token];
            if (Prism3.util.type(value) === "RegExp") {
              value = Prism3.languages.javascript[token] = {
                pattern: value
              };
            }
            var inside = value.inside || {};
            value.inside = inside;
            inside["maybe-class-name"] = /^[A-Z][\s\S]*/;
          }
        })(Prism2);
      }
      return jsExtras_1;
    }
    var jsTemplates_1;
    var hasRequiredJsTemplates;
    function requireJsTemplates() {
      if (hasRequiredJsTemplates)
        return jsTemplates_1;
      hasRequiredJsTemplates = 1;
      jsTemplates_1 = jsTemplates;
      jsTemplates.displayName = "jsTemplates";
      jsTemplates.aliases = [];
      function jsTemplates(Prism2) {
        (function(Prism3) {
          var templateString = Prism3.languages.javascript["template-string"];
          var templateLiteralPattern = templateString.pattern.source;
          var interpolationObject = templateString.inside["interpolation"];
          var interpolationPunctuationObject = interpolationObject.inside["interpolation-punctuation"];
          var interpolationPattern = interpolationObject.pattern.source;
          function createTemplate(language, tag) {
            if (!Prism3.languages[language]) {
              return void 0;
            }
            return {
              pattern: RegExp("((?:" + tag + ")\\s*)" + templateLiteralPattern),
              lookbehind: true,
              greedy: true,
              inside: {
                "template-punctuation": {
                  pattern: /^`|`$/,
                  alias: "string"
                },
                "embedded-code": {
                  pattern: /[\s\S]+/,
                  alias: language
                }
              }
            };
          }
          Prism3.languages.javascript["template-string"] = [
            // styled-jsx:
            //   css`a { color: #25F; }`
            // styled-components:
            //   styled.h1`color: red;`
            createTemplate(
              "css",
              /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source
            ),
            // html`<p></p>`
            // div.innerHTML = `<p></p>`
            createTemplate("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
            // svg`<path fill="#fff" d="M55.37 ..."/>`
            createTemplate("svg", /\bsvg/.source),
            // md`# h1`, markdown`## h2`
            createTemplate("markdown", /\b(?:markdown|md)/.source),
            // gql`...`, graphql`...`, graphql.experimental`...`
            createTemplate(
              "graphql",
              /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source
            ),
            // sql`...`
            createTemplate("sql", /\bsql/.source),
            // vanilla template string
            templateString
          ].filter(Boolean);
          function getPlaceholder(counter, language) {
            return "___" + language.toUpperCase() + "_" + counter + "___";
          }
          function tokenizeWithHooks(code2, grammar, language) {
            var env2 = {
              code: code2,
              grammar,
              language
            };
            Prism3.hooks.run("before-tokenize", env2);
            env2.tokens = Prism3.tokenize(env2.code, env2.grammar);
            Prism3.hooks.run("after-tokenize", env2);
            return env2.tokens;
          }
          function tokenizeInterpolationExpression(expression) {
            var tempGrammar = {};
            tempGrammar["interpolation-punctuation"] = interpolationPunctuationObject;
            var tokens = Prism3.tokenize(expression, tempGrammar);
            if (tokens.length === 3) {
              var args = [1, 1];
              args.push.apply(
                args,
                tokenizeWithHooks(tokens[1], Prism3.languages.javascript, "javascript")
              );
              tokens.splice.apply(tokens, args);
            }
            return new Prism3.Token(
              "interpolation",
              tokens,
              interpolationObject.alias,
              expression
            );
          }
          function tokenizeEmbedded(code2, grammar, language) {
            var _tokens = Prism3.tokenize(code2, {
              interpolation: {
                pattern: RegExp(interpolationPattern),
                lookbehind: true
              }
            });
            var placeholderCounter = 0;
            var placeholderMap = {};
            var embeddedCode = _tokens.map(function(token) {
              if (typeof token === "string") {
                return token;
              } else {
                var interpolationExpression = token.content;
                var placeholder;
                while (code2.indexOf(
                  placeholder = getPlaceholder(placeholderCounter++, language)
                ) !== -1) {
                }
                placeholderMap[placeholder] = interpolationExpression;
                return placeholder;
              }
            }).join("");
            var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);
            var placeholders = Object.keys(placeholderMap);
            placeholderCounter = 0;
            function walkTokens(tokens) {
              for (var i = 0; i < tokens.length; i++) {
                if (placeholderCounter >= placeholders.length) {
                  return;
                }
                var token = tokens[i];
                if (typeof token === "string" || typeof token.content === "string") {
                  var placeholder = placeholders[placeholderCounter];
                  var s = typeof token === "string" ? token : (
                    /** @type {string} */
                    token.content
                  );
                  var index2 = s.indexOf(placeholder);
                  if (index2 !== -1) {
                    ++placeholderCounter;
                    var before = s.substring(0, index2);
                    var middle = tokenizeInterpolationExpression(
                      placeholderMap[placeholder]
                    );
                    var after = s.substring(index2 + placeholder.length);
                    var replacement = [];
                    if (before) {
                      replacement.push(before);
                    }
                    replacement.push(middle);
                    if (after) {
                      var afterTokens = [after];
                      walkTokens(afterTokens);
                      replacement.push.apply(replacement, afterTokens);
                    }
                    if (typeof token === "string") {
                      tokens.splice.apply(tokens, [i, 1].concat(replacement));
                      i += replacement.length - 1;
                    } else {
                      token.content = replacement;
                    }
                  }
                } else {
                  var content2 = token.content;
                  if (Array.isArray(content2)) {
                    walkTokens(content2);
                  } else {
                    walkTokens([content2]);
                  }
                }
              }
            }
            walkTokens(embeddedTokens);
            return new Prism3.Token(
              language,
              embeddedTokens,
              "language-" + language,
              code2
            );
          }
          var supportedLanguages2 = {
            javascript: true,
            js: true,
            typescript: true,
            ts: true,
            jsx: true,
            tsx: true
          };
          Prism3.hooks.add("after-tokenize", function(env2) {
            if (!(env2.language in supportedLanguages2)) {
              return;
            }
            function findTemplateStrings(tokens) {
              for (var i = 0, l2 = tokens.length; i < l2; i++) {
                var token = tokens[i];
                if (typeof token === "string") {
                  continue;
                }
                var content2 = token.content;
                if (!Array.isArray(content2)) {
                  if (typeof content2 !== "string") {
                    findTemplateStrings([content2]);
                  }
                  continue;
                }
                if (token.type === "template-string") {
                  var embedded = content2[1];
                  if (content2.length === 3 && typeof embedded !== "string" && embedded.type === "embedded-code") {
                    var code2 = stringContent(embedded);
                    var alias2 = embedded.alias;
                    var language = Array.isArray(alias2) ? alias2[0] : alias2;
                    var grammar = Prism3.languages[language];
                    if (!grammar) {
                      continue;
                    }
                    content2[1] = tokenizeEmbedded(code2, grammar, language);
                  }
                } else {
                  findTemplateStrings(content2);
                }
              }
            }
            findTemplateStrings(env2.tokens);
          });
          function stringContent(value) {
            if (typeof value === "string") {
              return value;
            } else if (Array.isArray(value)) {
              return value.map(stringContent).join("");
            } else {
              return stringContent(value.content);
            }
          }
        })(Prism2);
      }
      return jsTemplates_1;
    }
    var typescript_1;
    var hasRequiredTypescript;
    function requireTypescript() {
      if (hasRequiredTypescript)
        return typescript_1;
      hasRequiredTypescript = 1;
      typescript_1 = typescript;
      typescript.displayName = "typescript";
      typescript.aliases = ["ts"];
      function typescript(Prism2) {
        (function(Prism3) {
          Prism3.languages.typescript = Prism3.languages.extend("javascript", {
            "class-name": {
              pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
              lookbehind: true,
              greedy: true,
              inside: null
              // see below
            },
            builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
          });
          Prism3.languages.typescript.keyword.push(
            /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
            // keywords that have to be followed by an identifier
            /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
            // This is for `import type *, {}`
            /\btype\b(?=\s*(?:[\{*]|$))/
          );
          delete Prism3.languages.typescript["parameter"];
          delete Prism3.languages.typescript["literal-property"];
          var typeInside = Prism3.languages.extend("typescript", {});
          delete typeInside["class-name"];
          Prism3.languages.typescript["class-name"].inside = typeInside;
          Prism3.languages.insertBefore("typescript", "function", {
            decorator: {
              pattern: /@[$\w\xA0-\uFFFF]+/,
              inside: {
                at: {
                  pattern: /^@/,
                  alias: "operator"
                },
                function: /^[\s\S]+/
              }
            },
            "generic-function": {
              // e.g. foo<T extends "bar" | "baz">( ...
              pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
              greedy: true,
              inside: {
                function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
                generic: {
                  pattern: /<[\s\S]+/,
                  // everything after the first <
                  alias: "class-name",
                  inside: typeInside
                }
              }
            }
          });
          Prism3.languages.ts = Prism3.languages.typescript;
        })(Prism2);
      }
      return typescript_1;
    }
    var jsdoc_1;
    var hasRequiredJsdoc;
    function requireJsdoc() {
      if (hasRequiredJsdoc)
        return jsdoc_1;
      hasRequiredJsdoc = 1;
      var refractorJavadoclike = requireJavadoclike();
      var refractorTypescript = requireTypescript();
      jsdoc_1 = jsdoc;
      jsdoc.displayName = "jsdoc";
      jsdoc.aliases = [];
      function jsdoc(Prism2) {
        Prism2.register(refractorJavadoclike);
        Prism2.register(refractorTypescript);
        (function(Prism3) {
          var javascript2 = Prism3.languages.javascript;
          var type = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source;
          var parameterPrefix = "(@(?:arg|argument|param|property)\\s+(?:" + type + "\\s+)?)";
          Prism3.languages.jsdoc = Prism3.languages.extend("javadoclike", {
            parameter: {
              // @param {string} foo - foo bar
              pattern: RegExp(
                parameterPrefix + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source
              ),
              lookbehind: true,
              inside: {
                punctuation: /\./
              }
            }
          });
          Prism3.languages.insertBefore("jsdoc", "keyword", {
            "optional-parameter": {
              // @param {string} [baz.foo="bar"] foo bar
              pattern: RegExp(
                parameterPrefix + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source
              ),
              lookbehind: true,
              inside: {
                parameter: {
                  pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/,
                  lookbehind: true,
                  inside: {
                    punctuation: /\./
                  }
                },
                code: {
                  pattern: /(=)[\s\S]*(?=\]$)/,
                  lookbehind: true,
                  inside: javascript2,
                  alias: "language-javascript"
                },
                punctuation: /[=[\]]/
              }
            },
            "class-name": [
              {
                pattern: RegExp(
                  /(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(
                    /<TYPE>/g,
                    function() {
                      return type;
                    }
                  )
                ),
                lookbehind: true,
                inside: {
                  punctuation: /\./
                }
              },
              {
                pattern: RegExp("(@[a-z]+\\s+)" + type),
                lookbehind: true,
                inside: {
                  string: javascript2.string,
                  number: javascript2.number,
                  boolean: javascript2.boolean,
                  keyword: Prism3.languages.typescript.keyword,
                  operator: /=>|\.\.\.|[&|?:*]/,
                  punctuation: /[.,;=<>{}()[\]]/
                }
              }
            ],
            example: {
              pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,
              lookbehind: true,
              inside: {
                code: {
                  pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m,
                  lookbehind: true,
                  inside: javascript2,
                  alias: "language-javascript"
                }
              }
            }
          });
          Prism3.languages.javadoclike.addSupport("javascript", Prism3.languages.jsdoc);
        })(Prism2);
      }
      return jsdoc_1;
    }
    var json_1;
    var hasRequiredJson;
    function requireJson() {
      if (hasRequiredJson)
        return json_1;
      hasRequiredJson = 1;
      json_1 = json;
      json.displayName = "json";
      json.aliases = ["webmanifest"];
      function json(Prism2) {
        Prism2.languages.json = {
          property: {
            pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
            lookbehind: true,
            greedy: true
          },
          string: {
            pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
            lookbehind: true,
            greedy: true
          },
          comment: {
            pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
            greedy: true
          },
          number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
          punctuation: /[{}[\],]/,
          operator: /:/,
          boolean: /\b(?:false|true)\b/,
          null: {
            pattern: /\bnull\b/,
            alias: "keyword"
          }
        };
        Prism2.languages.webmanifest = Prism2.languages.json;
      }
      return json_1;
    }
    var json5_1;
    var hasRequiredJson5;
    function requireJson5() {
      if (hasRequiredJson5)
        return json5_1;
      hasRequiredJson5 = 1;
      var refractorJson = requireJson();
      json5_1 = json5;
      json5.displayName = "json5";
      json5.aliases = [];
      function json5(Prism2) {
        Prism2.register(refractorJson);
        (function(Prism3) {
          var string2 = /("|')(?:\\(?:\r\n?|\n|.)|(?!\1)[^\\\r\n])*\1/;
          Prism3.languages.json5 = Prism3.languages.extend("json", {
            property: [
              {
                pattern: RegExp(string2.source + "(?=\\s*:)"),
                greedy: true
              },
              {
                pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/,
                alias: "unquoted"
              }
            ],
            string: {
              pattern: string2,
              greedy: true
            },
            number: /[+-]?\b(?:NaN|Infinity|0x[a-fA-F\d]+)\b|[+-]?(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+\b)?/
          });
        })(Prism2);
      }
      return json5_1;
    }
    var jsonp_1;
    var hasRequiredJsonp;
    function requireJsonp() {
      if (hasRequiredJsonp)
        return jsonp_1;
      hasRequiredJsonp = 1;
      var refractorJson = requireJson();
      jsonp_1 = jsonp;
      jsonp.displayName = "jsonp";
      jsonp.aliases = [];
      function jsonp(Prism2) {
        Prism2.register(refractorJson);
        Prism2.languages.jsonp = Prism2.languages.extend("json", {
          punctuation: /[{}[\]();,.]/
        });
        Prism2.languages.insertBefore("jsonp", "punctuation", {
          function: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*\()/
        });
      }
      return jsonp_1;
    }
    var jsstacktrace_1;
    var hasRequiredJsstacktrace;
    function requireJsstacktrace() {
      if (hasRequiredJsstacktrace)
        return jsstacktrace_1;
      hasRequiredJsstacktrace = 1;
      jsstacktrace_1 = jsstacktrace;
      jsstacktrace.displayName = "jsstacktrace";
      jsstacktrace.aliases = [];
      function jsstacktrace(Prism2) {
        Prism2.languages.jsstacktrace = {
          "error-message": {
            pattern: /^\S.*/m,
            alias: "string"
          },
          "stack-frame": {
            pattern: /(^[ \t]+)at[ \t].*/m,
            lookbehind: true,
            inside: {
              "not-my-code": {
                pattern: /^at[ \t]+(?!\s)(?:node\.js|<unknown>|.*(?:node_modules|\(<anonymous>\)|\(<unknown>|<anonymous>$|\(internal\/|\(node\.js)).*/m,
                alias: "comment"
              },
              filename: {
                pattern: /(\bat\s+(?!\s)|\()(?:[a-zA-Z]:)?[^():]+(?=:)/,
                lookbehind: true,
                alias: "url"
              },
              function: {
                pattern: /(\bat\s+(?:new\s+)?)(?!\s)[_$a-zA-Z\xA0-\uFFFF<][.$\w\xA0-\uFFFF<>]*/,
                lookbehind: true,
                inside: {
                  punctuation: /\./
                }
              },
              punctuation: /[()]/,
              keyword: /\b(?:at|new)\b/,
              alias: {
                pattern: /\[(?:as\s+)?(?!\s)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\]/,
                alias: "variable"
              },
              "line-number": {
                pattern: /:\d+(?::\d+)?\b/,
                alias: "number",
                inside: {
                  punctuation: /:/
                }
              }
            }
          }
        };
      }
      return jsstacktrace_1;
    }
    var jsx_1;
    var hasRequiredJsx;
    function requireJsx() {
      if (hasRequiredJsx)
        return jsx_1;
      hasRequiredJsx = 1;
      jsx_1 = jsx;
      jsx.displayName = "jsx";
      jsx.aliases = [];
      function jsx(Prism2) {
        (function(Prism3) {
          var javascript2 = Prism3.util.clone(Prism3.languages.javascript);
          var space2 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
          var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
          var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
          function re2(source, flags) {
            source = source.replace(/<S>/g, function() {
              return space2;
            }).replace(/<BRACES>/g, function() {
              return braces;
            }).replace(/<SPREAD>/g, function() {
              return spread;
            });
            return RegExp(source, flags);
          }
          spread = re2(spread).source;
          Prism3.languages.jsx = Prism3.languages.extend("markup", javascript2);
          Prism3.languages.jsx.tag.pattern = re2(
            /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
          );
          Prism3.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
          Prism3.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
          Prism3.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
          Prism3.languages.jsx.tag.inside["comment"] = javascript2["comment"];
          Prism3.languages.insertBefore(
            "inside",
            "attr-name",
            {
              spread: {
                pattern: re2(/<SPREAD>/.source),
                inside: Prism3.languages.jsx
              }
            },
            Prism3.languages.jsx.tag
          );
          Prism3.languages.insertBefore(
            "inside",
            "special-attr",
            {
              script: {
                // Allow for two levels of nesting
                pattern: re2(/=<BRACES>/.source),
                alias: "language-javascript",
                inside: {
                  "script-punctuation": {
                    pattern: /^=(?=\{)/,
                    alias: "punctuation"
                  },
                  rest: Prism3.languages.jsx
                }
              }
            },
            Prism3.languages.jsx.tag
          );
          var stringifyToken = function(token) {
            if (!token) {
              return "";
            }
            if (typeof token === "string") {
              return token;
            }
            if (typeof token.content === "string") {
              return token.content;
            }
            return token.content.map(stringifyToken).join("");
          };
          var walkTokens = function(tokens) {
            var openedTags = [];
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              var notTagNorBrace = false;
              if (typeof token !== "string") {
                if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
                  if (token.content[0].content[0].content === "</") {
                    if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
                      openedTags.pop();
                    }
                  } else {
                    if (token.content[token.content.length - 1].content === "/>")
                      ;
                    else {
                      openedTags.push({
                        tagName: stringifyToken(token.content[0].content[1]),
                        openedBraces: 0
                      });
                    }
                  }
                } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") {
                  openedTags[openedTags.length - 1].openedBraces++;
                } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
                  openedTags[openedTags.length - 1].openedBraces--;
                } else {
                  notTagNorBrace = true;
                }
              }
              if (notTagNorBrace || typeof token === "string") {
                if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
                  var plainText = stringifyToken(token);
                  if (i < tokens.length - 1 && (typeof tokens[i + 1] === "string" || tokens[i + 1].type === "plain-text")) {
                    plainText += stringifyToken(tokens[i + 1]);
                    tokens.splice(i + 1, 1);
                  }
                  if (i > 0 && (typeof tokens[i - 1] === "string" || tokens[i - 1].type === "plain-text")) {
                    plainText = stringifyToken(tokens[i - 1]) + plainText;
                    tokens.splice(i - 1, 1);
                    i--;
                  }
                  tokens[i] = new Prism3.Token(
                    "plain-text",
                    plainText,
                    null,
                    plainText
                  );
                }
              }
              if (token.content && typeof token.content !== "string") {
                walkTokens(token.content);
              }
            }
          };
          Prism3.hooks.add("after-tokenize", function(env2) {
            if (env2.language !== "jsx" && env2.language !== "tsx") {
              return;
            }
            walkTokens(env2.tokens);
          });
        })(Prism2);
      }
      return jsx_1;
    }
    var julia_1;
    var hasRequiredJulia;
    function requireJulia() {
      if (hasRequiredJulia)
        return julia_1;
      hasRequiredJulia = 1;
      julia_1 = julia;
      julia.displayName = "julia";
      julia.aliases = [];
      function julia(Prism2) {
        Prism2.languages.julia = {
          comment: {
            // support one level of nested comments
            // https://github.com/JuliaLang/julia/pull/6128
            pattern: /(^|[^\\])(?:#=(?:[^#=]|=(?!#)|#(?!=)|#=(?:[^#=]|=(?!#)|#(?!=))*=#)*=#|#.*)/,
            lookbehind: true
          },
          regex: {
            // https://docs.julialang.org/en/v1/manual/strings/#Regular-Expressions-1
            pattern: /r"(?:\\.|[^"\\\r\n])*"[imsx]{0,4}/,
            greedy: true
          },
          string: {
            // https://docs.julialang.org/en/v1/manual/strings/#String-Basics-1
            // https://docs.julialang.org/en/v1/manual/strings/#non-standard-string-literals-1
            // https://docs.julialang.org/en/v1/manual/running-external-programs/#Running-External-Programs-1
            pattern: /"""[\s\S]+?"""|(?:\b\w+)?"(?:\\.|[^"\\\r\n])*"|`(?:[^\\`\r\n]|\\.)*`/,
            greedy: true
          },
          char: {
            // https://docs.julialang.org/en/v1/manual/strings/#man-characters-1
            pattern: /(^|[^\w'])'(?:\\[^\r\n][^'\r\n]*|[^\\\r\n])'/,
            lookbehind: true,
            greedy: true
          },
          keyword: /\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|in|let|local|macro|module|print|println|quote|return|struct|try|type|typealias|using|while)\b/,
          boolean: /\b(?:false|true)\b/,
          number: /(?:\b(?=\d)|\B(?=\.))(?:0[box])?(?:[\da-f]+(?:_[\da-f]+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[efp][+-]?\d+(?:_\d+)*)?j?/i,
          // https://docs.julialang.org/en/v1/manual/mathematical-operations/
          // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity-1
          operator: /&&|\|\||[-+*^%÷⊻&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:|])?|>(?:=|>>?=?)?|==?=?|[~≠≤≥'√∛]/,
          punctuation: /::?|[{}[\]();,.?]/,
          // https://docs.julialang.org/en/v1/base/numbers/#Base.im
          constant: /\b(?:(?:Inf|NaN)(?:16|32|64)?|im|pi)\b|[πℯ]/
        };
      }
      return julia_1;
    }
    var keepalived_1;
    var hasRequiredKeepalived;
    function requireKeepalived() {
      if (hasRequiredKeepalived)
        return keepalived_1;
      hasRequiredKeepalived = 1;
      keepalived_1 = keepalived;
      keepalived.displayName = "keepalived";
      keepalived.aliases = [];
      function keepalived(Prism2) {
        Prism2.languages.keepalived = {
          comment: {
            pattern: /[#!].*/,
            greedy: true
          },
          string: {
            pattern: /(^|[^\\])(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,
            lookbehind: true,
            greedy: true
          },
          // support IPv4, IPv6, subnet mask
          ip: {
            pattern: RegExp(
              /\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source.replace(
                /<ipv4>/g,
                function() {
                  return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/.source;
                }
              ),
              "i"
            ),
            alias: "number"
          },
          // support *nix / Windows, directory / file
          path: {
            pattern: /(\s)\/(?:[^\/\s]+\/)*[^\/\s]*|\b[a-zA-Z]:\\(?:[^\\\s]+\\)*[^\\\s]*/,
            lookbehind: true,
            alias: "string"
          },
          variable: /\$\{?\w+\}?/,
          email: {
            pattern: /[\w-]+@[\w-]+(?:\.[\w-]{2,3}){1,2}/,
            alias: "string"
          },
          "conditional-configuration": {
            pattern: /@\^?[\w-]+/,
            alias: "variable"
          },
          operator: /=/,
          property: /\b(?:BFD_CHECK|DNS_CHECK|FILE_CHECK|HTTP_GET|MISC_CHECK|NAME|PING_CHECK|SCRIPTS|SMTP_CHECK|SSL|SSL_GET|TCP_CHECK|UDP_CHECK|accept|advert_int|alpha|auth_pass|auth_type|authentication|bfd_cpu_affinity|bfd_instance|bfd_no_swap|bfd_priority|bfd_process_name|bfd_rlimit_rttime|bfd_rt_priority|bind_if|bind_port|bindto|ca|certificate|check_unicast_src|checker|checker_cpu_affinity|checker_log_all_failures|checker_no_swap|checker_priority|checker_rlimit_rttime|checker_rt_priority|child_wait_time|connect_ip|connect_port|connect_timeout|dbus_service_name|debug|default_interface|delay|delay_before_retry|delay_loop|digest|dont_track_primary|dynamic|dynamic_interfaces|enable_(?:dbus|script_security|sni|snmp_checker|snmp_rfc|snmp_rfcv2|snmp_rfcv3|snmp_vrrp|traps)|end|fall|fast_recovery|file|flag-[123]|fork_delay|full_command|fwmark|garp_group|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|global_defs|global_tracking|gna_interval|group|ha_suspend|hashed|helo_name|higher_prio_send_advert|hoplimit|http_protocol|hysteresis|idle_tx|include|inhibit_on_failure|init_fail|init_file|instance|interface|interfaces|interval|ip_family|ipvs_process_name|keepalived.conf|kernel_rx_buf_size|key|linkbeat_interfaces|linkbeat_use_polling|log_all_failures|log_unknown_vrids|lower_prio_no_advert|lthreshold|lvs_flush|lvs_flush_onstop|lvs_method|lvs_netlink_cmd_rcv_bufs|lvs_netlink_cmd_rcv_bufs_force|lvs_netlink_monitor_rcv_bufs|lvs_netlink_monitor_rcv_bufs_force|lvs_notify_fifo|lvs_notify_fifo_script|lvs_sched|lvs_sync_daemon|max_auto_priority|max_hops|mcast_src_ip|mh-fallback|mh-port|min_auto_priority_delay|min_rx|min_tx|misc_dynamic|misc_path|misc_timeout|multiplier|name|namespace_with_ipsets|native_ipv6|neighbor_ip|net_namespace|net_namespace_ipvs|nftables|nftables_counters|nftables_ifindex|nftables_priority|no_accept|no_checker_emails|no_email_faults|nopreempt|notification_email|notification_email_from|notify|notify_backup|notify_deleted|notify_down|notify_fault|notify_fifo|notify_fifo_script|notify_master|notify_master_rx_lower_pri|notify_priority_changes|notify_stop|notify_up|old_unicast_checksum|omega|ops|param_match|passive|password|path|persistence_engine|persistence_granularity|persistence_timeout|preempt|preempt_delay|priority|process|process_monitor_rcv_bufs|process_monitor_rcv_bufs_force|process_name|process_names|promote_secondaries|protocol|proxy_arp|proxy_arp_pvlan|quorum|quorum_down|quorum_max|quorum_up|random_seed|real_server|regex|regex_max_offset|regex_min_offset|regex_no_match|regex_options|regex_stack|reload_repeat|reload_time_file|require_reply|retry|rise|router_id|rs_init_notifies|script|script_user|sh-fallback|sh-port|shutdown_script|shutdown_script_timeout|skip_check_adv_addr|smtp_alert|smtp_alert_checker|smtp_alert_vrrp|smtp_connect_timeout|smtp_helo_name|smtp_server|snmp_socket|sorry_server|sorry_server_inhibit|sorry_server_lvs_method|source_ip|start|startup_script|startup_script_timeout|state|static_ipaddress|static_routes|static_rules|status_code|step|strict_mode|sync_group_tracking_weight|terminate_delay|timeout|track_bfd|track_file|track_group|track_interface|track_process|track_script|track_src_ip|ttl|type|umask|unicast_peer|unicast_src_ip|unicast_ttl|url|use_ipvlan|use_pid_dir|use_vmac|user|uthreshold|val[123]|version|virtual_ipaddress|virtual_ipaddress_excluded|virtual_router_id|virtual_routes|virtual_rules|virtual_server|virtual_server_group|virtualhost|vmac_xmit_base|vrrp|vrrp_(?:check_unicast_src|cpu_affinity|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|gna_interval|higher_prio_send_advert|instance|ipsets|iptables|lower_prio_no_advert|mcast_group4|mcast_group6|min_garp|netlink_cmd_rcv_bufs|netlink_cmd_rcv_bufs_force|netlink_monitor_rcv_bufs|netlink_monitor_rcv_bufs_force|no_swap|notify_fifo|notify_fifo_script|notify_priority_changes|priority|process_name|rlimit_rttime|rt_priority|rx_bufs_multiplier|rx_bufs_policy|script|skip_check_adv_addr|startup_delay|strict|sync_group|track_process|version)|warmup|weight)\b/,
          constant: /\b(?:A|AAAA|AH|BACKUP|CNAME|DR|MASTER|MX|NAT|NS|PASS|SCTP|SOA|TCP|TUN|TXT|UDP|dh|fo|lblc|lblcr|lc|mh|nq|ovf|rr|sed|sh|wlc|wrr)\b/,
          number: {
            pattern: /(^|[^\w.-])-?\d+(?:\.\d+)?/,
            lookbehind: true
          },
          boolean: /\b(?:false|no|off|on|true|yes)\b/,
          punctuation: /[\{\}]/
        };
      }
      return keepalived_1;
    }
    var keyman_1;
    var hasRequiredKeyman;
    function requireKeyman() {
      if (hasRequiredKeyman)
        return keyman_1;
      hasRequiredKeyman = 1;
      keyman_1 = keyman;
      keyman.displayName = "keyman";
      keyman.aliases = [];
      function keyman(Prism2) {
        Prism2.languages.keyman = {
          comment: {
            pattern: /\bc .*/i,
            greedy: true
          },
          string: {
            pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
            greedy: true
          },
          "virtual-key": {
            pattern: /\[\s*(?:(?:ALT|CAPS|CTRL|LALT|LCTRL|NCAPS|RALT|RCTRL|SHIFT)\s+)*(?:[TKU]_[\w?]+|[A-E]\d\d?|"[^"\r\n]*"|'[^'\r\n]*')\s*\]/i,
            greedy: true,
            alias: "function"
            // alias for styles
          },
          // https://help.keyman.com/developer/language/guide/headers
          "header-keyword": {
            pattern: /&\w+/,
            alias: "bold"
            // alias for styles
          },
          "header-statement": {
            pattern: /\b(?:bitmap|bitmaps|caps always off|caps on only|copyright|hotkey|language|layout|message|name|shift frees caps|version)\b/i,
            alias: "bold"
            // alias for styles
          },
          "rule-keyword": {
            pattern: /\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|reset|return|save|set|store|use)\b/i,
            alias: "keyword"
          },
          "structural-keyword": {
            pattern: /\b(?:ansi|begin|group|match|nomatch|unicode|using keys)\b/i,
            alias: "keyword"
          },
          "compile-target": {
            pattern: /\$(?:keyman|keymanonly|keymanweb|kmfl|weaver):/i,
            alias: "property"
          },
          // U+####, x###, d### characters and numbers
          number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,
          operator: /[+>\\$]|\.\./,
          punctuation: /[()=,]/
        };
      }
      return keyman_1;
    }
    var kotlin_1;
    var hasRequiredKotlin;
    function requireKotlin() {
      if (hasRequiredKotlin)
        return kotlin_1;
      hasRequiredKotlin = 1;
      kotlin_1 = kotlin;
      kotlin.displayName = "kotlin";
      kotlin.aliases = ["kt", "kts"];
      function kotlin(Prism2) {
        (function(Prism3) {
          Prism3.languages.kotlin = Prism3.languages.extend("clike", {
            keyword: {
              // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
              pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
              lookbehind: true
            },
            function: [
              {
                pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
                greedy: true
              },
              {
                pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
                lookbehind: true,
                greedy: true
              }
            ],
            number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
            operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
          });
          delete Prism3.languages.kotlin["class-name"];
          var interpolationInside = {
            "interpolation-punctuation": {
              pattern: /^\$\{?|\}$/,
              alias: "punctuation"
            },
            expression: {
              pattern: /[\s\S]+/,
              inside: Prism3.languages.kotlin
            }
          };
          Prism3.languages.insertBefore("kotlin", "string", {
            // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
            "string-literal": [
              {
                pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
                alias: "multiline",
                inside: {
                  interpolation: {
                    pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                    inside: interpolationInside
                  },
                  string: /[\s\S]+/
                }
              },
              {
                pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
                alias: "singleline",
                inside: {
                  interpolation: {
                    pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                    lookbehind: true,
                    inside: interpolationInside
                  },
                  string: /[\s\S]+/
                }
              }
            ],
            char: {
              // https://kotlinlang.org/spec/expressions.html#character-literals
              pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
              greedy: true
            }
          });
          delete Prism3.languages.kotlin["string"];
          Prism3.languages.insertBefore("kotlin", "keyword", {
            annotation: {
              pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
              alias: "builtin"
            }
          });
          Prism3.languages.insertBefore("kotlin", "function", {
            label: {
              pattern: /\b\w+@|@\w+\b/,
              alias: "symbol"
            }
          });
          Prism3.languages.kt = Prism3.languages.kotlin;
          Prism3.languages.kts = Prism3.languages.kotlin;
        })(Prism2);
      }
      return kotlin_1;
    }
    var kumir_1;
    var hasRequiredKumir;
    function requireKumir() {
      if (hasRequiredKumir)
        return kumir_1;
      hasRequiredKumir = 1;
      kumir_1 = kumir;
      kumir.displayName = "kumir";
      kumir.aliases = ["kum"];
      function kumir(Prism2) {
        (function(Prism3) {
          var nonId = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
          function wrapId(pattern, flags) {
            return RegExp(pattern.replace(/<nonId>/g, nonId), flags);
          }
          Prism3.languages.kumir = {
            comment: {
              pattern: /\|.*/
            },
            prolog: {
              pattern: /#.*/,
              greedy: true
            },
            string: {
              pattern: /"[^\n\r"]*"|'[^\n\r']*'/,
              greedy: true
            },
            boolean: {
              pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),
              lookbehind: true
            },
            "operator-word": {
              pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),
              lookbehind: true,
              alias: "keyword"
            },
            "system-variable": {
              pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),
              lookbehind: true,
              alias: "keyword"
            },
            type: [
              {
                pattern: wrapId(
                  /(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\x20*таб)?(?=[<nonId>]|$)/.source
                ),
                lookbehind: true,
                alias: "builtin"
              },
              {
                pattern: wrapId(
                  /(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source
                ),
                lookbehind: true,
                alias: "important"
              }
            ],
            /**
             * Should be performed after searching for type names because of "таб".
             * "таб" is a reserved word, but never used without a preceding type name.
             * "НАЗНАЧИТЬ", "Фввод", and "Фвывод" are not reserved words.
             */
            keyword: {
              pattern: wrapId(
                /(^|[<nonId>])(?:алг|арг(?:\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\x20+|_)исп)?|кц(?:(?:\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source
              ),
              lookbehind: true
            },
            /** Should be performed after searching for reserved words. */
            name: {
              // eslint-disable-next-line regexp/no-super-linear-backtracking
              pattern: wrapId(
                /(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source
              ),
              lookbehind: true
            },
            /** Should be performed after searching for names. */
            number: {
              pattern: wrapId(
                /(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/.source,
                "i"
              ),
              lookbehind: true
            },
            /** Should be performed after searching for words. */
            punctuation: /:=|[(),:;\[\]]/,
            /**
             * Should be performed after searching for
             * - numeric constants (because of "+" and "-");
             * - punctuation marks (because of ":=" and "=").
             */
            "operator-char": {
              pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
              alias: "operator"
            }
          };
          Prism3.languages.kum = Prism3.languages.kumir;
        })(Prism2);
      }
      return kumir_1;
    }
    var kusto_1;
    var hasRequiredKusto;
    function requireKusto() {
      if (hasRequiredKusto)
        return kusto_1;
      hasRequiredKusto = 1;
      kusto_1 = kusto;
      kusto.displayName = "kusto";
      kusto.aliases = [];
      function kusto(Prism2) {
        Prism2.languages.kusto = {
          comment: {
            pattern: /\/\/.*/,
            greedy: true
          },
          string: {
            pattern: /```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
            greedy: true
          },
          verb: {
            pattern: /(\|\s*)[a-z][\w-]*/i,
            lookbehind: true,
            alias: "keyword"
          },
          command: {
            pattern: /\.[a-z][a-z\d-]*\b/,
            alias: "keyword"
          },
          "class-name": /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
          keyword: /\b(?:access|alias|and|anti|as|asc|auto|between|by|(?:contains|(?:ends|starts)with|has(?:perfix|suffix)?)(?:_cs)?|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
          boolean: /\b(?:false|null|true)\b/,
          function: /\b[a-z_]\w*(?=\s*\()/,
          datetime: [
            {
              // RFC 822 + RFC 850
              pattern: /\b(?:(?:Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:[A-Z]|(?:[ECMT][DS]|GM|U)T)|[+-]\d{4}))?\b/,
              alias: "number"
            },
            {
              // ISO 8601
              pattern: /[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
              alias: "number"
            }
          ],
          number: /\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mnµ]s|[dhms]|microsecond|tick)\b)?|[+-]?\binf\b/,
          operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
          punctuation: /[()\[\]{},;.:]/
        };
      }
      return kusto_1;
    }
    var latex_1;
    var hasRequiredLatex;
    function requireLatex() {
      if (hasRequiredLatex)
        return latex_1;
      hasRequiredLatex = 1;
      latex_1 = latex;
      latex.displayName = "latex";
      latex.aliases = ["tex", "context"];
      function latex(Prism2) {
        (function(Prism3) {
          var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
          var insideEqu = {
            "equation-command": {
              pattern: funcPattern,
              alias: "regex"
            }
          };
          Prism3.languages.latex = {
            comment: /%.*/,
            // the verbatim environment prints whitespace to the document
            cdata: {
              pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
              lookbehind: true
            },
            /*
             * equations can be between $$ $$ or $ $ or \( \) or \[ \]
             * (all are multiline)
             */
            equation: [
              {
                pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
                inside: insideEqu,
                alias: "string"
              },
              {
                pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
                lookbehind: true,
                inside: insideEqu,
                alias: "string"
              }
            ],
            /*
             * arguments which are keywords or references are highlighted
             * as keywords
             */
            keyword: {
              pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
              lookbehind: true
            },
            url: {
              pattern: /(\\url\{)[^}]+(?=\})/,
              lookbehind: true
            },
            /*
             * section or chapter headlines are highlighted as bold so that
             * they stand out more
             */
            headline: {
              pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
              lookbehind: true,
              alias: "class-name"
            },
            function: {
              pattern: funcPattern,
              alias: "selector"
            },
            punctuation: /[[\]{}&]/
          };
          Prism3.languages.tex = Prism3.languages.latex;
          Prism3.languages.context = Prism3.languages.latex;
        })(Prism2);
      }
      return latex_1;
    }
    var php_1;
    var hasRequiredPhp;
    function requirePhp() {
      if (hasRequiredPhp)
        return php_1;
      hasRequiredPhp = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      php_1 = php;
      php.displayName = "php";
      php.aliases = [];
      function php(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        (function(Prism3) {
          var comment = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
          var constant2 = [
            {
              pattern: /\b(?:false|true)\b/i,
              alias: "boolean"
            },
            {
              pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
              greedy: true,
              lookbehind: true
            },
            {
              pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
              greedy: true,
              lookbehind: true
            },
            /\b(?:null)\b/i,
            /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
          ];
          var number2 = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
          var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
          var punctuation = /[{}\[\](),:;]/;
          Prism3.languages.php = {
            delimiter: {
              pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
              alias: "important"
            },
            comment,
            variable: /\$+(?:\w+\b|(?=\{))/,
            package: {
              pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
              lookbehind: true,
              inside: {
                punctuation: /\\/
              }
            },
            "class-name-definition": {
              pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
              lookbehind: true,
              alias: "class-name"
            },
            "function-definition": {
              pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
              lookbehind: true,
              alias: "function"
            },
            keyword: [
              {
                pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
                alias: "type-casting",
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
                alias: "type-hint",
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string|void)\b/i,
                alias: "return-type",
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
                alias: "type-declaration",
                greedy: true
              },
              {
                pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
                alias: "type-declaration",
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /\b(?:parent|self|static)(?=\s*::)/i,
                alias: "static-context",
                greedy: true
              },
              {
                // yield from
                pattern: /(\byield\s+)from\b/i,
                lookbehind: true
              },
              // `class` is always a keyword unlike other keywords
              /\bclass\b/i,
              {
                // https://www.php.net/manual/en/reserved.keywords.php
                //
                // keywords cannot be preceded by "->"
                // the complex lookbehind means `(?<!(?:->|::)\s*)`
                pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
                lookbehind: true
              }
            ],
            "argument-name": {
              pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i,
              lookbehind: true
            },
            "class-name": [
              {
                pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
                greedy: true
              },
              {
                pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
                alias: "class-name-fully-qualified",
                greedy: true,
                lookbehind: true,
                inside: {
                  punctuation: /\\/
                }
              },
              {
                pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
                alias: "class-name-fully-qualified",
                greedy: true,
                inside: {
                  punctuation: /\\/
                }
              },
              {
                pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
                alias: "class-name-fully-qualified",
                greedy: true,
                lookbehind: true,
                inside: {
                  punctuation: /\\/
                }
              },
              {
                pattern: /\b[a-z_]\w*(?=\s*\$)/i,
                alias: "type-declaration",
                greedy: true
              },
              {
                pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
                alias: ["class-name-fully-qualified", "type-declaration"],
                greedy: true,
                inside: {
                  punctuation: /\\/
                }
              },
              {
                pattern: /\b[a-z_]\w*(?=\s*::)/i,
                alias: "static-context",
                greedy: true
              },
              {
                pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
                alias: ["class-name-fully-qualified", "static-context"],
                greedy: true,
                inside: {
                  punctuation: /\\/
                }
              },
              {
                pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
                alias: "type-hint",
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
                alias: ["class-name-fully-qualified", "type-hint"],
                greedy: true,
                lookbehind: true,
                inside: {
                  punctuation: /\\/
                }
              },
              {
                pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
                alias: "return-type",
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
                alias: ["class-name-fully-qualified", "return-type"],
                greedy: true,
                lookbehind: true,
                inside: {
                  punctuation: /\\/
                }
              }
            ],
            constant: constant2,
            function: {
              pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
              lookbehind: true,
              inside: {
                punctuation: /\\/
              }
            },
            property: {
              pattern: /(->\s*)\w+/,
              lookbehind: true
            },
            number: number2,
            operator,
            punctuation
          };
          var string_interpolation = {
            pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
            lookbehind: true,
            inside: Prism3.languages.php
          };
          var string2 = [
            {
              pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
              alias: "nowdoc-string",
              greedy: true,
              inside: {
                delimiter: {
                  pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
                  alias: "symbol",
                  inside: {
                    punctuation: /^<<<'?|[';]$/
                  }
                }
              }
            },
            {
              pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
              alias: "heredoc-string",
              greedy: true,
              inside: {
                delimiter: {
                  pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
                  alias: "symbol",
                  inside: {
                    punctuation: /^<<<"?|[";]$/
                  }
                },
                interpolation: string_interpolation
              }
            },
            {
              pattern: /`(?:\\[\s\S]|[^\\`])*`/,
              alias: "backtick-quoted-string",
              greedy: true
            },
            {
              pattern: /'(?:\\[\s\S]|[^\\'])*'/,
              alias: "single-quoted-string",
              greedy: true
            },
            {
              pattern: /"(?:\\[\s\S]|[^\\"])*"/,
              alias: "double-quoted-string",
              greedy: true,
              inside: {
                interpolation: string_interpolation
              }
            }
          ];
          Prism3.languages.insertBefore("php", "variable", {
            string: string2,
            attribute: {
              pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
              greedy: true,
              inside: {
                "attribute-content": {
                  pattern: /^(#\[)[\s\S]+(?=\]$)/,
                  lookbehind: true,
                  // inside can appear subset of php
                  inside: {
                    comment,
                    string: string2,
                    "attribute-class-name": [
                      {
                        pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                        alias: "class-name",
                        greedy: true,
                        lookbehind: true
                      },
                      {
                        pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                        alias: ["class-name", "class-name-fully-qualified"],
                        greedy: true,
                        lookbehind: true,
                        inside: {
                          punctuation: /\\/
                        }
                      }
                    ],
                    constant: constant2,
                    number: number2,
                    operator,
                    punctuation
                  }
                },
                delimiter: {
                  pattern: /^#\[|\]$/,
                  alias: "punctuation"
                }
              }
            }
          });
          Prism3.hooks.add("before-tokenize", function(env2) {
            if (!/<\?/.test(env2.code)) {
              return;
            }
            var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
            Prism3.languages["markup-templating"].buildPlaceholders(
              env2,
              "php",
              phpPattern
            );
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            Prism3.languages["markup-templating"].tokenizePlaceholders(env2, "php");
          });
        })(Prism2);
      }
      return php_1;
    }
    var latte_1;
    var hasRequiredLatte;
    function requireLatte() {
      if (hasRequiredLatte)
        return latte_1;
      hasRequiredLatte = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      var refractorPhp = requirePhp();
      latte_1 = latte;
      latte.displayName = "latte";
      latte.aliases = [];
      function latte(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        Prism2.register(refractorPhp);
        (function(Prism3) {
          Prism3.languages.latte = {
            comment: /^\{\*[\s\S]*/,
            "latte-tag": {
              // https://latte.nette.org/en/tags
              pattern: /(^\{(?:\/(?=[a-z]))?)(?:[=_]|[a-z]\w*\b(?!\())/i,
              lookbehind: true,
              alias: "important"
            },
            delimiter: {
              pattern: /^\{\/?|\}$/,
              alias: "punctuation"
            },
            php: {
              pattern: /\S(?:[\s\S]*\S)?/,
              alias: "language-php",
              inside: Prism3.languages.php
            }
          };
          var markupLatte = Prism3.languages.extend("markup", {});
          Prism3.languages.insertBefore(
            "inside",
            "attr-value",
            {
              "n-attr": {
                pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
                inside: {
                  "attr-name": {
                    pattern: /^[^\s=]+/,
                    alias: "important"
                  },
                  "attr-value": {
                    pattern: /=[\s\S]+/,
                    inside: {
                      punctuation: [
                        /^=/,
                        {
                          pattern: /^(\s*)["']|["']$/,
                          lookbehind: true
                        }
                      ],
                      php: {
                        pattern: /\S(?:[\s\S]*\S)?/,
                        inside: Prism3.languages.php
                      }
                    }
                  }
                }
              }
            },
            markupLatte.tag
          );
          Prism3.hooks.add("before-tokenize", function(env2) {
            if (env2.language !== "latte") {
              return;
            }
            var lattePattern = /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
            Prism3.languages["markup-templating"].buildPlaceholders(
              env2,
              "latte",
              lattePattern
            );
            env2.grammar = markupLatte;
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            Prism3.languages["markup-templating"].tokenizePlaceholders(env2, "latte");
          });
        })(Prism2);
      }
      return latte_1;
    }
    var less_1;
    var hasRequiredLess;
    function requireLess() {
      if (hasRequiredLess)
        return less_1;
      hasRequiredLess = 1;
      less_1 = less;
      less.displayName = "less";
      less.aliases = [];
      function less(Prism2) {
        Prism2.languages.less = Prism2.languages.extend("css", {
          comment: [
            /\/\*[\s\S]*?\*\//,
            {
              pattern: /(^|[^\\])\/\/.*/,
              lookbehind: true
            }
          ],
          atrule: {
            pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
            inside: {
              punctuation: /[:()]/
            }
          },
          // selectors and mixins are considered the same
          selector: {
            pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
            inside: {
              // mixin parameters
              variable: /@+[\w-]+/
            }
          },
          property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
          operator: /[+\-*\/]/
        });
        Prism2.languages.insertBefore("less", "property", {
          variable: [
            // Variable declaration (the colon must be consumed!)
            {
              pattern: /@[\w-]+\s*:/,
              inside: {
                punctuation: /:/
              }
            },
            // Variable usage
            /@@?[\w-]+/
          ],
          "mixin-usage": {
            pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
            lookbehind: true,
            alias: "function"
          }
        });
      }
      return less_1;
    }
    var scheme_1;
    var hasRequiredScheme;
    function requireScheme() {
      if (hasRequiredScheme)
        return scheme_1;
      hasRequiredScheme = 1;
      scheme_1 = scheme;
      scheme.displayName = "scheme";
      scheme.aliases = [];
      function scheme(Prism2) {
        (function(Prism3) {
          Prism3.languages.scheme = {
            // this supports "normal" single-line comments:
            //   ; comment
            // and (potentially nested) multiline comments:
            //   #| comment #| nested |# still comment |#
            // (only 1 level of nesting is supported)
            comment: /;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
            string: {
              pattern: /"(?:[^"\\]|\\.)*"/,
              greedy: true
            },
            symbol: {
              pattern: /'[^()\[\]#'\s]+/,
              greedy: true
            },
            char: {
              pattern: /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
              greedy: true
            },
            "lambda-parameter": [
              // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30
              {
                pattern: /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
                lookbehind: true
              },
              {
                pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
                lookbehind: true
              }
            ],
            keyword: {
              pattern: /((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
              lookbehind: true
            },
            builtin: {
              // all functions of the base library of R7RS plus some of built-ins of R5Rs
              pattern: /((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
              lookbehind: true
            },
            operator: {
              pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
              lookbehind: true
            },
            number: {
              // The number pattern from [the R7RS spec](https://small.r7rs.org/attachment/r7rs.pdf).
              //
              // <number>      := <num 2>|<num 8>|<num 10>|<num 16>
              // <num R>       := <prefix R><complex R>
              // <complex R>   := <real R>(?:@<real R>|<imaginary R>)?|<imaginary R>
              // <imaginary R> := [+-](?:<ureal R>|(?:inf|nan)\.0)?i
              // <real R>      := [+-]?<ureal R>|[+-](?:inf|nan)\.0
              // <ureal R>     := <uint R>(?:\/<uint R>)?
              //                | <decimal R>
              //
              // <decimal 10>  := (?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?
              // <uint R>      := <digit R>+
              // <prefix R>    := <radix R>(?:#[ei])?|(?:#[ei])?<radix R>
              // <radix 2>     := #b
              // <radix 8>     := #o
              // <radix 10>    := (?:#d)?
              // <radix 16>    := #x
              // <digit 2>     := [01]
              // <digit 8>     := [0-7]
              // <digit 10>    := \d
              // <digit 16>    := [0-9a-f]
              //
              // The problem with this grammar is that the resulting regex is way to complex, so we simplify by grouping all
              // non-decimal bases together. This results in a decimal (dec) and combined binary, octal, and hexadecimal (box)
              // pattern:
              pattern: RegExp(
                SortedBNF({
                  "<ureal dec>": /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
                  "<real dec>": /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
                  "<imaginary dec>": /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
                  "<complex dec>": /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/.source,
                  "<num dec>": /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
                  "<ureal box>": /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
                  "<real box>": /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
                  "<imaginary box>": /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
                  "<complex box>": /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/.source,
                  "<num box>": /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,
                  "<number>": /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/.source
                }),
                "i"
              ),
              lookbehind: true
            },
            boolean: {
              pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
              lookbehind: true
            },
            function: {
              pattern: /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
              lookbehind: true
            },
            identifier: {
              pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
              lookbehind: true,
              greedy: true
            },
            punctuation: /[()\[\]']/
          };
          function SortedBNF(grammar) {
            for (var key in grammar) {
              grammar[key] = grammar[key].replace(/<[\w\s]+>/g, function(key2) {
                return "(?:" + grammar[key2].trim() + ")";
              });
            }
            return grammar[key];
          }
        })(Prism2);
      }
      return scheme_1;
    }
    var lilypond_1;
    var hasRequiredLilypond;
    function requireLilypond() {
      if (hasRequiredLilypond)
        return lilypond_1;
      hasRequiredLilypond = 1;
      var refractorScheme = requireScheme();
      lilypond_1 = lilypond;
      lilypond.displayName = "lilypond";
      lilypond.aliases = [];
      function lilypond(Prism2) {
        Prism2.register(refractorScheme);
        (function(Prism3) {
          var schemeExpression = /\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/.source;
          var recursivenessLog2 = 5;
          for (var i = 0; i < recursivenessLog2; i++) {
            schemeExpression = schemeExpression.replace(/<expr>/g, function() {
              return schemeExpression;
            });
          }
          schemeExpression = schemeExpression.replace(/<expr>/g, /[^\s\S]/.source);
          var lilypond2 = Prism3.languages.lilypond = {
            comment: /%(?:(?!\{).*|\{[\s\S]*?%\})/,
            "embedded-scheme": {
              pattern: RegExp(
                /(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(
                  /<expr>/g,
                  function() {
                    return schemeExpression;
                  }
                ),
                "m"
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                scheme: {
                  pattern: /^(#)[\s\S]+$/,
                  lookbehind: true,
                  alias: "language-scheme",
                  inside: {
                    "embedded-lilypond": {
                      pattern: /#\{[\s\S]*?#\}/,
                      greedy: true,
                      inside: {
                        punctuation: /^#\{|#\}$/,
                        lilypond: {
                          pattern: /[\s\S]+/,
                          alias: "language-lilypond",
                          inside: null
                          // see below
                        }
                      }
                    },
                    rest: Prism3.languages.scheme
                  }
                },
                punctuation: /#/
              }
            },
            string: {
              pattern: /"(?:[^"\\]|\\.)*"/,
              greedy: true
            },
            "class-name": {
              pattern: /(\\new\s+)[\w-]+/,
              lookbehind: true
            },
            keyword: {
              pattern: /\\[a-z][-\w]*/i,
              inside: {
                punctuation: /^\\/
              }
            },
            operator: /[=|]|<<|>>/,
            punctuation: {
              pattern: /(^|[a-z\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\d))|[_^]\.?|[.!])|[{}()[\]<>^~]|\\[()[\]<>\\!]|--|__/,
              lookbehind: true
            },
            number: /\b\d+(?:\/\d+)?\b/
          };
          lilypond2["embedded-scheme"].inside["scheme"].inside["embedded-lilypond"].inside["lilypond"].inside = lilypond2;
          Prism3.languages.ly = lilypond2;
        })(Prism2);
      }
      return lilypond_1;
    }
    var liquid_1;
    var hasRequiredLiquid;
    function requireLiquid() {
      if (hasRequiredLiquid)
        return liquid_1;
      hasRequiredLiquid = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      liquid_1 = liquid;
      liquid.displayName = "liquid";
      liquid.aliases = [];
      function liquid(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        Prism2.languages.liquid = {
          comment: {
            pattern: /(^\{%\s*comment\s*%\})[\s\S]+(?=\{%\s*endcomment\s*%\}$)/,
            lookbehind: true
          },
          delimiter: {
            pattern: /^\{(?:\{\{|[%\{])-?|-?(?:\}\}|[%\}])\}$/,
            alias: "punctuation"
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          keyword: /\b(?:as|assign|break|(?:end)?(?:capture|case|comment|for|form|if|paginate|raw|style|tablerow|unless)|continue|cycle|decrement|echo|else|elsif|in|include|increment|limit|liquid|offset|range|render|reversed|section|when|with)\b/,
          object: /\b(?:address|all_country_option_tags|article|block|blog|cart|checkout|collection|color|country|country_option_tags|currency|current_page|current_tags|customer|customer_address|date|discount_allocation|discount_application|external_video|filter|filter_value|font|forloop|fulfillment|generic_file|gift_card|group|handle|image|line_item|link|linklist|localization|location|measurement|media|metafield|model|model_source|order|page|page_description|page_image|page_title|part|policy|product|product_option|recommendations|request|robots|routes|rule|script|search|selling_plan|selling_plan_allocation|selling_plan_group|shipping_method|shop|shop_locale|sitemap|store_availability|tax_line|template|theme|transaction|unit_price_measurement|user_agent|variant|video|video_source)\b/,
          function: [
            {
              pattern: /(\|\s*)\w+/,
              lookbehind: true,
              alias: "filter"
            },
            {
              // array functions
              pattern: /(\.\s*)(?:first|last|size)/,
              lookbehind: true
            }
          ],
          boolean: /\b(?:false|nil|true)\b/,
          range: {
            pattern: /\.\./,
            alias: "operator"
          },
          // https://github.com/Shopify/liquid/blob/698f5e0d967423e013f6169d9111bd969bd78337/lib/liquid/lexer.rb#L21
          number: /\b\d+(?:\.\d+)?\b/,
          operator: /[!=]=|<>|[<>]=?|[|?:=-]|\b(?:and|contains(?=\s)|or)\b/,
          punctuation: /[.,\[\]()]/,
          empty: {
            pattern: /\bempty\b/,
            alias: "keyword"
          }
        };
        Prism2.hooks.add("before-tokenize", function(env2) {
          var liquidPattern = /\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g;
          var insideRaw = false;
          Prism2.languages["markup-templating"].buildPlaceholders(
            env2,
            "liquid",
            liquidPattern,
            function(match) {
              var tagMatch = /^\{%-?\s*(\w+)/.exec(match);
              if (tagMatch) {
                var tag = tagMatch[1];
                if (tag === "raw" && !insideRaw) {
                  insideRaw = true;
                  return true;
                } else if (tag === "endraw") {
                  insideRaw = false;
                  return true;
                }
              }
              return !insideRaw;
            }
          );
        });
        Prism2.hooks.add("after-tokenize", function(env2) {
          Prism2.languages["markup-templating"].tokenizePlaceholders(env2, "liquid");
        });
      }
      return liquid_1;
    }
    var lisp_1;
    var hasRequiredLisp;
    function requireLisp() {
      if (hasRequiredLisp)
        return lisp_1;
      hasRequiredLisp = 1;
      lisp_1 = lisp;
      lisp.displayName = "lisp";
      lisp.aliases = [];
      function lisp(Prism2) {
        (function(Prism3) {
          function simple_form(name2) {
            return RegExp(/(\()/.source + "(?:" + name2 + ")" + /(?=[\s\)])/.source);
          }
          function primitive(pattern) {
            return RegExp(
              /([\s([])/.source + "(?:" + pattern + ")" + /(?=[\s)])/.source
            );
          }
          var symbol = /(?!\d)[-+*/~!@$%^=<>{}\w]+/.source;
          var marker = "&" + symbol;
          var par = "(\\()";
          var endpar = "(?=\\))";
          var space2 = "(?=\\s)";
          var nestedPar = /(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/.source;
          var language = {
            // Three or four semicolons are considered a heading.
            // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html
            heading: {
              pattern: /;;;.*/,
              alias: ["comment", "title"]
            },
            comment: /;.*/,
            string: {
              pattern: /"(?:[^"\\]|\\.)*"/,
              greedy: true,
              inside: {
                argument: /[-A-Z]+(?=[.,\s])/,
                symbol: RegExp("`" + symbol + "'")
              }
            },
            "quoted-symbol": {
              pattern: RegExp("#?'" + symbol),
              alias: ["variable", "symbol"]
            },
            "lisp-property": {
              pattern: RegExp(":" + symbol),
              alias: "property"
            },
            splice: {
              pattern: RegExp(",@?" + symbol),
              alias: ["symbol", "variable"]
            },
            keyword: [
              {
                pattern: RegExp(
                  par + "(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)" + space2
                ),
                lookbehind: true
              },
              {
                pattern: RegExp(
                  par + "(?:append|by|collect|concat|do|finally|for|in|return)" + space2
                ),
                lookbehind: true
              }
            ],
            declare: {
              pattern: simple_form(/declare/.source),
              lookbehind: true,
              alias: "keyword"
            },
            interactive: {
              pattern: simple_form(/interactive/.source),
              lookbehind: true,
              alias: "keyword"
            },
            boolean: {
              pattern: primitive(/nil|t/.source),
              lookbehind: true
            },
            number: {
              pattern: primitive(/[-+]?\d+(?:\.\d*)?/.source),
              lookbehind: true
            },
            defvar: {
              pattern: RegExp(par + "def(?:const|custom|group|var)\\s+" + symbol),
              lookbehind: true,
              inside: {
                keyword: /^def[a-z]+/,
                variable: RegExp(symbol)
              }
            },
            defun: {
              pattern: RegExp(
                par + /(?:cl-)?(?:defmacro|defun\*?)\s+/.source + symbol + /\s+\(/.source + nestedPar + /\)/.source
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                keyword: /^(?:cl-)?def\S+/,
                // See below, this property needs to be defined later so that it can
                // reference the language object.
                arguments: null,
                function: {
                  pattern: RegExp("(^\\s)" + symbol),
                  lookbehind: true
                },
                punctuation: /[()]/
              }
            },
            lambda: {
              pattern: RegExp(
                par + "lambda\\s+\\(\\s*(?:&?" + symbol + "(?:\\s+&?" + symbol + ")*\\s*)?\\)"
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                keyword: /^lambda/,
                // See below, this property needs to be defined later so that it can
                // reference the language object.
                arguments: null,
                punctuation: /[()]/
              }
            },
            car: {
              pattern: RegExp(par + symbol),
              lookbehind: true
            },
            punctuation: [
              // open paren, brackets, and close paren
              /(?:['`,]?\(|[)\[\]])/,
              // cons
              {
                pattern: /(\s)\.(?=\s)/,
                lookbehind: true
              }
            ]
          };
          var arg = {
            "lisp-marker": RegExp(marker),
            varform: {
              pattern: RegExp(
                /\(/.source + symbol + /\s+(?=\S)/.source + nestedPar + /\)/.source
              ),
              inside: language
            },
            argument: {
              pattern: RegExp(/(^|[\s(])/.source + symbol),
              lookbehind: true,
              alias: "variable"
            },
            rest: language
          };
          var forms = "\\S+(?:\\s+\\S+)*";
          var arglist = {
            pattern: RegExp(par + nestedPar + endpar),
            lookbehind: true,
            inside: {
              "rest-vars": {
                pattern: RegExp("&(?:body|rest)\\s+" + forms),
                inside: arg
              },
              "other-marker-vars": {
                pattern: RegExp("&(?:aux|optional)\\s+" + forms),
                inside: arg
              },
              keys: {
                pattern: RegExp("&key\\s+" + forms + "(?:\\s+&allow-other-keys)?"),
                inside: arg
              },
              argument: {
                pattern: RegExp(symbol),
                alias: "variable"
              },
              punctuation: /[()]/
            }
          };
          language["lambda"].inside.arguments = arglist;
          language["defun"].inside.arguments = Prism3.util.clone(arglist);
          language["defun"].inside.arguments.inside.sublist = arglist;
          Prism3.languages.lisp = language;
          Prism3.languages.elisp = language;
          Prism3.languages.emacs = language;
          Prism3.languages["emacs-lisp"] = language;
        })(Prism2);
      }
      return lisp_1;
    }
    var livescript_1;
    var hasRequiredLivescript;
    function requireLivescript() {
      if (hasRequiredLivescript)
        return livescript_1;
      hasRequiredLivescript = 1;
      livescript_1 = livescript;
      livescript.displayName = "livescript";
      livescript.aliases = [];
      function livescript(Prism2) {
        Prism2.languages.livescript = {
          comment: [
            {
              pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
              lookbehind: true
            },
            {
              pattern: /(^|[^\\])#.*/,
              lookbehind: true
            }
          ],
          "interpolated-string": {
            /* Look-behind and look-ahead prevents wrong behavior of the greedy pattern
             * forcing it to match """-quoted string when it would otherwise match "-quoted first. */
            pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
            lookbehind: true,
            greedy: true,
            inside: {
              variable: {
                pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
                lookbehind: true
              },
              interpolation: {
                pattern: /(^|[^\\])#\{[^}]+\}/m,
                lookbehind: true,
                inside: {
                  "interpolation-punctuation": {
                    pattern: /^#\{|\}$/,
                    alias: "variable"
                  }
                  // See rest below
                }
              },
              string: /[\s\S]+/
            }
          },
          string: [
            {
              pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
              greedy: true
            },
            {
              pattern: /<\[[\s\S]*?\]>/,
              greedy: true
            },
            /\\[^\s,;\])}]+/
          ],
          regex: [
            {
              pattern: /\/\/(?:\[[^\r\n\]]*\]|\\.|(?!\/\/)[^\\\[])+\/\/[gimyu]{0,5}/,
              greedy: true,
              inside: {
                comment: {
                  pattern: /(^|[^\\])#.*/,
                  lookbehind: true
                }
              }
            },
            {
              pattern: /\/(?:\[[^\r\n\]]*\]|\\.|[^/\\\r\n\[])+\/[gimyu]{0,5}/,
              greedy: true
            }
          ],
          keyword: {
            pattern: /(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
            lookbehind: true
          },
          "keyword-operator": {
            pattern: /(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?: not|nt)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
            lookbehind: true,
            alias: "operator"
          },
          boolean: {
            pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
            lookbehind: true
          },
          argument: {
            // Don't match .&. nor &&
            pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
            lookbehind: true,
            alias: "variable"
          },
          number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
          identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
          operator: [
            // Spaced .
            {
              pattern: /( )\.(?= )/,
              lookbehind: true
            },
            // Full list, in order:
            // .= .~ .. ...
            // .&. .^. .<<. .>>. .>>>.
            // := :: ::=
            // &&
            // || |>
            // < << <<< <<<<
            // <- <-- <-! <--!
            // <~ <~~ <~! <~~!
            // <| <= <?
            // > >> >= >?
            // - -- -> -->
            // + ++
            // @ @@
            // % %%
            // * **
            // ! != !~=
            // !~> !~~>
            // !-> !-->
            // ~ ~> ~~> ~=
            // = ==
            // ^ ^^
            // / ?
            /\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/
          ],
          punctuation: /[(){}\[\]|.,:;`]/
        };
        Prism2.languages.livescript["interpolated-string"].inside["interpolation"].inside.rest = Prism2.languages.livescript;
      }
      return livescript_1;
    }
    var llvm_1;
    var hasRequiredLlvm;
    function requireLlvm() {
      if (hasRequiredLlvm)
        return llvm_1;
      hasRequiredLlvm = 1;
      llvm_1 = llvm;
      llvm.displayName = "llvm";
      llvm.aliases = [];
      function llvm(Prism2) {
        (function(Prism3) {
          Prism3.languages.llvm = {
            comment: /;.*/,
            string: {
              pattern: /"[^"]*"/,
              greedy: true
            },
            boolean: /\b(?:false|true)\b/,
            variable: /[%@!#](?:(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+|\d+)/i,
            label: /(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+:/i,
            type: {
              pattern: /\b(?:double|float|fp128|half|i[1-9]\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\b/,
              alias: "class-name"
            },
            keyword: /\b[a-z_][a-z_0-9]*\b/,
            number: /[+-]?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-Fa-f]+\b|\b0xK[\dA-Fa-f]{20}\b|\b0x[ML][\dA-Fa-f]{32}\b|\b0xH[\dA-Fa-f]{4}\b/,
            punctuation: /[{}[\];(),.!*=<>]/
          };
        })(Prism2);
      }
      return llvm_1;
    }
    var log_1;
    var hasRequiredLog;
    function requireLog() {
      if (hasRequiredLog)
        return log_1;
      hasRequiredLog = 1;
      log_1 = log;
      log.displayName = "log";
      log.aliases = [];
      function log(Prism2) {
        Prism2.languages.log = {
          string: {
            // Single-quoted strings must not be confused with plain text. E.g. Can't isn't Susan's Chris' toy
            pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
            greedy: true
          },
          exception: {
            pattern: /(^|[^\w.])[a-z][\w.]*(?:Error|Exception):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
            lookbehind: true,
            greedy: true,
            alias: ["javastacktrace", "language-javastacktrace"],
            inside: Prism2.languages["javastacktrace"] || {
              keyword: /\bat\b/,
              function: /[a-z_][\w$]*(?=\()/,
              punctuation: /[.:()]/
            }
          },
          level: [
            {
              pattern: /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
              alias: ["error", "important"]
            },
            {
              pattern: /\b(?:WARN|WARNING|WRN)\b/,
              alias: ["warning", "important"]
            },
            {
              pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
              alias: ["info", "keyword"]
            },
            {
              pattern: /\b(?:DBG|DEBUG|FINE)\b/,
              alias: ["debug", "keyword"]
            },
            {
              pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
              alias: ["trace", "comment"]
            }
          ],
          property: {
            pattern: /((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
            lookbehind: true
          },
          separator: {
            pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
            lookbehind: true,
            alias: "comment"
          },
          url: /\b(?:file|ftp|https?):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
          email: {
            pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
            lookbehind: true,
            alias: "url"
          },
          "ip-address": {
            pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/,
            alias: "constant"
          },
          "mac-address": {
            pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
            alias: "constant"
          },
          domain: {
            pattern: /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
            lookbehind: true,
            alias: "constant"
          },
          uuid: {
            pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
            alias: "constant"
          },
          hash: {
            pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i,
            alias: "constant"
          },
          "file-path": {
            pattern: /\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
            lookbehind: true,
            greedy: true,
            alias: "string"
          },
          date: {
            pattern: RegExp(
              /\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source + "|" + /\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/.source + "|" + /\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/.source,
              "i"
            ),
            alias: "number"
          },
          time: {
            pattern: /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
            alias: "number"
          },
          boolean: /\b(?:false|null|true)\b/i,
          number: {
            pattern: /(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
            lookbehind: true
          },
          operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
          punctuation: /[\[\].,]/
        };
      }
      return log_1;
    }
    var lolcode_1;
    var hasRequiredLolcode;
    function requireLolcode() {
      if (hasRequiredLolcode)
        return lolcode_1;
      hasRequiredLolcode = 1;
      lolcode_1 = lolcode;
      lolcode.displayName = "lolcode";
      lolcode.aliases = [];
      function lolcode(Prism2) {
        Prism2.languages.lolcode = {
          comment: [/\bOBTW\s[\s\S]*?\sTLDR\b/, /\bBTW.+/],
          string: {
            pattern: /"(?::.|[^":])*"/,
            inside: {
              variable: /:\{[^}]+\}/,
              symbol: [/:\([a-f\d]+\)/i, /:\[[^\]]+\]/, /:[)>o":]/]
            },
            greedy: true
          },
          number: /(?:\B-)?(?:\b\d+(?:\.\d*)?|\B\.\d+)/,
          symbol: {
            pattern: /(^|\s)(?:A )?(?:BUKKIT|NOOB|NUMBAR|NUMBR|TROOF|YARN)(?=\s|,|$)/,
            lookbehind: true,
            inside: {
              keyword: /A(?=\s)/
            }
          },
          label: {
            pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
            lookbehind: true,
            alias: "string"
          },
          function: {
            pattern: /((?:^|\s)(?:HOW IZ I|I IZ|IZ) )[a-zA-Z]\w*/,
            lookbehind: true
          },
          keyword: [
            {
              pattern: /(^|\s)(?:AN|FOUND YR|GIMMEH|GTFO|HAI|HAS A|HOW IZ I|I HAS A|I IZ|IF U SAY SO|IM IN YR|IM OUTTA YR|IS NOW(?: A)?|ITZ(?: A)?|IZ|KTHX|KTHXBYE|LIEK(?: A)?|MAEK|MEBBE|MKAY|NERFIN|NO WAI|O HAI IM|O RLY\?|OIC|OMG|OMGWTF|R|SMOOSH|SRS|TIL|UPPIN|VISIBLE|WILE|WTF\?|YA RLY|YR)(?=\s|,|$)/,
              lookbehind: true
            },
            /'Z(?=\s|,|$)/
          ],
          boolean: {
            pattern: /(^|\s)(?:FAIL|WIN)(?=\s|,|$)/,
            lookbehind: true
          },
          variable: {
            pattern: /(^|\s)IT(?=\s|,|$)/,
            lookbehind: true
          },
          operator: {
            pattern: /(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:ALL|ANY|BIGGR|BOTH|DIFF|EITHER|MOD|PRODUKT|QUOSHUNT|SMALLR|SUM|WON) OF)(?=\s|,|$)/,
            lookbehind: true
          },
          punctuation: /\.{3}|…|,|!/
        };
      }
      return lolcode_1;
    }
    var magma_1;
    var hasRequiredMagma;
    function requireMagma() {
      if (hasRequiredMagma)
        return magma_1;
      hasRequiredMagma = 1;
      magma_1 = magma;
      magma.displayName = "magma";
      magma.aliases = [];
      function magma(Prism2) {
        Prism2.languages.magma = {
          output: {
            pattern: /^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
            lookbehind: true,
            greedy: true
          },
          comment: {
            pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
            greedy: true
          },
          string: {
            pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
            lookbehind: true,
            greedy: true
          },
          // http://magma.maths.usyd.edu.au/magma/handbook/text/82
          keyword: /\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
          boolean: /\b(?:false|true)\b/,
          generator: {
            pattern: /\b[a-z_]\w*(?=\s*<)/i,
            alias: "class-name"
          },
          function: /\b[a-z_]\w*(?=\s*\()/i,
          number: {
            pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
            lookbehind: true
          },
          operator: /->|[-+*/^~!|#=]|:=|\.\./,
          punctuation: /[()[\]{}<>,;.:]/
        };
      }
      return magma_1;
    }
    var makefile_1;
    var hasRequiredMakefile;
    function requireMakefile() {
      if (hasRequiredMakefile)
        return makefile_1;
      hasRequiredMakefile = 1;
      makefile_1 = makefile;
      makefile.displayName = "makefile";
      makefile.aliases = [];
      function makefile(Prism2) {
        Prism2.languages.makefile = {
          comment: {
            pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
            lookbehind: true
          },
          string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          "builtin-target": {
            pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
            alias: "builtin"
          },
          target: {
            pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
            alias: "symbol",
            inside: {
              variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
            }
          },
          variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
          // Directives
          keyword: /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
          function: {
            pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
            lookbehind: true
          },
          operator: /(?:::|[?:+!])?=|[|@]/,
          punctuation: /[:;(){}]/
        };
      }
      return makefile_1;
    }
    var markdown_1;
    var hasRequiredMarkdown;
    function requireMarkdown() {
      if (hasRequiredMarkdown)
        return markdown_1;
      hasRequiredMarkdown = 1;
      markdown_1 = markdown;
      markdown.displayName = "markdown";
      markdown.aliases = ["md"];
      function markdown(Prism2) {
        (function(Prism3) {
          var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
          function createInline(pattern) {
            pattern = pattern.replace(/<inner>/g, function() {
              return inner;
            });
            return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
          }
          var tableCell2 = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
          var tableRow2 = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
            /__/g,
            function() {
              return tableCell2;
            }
          );
          var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
          Prism3.languages.markdown = Prism3.languages.extend("markup", {});
          Prism3.languages.insertBefore("markdown", "prolog", {
            "front-matter-block": {
              pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
              lookbehind: true,
              greedy: true,
              inside: {
                punctuation: /^---|---$/,
                "front-matter": {
                  pattern: /\S+(?:\s+\S+)*/,
                  alias: ["yaml", "language-yaml"],
                  inside: Prism3.languages.yaml
                }
              }
            },
            blockquote: {
              // > ...
              pattern: /^>(?:[\t ]*>)*/m,
              alias: "punctuation"
            },
            table: {
              pattern: RegExp(
                "^" + tableRow2 + tableLine + "(?:" + tableRow2 + ")*",
                "m"
              ),
              inside: {
                "table-data-rows": {
                  pattern: RegExp(
                    "^(" + tableRow2 + tableLine + ")(?:" + tableRow2 + ")*$"
                  ),
                  lookbehind: true,
                  inside: {
                    "table-data": {
                      pattern: RegExp(tableCell2),
                      inside: Prism3.languages.markdown
                    },
                    punctuation: /\|/
                  }
                },
                "table-line": {
                  pattern: RegExp("^(" + tableRow2 + ")" + tableLine + "$"),
                  lookbehind: true,
                  inside: {
                    punctuation: /\||:?-{3,}:?/
                  }
                },
                "table-header-row": {
                  pattern: RegExp("^" + tableRow2 + "$"),
                  inside: {
                    "table-header": {
                      pattern: RegExp(tableCell2),
                      alias: "important",
                      inside: Prism3.languages.markdown
                    },
                    punctuation: /\|/
                  }
                }
              }
            },
            code: [
              {
                // Prefixed by 4 spaces or 1 tab and preceded by an empty line
                pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
                lookbehind: true,
                alias: "keyword"
              },
              {
                // ```optional language
                // code block
                // ```
                pattern: /^```[\s\S]*?^```$/m,
                greedy: true,
                inside: {
                  "code-block": {
                    pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
                    lookbehind: true
                  },
                  "code-language": {
                    pattern: /^(```).+/,
                    lookbehind: true
                  },
                  punctuation: /```/
                }
              }
            ],
            title: [
              {
                // title 1
                // =======
                // title 2
                // -------
                pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
                alias: "important",
                inside: {
                  punctuation: /==+$|--+$/
                }
              },
              {
                // # title 1
                // ###### title 6
                pattern: /(^\s*)#.+/m,
                lookbehind: true,
                alias: "important",
                inside: {
                  punctuation: /^#+|#+$/
                }
              }
            ],
            hr: {
              // ***
              // ---
              // * * *
              // -----------
              pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
              lookbehind: true,
              alias: "punctuation"
            },
            list: {
              // * item
              // + item
              // - item
              // 1. item
              pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
              lookbehind: true,
              alias: "punctuation"
            },
            "url-reference": {
              // [id]: http://example.com "Optional title"
              // [id]: http://example.com 'Optional title'
              // [id]: http://example.com (Optional title)
              // [id]: <http://example.com> "Optional title"
              pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
              inside: {
                variable: {
                  pattern: /^(!?\[)[^\]]+/,
                  lookbehind: true
                },
                string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
                punctuation: /^[\[\]!:]|[<>]/
              },
              alias: "url"
            },
            bold: {
              // **strong**
              // __strong__
              // allow one nested instance of italic text using the same delimiter
              pattern: createInline(
                /\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                content: {
                  pattern: /(^..)[\s\S]+(?=..$)/,
                  lookbehind: true,
                  inside: {}
                  // see below
                },
                punctuation: /\*\*|__/
              }
            },
            italic: {
              // *em*
              // _em_
              // allow one nested instance of bold text using the same delimiter
              pattern: createInline(
                /\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                content: {
                  pattern: /(^.)[\s\S]+(?=.$)/,
                  lookbehind: true,
                  inside: {}
                  // see below
                },
                punctuation: /[*_]/
              }
            },
            strike: {
              // ~~strike through~~
              // ~strike~
              // eslint-disable-next-line regexp/strict
              pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
              lookbehind: true,
              greedy: true,
              inside: {
                content: {
                  pattern: /(^~~?)[\s\S]+(?=\1$)/,
                  lookbehind: true,
                  inside: {}
                  // see below
                },
                punctuation: /~~?/
              }
            },
            "code-snippet": {
              // `code`
              // ``code``
              pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
              lookbehind: true,
              greedy: true,
              alias: ["code", "keyword"]
            },
            url: {
              // [example](http://example.com "Optional title")
              // [example][id]
              // [example] [id]
              pattern: createInline(
                /!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                operator: /^!/,
                content: {
                  pattern: /(^\[)[^\]]+(?=\])/,
                  lookbehind: true,
                  inside: {}
                  // see below
                },
                variable: {
                  pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
                  lookbehind: true
                },
                url: {
                  pattern: /(^\]\()[^\s)]+/,
                  lookbehind: true
                },
                string: {
                  pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
                  lookbehind: true
                }
              }
            }
          });
          ["url", "bold", "italic", "strike"].forEach(function(token) {
            ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
              if (token !== inside) {
                Prism3.languages.markdown[token].inside.content.inside[inside] = Prism3.languages.markdown[inside];
              }
            });
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            if (env2.language !== "markdown" && env2.language !== "md") {
              return;
            }
            function walkTokens(tokens) {
              if (!tokens || typeof tokens === "string") {
                return;
              }
              for (var i = 0, l2 = tokens.length; i < l2; i++) {
                var token = tokens[i];
                if (token.type !== "code") {
                  walkTokens(token.content);
                  continue;
                }
                var codeLang = token.content[1];
                var codeBlock = token.content[3];
                if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
                  var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
                  lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
                  var alias2 = "language-" + lang;
                  if (!codeBlock.alias) {
                    codeBlock.alias = [alias2];
                  } else if (typeof codeBlock.alias === "string") {
                    codeBlock.alias = [codeBlock.alias, alias2];
                  } else {
                    codeBlock.alias.push(alias2);
                  }
                }
              }
            }
            walkTokens(env2.tokens);
          });
          Prism3.hooks.add("wrap", function(env2) {
            if (env2.type !== "code-block") {
              return;
            }
            var codeLang = "";
            for (var i = 0, l2 = env2.classes.length; i < l2; i++) {
              var cls = env2.classes[i];
              var match = /language-(.+)/.exec(cls);
              if (match) {
                codeLang = match[1];
                break;
              }
            }
            var grammar = Prism3.languages[codeLang];
            if (!grammar) {
              if (codeLang && codeLang !== "none" && Prism3.plugins.autoloader) {
                var id2 = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
                env2.attributes["id"] = id2;
                Prism3.plugins.autoloader.loadLanguages(codeLang, function() {
                  var ele = document.getElementById(id2);
                  if (ele) {
                    ele.innerHTML = Prism3.highlight(
                      ele.textContent,
                      Prism3.languages[codeLang],
                      codeLang
                    );
                  }
                });
              }
            } else {
              env2.content = Prism3.highlight(
                textContent(env2.content.value),
                grammar,
                codeLang
              );
            }
          });
          var tagPattern = RegExp(Prism3.languages.markup.tag.pattern.source, "gi");
          var KNOWN_ENTITY_NAMES = {
            amp: "&",
            lt: "<",
            gt: ">",
            quot: '"'
          };
          var fromCodePoint = String.fromCodePoint || String.fromCharCode;
          function textContent(html2) {
            var text2 = html2.replace(tagPattern, "");
            text2 = text2.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code2) {
              code2 = code2.toLowerCase();
              if (code2[0] === "#") {
                var value;
                if (code2[1] === "x") {
                  value = parseInt(code2.slice(2), 16);
                } else {
                  value = Number(code2.slice(1));
                }
                return fromCodePoint(value);
              } else {
                var known = KNOWN_ENTITY_NAMES[code2];
                if (known) {
                  return known;
                }
                return m2;
              }
            });
            return text2;
          }
          Prism3.languages.md = Prism3.languages.markdown;
        })(Prism2);
      }
      return markdown_1;
    }
    var matlab_1;
    var hasRequiredMatlab;
    function requireMatlab() {
      if (hasRequiredMatlab)
        return matlab_1;
      hasRequiredMatlab = 1;
      matlab_1 = matlab;
      matlab.displayName = "matlab";
      matlab.aliases = [];
      function matlab(Prism2) {
        Prism2.languages.matlab = {
          comment: [/%\{[\s\S]*?\}%/, /%.+/],
          string: {
            pattern: /\B'(?:''|[^'\r\n])*'/,
            greedy: true
          },
          // FIXME We could handle imaginary numbers as a whole
          number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
          keyword: /\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
          function: /\b(?!\d)\w+(?=\s*\()/,
          operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
          punctuation: /\.{3}|[.,;\[\](){}!]/
        };
      }
      return matlab_1;
    }
    var maxscript_1;
    var hasRequiredMaxscript;
    function requireMaxscript() {
      if (hasRequiredMaxscript)
        return maxscript_1;
      hasRequiredMaxscript = 1;
      maxscript_1 = maxscript;
      maxscript.displayName = "maxscript";
      maxscript.aliases = [];
      function maxscript(Prism2) {
        (function(Prism3) {
          var keywords = /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
          Prism3.languages.maxscript = {
            comment: {
              pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
              greedy: true
            },
            string: {
              pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
              lookbehind: true,
              greedy: true
            },
            path: {
              pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
              greedy: true,
              alias: "string"
            },
            "function-call": {
              pattern: RegExp(
                "((?:" + // start of line
                (/^/.source + "|" + // operators and other language constructs
                /[;=<>+\-*/^({\[]/.source + "|" + // keywords as part of statements
                /\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/.source) + ")[ 	]*)(?!" + keywords.source + ")" + /[a-z_]\w*\b/.source + "(?=[ 	]*(?:" + // variable
                ("(?!" + keywords.source + ")" + /[a-z_]/.source + "|" + // number
                /\d|-\.?\d/.source + "|" + // other expressions or literals
                /[({'"$@#?]/.source) + "))",
                "im"
              ),
              lookbehind: true,
              greedy: true,
              alias: "function"
            },
            "function-definition": {
              pattern: /(\b(?:fn|function)\s+)\w+\b/i,
              lookbehind: true,
              alias: "function"
            },
            argument: {
              pattern: /\b[a-z_]\w*(?=:)/i,
              alias: "attr-name"
            },
            keyword: keywords,
            boolean: /\b(?:false|true)\b/,
            time: {
              pattern: /(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
              lookbehind: true,
              alias: "number"
            },
            number: [
              {
                pattern: /(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
                lookbehind: true
              },
              /\b(?:e|pi)\b/
            ],
            constant: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/,
            color: {
              pattern: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/i,
              alias: "constant"
            },
            operator: /[-+*/<>=!]=?|[&^?]|#(?!\()/,
            punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
          };
        })(Prism2);
      }
      return maxscript_1;
    }
    var mel_1;
    var hasRequiredMel;
    function requireMel() {
      if (hasRequiredMel)
        return mel_1;
      hasRequiredMel = 1;
      mel_1 = mel;
      mel.displayName = "mel";
      mel.aliases = [];
      function mel(Prism2) {
        Prism2.languages.mel = {
          comment: /\/\/.*/,
          code: {
            pattern: /`(?:\\.|[^\\`\r\n])*`/,
            greedy: true,
            alias: "italic",
            inside: {
              delimiter: {
                pattern: /^`|`$/,
                alias: "punctuation"
              }
              // See rest below
            }
          },
          string: {
            pattern: /"(?:\\.|[^\\"\r\n])*"/,
            greedy: true
          },
          variable: /\$\w+/,
          number: /\b0x[\da-fA-F]+\b|\b\d+(?:\.\d*)?|\B\.\d+/,
          flag: {
            pattern: /-[^\d\W]\w*/,
            alias: "operator"
          },
          keyword: /\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
          function: /\b\w+(?=\()|\b(?:CBG|HfAddAttractorToAS|HfAssignAS|HfBuildEqualMap|HfBuildFurFiles|HfBuildFurImages|HfCancelAFR|HfConnectASToHF|HfCreateAttractor|HfDeleteAS|HfEditAS|HfPerformCreateAS|HfRemoveAttractorFromAS|HfSelectAttached|HfSelectAttractors|HfUnAssignAS|Mayatomr|about|abs|addAttr|addAttributeEditorNodeHelp|addDynamic|addNewShelfTab|addPP|addPanelCategory|addPrefixToName|advanceToNextDrivenKey|affectedNet|affects|aimConstraint|air|alias|aliasAttr|align|alignCtx|alignCurve|alignSurface|allViewFit|ambientLight|angle|angleBetween|animCone|animCurveEditor|animDisplay|animView|annotate|appendStringArray|applicationName|applyAttrPreset|applyTake|arcLenDimContext|arcLengthDimension|arclen|arrayMapper|art3dPaintCtx|artAttrCtx|artAttrPaintVertexCtx|artAttrSkinPaintCtx|artAttrTool|artBuildPaintMenu|artFluidAttrCtx|artPuttyCtx|artSelectCtx|artSetPaintCtx|artUserPaintCtx|assignCommand|assignInputDevice|assignViewportFactories|attachCurve|attachDeviceAttr|attachSurface|attrColorSliderGrp|attrCompatibility|attrControlGrp|attrEnumOptionMenu|attrEnumOptionMenuGrp|attrFieldGrp|attrFieldSliderGrp|attrNavigationControlGrp|attrPresetEditWin|attributeExists|attributeInfo|attributeMenu|attributeQuery|autoKeyframe|autoPlace|bakeClip|bakeFluidShading|bakePartialHistory|bakeResults|bakeSimulation|basename|basenameEx|batchRender|bessel|bevel|bevelPlus|binMembership|bindSkin|blend2|blendShape|blendShapeEditor|blendShapePanel|blendTwoAttr|blindDataType|boneLattice|boundary|boxDollyCtx|boxZoomCtx|bufferCurve|buildBookmarkMenu|buildKeyframeMenu|button|buttonManip|cacheFile|cacheFileCombine|cacheFileMerge|cacheFileTrack|camera|cameraView|canCreateManip|canvas|capitalizeString|catch|catchQuiet|ceil|changeSubdivComponentDisplayLevel|changeSubdivRegion|channelBox|character|characterMap|characterOutlineEditor|characterize|chdir|checkBox|checkBoxGrp|checkDefaultRenderGlobals|choice|circle|circularFillet|clamp|clear|clearCache|clip|clipEditor|clipEditorCurrentTimeCtx|clipSchedule|clipSchedulerOutliner|clipTrimBefore|closeCurve|closeSurface|cluster|cmdFileOutput|cmdScrollFieldExecuter|cmdScrollFieldReporter|cmdShell|coarsenSubdivSelectionList|collision|color|colorAtPoint|colorEditor|colorIndex|colorIndexSliderGrp|colorSliderButtonGrp|colorSliderGrp|columnLayout|commandEcho|commandLine|commandPort|compactHairSystem|componentEditor|compositingInterop|computePolysetVolume|condition|cone|confirmDialog|connectAttr|connectControl|connectDynamic|connectJoint|connectionInfo|constrain|constrainValue|constructionHistory|container|containsMultibyte|contextInfo|control|convertFromOldLayers|convertIffToPsd|convertLightmap|convertSolidTx|convertTessellation|convertUnit|copyArray|copyFlexor|copyKey|copySkinWeights|cos|cpButton|cpCache|cpClothSet|cpCollision|cpConstraint|cpConvClothToMesh|cpForces|cpGetSolverAttr|cpPanel|cpProperty|cpRigidCollisionFilter|cpSeam|cpSetEdit|cpSetSolverAttr|cpSolver|cpSolverTypes|cpTool|cpUpdateClothUVs|createDisplayLayer|createDrawCtx|createEditor|createLayeredPsdFile|createMotionField|createNewShelf|createNode|createRenderLayer|createSubdivRegion|cross|crossProduct|ctxAbort|ctxCompletion|ctxEditMode|ctxTraverse|currentCtx|currentTime|currentTimeCtx|currentUnit|curve|curveAddPtCtx|curveCVCtx|curveEPCtx|curveEditorCtx|curveIntersect|curveMoveEPCtx|curveOnSurface|curveSketchCtx|cutKey|cycleCheck|cylinder|dagPose|date|defaultLightListCheckBox|defaultNavigation|defineDataServer|defineVirtualDevice|deformer|deg_to_rad|delete|deleteAttr|deleteShadingGroupsAndMaterials|deleteShelfTab|deleteUI|deleteUnusedBrushes|delrandstr|detachCurve|detachDeviceAttr|detachSurface|deviceEditor|devicePanel|dgInfo|dgdirty|dgeval|dgtimer|dimWhen|directKeyCtx|directionalLight|dirmap|dirname|disable|disconnectAttr|disconnectJoint|diskCache|displacementToPoly|displayAffected|displayColor|displayCull|displayLevelOfDetail|displayPref|displayRGBColor|displaySmoothness|displayStats|displayString|displaySurface|distanceDimContext|distanceDimension|doBlur|dolly|dollyCtx|dopeSheetEditor|dot|dotProduct|doubleProfileBirailSurface|drag|dragAttrContext|draggerContext|dropoffLocator|duplicate|duplicateCurve|duplicateSurface|dynCache|dynControl|dynExport|dynExpression|dynGlobals|dynPaintEditor|dynParticleCtx|dynPref|dynRelEdPanel|dynRelEditor|dynamicLoad|editAttrLimits|editDisplayLayerGlobals|editDisplayLayerMembers|editRenderLayerAdjustment|editRenderLayerGlobals|editRenderLayerMembers|editor|editorTemplate|effector|emit|emitter|enableDevice|encodeString|endString|endsWith|env|equivalent|equivalentTol|erf|error|eval|evalDeferred|evalEcho|event|exactWorldBoundingBox|exclusiveLightCheckBox|exec|executeForEachObject|exists|exp|expression|expressionEditorListen|extendCurve|extendSurface|extrude|fcheck|fclose|feof|fflush|fgetline|fgetword|file|fileBrowserDialog|fileDialog|fileExtension|fileInfo|filetest|filletCurve|filter|filterCurve|filterExpand|filterStudioImport|findAllIntersections|findAnimCurves|findKeyframe|findMenuItem|findRelatedSkinCluster|finder|firstParentOf|fitBspline|flexor|floatEq|floatField|floatFieldGrp|floatScrollBar|floatSlider|floatSlider2|floatSliderButtonGrp|floatSliderGrp|floor|flow|fluidCacheInfo|fluidEmitter|fluidVoxelInfo|flushUndo|fmod|fontDialog|fopen|formLayout|format|fprint|frameLayout|fread|freeFormFillet|frewind|fromNativePath|fwrite|gamma|gauss|geometryConstraint|getApplicationVersionAsFloat|getAttr|getClassification|getDefaultBrush|getFileList|getFluidAttr|getInputDeviceRange|getMayaPanelTypes|getModifiers|getPanel|getParticleAttr|getPluginResource|getenv|getpid|glRender|glRenderEditor|globalStitch|gmatch|goal|gotoBindPose|grabColor|gradientControl|gradientControlNoAttr|graphDollyCtx|graphSelectContext|graphTrackCtx|gravity|grid|gridLayout|group|groupObjectsByName|hardenPointCurve|hardware|hardwareRenderPanel|headsUpDisplay|headsUpMessage|help|helpLine|hermite|hide|hilite|hitTest|hotBox|hotkey|hotkeyCheck|hsv_to_rgb|hudButton|hudSlider|hudSliderButton|hwReflectionMap|hwRender|hwRenderLoad|hyperGraph|hyperPanel|hyperShade|hypot|iconTextButton|iconTextCheckBox|iconTextRadioButton|iconTextRadioCollection|iconTextScrollList|iconTextStaticLabel|ikHandle|ikHandleCtx|ikHandleDisplayScale|ikSolver|ikSplineHandleCtx|ikSystem|ikSystemInfo|ikfkDisplayMethod|illustratorCurves|image|imfPlugins|inheritTransform|insertJoint|insertJointCtx|insertKeyCtx|insertKnotCurve|insertKnotSurface|instance|instanceable|instancer|intField|intFieldGrp|intScrollBar|intSlider|intSliderGrp|interToUI|internalVar|intersect|iprEngine|isAnimCurve|isConnected|isDirty|isParentOf|isSameObject|isTrue|isValidObjectName|isValidString|isValidUiName|isolateSelect|itemFilter|itemFilterAttr|itemFilterRender|itemFilterType|joint|jointCluster|jointCtx|jointDisplayScale|jointLattice|keyTangent|keyframe|keyframeOutliner|keyframeRegionCurrentTimeCtx|keyframeRegionDirectKeyCtx|keyframeRegionDollyCtx|keyframeRegionInsertKeyCtx|keyframeRegionMoveKeyCtx|keyframeRegionScaleKeyCtx|keyframeRegionSelectKeyCtx|keyframeRegionSetKeyCtx|keyframeRegionTrackCtx|keyframeStats|lassoContext|lattice|latticeDeformKeyCtx|launch|launchImageEditor|layerButton|layeredShaderPort|layeredTexturePort|layout|layoutDialog|lightList|lightListEditor|lightListPanel|lightlink|lineIntersection|linearPrecision|linstep|listAnimatable|listAttr|listCameras|listConnections|listDeviceAttachments|listHistory|listInputDeviceAxes|listInputDeviceButtons|listInputDevices|listMenuAnnotation|listNodeTypes|listPanelCategories|listRelatives|listSets|listTransforms|listUnselected|listerEditor|loadFluid|loadNewShelf|loadPlugin|loadPluginLanguageResources|loadPrefObjects|localizedPanelLabel|lockNode|loft|log|longNameOf|lookThru|ls|lsThroughFilter|lsType|lsUI|mag|makeIdentity|makeLive|makePaintable|makeRoll|makeSingleSurface|makeTubeOn|makebot|manipMoveContext|manipMoveLimitsCtx|manipOptions|manipRotateContext|manipRotateLimitsCtx|manipScaleContext|manipScaleLimitsCtx|marker|match|max|memory|menu|menuBarLayout|menuEditor|menuItem|menuItemToShelf|menuSet|menuSetPref|messageLine|min|minimizeApp|mirrorJoint|modelCurrentTimeCtx|modelEditor|modelPanel|mouse|movIn|movOut|move|moveIKtoFK|moveKeyCtx|moveVertexAlongDirection|multiProfileBirailSurface|mute|nParticle|nameCommand|nameField|namespace|namespaceInfo|newPanelItems|newton|nodeCast|nodeIconButton|nodeOutliner|nodePreset|nodeType|noise|nonLinear|normalConstraint|normalize|nurbsBoolean|nurbsCopyUVSet|nurbsCube|nurbsEditUV|nurbsPlane|nurbsSelect|nurbsSquare|nurbsToPoly|nurbsToPolygonsPref|nurbsToSubdiv|nurbsToSubdivPref|nurbsUVSet|nurbsViewDirectionVector|objExists|objectCenter|objectLayer|objectType|objectTypeUI|obsoleteProc|oceanNurbsPreviewPlane|offsetCurve|offsetCurveOnSurface|offsetSurface|openGLExtension|openMayaPref|optionMenu|optionMenuGrp|optionVar|orbit|orbitCtx|orientConstraint|outlinerEditor|outlinerPanel|overrideModifier|paintEffectsDisplay|pairBlend|palettePort|paneLayout|panel|panelConfiguration|panelHistory|paramDimContext|paramDimension|paramLocator|parent|parentConstraint|particle|particleExists|particleInstancer|particleRenderInfo|partition|pasteKey|pathAnimation|pause|pclose|percent|performanceOptions|pfxstrokes|pickWalk|picture|pixelMove|planarSrf|plane|play|playbackOptions|playblast|plugAttr|plugNode|pluginInfo|pluginResourceUtil|pointConstraint|pointCurveConstraint|pointLight|pointMatrixMult|pointOnCurve|pointOnSurface|pointPosition|poleVectorConstraint|polyAppend|polyAppendFacetCtx|polyAppendVertex|polyAutoProjection|polyAverageNormal|polyAverageVertex|polyBevel|polyBlendColor|polyBlindData|polyBoolOp|polyBridgeEdge|polyCacheMonitor|polyCheck|polyChipOff|polyClipboard|polyCloseBorder|polyCollapseEdge|polyCollapseFacet|polyColorBlindData|polyColorDel|polyColorPerVertex|polyColorSet|polyCompare|polyCone|polyCopyUV|polyCrease|polyCreaseCtx|polyCreateFacet|polyCreateFacetCtx|polyCube|polyCut|polyCutCtx|polyCylinder|polyCylindricalProjection|polyDelEdge|polyDelFacet|polyDelVertex|polyDuplicateAndConnect|polyDuplicateEdge|polyEditUV|polyEditUVShell|polyEvaluate|polyExtrudeEdge|polyExtrudeFacet|polyExtrudeVertex|polyFlipEdge|polyFlipUV|polyForceUV|polyGeoSampler|polyHelix|polyInfo|polyInstallAction|polyLayoutUV|polyListComponentConversion|polyMapCut|polyMapDel|polyMapSew|polyMapSewMove|polyMergeEdge|polyMergeEdgeCtx|polyMergeFacet|polyMergeFacetCtx|polyMergeUV|polyMergeVertex|polyMirrorFace|polyMoveEdge|polyMoveFacet|polyMoveFacetUV|polyMoveUV|polyMoveVertex|polyNormal|polyNormalPerVertex|polyNormalizeUV|polyOptUvs|polyOptions|polyOutput|polyPipe|polyPlanarProjection|polyPlane|polyPlatonicSolid|polyPoke|polyPrimitive|polyPrism|polyProjection|polyPyramid|polyQuad|polyQueryBlindData|polyReduce|polySelect|polySelectConstraint|polySelectConstraintMonitor|polySelectCtx|polySelectEditCtx|polySeparate|polySetToFaceNormal|polySewEdge|polyShortestPathCtx|polySmooth|polySoftEdge|polySphere|polySphericalProjection|polySplit|polySplitCtx|polySplitEdge|polySplitRing|polySplitVertex|polyStraightenUVBorder|polySubdivideEdge|polySubdivideFacet|polyToSubdiv|polyTorus|polyTransfer|polyTriangulate|polyUVSet|polyUnite|polyWedgeFace|popen|popupMenu|pose|pow|preloadRefEd|print|progressBar|progressWindow|projFileViewer|projectCurve|projectTangent|projectionContext|projectionManip|promptDialog|propModCtx|propMove|psdChannelOutliner|psdEditTextureFile|psdExport|psdTextureFile|putenv|pwd|python|querySubdiv|quit|rad_to_deg|radial|radioButton|radioButtonGrp|radioCollection|radioMenuItemCollection|rampColorPort|rand|randomizeFollicles|randstate|rangeControl|readTake|rebuildCurve|rebuildSurface|recordAttr|recordDevice|redo|reference|referenceEdit|referenceQuery|refineSubdivSelectionList|refresh|refreshAE|registerPluginResource|rehash|reloadImage|removeJoint|removeMultiInstance|removePanelCategory|rename|renameAttr|renameSelectionList|renameUI|render|renderGlobalsNode|renderInfo|renderLayerButton|renderLayerParent|renderLayerPostProcess|renderLayerUnparent|renderManip|renderPartition|renderQualityNode|renderSettings|renderThumbnailUpdate|renderWindowEditor|renderWindowSelectContext|renderer|reorder|reorderDeformers|requires|reroot|resampleFluid|resetAE|resetPfxToPolyCamera|resetTool|resolutionNode|retarget|reverseCurve|reverseSurface|revolve|rgb_to_hsv|rigidBody|rigidSolver|roll|rollCtx|rootOf|rot|rotate|rotationInterpolation|roundConstantRadius|rowColumnLayout|rowLayout|runTimeCommand|runup|sampleImage|saveAllShelves|saveAttrPreset|saveFluid|saveImage|saveInitialState|saveMenu|savePrefObjects|savePrefs|saveShelf|saveToolSettings|scale|scaleBrushBrightness|scaleComponents|scaleConstraint|scaleKey|scaleKeyCtx|sceneEditor|sceneUIReplacement|scmh|scriptCtx|scriptEditorInfo|scriptJob|scriptNode|scriptTable|scriptToShelf|scriptedPanel|scriptedPanelType|scrollField|scrollLayout|sculpt|searchPathArray|seed|selLoadSettings|select|selectContext|selectCurveCV|selectKey|selectKeyCtx|selectKeyframeRegionCtx|selectMode|selectPref|selectPriority|selectType|selectedNodes|selectionConnection|separator|setAttr|setAttrEnumResource|setAttrMapping|setAttrNiceNameResource|setConstraintRestPosition|setDefaultShadingGroup|setDrivenKeyframe|setDynamic|setEditCtx|setEditor|setFluidAttr|setFocus|setInfinity|setInputDeviceMapping|setKeyCtx|setKeyPath|setKeyframe|setKeyframeBlendshapeTargetWts|setMenuMode|setNodeNiceNameResource|setNodeTypeFlag|setParent|setParticleAttr|setPfxToPolyCamera|setPluginResource|setProject|setStampDensity|setStartupMessage|setState|setToolTo|setUITemplate|setXformManip|sets|shadingConnection|shadingGeometryRelCtx|shadingLightRelCtx|shadingNetworkCompare|shadingNode|shapeCompare|shelfButton|shelfLayout|shelfTabLayout|shellField|shortNameOf|showHelp|showHidden|showManipCtx|showSelectionInTitle|showShadingGroupAttrEditor|showWindow|sign|simplify|sin|singleProfileBirailSurface|size|sizeBytes|skinCluster|skinPercent|smoothCurve|smoothTangentSurface|smoothstep|snap2to2|snapKey|snapMode|snapTogetherCtx|snapshot|soft|softMod|softModCtx|sort|sound|soundControl|source|spaceLocator|sphere|sphrand|spotLight|spotLightPreviewPort|spreadSheetEditor|spring|sqrt|squareSurface|srtContext|stackTrace|startString|startsWith|stitchAndExplodeShell|stitchSurface|stitchSurfacePoints|strcmp|stringArrayCatenate|stringArrayContains|stringArrayCount|stringArrayInsertAtIndex|stringArrayIntersector|stringArrayRemove|stringArrayRemoveAtIndex|stringArrayRemoveDuplicates|stringArrayRemoveExact|stringArrayToString|stringToStringArray|strip|stripPrefixFromName|stroke|subdAutoProjection|subdCleanTopology|subdCollapse|subdDuplicateAndConnect|subdEditUV|subdListComponentConversion|subdMapCut|subdMapSewMove|subdMatchTopology|subdMirror|subdToBlind|subdToPoly|subdTransferUVsToCache|subdiv|subdivCrease|subdivDisplaySmoothness|substitute|substituteAllString|substituteGeometry|substring|surface|surfaceSampler|surfaceShaderList|swatchDisplayPort|switchTable|symbolButton|symbolCheckBox|sysFile|system|tabLayout|tan|tangentConstraint|texLatticeDeformContext|texManipContext|texMoveContext|texMoveUVShellContext|texRotateContext|texScaleContext|texSelectContext|texSelectShortestPathCtx|texSmudgeUVContext|texWinToolCtx|text|textCurves|textField|textFieldButtonGrp|textFieldGrp|textManip|textScrollList|textToShelf|textureDisplacePlane|textureHairColor|texturePlacementContext|textureWindow|threadCount|threePointArcCtx|timeControl|timePort|timerX|toNativePath|toggle|toggleAxis|toggleWindowVisibility|tokenize|tokenizeList|tolerance|tolower|toolButton|toolCollection|toolDropped|toolHasOptions|toolPropertyWindow|torus|toupper|trace|track|trackCtx|transferAttributes|transformCompare|transformLimits|translator|trim|trunc|truncateFluidCache|truncateHairCache|tumble|tumbleCtx|turbulence|twoPointArcCtx|uiRes|uiTemplate|unassignInputDevice|undo|undoInfo|ungroup|uniform|unit|unloadPlugin|untangleUV|untitledFileName|untrim|upAxis|updateAE|userCtx|uvLink|uvSnapshot|validateShelfName|vectorize|view2dToolCtx|viewCamera|viewClipPlane|viewFit|viewHeadOn|viewLookAt|viewManip|viewPlace|viewSet|visor|volumeAxis|vortex|waitCursor|warning|webBrowser|webBrowserPrefs|whatIs|window|windowPref|wire|wireContext|workspace|wrinkle|wrinkleContext|writeTake|xbmLangPathList|xform)\b/,
          operator: [
            /\+[+=]?|-[-=]?|&&|\|\||[<>]=|[*\/!=]=?|[%^]/,
            {
              // We don't want to match <<
              pattern: /(^|[^<])<(?!<)/,
              lookbehind: true
            },
            {
              // We don't want to match >>
              pattern: /(^|[^>])>(?!>)/,
              lookbehind: true
            }
          ],
          punctuation: /<<|>>|[.,:;?\[\](){}]/
        };
        Prism2.languages.mel["code"].inside.rest = Prism2.languages.mel;
      }
      return mel_1;
    }
    var mermaid_1;
    var hasRequiredMermaid;
    function requireMermaid() {
      if (hasRequiredMermaid)
        return mermaid_1;
      hasRequiredMermaid = 1;
      mermaid_1 = mermaid;
      mermaid.displayName = "mermaid";
      mermaid.aliases = [];
      function mermaid(Prism2) {
        Prism2.languages.mermaid = {
          comment: {
            pattern: /%%.*/,
            greedy: true
          },
          style: {
            pattern: /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
            lookbehind: true,
            inside: {
              property: /\b\w[\w-]*(?=[ \t]*:)/,
              operator: /:/,
              punctuation: /,/
            }
          },
          "inter-arrow-label": {
            pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
            lookbehind: true,
            greedy: true,
            inside: {
              arrow: {
                pattern: /(?:\.+->?|--+[->]|==+[=>])$/,
                alias: "operator"
              },
              label: {
                pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
                lookbehind: true,
                alias: "property"
              },
              "arrow-head": {
                pattern: /^\S+/,
                alias: ["arrow", "operator"]
              }
            }
          },
          arrow: [
            // This might look complex but it really isn't.
            // There are many possible arrows (see tests) and it's impossible to fit all of them into one pattern. The
            // problem is that we only have one lookbehind per pattern. However, we cannot disallow too many arrow
            // characters in the one lookbehind because that would create too many false negatives. So we have to split the
            // arrows into different patterns.
            {
              // ER diagram
              pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
              lookbehind: true,
              alias: "operator"
            },
            {
              // flow chart
              // (?:==+|--+|-\.*-)
              pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
              lookbehind: true,
              alias: "operator"
            },
            {
              // sequence diagram
              pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
              lookbehind: true,
              alias: "operator"
            },
            {
              // class diagram
              pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
              lookbehind: true,
              alias: "operator"
            }
          ],
          label: {
            pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
            lookbehind: true,
            greedy: true,
            alias: "property"
          },
          text: {
            pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
            alias: "string"
          },
          string: {
            pattern: /"[^"\r\n]*"/,
            greedy: true
          },
          annotation: {
            pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
            alias: "important"
          },
          keyword: [
            // This language has both case-sensitive and case-insensitive keywords
            {
              pattern: /(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
              lookbehind: true,
              greedy: true
            },
            {
              pattern: /(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
              lookbehind: true,
              greedy: true
            }
          ],
          entity: /#[a-z0-9]+;/,
          operator: {
            pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/,
            lookbehind: true
          },
          punctuation: /[(){};]/
        };
      }
      return mermaid_1;
    }
    var mizar_1;
    var hasRequiredMizar;
    function requireMizar() {
      if (hasRequiredMizar)
        return mizar_1;
      hasRequiredMizar = 1;
      mizar_1 = mizar;
      mizar.displayName = "mizar";
      mizar.aliases = [];
      function mizar(Prism2) {
        Prism2.languages.mizar = {
          comment: /::.+/,
          keyword: /@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|end|environ|equals|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:ies|y)|when|where|with|wrt)\b/,
          parameter: {
            pattern: /\$(?:10|\d)/,
            alias: "variable"
          },
          variable: /\b\w+(?=:)/,
          number: /(?:\b|-)\d+\b/,
          operator: /\.\.\.|->|&|\.?=/,
          punctuation: /\(#|#\)|[,:;\[\](){}]/
        };
      }
      return mizar_1;
    }
    var mongodb_1;
    var hasRequiredMongodb;
    function requireMongodb() {
      if (hasRequiredMongodb)
        return mongodb_1;
      hasRequiredMongodb = 1;
      mongodb_1 = mongodb;
      mongodb.displayName = "mongodb";
      mongodb.aliases = [];
      function mongodb(Prism2) {
        (function(Prism3) {
          var operators = [
            // query and projection
            "$eq",
            "$gt",
            "$gte",
            "$in",
            "$lt",
            "$lte",
            "$ne",
            "$nin",
            "$and",
            "$not",
            "$nor",
            "$or",
            "$exists",
            "$type",
            "$expr",
            "$jsonSchema",
            "$mod",
            "$regex",
            "$text",
            "$where",
            "$geoIntersects",
            "$geoWithin",
            "$near",
            "$nearSphere",
            "$all",
            "$elemMatch",
            "$size",
            "$bitsAllClear",
            "$bitsAllSet",
            "$bitsAnyClear",
            "$bitsAnySet",
            "$comment",
            "$elemMatch",
            "$meta",
            "$slice",
            // update
            "$currentDate",
            "$inc",
            "$min",
            "$max",
            "$mul",
            "$rename",
            "$set",
            "$setOnInsert",
            "$unset",
            "$addToSet",
            "$pop",
            "$pull",
            "$push",
            "$pullAll",
            "$each",
            "$position",
            "$slice",
            "$sort",
            "$bit",
            // aggregation pipeline stages
            "$addFields",
            "$bucket",
            "$bucketAuto",
            "$collStats",
            "$count",
            "$currentOp",
            "$facet",
            "$geoNear",
            "$graphLookup",
            "$group",
            "$indexStats",
            "$limit",
            "$listLocalSessions",
            "$listSessions",
            "$lookup",
            "$match",
            "$merge",
            "$out",
            "$planCacheStats",
            "$project",
            "$redact",
            "$replaceRoot",
            "$replaceWith",
            "$sample",
            "$set",
            "$skip",
            "$sort",
            "$sortByCount",
            "$unionWith",
            "$unset",
            "$unwind",
            "$setWindowFields",
            // aggregation pipeline operators
            "$abs",
            "$accumulator",
            "$acos",
            "$acosh",
            "$add",
            "$addToSet",
            "$allElementsTrue",
            "$and",
            "$anyElementTrue",
            "$arrayElemAt",
            "$arrayToObject",
            "$asin",
            "$asinh",
            "$atan",
            "$atan2",
            "$atanh",
            "$avg",
            "$binarySize",
            "$bsonSize",
            "$ceil",
            "$cmp",
            "$concat",
            "$concatArrays",
            "$cond",
            "$convert",
            "$cos",
            "$dateFromParts",
            "$dateToParts",
            "$dateFromString",
            "$dateToString",
            "$dayOfMonth",
            "$dayOfWeek",
            "$dayOfYear",
            "$degreesToRadians",
            "$divide",
            "$eq",
            "$exp",
            "$filter",
            "$first",
            "$floor",
            "$function",
            "$gt",
            "$gte",
            "$hour",
            "$ifNull",
            "$in",
            "$indexOfArray",
            "$indexOfBytes",
            "$indexOfCP",
            "$isArray",
            "$isNumber",
            "$isoDayOfWeek",
            "$isoWeek",
            "$isoWeekYear",
            "$last",
            "$last",
            "$let",
            "$literal",
            "$ln",
            "$log",
            "$log10",
            "$lt",
            "$lte",
            "$ltrim",
            "$map",
            "$max",
            "$mergeObjects",
            "$meta",
            "$min",
            "$millisecond",
            "$minute",
            "$mod",
            "$month",
            "$multiply",
            "$ne",
            "$not",
            "$objectToArray",
            "$or",
            "$pow",
            "$push",
            "$radiansToDegrees",
            "$range",
            "$reduce",
            "$regexFind",
            "$regexFindAll",
            "$regexMatch",
            "$replaceOne",
            "$replaceAll",
            "$reverseArray",
            "$round",
            "$rtrim",
            "$second",
            "$setDifference",
            "$setEquals",
            "$setIntersection",
            "$setIsSubset",
            "$setUnion",
            "$size",
            "$sin",
            "$slice",
            "$split",
            "$sqrt",
            "$stdDevPop",
            "$stdDevSamp",
            "$strcasecmp",
            "$strLenBytes",
            "$strLenCP",
            "$substr",
            "$substrBytes",
            "$substrCP",
            "$subtract",
            "$sum",
            "$switch",
            "$tan",
            "$toBool",
            "$toDate",
            "$toDecimal",
            "$toDouble",
            "$toInt",
            "$toLong",
            "$toObjectId",
            "$toString",
            "$toLower",
            "$toUpper",
            "$trim",
            "$trunc",
            "$type",
            "$week",
            "$year",
            "$zip",
            "$count",
            "$dateAdd",
            "$dateDiff",
            "$dateSubtract",
            "$dateTrunc",
            "$getField",
            "$rand",
            "$sampleRate",
            "$setField",
            "$unsetField",
            // aggregation pipeline query modifiers
            "$comment",
            "$explain",
            "$hint",
            "$max",
            "$maxTimeMS",
            "$min",
            "$orderby",
            "$query",
            "$returnKey",
            "$showDiskLoc",
            "$natural"
          ];
          var builtinFunctions = [
            "ObjectId",
            "Code",
            "BinData",
            "DBRef",
            "Timestamp",
            "NumberLong",
            "NumberDecimal",
            "MaxKey",
            "MinKey",
            "RegExp",
            "ISODate",
            "UUID"
          ];
          operators = operators.map(function(operator) {
            return operator.replace("$", "\\$");
          });
          var operatorsSource = "(?:" + operators.join("|") + ")\\b";
          Prism3.languages.mongodb = Prism3.languages.extend("javascript", {});
          Prism3.languages.insertBefore("mongodb", "string", {
            property: {
              pattern: /(?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)(?=\s*:)/,
              greedy: true,
              inside: {
                keyword: RegExp(`^(['"])?` + operatorsSource + "(?:\\1)?$")
              }
            }
          });
          Prism3.languages.mongodb.string.inside = {
            url: {
              // url pattern
              pattern: /https?:\/\/[-\w@:%.+~#=]{1,256}\.[a-z0-9()]{1,6}\b[-\w()@:%+.~#?&/=]*/i,
              greedy: true
            },
            entity: {
              // ipv4
              pattern: /\b(?:(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d\d?|2[0-4]\d|25[0-5])\b/,
              greedy: true
            }
          };
          Prism3.languages.insertBefore("mongodb", "constant", {
            builtin: {
              pattern: RegExp("\\b(?:" + builtinFunctions.join("|") + ")\\b"),
              alias: "keyword"
            }
          });
        })(Prism2);
      }
      return mongodb_1;
    }
    var monkey_1;
    var hasRequiredMonkey;
    function requireMonkey() {
      if (hasRequiredMonkey)
        return monkey_1;
      hasRequiredMonkey = 1;
      monkey_1 = monkey;
      monkey.displayName = "monkey";
      monkey.aliases = [];
      function monkey(Prism2) {
        Prism2.languages.monkey = {
          comment: {
            pattern: /^#Rem\s[\s\S]*?^#End|'.+/im,
            greedy: true
          },
          string: {
            pattern: /"[^"\r\n]*"/,
            greedy: true
          },
          preprocessor: {
            pattern: /(^[ \t]*)#.+/m,
            lookbehind: true,
            greedy: true,
            alias: "property"
          },
          function: /\b\w+(?=\()/,
          "type-char": {
            pattern: /\b[?%#$]/,
            alias: "class-name"
          },
          number: {
            pattern: /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
            lookbehind: true
          },
          keyword: /\b(?:Abstract|Array|Bool|Case|Catch|Class|Const|Continue|Default|Eachin|Else|ElseIf|End|EndIf|Exit|Extends|Extern|False|Field|Final|Float|For|Forever|Function|Global|If|Implements|Import|Inline|Int|Interface|Local|Method|Module|New|Next|Null|Object|Private|Property|Public|Repeat|Return|Select|Self|Step|Strict|String|Super|Then|Throw|To|True|Try|Until|Void|Wend|While)\b/i,
          operator: /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
          punctuation: /[.,:;()\[\]]/
        };
      }
      return monkey_1;
    }
    var moonscript_1;
    var hasRequiredMoonscript;
    function requireMoonscript() {
      if (hasRequiredMoonscript)
        return moonscript_1;
      hasRequiredMoonscript = 1;
      moonscript_1 = moonscript;
      moonscript.displayName = "moonscript";
      moonscript.aliases = ["moon"];
      function moonscript(Prism2) {
        Prism2.languages.moonscript = {
          comment: /--.*/,
          string: [
            {
              pattern: /'[^']*'|\[(=*)\[[\s\S]*?\]\1\]/,
              greedy: true
            },
            {
              pattern: /"[^"]*"/,
              greedy: true,
              inside: {
                interpolation: {
                  pattern: /#\{[^{}]*\}/,
                  inside: {
                    moonscript: {
                      pattern: /(^#\{)[\s\S]+(?=\})/,
                      lookbehind: true,
                      inside: null
                      // see beow
                    },
                    "interpolation-punctuation": {
                      pattern: /#\{|\}/,
                      alias: "punctuation"
                    }
                  }
                }
              }
            }
          ],
          "class-name": [
            {
              pattern: /(\b(?:class|extends)[ \t]+)\w+/,
              lookbehind: true
            },
            // class-like names start with a capital letter
            /\b[A-Z]\w*/
          ],
          keyword: /\b(?:class|continue|do|else|elseif|export|extends|for|from|if|import|in|local|nil|return|self|super|switch|then|unless|using|when|while|with)\b/,
          variable: /@@?\w*/,
          property: {
            pattern: /\b(?!\d)\w+(?=:)|(:)(?!\d)\w+/,
            lookbehind: true
          },
          function: {
            pattern: /\b(?:_G|_VERSION|assert|collectgarbage|coroutine\.(?:create|resume|running|status|wrap|yield)|debug\.(?:debug|getfenv|gethook|getinfo|getlocal|getmetatable|getregistry|getupvalue|setfenv|sethook|setlocal|setmetatable|setupvalue|traceback)|dofile|error|getfenv|getmetatable|io\.(?:close|flush|input|lines|open|output|popen|read|stderr|stdin|stdout|tmpfile|type|write)|ipairs|load|loadfile|loadstring|math\.(?:abs|acos|asin|atan|atan2|ceil|cos|cosh|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pi|pow|rad|random|randomseed|sin|sinh|sqrt|tan|tanh)|module|next|os\.(?:clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(?:cpath|loaded|loadlib|path|preload|seeall)|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|string\.(?:byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|table\.(?:concat|insert|maxn|remove|sort)|tonumber|tostring|type|unpack|xpcall)\b/,
            inside: {
              punctuation: /\./
            }
          },
          boolean: /\b(?:false|true)\b/,
          number: /(?:\B\.\d+|\b\d+\.\d+|\b\d+(?=[eE]))(?:[eE][-+]?\d+)?\b|\b(?:0x[a-fA-F\d]+|\d+)(?:U?LL)?\b/,
          operator: /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
          punctuation: /[.,()[\]{}\\]/
        };
        Prism2.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside = Prism2.languages.moonscript;
        Prism2.languages.moon = Prism2.languages.moonscript;
      }
      return moonscript_1;
    }
    var n1ql_1;
    var hasRequiredN1ql;
    function requireN1ql() {
      if (hasRequiredN1ql)
        return n1ql_1;
      hasRequiredN1ql = 1;
      n1ql_1 = n1ql;
      n1ql.displayName = "n1ql";
      n1ql.aliases = [];
      function n1ql(Prism2) {
        Prism2.languages.n1ql = {
          comment: {
            pattern: /\/\*[\s\S]*?(?:$|\*\/)|--.*/,
            greedy: true
          },
          string: {
            pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\]|\1\1)*\1/,
            greedy: true
          },
          identifier: {
            pattern: /`(?:\\[\s\S]|[^\\`]|``)*`/,
            greedy: true
          },
          parameter: /\$[\w.]+/,
          // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html#n1ql-reserved-words
          keyword: /\b(?:ADVISE|ALL|ALTER|ANALYZE|AS|ASC|AT|BEGIN|BINARY|BOOLEAN|BREAK|BUCKET|BUILD|BY|CALL|CAST|CLUSTER|COLLATE|COLLECTION|COMMIT|COMMITTED|CONNECT|CONTINUE|CORRELATE|CORRELATED|COVER|CREATE|CURRENT|DATABASE|DATASET|DATASTORE|DECLARE|DECREMENT|DELETE|DERIVED|DESC|DESCRIBE|DISTINCT|DO|DROP|EACH|ELEMENT|EXCEPT|EXCLUDE|EXECUTE|EXPLAIN|FETCH|FILTER|FLATTEN|FLUSH|FOLLOWING|FOR|FORCE|FROM|FTS|FUNCTION|GOLANG|GRANT|GROUP|GROUPS|GSI|HASH|HAVING|IF|IGNORE|ILIKE|INCLUDE|INCREMENT|INDEX|INFER|INLINE|INNER|INSERT|INTERSECT|INTO|IS|ISOLATION|JAVASCRIPT|JOIN|KEY|KEYS|KEYSPACE|KNOWN|LANGUAGE|LAST|LEFT|LET|LETTING|LEVEL|LIMIT|LSM|MAP|MAPPING|MATCHED|MATERIALIZED|MERGE|MINUS|MISSING|NAMESPACE|NEST|NL|NO|NTH_VALUE|NULL|NULLS|NUMBER|OBJECT|OFFSET|ON|OPTION|OPTIONS|ORDER|OTHERS|OUTER|OVER|PARSE|PARTITION|PASSWORD|PATH|POOL|PRECEDING|PREPARE|PRIMARY|PRIVATE|PRIVILEGE|PROBE|PROCEDURE|PUBLIC|RANGE|RAW|REALM|REDUCE|RENAME|RESPECT|RETURN|RETURNING|REVOKE|RIGHT|ROLE|ROLLBACK|ROW|ROWS|SATISFIES|SAVEPOINT|SCHEMA|SCOPE|SELECT|SELF|SEMI|SET|SHOW|SOME|START|STATISTICS|STRING|SYSTEM|TIES|TO|TRAN|TRANSACTION|TRIGGER|TRUNCATE|UNBOUNDED|UNDER|UNION|UNIQUE|UNKNOWN|UNNEST|UNSET|UPDATE|UPSERT|USE|USER|USING|VALIDATE|VALUE|VALUES|VIA|VIEW|WHERE|WHILE|WINDOW|WITH|WORK|XOR)\b/i,
          function: /\b[a-z_]\w*(?=\s*\()/i,
          boolean: /\b(?:FALSE|TRUE)\b/i,
          number: /(?:\b\d+\.|\B\.)\d+e[+\-]?\d+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
          operator: /[-+*\/%]|!=|==?|\|\||<[>=]?|>=?|\b(?:AND|ANY|ARRAY|BETWEEN|CASE|ELSE|END|EVERY|EXISTS|FIRST|IN|LIKE|NOT|OR|THEN|VALUED|WHEN|WITHIN)\b/i,
          punctuation: /[;[\](),.{}:]/
        };
      }
      return n1ql_1;
    }
    var n4js_1;
    var hasRequiredN4js;
    function requireN4js() {
      if (hasRequiredN4js)
        return n4js_1;
      hasRequiredN4js = 1;
      n4js_1 = n4js;
      n4js.displayName = "n4js";
      n4js.aliases = ["n4jsd"];
      function n4js(Prism2) {
        Prism2.languages.n4js = Prism2.languages.extend("javascript", {
          // Keywords from N4JS language spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html
          keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/
        });
        Prism2.languages.insertBefore("n4js", "constant", {
          // Annotations in N4JS spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html#_annotations
          annotation: {
            pattern: /@+\w+/,
            alias: "operator"
          }
        });
        Prism2.languages.n4jsd = Prism2.languages.n4js;
      }
      return n4js_1;
    }
    var nand2tetrisHdl_1;
    var hasRequiredNand2tetrisHdl;
    function requireNand2tetrisHdl() {
      if (hasRequiredNand2tetrisHdl)
        return nand2tetrisHdl_1;
      hasRequiredNand2tetrisHdl = 1;
      nand2tetrisHdl_1 = nand2tetrisHdl;
      nand2tetrisHdl.displayName = "nand2tetrisHdl";
      nand2tetrisHdl.aliases = [];
      function nand2tetrisHdl(Prism2) {
        Prism2.languages["nand2tetris-hdl"] = {
          comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
          keyword: /\b(?:BUILTIN|CHIP|CLOCKED|IN|OUT|PARTS)\b/,
          boolean: /\b(?:false|true)\b/,
          function: /\b[A-Za-z][A-Za-z0-9]*(?=\()/,
          number: /\b\d+\b/,
          operator: /=|\.\./,
          punctuation: /[{}[\];(),:]/
        };
      }
      return nand2tetrisHdl_1;
    }
    var naniscript_1;
    var hasRequiredNaniscript;
    function requireNaniscript() {
      if (hasRequiredNaniscript)
        return naniscript_1;
      hasRequiredNaniscript = 1;
      naniscript_1 = naniscript;
      naniscript.displayName = "naniscript";
      naniscript.aliases = [];
      function naniscript(Prism2) {
        (function(Prism3) {
          var expressionDef = /\{[^\r\n\[\]{}]*\}/;
          var params = {
            "quoted-string": {
              pattern: /"(?:[^"\\]|\\.)*"/,
              alias: "operator"
            },
            "command-param-id": {
              pattern: /(\s)\w+:/,
              lookbehind: true,
              alias: "property"
            },
            "command-param-value": [
              {
                pattern: expressionDef,
                alias: "selector"
              },
              {
                pattern: /([\t ])\S+/,
                lookbehind: true,
                greedy: true,
                alias: "operator"
              },
              {
                pattern: /\S(?:.*\S)?/,
                alias: "operator"
              }
            ]
          };
          Prism3.languages.naniscript = {
            // ; ...
            comment: {
              pattern: /^([\t ]*);.*/m,
              lookbehind: true
            },
            // > ...
            // Define is a control line starting with '>' followed by a word, a space and a text.
            define: {
              pattern: /^>.+/m,
              alias: "tag",
              inside: {
                value: {
                  pattern: /(^>\w+[\t ]+)(?!\s)[^{}\r\n]+/,
                  lookbehind: true,
                  alias: "operator"
                },
                key: {
                  pattern: /(^>)\w+/,
                  lookbehind: true
                }
              }
            },
            // # ...
            label: {
              pattern: /^([\t ]*)#[\t ]*\w+[\t ]*$/m,
              lookbehind: true,
              alias: "regex"
            },
            command: {
              pattern: /^([\t ]*)@\w+(?=[\t ]|$).*/m,
              lookbehind: true,
              alias: "function",
              inside: {
                "command-name": /^@\w+/,
                expression: {
                  pattern: expressionDef,
                  greedy: true,
                  alias: "selector"
                },
                "command-params": {
                  pattern: /\s*\S[\s\S]*/,
                  inside: params
                }
              }
            },
            // Generic is any line that doesn't start with operators: ;>#@
            "generic-text": {
              pattern: /(^[ \t]*)[^#@>;\s].*/m,
              lookbehind: true,
              alias: "punctuation",
              inside: {
                // \{ ... \} ... \[ ... \] ... \"
                "escaped-char": /\\[{}\[\]"]/,
                expression: {
                  pattern: expressionDef,
                  greedy: true,
                  alias: "selector"
                },
                "inline-command": {
                  pattern: /\[[\t ]*\w[^\r\n\[\]]*\]/,
                  greedy: true,
                  alias: "function",
                  inside: {
                    "command-params": {
                      pattern: /(^\[[\t ]*\w+\b)[\s\S]+(?=\]$)/,
                      lookbehind: true,
                      inside: params
                    },
                    "command-param-name": {
                      pattern: /^(\[[\t ]*)\w+/,
                      lookbehind: true,
                      alias: "name"
                    },
                    "start-stop-char": /[\[\]]/
                  }
                }
              }
            }
          };
          Prism3.languages.nani = Prism3.languages["naniscript"];
          Prism3.hooks.add("after-tokenize", function(env2) {
            var tokens = env2.tokens;
            tokens.forEach(function(token) {
              if (typeof token !== "string" && token.type === "generic-text") {
                var content2 = getTextContent(token);
                if (!isBracketsBalanced(content2)) {
                  token.type = "bad-line";
                  token.content = content2;
                }
              }
            });
          });
          function isBracketsBalanced(input) {
            var brackets = "[]{}";
            var stack = [];
            for (var i = 0; i < input.length; i++) {
              var bracket = input[i];
              var bracketsIndex = brackets.indexOf(bracket);
              if (bracketsIndex !== -1) {
                if (bracketsIndex % 2 === 0) {
                  stack.push(bracketsIndex + 1);
                } else if (stack.pop() !== bracketsIndex) {
                  return false;
                }
              }
            }
            return stack.length === 0;
          }
          function getTextContent(token) {
            if (typeof token === "string") {
              return token;
            } else if (Array.isArray(token)) {
              return token.map(getTextContent).join("");
            } else {
              return getTextContent(token.content);
            }
          }
        })(Prism2);
      }
      return naniscript_1;
    }
    var nasm_1;
    var hasRequiredNasm;
    function requireNasm() {
      if (hasRequiredNasm)
        return nasm_1;
      hasRequiredNasm = 1;
      nasm_1 = nasm;
      nasm.displayName = "nasm";
      nasm.aliases = [];
      function nasm(Prism2) {
        Prism2.languages.nasm = {
          comment: /;.*$/m,
          string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
          label: {
            pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
            lookbehind: true,
            alias: "function"
          },
          keyword: [
            /\[?BITS (?:16|32|64)\]?/,
            {
              pattern: /(^\s*)section\s*[a-z.]+:?/im,
              lookbehind: true
            },
            /(?:extern|global)[^;\r\n]*/i,
            /(?:CPU|DEFAULT|FLOAT).*$/m
          ],
          register: {
            pattern: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s)\b/i,
            alias: "variable"
          },
          number: /(?:\b|(?=\$))(?:0[hx](?:\.[\da-f]+|[\da-f]+(?:\.[\da-f]+)?)(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
          operator: /[\[\]*+\-\/%<>=&|$!]/
        };
      }
      return nasm_1;
    }
    var neon_1;
    var hasRequiredNeon;
    function requireNeon() {
      if (hasRequiredNeon)
        return neon_1;
      hasRequiredNeon = 1;
      neon_1 = neon;
      neon.displayName = "neon";
      neon.aliases = [];
      function neon(Prism2) {
        Prism2.languages.neon = {
          comment: {
            pattern: /#.*/,
            greedy: true
          },
          datetime: {
            pattern: /(^|[[{(=:,\s])\d\d\d\d-\d\d?-\d\d?(?:(?:[Tt]| +)\d\d?:\d\d:\d\d(?:\.\d*)? *(?:Z|[-+]\d\d?(?::?\d\d)?)?)?(?=$|[\]}),\s])/,
            lookbehind: true,
            alias: "number"
          },
          key: {
            pattern: /(^|[[{(,\s])[^,:=[\]{}()'"\s]+(?=\s*:(?:$|[\]}),\s])|\s*=)/,
            lookbehind: true,
            alias: "atrule"
          },
          number: {
            pattern: /(^|[[{(=:,\s])[+-]?(?:0x[\da-fA-F]+|0o[0-7]+|0b[01]+|(?:\d+(?:\.\d*)?|\.?\d+)(?:[eE][+-]?\d+)?)(?=$|[\]}),:=\s])/,
            lookbehind: true
          },
          boolean: {
            pattern: /(^|[[{(=:,\s])(?:false|no|true|yes)(?=$|[\]}),:=\s])/i,
            lookbehind: true
          },
          null: {
            pattern: /(^|[[{(=:,\s])(?:null)(?=$|[\]}),:=\s])/i,
            lookbehind: true,
            alias: "keyword"
          },
          string: {
            pattern: /(^|[[{(=:,\s])(?:('''|""")\r?\n(?:(?:[^\r\n]|\r?\n(?![\t ]*\2))*\r?\n)?[\t ]*\2|'[^'\r\n]*'|"(?:\\.|[^\\"\r\n])*")/,
            lookbehind: true,
            greedy: true
          },
          literal: {
            pattern: /(^|[[{(=:,\s])(?:[^#"',:=[\]{}()\s`-]|[:-][^"',=[\]{}()\s])(?:[^,:=\]})(\s]|:(?![\s,\]})]|$)|[ \t]+[^#,:=\]})(\s])*/,
            lookbehind: true,
            alias: "string"
          },
          punctuation: /[,:=[\]{}()-]/
        };
      }
      return neon_1;
    }
    var nevod_1;
    var hasRequiredNevod;
    function requireNevod() {
      if (hasRequiredNevod)
        return nevod_1;
      hasRequiredNevod = 1;
      nevod_1 = nevod;
      nevod.displayName = "nevod";
      nevod.aliases = [];
      function nevod(Prism2) {
        Prism2.languages.nevod = {
          comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
          string: {
            pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
            greedy: true,
            inside: {
              "string-attrs": /!$|!\*$|\*$/
            }
          },
          namespace: {
            pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
            lookbehind: true
          },
          pattern: {
            pattern: /(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
            lookbehind: true,
            inside: {
              "pattern-name": {
                pattern: /^#?[a-zA-Z0-9\-.]+/,
                alias: "class-name"
              },
              fields: {
                pattern: /\(.*\)/,
                inside: {
                  "field-name": {
                    pattern: /[a-zA-Z0-9\-.]+/,
                    alias: "variable"
                  },
                  punctuation: /[,()]/,
                  operator: {
                    pattern: /~/,
                    alias: "field-hidden-mark"
                  }
                }
              }
            }
          },
          search: {
            pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
            alias: "function",
            lookbehind: true
          },
          keyword: /@(?:having|inside|namespace|outside|pattern|require|search|where)\b/,
          "standard-pattern": {
            pattern: /\b(?:Alpha|AlphaNum|Any|Blank|End|LineBreak|Num|NumAlpha|Punct|Space|Start|Symbol|Word|WordBreak)\b(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
            inside: {
              "standard-pattern-name": {
                pattern: /^[a-zA-Z0-9\-.]+/,
                alias: "builtin"
              },
              quantifier: {
                pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
                alias: "number"
              },
              "standard-pattern-attr": {
                pattern: /[a-zA-Z0-9\-.]+/,
                alias: "builtin"
              },
              punctuation: /[,()]/
            }
          },
          quantifier: {
            pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
            alias: "number"
          },
          operator: [
            {
              pattern: /=/,
              alias: "pattern-def"
            },
            {
              pattern: /&/,
              alias: "conjunction"
            },
            {
              pattern: /~/,
              alias: "exception"
            },
            {
              pattern: /\?/,
              alias: "optionality"
            },
            {
              pattern: /[[\]]/,
              alias: "repetition"
            },
            {
              pattern: /[{}]/,
              alias: "variation"
            },
            {
              pattern: /[+_]/,
              alias: "sequence"
            },
            {
              pattern: /\.{2,3}/,
              alias: "span"
            }
          ],
          "field-capture": [
            {
              pattern: /([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
              lookbehind: true,
              inside: {
                "field-name": {
                  pattern: /[a-zA-Z0-9\-.]+/,
                  alias: "variable"
                },
                colon: /:/
              }
            },
            {
              pattern: /[a-zA-Z0-9\-.]+\s*:/,
              inside: {
                "field-name": {
                  pattern: /[a-zA-Z0-9\-.]+/,
                  alias: "variable"
                },
                colon: /:/
              }
            }
          ],
          punctuation: /[:;,()]/,
          name: /[a-zA-Z0-9\-.]+/
        };
      }
      return nevod_1;
    }
    var nginx_1;
    var hasRequiredNginx;
    function requireNginx() {
      if (hasRequiredNginx)
        return nginx_1;
      hasRequiredNginx = 1;
      nginx_1 = nginx;
      nginx.displayName = "nginx";
      nginx.aliases = [];
      function nginx(Prism2) {
        (function(Prism3) {
          var variable = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
          Prism3.languages.nginx = {
            comment: {
              pattern: /(^|[\s{};])#.*/,
              lookbehind: true,
              greedy: true
            },
            directive: {
              pattern: /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
              lookbehind: true,
              greedy: true,
              inside: {
                string: {
                  pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
                  lookbehind: true,
                  greedy: true,
                  inside: {
                    escape: {
                      pattern: /\\["'\\nrt]/,
                      alias: "entity"
                    },
                    variable
                  }
                },
                comment: {
                  pattern: /(\s)#.*/,
                  lookbehind: true,
                  greedy: true
                },
                keyword: {
                  pattern: /^\S+/,
                  greedy: true
                },
                // other patterns
                boolean: {
                  pattern: /(\s)(?:off|on)(?!\S)/,
                  lookbehind: true
                },
                number: {
                  pattern: /(\s)\d+[a-z]*(?!\S)/i,
                  lookbehind: true
                },
                variable
              }
            },
            punctuation: /[{};]/
          };
        })(Prism2);
      }
      return nginx_1;
    }
    var nim_1;
    var hasRequiredNim;
    function requireNim() {
      if (hasRequiredNim)
        return nim_1;
      hasRequiredNim = 1;
      nim_1 = nim;
      nim.displayName = "nim";
      nim.aliases = [];
      function nim(Prism2) {
        Prism2.languages.nim = {
          comment: {
            pattern: /#.*/,
            greedy: true
          },
          string: {
            // Double-quoted strings can be prefixed by an identifier (Generalized raw string literals)
            pattern: /(?:\b(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")/,
            greedy: true
          },
          char: {
            // Character literals are handled specifically to prevent issues with numeric type suffixes
            pattern: /'(?:\\(?:\d+|x[\da-fA-F]{0,2}|.)|[^'])'/,
            greedy: true
          },
          function: {
            pattern: /(?:(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
            greedy: true,
            inside: {
              operator: /\*$/
            }
          },
          // We don't want to highlight operators (and anything really) inside backticks
          identifier: {
            pattern: /`[^`\r\n]+`/,
            greedy: true,
            inside: {
              punctuation: /`/
            }
          },
          // The negative look ahead prevents wrong highlighting of the .. operator
          number: /\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
          keyword: /\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
          operator: {
            // Look behind and look ahead prevent wrong highlighting of punctuations [. .] {. .} (. .)
            // but allow the slice operator .. to take precedence over them
            // One can define his own operators in Nim so all combination of operators might be an operator.
            pattern: /(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\b)/m,
            lookbehind: true
          },
          punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
        };
      }
      return nim_1;
    }
    var nix_1;
    var hasRequiredNix;
    function requireNix() {
      if (hasRequiredNix)
        return nix_1;
      hasRequiredNix = 1;
      nix_1 = nix;
      nix.displayName = "nix";
      nix.aliases = [];
      function nix(Prism2) {
        Prism2.languages.nix = {
          comment: {
            pattern: /\/\*[\s\S]*?\*\/|#.*/,
            greedy: true
          },
          string: {
            pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
            greedy: true,
            inside: {
              interpolation: {
                // The lookbehind ensures the ${} is not preceded by \ or ''
                pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
                lookbehind: true,
                inside: null
                // see below
              }
            }
          },
          url: [
            /\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/,
            {
              pattern: /([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
              lookbehind: true
            }
          ],
          antiquotation: {
            pattern: /\$(?=\{)/,
            alias: "important"
          },
          number: /\b\d+\b/,
          keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
          function: /\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:Tarball|url)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
          boolean: /\b(?:false|true)\b/,
          operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
          punctuation: /[{}()[\].,:;]/
        };
        Prism2.languages.nix.string.inside.interpolation.inside = Prism2.languages.nix;
      }
      return nix_1;
    }
    var nsis_1;
    var hasRequiredNsis;
    function requireNsis() {
      if (hasRequiredNsis)
        return nsis_1;
      hasRequiredNsis = 1;
      nsis_1 = nsis;
      nsis.displayName = "nsis";
      nsis.aliases = [];
      function nsis(Prism2) {
        Prism2.languages.nsis = {
          comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|[#;].*)/,
            lookbehind: true,
            greedy: true
          },
          string: {
            pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          keyword: {
            pattern: /(^[\t ]*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|BG(?:Font|Gradient|Image)|Banner|BrandingText|BringToFront|CRCCheck|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|Seek|Write|WriteByte|WriteUTF16LE|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DLLVersion(?:Local)?|DlgItem|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|LabelAddress|TempFileName)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|Silent)|InitPluginsDir|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|Int(?:64|Ptr)?CmpU?|Int(?:64)?Fmt|Int(?:Ptr)?Op|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|NSISdl|Name|Nop|OutFile|PE(?:DllCharacteristics|SubsysVer)|Page(?:Callbacks)?|Pop|Push|Quit|RMDir|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|UnRegDLL|Unicode|UninstPage|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UserInfo|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|Var|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle|ns(?:Dialogs|Exec))\b/m,
            lookbehind: true
          },
          property: /\b(?:ARCHIVE|FILE_(?:ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(?:(?:CR|CU|LM)(?:32|64)?|DD|PD|U)|HKEY_(?:CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(?:ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(?:ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY|admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user)\b/,
          constant: /\$\{[!\w\.:\^-]+\}|\$\([!\w\.:\^-]+\)/,
          variable: /\$\w[\w\.]*/,
          number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
          punctuation: /[{}[\];(),.:]/,
          important: {
            pattern: /(^[\t ]*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversion|gettlbversion|if|ifdef|ifmacrodef|ifmacrondef|ifndef|include|insertmacro|macro|macroend|makensis|packhdr|pragma|searchparse|searchreplace|system|tempfile|undef|verbose|warning)\b/im,
            lookbehind: true
          }
        };
      }
      return nsis_1;
    }
    var objectivec_1;
    var hasRequiredObjectivec;
    function requireObjectivec() {
      if (hasRequiredObjectivec)
        return objectivec_1;
      hasRequiredObjectivec = 1;
      var refractorC = requireC();
      objectivec_1 = objectivec;
      objectivec.displayName = "objectivec";
      objectivec.aliases = ["objc"];
      function objectivec(Prism2) {
        Prism2.register(refractorC);
        Prism2.languages.objectivec = Prism2.languages.extend("c", {
          string: {
            pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
            greedy: true
          },
          keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
          operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
        });
        delete Prism2.languages.objectivec["class-name"];
        Prism2.languages.objc = Prism2.languages.objectivec;
      }
      return objectivec_1;
    }
    var ocaml_1;
    var hasRequiredOcaml;
    function requireOcaml() {
      if (hasRequiredOcaml)
        return ocaml_1;
      hasRequiredOcaml = 1;
      ocaml_1 = ocaml;
      ocaml.displayName = "ocaml";
      ocaml.aliases = [];
      function ocaml(Prism2) {
        Prism2.languages.ocaml = {
          comment: {
            pattern: /\(\*[\s\S]*?\*\)/,
            greedy: true
          },
          char: {
            pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
            greedy: true
          },
          string: [
            {
              pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
              greedy: true
            },
            {
              pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
              greedy: true
            }
          ],
          number: [
            // binary and octal
            /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
            // hexadecimal
            /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
            // decimal
            /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
          ],
          directive: {
            pattern: /\B#\w+/,
            alias: "property"
          },
          label: {
            pattern: /\B~\w+/,
            alias: "property"
          },
          "type-variable": {
            pattern: /\B'\w+/,
            alias: "function"
          },
          variant: {
            pattern: /`\w+/,
            alias: "symbol"
          },
          // For the list of keywords and operators,
          // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84
          keyword: /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
          boolean: /\b(?:false|true)\b/,
          "operator-like-punctuation": {
            pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
            alias: "punctuation"
          },
          // Custom operators are allowed
          operator: /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
          punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
        };
      }
      return ocaml_1;
    }
    var opencl_1;
    var hasRequiredOpencl;
    function requireOpencl() {
      if (hasRequiredOpencl)
        return opencl_1;
      hasRequiredOpencl = 1;
      var refractorC = requireC();
      opencl_1 = opencl;
      opencl.displayName = "opencl";
      opencl.aliases = [];
      function opencl(Prism2) {
        Prism2.register(refractorC);
        (function(Prism3) {
          Prism3.languages.opencl = Prism3.languages.extend("c", {
            // Extracted from the official specs (2.0) and http://streamcomputing.eu/downloads/?opencl.lang (opencl-keywords, opencl-types) and http://sourceforge.net/tracker/?func=detail&aid=2957794&group_id=95717&atid=612384 (Words2, partly Words3)
            keyword: /\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
            // Extracted from http://streamcomputing.eu/downloads/?opencl.lang (opencl-const)
            // Math Constants: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/mathConstants.html
            // Macros and Limits: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/macroLimits.html
            number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
            boolean: /\b(?:false|true)\b/,
            "constant-opencl-kernel": {
              pattern: /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:2|10)E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
              alias: "constant"
            }
          });
          Prism3.languages.insertBefore("opencl", "class-name", {
            // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/scalarDataTypes.html
            // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/otherDataTypes.html
            "builtin-type": {
              pattern: /\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|intptr_t|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|uintptr_t)\b/,
              alias: "keyword"
            }
          });
          var attributes2 = {
            // Extracted from http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-types and opencl-host)
            "type-opencl-host": {
              pattern: /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
              alias: "keyword"
            },
            "boolean-opencl-host": {
              pattern: /\bCL_(?:FALSE|TRUE)\b/,
              alias: "boolean"
            },
            // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-const)
            "constant-opencl-host": {
              pattern: /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
              alias: "constant"
            },
            // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-host)
            "function-opencl-host": {
              pattern: /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
              alias: "function"
            }
          };
          Prism3.languages.insertBefore("c", "keyword", attributes2);
          if (Prism3.languages.cpp) {
            attributes2["type-opencl-host-cpp"] = {
              pattern: /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|Sampler|UserEvent)\b/,
              alias: "keyword"
            };
            Prism3.languages.insertBefore("cpp", "keyword", attributes2);
          }
        })(Prism2);
      }
      return opencl_1;
    }
    var openqasm_1;
    var hasRequiredOpenqasm;
    function requireOpenqasm() {
      if (hasRequiredOpenqasm)
        return openqasm_1;
      hasRequiredOpenqasm = 1;
      openqasm_1 = openqasm;
      openqasm.displayName = "openqasm";
      openqasm.aliases = ["qasm"];
      function openqasm(Prism2) {
        Prism2.languages.openqasm = {
          comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
          string: {
            pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/,
            greedy: true
          },
          keyword: /\b(?:CX|OPENQASM|U|barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while)\b|#pragma\b/,
          "class-name": /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
          function: /\b(?:cos|exp|ln|popcount|rotl|rotr|sin|sqrt|tan)\b(?=\s*\()/,
          constant: /\b(?:euler|pi|tau)\b|π|𝜏|ℇ/,
          number: {
            pattern: /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|µs|ms|s)?/i,
            lookbehind: true
          },
          operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
          punctuation: /[(){}\[\];,:.]/
        };
        Prism2.languages.qasm = Prism2.languages.openqasm;
      }
      return openqasm_1;
    }
    var oz_1;
    var hasRequiredOz;
    function requireOz() {
      if (hasRequiredOz)
        return oz_1;
      hasRequiredOz = 1;
      oz_1 = oz;
      oz.displayName = "oz";
      oz.aliases = [];
      function oz(Prism2) {
        Prism2.languages.oz = {
          comment: {
            pattern: /\/\*[\s\S]*?\*\/|%.*/,
            greedy: true
          },
          string: {
            pattern: /"(?:[^"\\]|\\[\s\S])*"/,
            greedy: true
          },
          atom: {
            pattern: /'(?:[^'\\]|\\[\s\S])*'/,
            greedy: true,
            alias: "builtin"
          },
          keyword: /\$|\[\]|\b(?:_|at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
          function: [
            /\b[a-z][A-Za-z\d]*(?=\()/,
            {
              pattern: /(\{)[A-Z][A-Za-z\d]*\b/,
              lookbehind: true
            }
          ],
          number: /\b(?:0[bx][\da-f]+|\d+(?:\.\d*)?(?:e~?\d+)?)\b|&(?:[^\\]|\\(?:\d{3}|.))/i,
          variable: /`(?:[^`\\]|\\.)+`/,
          "attr-name": /\b\w+(?=[ \t]*:(?![:=]))/,
          operator: /:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
          punctuation: /[\[\](){}.:;?]/
        };
      }
      return oz_1;
    }
    var parigp_1;
    var hasRequiredParigp;
    function requireParigp() {
      if (hasRequiredParigp)
        return parigp_1;
      hasRequiredParigp = 1;
      parigp_1 = parigp;
      parigp.displayName = "parigp";
      parigp.aliases = [];
      function parigp(Prism2) {
        Prism2.languages.parigp = {
          comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
          string: {
            pattern: /"(?:[^"\\\r\n]|\\.)*"/,
            greedy: true
          },
          // PARI/GP does not care about white spaces at all
          // so let's process the keywords to build an appropriate regexp
          // (e.g. "b *r *e *a *k", etc.)
          keyword: function() {
            var keywords = [
              "breakpoint",
              "break",
              "dbg_down",
              "dbg_err",
              "dbg_up",
              "dbg_x",
              "forcomposite",
              "fordiv",
              "forell",
              "forpart",
              "forprime",
              "forstep",
              "forsubgroup",
              "forvec",
              "for",
              "iferr",
              "if",
              "local",
              "my",
              "next",
              "return",
              "until",
              "while"
            ];
            keywords = keywords.map(function(keyword) {
              return keyword.split("").join(" *");
            }).join("|");
            return RegExp("\\b(?:" + keywords + ")\\b");
          }(),
          function: /\b\w(?:[\w ]*\w)?(?= *\()/,
          number: {
            // The lookbehind and the negative lookahead prevent from breaking the .. operator
            pattern: /((?:\. *\. *)?)(?:\b\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *(?:[+-] *)?\d(?: *\d)*)?/i,
            lookbehind: true
          },
          operator: /\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
          punctuation: /[\[\]{}().,:;|]/
        };
      }
      return parigp_1;
    }
    var parser_1;
    var hasRequiredParser;
    function requireParser() {
      if (hasRequiredParser)
        return parser_1;
      hasRequiredParser = 1;
      parser_1 = parser;
      parser.displayName = "parser";
      parser.aliases = [];
      function parser(Prism2) {
        (function(Prism3) {
          var parser2 = Prism3.languages.parser = Prism3.languages.extend("markup", {
            keyword: {
              pattern: /(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
              lookbehind: true
            },
            variable: {
              pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
              lookbehind: true,
              inside: {
                punctuation: /\.|:+/
              }
            },
            function: {
              pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
              lookbehind: true,
              inside: {
                keyword: {
                  pattern: /(^@)(?:GET_|SET_)/,
                  lookbehind: true
                },
                punctuation: /\.|:+/
              }
            },
            escape: {
              pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
              alias: "builtin"
            },
            punctuation: /[\[\](){};]/
          });
          parser2 = Prism3.languages.insertBefore("parser", "keyword", {
            "parser-comment": {
              pattern: /(\s)#.*/,
              lookbehind: true,
              alias: "comment"
            },
            expression: {
              // Allow for 3 levels of depth
              pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
              greedy: true,
              lookbehind: true,
              inside: {
                string: {
                  pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
                  lookbehind: true
                },
                keyword: parser2.keyword,
                variable: parser2.variable,
                function: parser2.function,
                boolean: /\b(?:false|true)\b/,
                number: /\b(?:0x[a-f\d]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?)\b/i,
                escape: parser2.escape,
                operator: /[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
                punctuation: parser2.punctuation
              }
            }
          });
          Prism3.languages.insertBefore(
            "inside",
            "punctuation",
            {
              expression: parser2.expression,
              keyword: parser2.keyword,
              variable: parser2.variable,
              function: parser2.function,
              escape: parser2.escape,
              "parser-punctuation": {
                pattern: parser2.punctuation,
                alias: "punctuation"
              }
            },
            parser2["tag"].inside["attr-value"]
          );
        })(Prism2);
      }
      return parser_1;
    }
    var pascal_1;
    var hasRequiredPascal;
    function requirePascal() {
      if (hasRequiredPascal)
        return pascal_1;
      hasRequiredPascal = 1;
      pascal_1 = pascal;
      pascal.displayName = "pascal";
      pascal.aliases = ["objectpascal"];
      function pascal(Prism2) {
        Prism2.languages.pascal = {
          directive: {
            pattern: /\{\$[\s\S]*?\}/,
            greedy: true,
            alias: ["marco", "property"]
          },
          comment: {
            pattern: /\(\*[\s\S]*?\*\)|\{[\s\S]*?\}|\/\/.*/,
            greedy: true
          },
          string: {
            pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
            greedy: true
          },
          asm: {
            pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          keyword: [
            {
              // Turbo Pascal
              pattern: /(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
              lookbehind: true
            },
            {
              // Free Pascal
              pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
              lookbehind: true
            },
            {
              // Object Pascal
              pattern: /(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
              lookbehind: true
            },
            {
              // Modifiers
              pattern: /(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
              lookbehind: true
            }
          ],
          number: [
            // Hexadecimal, octal and binary
            /(?:[&%]\d+|\$[a-f\d]+)/i,
            // Decimal
            /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i
          ],
          operator: [
            /\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/,
            {
              pattern: /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
              lookbehind: true
            }
          ],
          punctuation: /\(\.|\.\)|[()\[\]:;,.]/
        };
        Prism2.languages.pascal.asm.inside = Prism2.languages.extend("pascal", {
          asm: void 0,
          keyword: void 0,
          operator: void 0
        });
        Prism2.languages.objectpascal = Prism2.languages.pascal;
      }
      return pascal_1;
    }
    var pascaligo_1;
    var hasRequiredPascaligo;
    function requirePascaligo() {
      if (hasRequiredPascaligo)
        return pascaligo_1;
      hasRequiredPascaligo = 1;
      pascaligo_1 = pascaligo;
      pascaligo.displayName = "pascaligo";
      pascaligo.aliases = [];
      function pascaligo(Prism2) {
        (function(Prism3) {
          var braces = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source;
          var type = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(
            /<braces>/g,
            function() {
              return braces;
            }
          );
          var pascaligo2 = Prism3.languages.pascaligo = {
            comment: /\(\*[\s\S]+?\*\)|\/\/.*/,
            string: {
              pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1|\^[a-z]/i,
              greedy: true
            },
            "class-name": [
              {
                pattern: RegExp(
                  /(\btype\s+\w+\s+is\s+)<type>/.source.replace(
                    /<type>/g,
                    function() {
                      return type;
                    }
                  ),
                  "i"
                ),
                lookbehind: true,
                inside: null
                // see below
              },
              {
                pattern: RegExp(
                  /<type>(?=\s+is\b)/.source.replace(/<type>/g, function() {
                    return type;
                  }),
                  "i"
                ),
                inside: null
                // see below
              },
              {
                pattern: RegExp(
                  /(:\s*)<type>/.source.replace(/<type>/g, function() {
                    return type;
                  })
                ),
                lookbehind: true,
                inside: null
                // see below
              }
            ],
            keyword: {
              pattern: /(^|[^&])\b(?:begin|block|case|const|else|end|fail|for|from|function|if|is|nil|of|remove|return|skip|then|type|var|while|with)\b/i,
              lookbehind: true
            },
            boolean: {
              pattern: /(^|[^&])\b(?:False|True)\b/i,
              lookbehind: true
            },
            builtin: {
              pattern: /(^|[^&])\b(?:bool|int|list|map|nat|record|string|unit)\b/i,
              lookbehind: true
            },
            function: /\b\w+(?=\s*\()/,
            number: [
              // Hexadecimal, octal and binary
              /%[01]+|&[0-7]+|\$[a-f\d]+/i,
              // Decimal
              /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?(?:mtz|n)?/i
            ],
            operator: /->|=\/=|\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=|]|\b(?:and|mod|or)\b/,
            punctuation: /\(\.|\.\)|[()\[\]:;,.{}]/
          };
          var classNameInside = [
            "comment",
            "keyword",
            "builtin",
            "operator",
            "punctuation"
          ].reduce(function(accum, key) {
            accum[key] = pascaligo2[key];
            return accum;
          }, {});
          pascaligo2["class-name"].forEach(function(p2) {
            p2.inside = classNameInside;
          });
        })(Prism2);
      }
      return pascaligo_1;
    }
    var pcaxis_1;
    var hasRequiredPcaxis;
    function requirePcaxis() {
      if (hasRequiredPcaxis)
        return pcaxis_1;
      hasRequiredPcaxis = 1;
      pcaxis_1 = pcaxis;
      pcaxis.displayName = "pcaxis";
      pcaxis.aliases = ["px"];
      function pcaxis(Prism2) {
        Prism2.languages.pcaxis = {
          string: /"[^"]*"/,
          keyword: {
            pattern: /((?:^|;)\s*)[-A-Z\d]+(?:\s*\[[-\w]+\])?(?:\s*\("[^"]*"(?:,\s*"[^"]*")*\))?(?=\s*=)/,
            lookbehind: true,
            greedy: true,
            inside: {
              keyword: /^[-A-Z\d]+/,
              language: {
                pattern: /^(\s*)\[[-\w]+\]/,
                lookbehind: true,
                inside: {
                  punctuation: /^\[|\]$/,
                  property: /[-\w]+/
                }
              },
              "sub-key": {
                pattern: /^(\s*)\S[\s\S]*/,
                lookbehind: true,
                inside: {
                  parameter: {
                    pattern: /"[^"]*"/,
                    alias: "property"
                  },
                  punctuation: /^\(|\)$|,/
                }
              }
            }
          },
          operator: /=/,
          tlist: {
            pattern: /TLIST\s*\(\s*\w+(?:(?:\s*,\s*"[^"]*")+|\s*,\s*"[^"]*"-"[^"]*")?\s*\)/,
            greedy: true,
            inside: {
              function: /^TLIST/,
              property: {
                pattern: /^(\s*\(\s*)\w+/,
                lookbehind: true
              },
              string: /"[^"]*"/,
              punctuation: /[(),]/,
              operator: /-/
            }
          },
          punctuation: /[;,]/,
          number: {
            pattern: /(^|\s)\d+(?:\.\d+)?(?!\S)/,
            lookbehind: true
          },
          boolean: /NO|YES/
        };
        Prism2.languages.px = Prism2.languages.pcaxis;
      }
      return pcaxis_1;
    }
    var peoplecode_1;
    var hasRequiredPeoplecode;
    function requirePeoplecode() {
      if (hasRequiredPeoplecode)
        return peoplecode_1;
      hasRequiredPeoplecode = 1;
      peoplecode_1 = peoplecode;
      peoplecode.displayName = "peoplecode";
      peoplecode.aliases = ["pcode"];
      function peoplecode(Prism2) {
        Prism2.languages.peoplecode = {
          comment: RegExp(
            [
              // C-style multiline comments
              /\/\*[\s\S]*?\*\//.source,
              // REM comments
              /\bREM[^;]*;/.source,
              // Nested <* *> comments
              /<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source,
              // /+ +/ comments
              /\/\+[\s\S]*?\+\//.source
            ].join("|")
          ),
          string: {
            pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
            greedy: true
          },
          variable: /%\w+/,
          "function-definition": {
            pattern: /((?:^|[^\w-])(?:function|method)\s+)\w+/i,
            lookbehind: true,
            alias: "function"
          },
          "class-name": {
            pattern: /((?:^|[^-\w])(?:as|catch|class|component|create|extends|global|implements|instance|local|of|property|returns)\s+)\w+(?::\w+)*/i,
            lookbehind: true,
            inside: {
              punctuation: /:/
            }
          },
          keyword: /\b(?:abstract|alias|as|catch|class|component|constant|create|declare|else|end-(?:class|evaluate|for|function|get|if|method|set|try|while)|evaluate|extends|for|function|get|global|if|implements|import|instance|library|local|method|null|of|out|peopleCode|private|program|property|protected|readonly|ref|repeat|returns?|set|step|then|throw|to|try|until|value|when(?:-other)?|while)\b/i,
          "operator-keyword": {
            pattern: /\b(?:and|not|or)\b/i,
            alias: "operator"
          },
          function: /[_a-z]\w*(?=\s*\()/i,
          boolean: /\b(?:false|true)\b/i,
          number: /\b\d+(?:\.\d+)?\b/,
          operator: /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
          punctuation: /[:.;,()[\]]/
        };
        Prism2.languages.pcode = Prism2.languages.peoplecode;
      }
      return peoplecode_1;
    }
    var perl_1;
    var hasRequiredPerl;
    function requirePerl() {
      if (hasRequiredPerl)
        return perl_1;
      hasRequiredPerl = 1;
      perl_1 = perl;
      perl.displayName = "perl";
      perl.aliases = [];
      function perl(Prism2) {
        (function(Prism3) {
          var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
          Prism3.languages.perl = {
            comment: [
              {
                // POD
                pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
                lookbehind: true,
                greedy: true
              },
              {
                pattern: /(^|[^\\$])#.*/,
                lookbehind: true,
                greedy: true
              }
            ],
            // TODO Could be nice to handle Heredoc too.
            string: [
              {
                pattern: RegExp(
                  /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                    // q/.../
                    /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                    // q a...a
                    // eslint-disable-next-line regexp/strict
                    /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                    // q(...)
                    // q{...}
                    // q[...]
                    // q<...>
                    brackets
                  ].join("|") + ")"
                ),
                greedy: true
              },
              // "...", `...`
              {
                pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
                greedy: true
              },
              // '...'
              // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
              {
                pattern: /'(?:[^'\\\r\n]|\\.)*'/,
                greedy: true
              }
            ],
            regex: [
              {
                pattern: RegExp(
                  /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                    // m/.../
                    /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                    // m a...a
                    // eslint-disable-next-line regexp/strict
                    /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                    // m(...)
                    // m{...}
                    // m[...]
                    // m<...>
                    brackets
                  ].join("|") + ")" + /[msixpodualngc]*/.source
                ),
                greedy: true
              },
              // The lookbehinds prevent -s from breaking
              {
                pattern: RegExp(
                  /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                    // s/.../.../
                    // eslint-disable-next-line regexp/strict
                    /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                    // s a...a...a
                    // eslint-disable-next-line regexp/strict
                    /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
                    // s(...)(...)
                    // s{...}{...}
                    // s[...][...]
                    // s<...><...>
                    // s(...)[...]
                    brackets + /\s*/.source + brackets
                  ].join("|") + ")" + /[msixpodualngcer]*/.source
                ),
                lookbehind: true,
                greedy: true
              },
              // /.../
              // The look-ahead tries to prevent two divisions on
              // the same line from being highlighted as regex.
              // This does not support multi-line regex.
              {
                pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
                greedy: true
              }
            ],
            // FIXME Not sure about the handling of ::, ', and #
            variable: [
              // ${^POSTMATCH}
              /[&*$@%]\{\^[A-Z]+\}/,
              // $^V
              /[&*$@%]\^[A-Z_]/,
              // ${...}
              /[&*$@%]#?(?=\{)/,
              // $foo
              /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
              // $1
              /[&*$@%]\d+/,
              // $_, @_, %!
              // The negative lookahead prevents from breaking the %= operator
              /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
            ],
            filehandle: {
              // <>, <FOO>, _
              pattern: /<(?![<=])\S*?>|\b_\b/,
              alias: "symbol"
            },
            "v-string": {
              // v1.2, 1.2.3
              pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
              alias: "string"
            },
            function: {
              pattern: /(\bsub[ \t]+)\w+/,
              lookbehind: true
            },
            keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
            number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
            operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
            punctuation: /[{}[\];(),:]/
          };
        })(Prism2);
      }
      return perl_1;
    }
    var phpExtras_1;
    var hasRequiredPhpExtras;
    function requirePhpExtras() {
      if (hasRequiredPhpExtras)
        return phpExtras_1;
      hasRequiredPhpExtras = 1;
      var refractorPhp = requirePhp();
      phpExtras_1 = phpExtras;
      phpExtras.displayName = "phpExtras";
      phpExtras.aliases = [];
      function phpExtras(Prism2) {
        Prism2.register(refractorPhp);
        Prism2.languages.insertBefore("php", "variable", {
          this: {
            pattern: /\$this\b/,
            alias: "keyword"
          },
          global: /\$(?:GLOBALS|HTTP_RAW_POST_DATA|_(?:COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)|argc|argv|http_response_header|php_errormsg)\b/,
          scope: {
            pattern: /\b[\w\\]+::/,
            inside: {
              keyword: /\b(?:parent|self|static)\b/,
              punctuation: /::|\\/
            }
          }
        });
      }
      return phpExtras_1;
    }
    var phpdoc_1;
    var hasRequiredPhpdoc;
    function requirePhpdoc() {
      if (hasRequiredPhpdoc)
        return phpdoc_1;
      hasRequiredPhpdoc = 1;
      var refractorPhp = requirePhp();
      var refractorJavadoclike = requireJavadoclike();
      phpdoc_1 = phpdoc;
      phpdoc.displayName = "phpdoc";
      phpdoc.aliases = [];
      function phpdoc(Prism2) {
        Prism2.register(refractorPhp);
        Prism2.register(refractorJavadoclike);
        (function(Prism3) {
          var typeExpression = /(?:\b[a-zA-Z]\w*|[|\\[\]])+/.source;
          Prism3.languages.phpdoc = Prism3.languages.extend("javadoclike", {
            parameter: {
              pattern: RegExp(
                "(@(?:global|param|property(?:-read|-write)?|var)\\s+(?:" + typeExpression + "\\s+)?)\\$\\w+"
              ),
              lookbehind: true
            }
          });
          Prism3.languages.insertBefore("phpdoc", "keyword", {
            "class-name": [
              {
                pattern: RegExp(
                  "(@(?:global|package|param|property(?:-read|-write)?|return|subpackage|throws|var)\\s+)" + typeExpression
                ),
                lookbehind: true,
                inside: {
                  keyword: /\b(?:array|bool|boolean|callback|double|false|float|int|integer|mixed|null|object|resource|self|string|true|void)\b/,
                  punctuation: /[|\\[\]()]/
                }
              }
            ]
          });
          Prism3.languages.javadoclike.addSupport("php", Prism3.languages.phpdoc);
        })(Prism2);
      }
      return phpdoc_1;
    }
    var plsql_1;
    var hasRequiredPlsql;
    function requirePlsql() {
      if (hasRequiredPlsql)
        return plsql_1;
      hasRequiredPlsql = 1;
      var refractorSql = requireSql();
      plsql_1 = plsql;
      plsql.displayName = "plsql";
      plsql.aliases = [];
      function plsql(Prism2) {
        Prism2.register(refractorSql);
        Prism2.languages.plsql = Prism2.languages.extend("sql", {
          comment: {
            pattern: /\/\*[\s\S]*?\*\/|--.*/,
            greedy: true
          },
          // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-reserved-words-keywords.html
          keyword: /\b(?:A|ACCESSIBLE|ADD|AGENT|AGGREGATE|ALL|ALTER|AND|ANY|ARRAY|AS|ASC|AT|ATTRIBUTE|AUTHID|AVG|BEGIN|BETWEEN|BFILE_BASE|BINARY|BLOB_BASE|BLOCK|BODY|BOTH|BOUND|BULK|BY|BYTE|C|CALL|CALLING|CASCADE|CASE|CHAR|CHARACTER|CHARSET|CHARSETFORM|CHARSETID|CHAR_BASE|CHECK|CLOB_BASE|CLONE|CLOSE|CLUSTER|CLUSTERS|COLAUTH|COLLECT|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPILED|COMPRESS|CONNECT|CONSTANT|CONSTRUCTOR|CONTEXT|CONTINUE|CONVERT|COUNT|CRASH|CREATE|CREDENTIAL|CURRENT|CURSOR|CUSTOMDATUM|DANGLING|DATA|DATE|DATE_BASE|DAY|DECLARE|DEFAULT|DEFINE|DELETE|DESC|DETERMINISTIC|DIRECTORY|DISTINCT|DOUBLE|DROP|DURATION|ELEMENT|ELSE|ELSIF|EMPTY|END|ESCAPE|EXCEPT|EXCEPTION|EXCEPTIONS|EXCLUSIVE|EXECUTE|EXISTS|EXIT|EXTERNAL|FETCH|FINAL|FIRST|FIXED|FLOAT|FOR|FORALL|FORCE|FROM|FUNCTION|GENERAL|GOTO|GRANT|GROUP|HASH|HAVING|HEAP|HIDDEN|HOUR|IDENTIFIED|IF|IMMEDIATE|IMMUTABLE|IN|INCLUDING|INDEX|INDEXES|INDICATOR|INDICES|INFINITE|INSERT|INSTANTIABLE|INT|INTERFACE|INTERSECT|INTERVAL|INTO|INVALIDATE|IS|ISOLATION|JAVA|LANGUAGE|LARGE|LEADING|LENGTH|LEVEL|LIBRARY|LIKE|LIKE2|LIKE4|LIKEC|LIMIT|LIMITED|LOCAL|LOCK|LONG|LOOP|MAP|MAX|MAXLEN|MEMBER|MERGE|MIN|MINUS|MINUTE|MOD|MODE|MODIFY|MONTH|MULTISET|MUTABLE|NAME|NAN|NATIONAL|NATIVE|NCHAR|NEW|NOCOMPRESS|NOCOPY|NOT|NOWAIT|NULL|NUMBER_BASE|OBJECT|OCICOLL|OCIDATE|OCIDATETIME|OCIDURATION|OCIINTERVAL|OCILOBLOCATOR|OCINUMBER|OCIRAW|OCIREF|OCIREFCURSOR|OCIROWID|OCISTRING|OCITYPE|OF|OLD|ON|ONLY|OPAQUE|OPEN|OPERATOR|OPTION|OR|ORACLE|ORADATA|ORDER|ORGANIZATION|ORLANY|ORLVARY|OTHERS|OUT|OVERLAPS|OVERRIDING|PACKAGE|PARALLEL_ENABLE|PARAMETER|PARAMETERS|PARENT|PARTITION|PASCAL|PERSISTABLE|PIPE|PIPELINED|PLUGGABLE|POLYMORPHIC|PRAGMA|PRECISION|PRIOR|PRIVATE|PROCEDURE|PUBLIC|RAISE|RANGE|RAW|READ|RECORD|REF|REFERENCE|RELIES_ON|REM|REMAINDER|RENAME|RESOURCE|RESULT|RESULT_CACHE|RETURN|RETURNING|REVERSE|REVOKE|ROLLBACK|ROW|SAMPLE|SAVE|SAVEPOINT|SB1|SB2|SB4|SECOND|SEGMENT|SELECT|SELF|SEPARATE|SEQUENCE|SERIALIZABLE|SET|SHARE|SHORT|SIZE|SIZE_T|SOME|SPARSE|SQL|SQLCODE|SQLDATA|SQLNAME|SQLSTATE|STANDARD|START|STATIC|STDDEV|STORED|STRING|STRUCT|STYLE|SUBMULTISET|SUBPARTITION|SUBSTITUTABLE|SUBTYPE|SUM|SYNONYM|TABAUTH|TABLE|TDO|THE|THEN|TIME|TIMESTAMP|TIMEZONE_ABBR|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_REGION|TO|TRAILING|TRANSACTION|TRANSACTIONAL|TRUSTED|TYPE|UB1|UB2|UB4|UNDER|UNION|UNIQUE|UNPLUG|UNSIGNED|UNTRUSTED|UPDATE|USE|USING|VALIST|VALUE|VALUES|VARIABLE|VARIANCE|VARRAY|VARYING|VIEW|VIEWS|VOID|WHEN|WHERE|WHILE|WITH|WORK|WRAPPED|WRITE|YEAR|ZONE)\b/i,
          // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-language-fundamentals.html#GUID-96A42F7C-7A71-4B90-8255-CA9C8BD9722E
          operator: /:=?|=>|[<>^~!]=|\.\.|\|\||\*\*|[-+*/%<>=@]/
        });
        Prism2.languages.insertBefore("plsql", "operator", {
          label: {
            pattern: /<<\s*\w+\s*>>/,
            alias: "symbol"
          }
        });
      }
      return plsql_1;
    }
    var powerquery_1;
    var hasRequiredPowerquery;
    function requirePowerquery() {
      if (hasRequiredPowerquery)
        return powerquery_1;
      hasRequiredPowerquery = 1;
      powerquery_1 = powerquery;
      powerquery.displayName = "powerquery";
      powerquery.aliases = [];
      function powerquery(Prism2) {
        Prism2.languages.powerquery = {
          comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
            lookbehind: true,
            greedy: true
          },
          "quoted-identifier": {
            pattern: /#"(?:[^"\r\n]|"")*"(?!")/,
            greedy: true
          },
          string: {
            pattern: /(?:#!)?"(?:[^"\r\n]|"")*"(?!")/,
            greedy: true
          },
          constant: [
            /\bDay\.(?:Friday|Monday|Saturday|Sunday|Thursday|Tuesday|Wednesday)\b/,
            /\bTraceLevel\.(?:Critical|Error|Information|Verbose|Warning)\b/,
            /\bOccurrence\.(?:All|First|Last)\b/,
            /\bOrder\.(?:Ascending|Descending)\b/,
            /\bRoundingMode\.(?:AwayFromZero|Down|ToEven|TowardZero|Up)\b/,
            /\bMissingField\.(?:Error|Ignore|UseNull)\b/,
            /\bQuoteStyle\.(?:Csv|None)\b/,
            /\bJoinKind\.(?:FullOuter|Inner|LeftAnti|LeftOuter|RightAnti|RightOuter)\b/,
            /\bGroupKind\.(?:Global|Local)\b/,
            /\bExtraValues\.(?:Error|Ignore|List)\b/,
            /\bJoinAlgorithm\.(?:Dynamic|LeftHash|LeftIndex|PairwiseHash|RightHash|RightIndex|SortMerge)\b/,
            /\bJoinSide\.(?:Left|Right)\b/,
            /\bPrecision\.(?:Decimal|Double)\b/,
            /\bRelativePosition\.From(?:End|Start)\b/,
            /\bTextEncoding\.(?:Ascii|BigEndianUnicode|Unicode|Utf16|Utf8|Windows)\b/,
            /\b(?:Any|Binary|Date|DateTime|DateTimeZone|Duration|Function|Int16|Int32|Int64|Int8|List|Logical|None|Number|Record|Table|Text|Time)\.Type\b/,
            /\bnull\b/
          ],
          boolean: /\b(?:false|true)\b/,
          keyword: /\b(?:and|as|each|else|error|if|in|is|let|meta|not|nullable|optional|or|otherwise|section|shared|then|try|type)\b|#(?:binary|date|datetime|datetimezone|duration|infinity|nan|sections|shared|table|time)\b/,
          function: {
            pattern: /(^|[^#\w.])[a-z_][\w.]*(?=\s*\()/i,
            lookbehind: true
          },
          "data-type": {
            pattern: /\b(?:any|anynonnull|binary|date|datetime|datetimezone|duration|function|list|logical|none|number|record|table|text|time)\b/,
            alias: "class-name"
          },
          number: {
            pattern: /\b0x[\da-f]+\b|(?:[+-]?(?:\b\d+\.)?\b\d+|[+-]\.\d+|(^|[^.])\B\.\d+)(?:e[+-]?\d+)?\b/i,
            lookbehind: true
          },
          operator: /[-+*\/&?@^]|<(?:=>?|>)?|>=?|=>?|\.\.\.?/,
          punctuation: /[,;\[\](){}]/
        };
        Prism2.languages.pq = Prism2.languages["powerquery"];
        Prism2.languages.mscript = Prism2.languages["powerquery"];
      }
      return powerquery_1;
    }
    var powershell_1;
    var hasRequiredPowershell;
    function requirePowershell() {
      if (hasRequiredPowershell)
        return powershell_1;
      hasRequiredPowershell = 1;
      powershell_1 = powershell;
      powershell.displayName = "powershell";
      powershell.aliases = [];
      function powershell(Prism2) {
        (function(Prism3) {
          var powershell2 = Prism3.languages.powershell = {
            comment: [
              {
                pattern: /(^|[^`])<#[\s\S]*?#>/,
                lookbehind: true
              },
              {
                pattern: /(^|[^`])#.*/,
                lookbehind: true
              }
            ],
            string: [
              {
                pattern: /"(?:`[\s\S]|[^`"])*"/,
                greedy: true,
                inside: null
                // see below
              },
              {
                pattern: /'(?:[^']|'')*'/,
                greedy: true
              }
            ],
            // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
            // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
            namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
            boolean: /\$(?:false|true)\b/i,
            variable: /\$\w+\b/,
            // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
            // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
            // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
            function: [
              /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
              /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
            ],
            // per http://technet.microsoft.com/en-us/library/hh847744.aspx
            keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
            operator: {
              pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
              lookbehind: true
            },
            punctuation: /[|{}[\];(),.]/
          };
          powershell2.string[0].inside = {
            function: {
              // Allow for one level of nesting
              pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
              lookbehind: true,
              inside: powershell2
            },
            boolean: powershell2.boolean,
            variable: powershell2.variable
          };
        })(Prism2);
      }
      return powershell_1;
    }
    var processing_1;
    var hasRequiredProcessing;
    function requireProcessing() {
      if (hasRequiredProcessing)
        return processing_1;
      hasRequiredProcessing = 1;
      processing_1 = processing;
      processing.displayName = "processing";
      processing.aliases = [];
      function processing(Prism2) {
        Prism2.languages.processing = Prism2.languages.extend("clike", {
          keyword: /\b(?:break|case|catch|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
          // Spaces are allowed between function name and parenthesis
          function: /\b\w+(?=\s*\()/,
          operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
        });
        Prism2.languages.insertBefore("processing", "number", {
          // Special case: XML is a type
          constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
          type: {
            pattern: /\b(?:boolean|byte|char|color|double|float|int|[A-Z]\w*)\b/,
            alias: "class-name"
          }
        });
      }
      return processing_1;
    }
    var prolog_1;
    var hasRequiredProlog;
    function requireProlog() {
      if (hasRequiredProlog)
        return prolog_1;
      hasRequiredProlog = 1;
      prolog_1 = prolog;
      prolog.displayName = "prolog";
      prolog.aliases = [];
      function prolog(Prism2) {
        Prism2.languages.prolog = {
          // Syntax depends on the implementation
          comment: {
            pattern: /\/\*[\s\S]*?\*\/|%.*/,
            greedy: true
          },
          // Depending on the implementation, strings may allow escaped newlines and quote-escape
          string: {
            pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1(?!\1)/,
            greedy: true
          },
          builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
          // FIXME: Should we list all null-ary predicates (not followed by a parenthesis) like halt, trace, etc.?
          function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
          number: /\b\d+(?:\.\d*)?/,
          // Custom operators are allowed
          operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
          punctuation: /[(){}\[\],]/
        };
      }
      return prolog_1;
    }
    var promql_1;
    var hasRequiredPromql;
    function requirePromql() {
      if (hasRequiredPromql)
        return promql_1;
      hasRequiredPromql = 1;
      promql_1 = promql;
      promql.displayName = "promql";
      promql.aliases = [];
      function promql(Prism2) {
        (function(Prism3) {
          var aggregations = [
            "sum",
            "min",
            "max",
            "avg",
            "group",
            "stddev",
            "stdvar",
            "count",
            "count_values",
            "bottomk",
            "topk",
            "quantile"
          ];
          var vectorMatching = [
            "on",
            "ignoring",
            "group_right",
            "group_left",
            "by",
            "without"
          ];
          var offsetModifier = ["offset"];
          var keywords = aggregations.concat(vectorMatching, offsetModifier);
          Prism3.languages.promql = {
            comment: {
              pattern: /(^[ \t]*)#.*/m,
              lookbehind: true
            },
            "vector-match": {
              // Match the comma-separated label lists inside vector matching:
              pattern: new RegExp(
                "((?:" + vectorMatching.join("|") + ")\\s*)\\([^)]*\\)"
              ),
              lookbehind: true,
              inside: {
                "label-key": {
                  pattern: /\b[^,]+\b/,
                  alias: "attr-name"
                },
                punctuation: /[(),]/
              }
            },
            "context-labels": {
              pattern: /\{[^{}]*\}/,
              inside: {
                "label-key": {
                  pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
                  alias: "attr-name"
                },
                "label-value": {
                  pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
                  greedy: true,
                  alias: "attr-value"
                },
                punctuation: /\{|\}|=~?|![=~]|,/
              }
            },
            "context-range": [
              {
                pattern: /\[[\w\s:]+\]/,
                // [1m]
                inside: {
                  punctuation: /\[|\]|:/,
                  "range-duration": {
                    pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
                    alias: "number"
                  }
                }
              },
              {
                pattern: /(\boffset\s+)\w+/,
                // offset 1m
                lookbehind: true,
                inside: {
                  "range-duration": {
                    pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
                    alias: "number"
                  }
                }
              }
            ],
            keyword: new RegExp("\\b(?:" + keywords.join("|") + ")\\b", "i"),
            function: /\b[a-z_]\w*(?=\s*\()/i,
            number: /[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
            operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|or|unless)\b/i,
            punctuation: /[{};()`,.[\]]/
          };
        })(Prism2);
      }
      return promql_1;
    }
    var properties_1;
    var hasRequiredProperties;
    function requireProperties() {
      if (hasRequiredProperties)
        return properties_1;
      hasRequiredProperties = 1;
      properties_1 = properties;
      properties.displayName = "properties";
      properties.aliases = [];
      function properties(Prism2) {
        Prism2.languages.properties = {
          comment: /^[ \t]*[#!].*$/m,
          "attr-value": {
            pattern: /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
            lookbehind: true
          },
          "attr-name": /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
          punctuation: /[=:]/
        };
      }
      return properties_1;
    }
    var protobuf_1;
    var hasRequiredProtobuf;
    function requireProtobuf() {
      if (hasRequiredProtobuf)
        return protobuf_1;
      hasRequiredProtobuf = 1;
      protobuf_1 = protobuf;
      protobuf.displayName = "protobuf";
      protobuf.aliases = [];
      function protobuf(Prism2) {
        (function(Prism3) {
          var builtinTypes = /\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
          Prism3.languages.protobuf = Prism3.languages.extend("clike", {
            "class-name": [
              {
                pattern: /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
                lookbehind: true
              },
              {
                pattern: /(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
                lookbehind: true
              }
            ],
            keyword: /\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
            function: /\b[a-z_]\w*(?=\s*\()/i
          });
          Prism3.languages.insertBefore("protobuf", "operator", {
            map: {
              pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
              alias: "class-name",
              inside: {
                punctuation: /[<>.,]/,
                builtin: builtinTypes
              }
            },
            builtin: builtinTypes,
            "positional-class-name": {
              pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
              alias: "class-name",
              inside: {
                punctuation: /\./
              }
            },
            annotation: {
              pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i,
              lookbehind: true
            }
          });
        })(Prism2);
      }
      return protobuf_1;
    }
    var psl_1;
    var hasRequiredPsl;
    function requirePsl() {
      if (hasRequiredPsl)
        return psl_1;
      hasRequiredPsl = 1;
      psl_1 = psl;
      psl.displayName = "psl";
      psl.aliases = [];
      function psl(Prism2) {
        Prism2.languages.psl = {
          comment: {
            pattern: /#.*/,
            greedy: true
          },
          string: {
            pattern: /"(?:\\.|[^\\"])*"/,
            greedy: true,
            inside: {
              symbol: /\\[ntrbA-Z"\\]/
            }
          },
          "heredoc-string": {
            pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
            alias: "string",
            greedy: true
          },
          keyword: /\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
          constant: /\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SEP_HORIZ|R_SEP_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|VOID|WARN)\b/,
          boolean: /\b(?:FALSE|False|NO|No|TRUE|True|YES|Yes|false|no|true|yes)\b/,
          variable: /\b(?:PslDebug|errno|exit_status)\b/,
          builtin: {
            pattern: /\b(?:PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|_snmp_debug|acos|add_diary|annotate|annotate_get|ascii_to_ebcdic|asctime|asin|atan|atexit|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|date|dcget_text|destroy|destroy_lock|dget_text|difference|dump_hist|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|file|floor|fmod|fopen|fseek|ftell|full_discovery|get|get_chan_info|get_ranges|get_text|get_vars|getenv|gethostinfo|getpid|getpname|grep|history|history_get_retention|in_transition|index|int|internal|intersection|is_var|isnumber|join|kill|length|lines|lock|lock_info|log|log10|loge|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|nthargf|nthline|nthlinef|num_bytes|num_consoles|pconfig|popen|poplines|pow|print|printf|proc_exists|process|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|snmp_agent_config|snmp_agent_start|snmp_agent_stop|snmp_close|snmp_config|snmp_get|snmp_get_next|snmp_h_get|snmp_h_get_next|snmp_h_set|snmp_open|snmp_set|snmp_trap_ignore|snmp_trap_listen|snmp_trap_raise_std_trap|snmp_trap_receive|snmp_trap_register_im|snmp_trap_send|snmp_walk|sopen|sort|splitline|sprintf|sqrt|srandom|str_repeat|strcasecmp|subset|substr|system|tail|tan|tanh|text_domain|time|tmpnam|tolower|toupper|trace_psl_process|trim|union|unique|unlock|unset|va_arg|va_start|write)\b/,
            alias: "builtin-function"
          },
          "foreach-variable": {
            pattern: /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
            lookbehind: true,
            greedy: true
          },
          function: /\b[_a-z]\w*\b(?=\s*\()/i,
          number: /\b(?:0x[0-9a-f]+|\d+(?:\.\d+)?)\b/i,
          operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
          punctuation: /[(){}\[\];,]/
        };
      }
      return psl_1;
    }
    var pug_1;
    var hasRequiredPug;
    function requirePug() {
      if (hasRequiredPug)
        return pug_1;
      hasRequiredPug = 1;
      pug_1 = pug;
      pug.displayName = "pug";
      pug.aliases = [];
      function pug(Prism2) {
        (function(Prism3) {
          Prism3.languages.pug = {
            // Multiline stuff should appear before the rest
            // This handles both single-line and multi-line comments
            comment: {
              pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ].+)*/m,
              lookbehind: true
            },
            // All the tag-related part is in lookbehind
            // so that it can be highlighted by the "tag" pattern
            "multiline-script": {
              pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
              lookbehind: true,
              inside: Prism3.languages.javascript
            },
            // See at the end of the file for known filters
            filter: {
              pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
              lookbehind: true,
              inside: {
                "filter-name": {
                  pattern: /^:[\w-]+/,
                  alias: "variable"
                },
                text: /\S[\s\S]*/
              }
            },
            "multiline-plain-text": {
              pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
              lookbehind: true
            },
            markup: {
              pattern: /(^[\t ]*)<.+/m,
              lookbehind: true,
              inside: Prism3.languages.markup
            },
            doctype: {
              pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
              lookbehind: true
            },
            // This handle all conditional and loop keywords
            "flow-control": {
              pattern: /(^[\t ]*)(?:case|default|each|else|if|unless|when|while)\b(?: .+)?/m,
              lookbehind: true,
              inside: {
                each: {
                  pattern: /^each .+? in\b/,
                  inside: {
                    keyword: /\b(?:each|in)\b/,
                    punctuation: /,/
                  }
                },
                branch: {
                  pattern: /^(?:case|default|else|if|unless|when|while)\b/,
                  alias: "keyword"
                },
                rest: Prism3.languages.javascript
              }
            },
            keyword: {
              pattern: /(^[\t ]*)(?:append|block|extends|include|prepend)\b.+/m,
              lookbehind: true
            },
            mixin: [
              // Declaration
              {
                pattern: /(^[\t ]*)mixin .+/m,
                lookbehind: true,
                inside: {
                  keyword: /^mixin/,
                  function: /\w+(?=\s*\(|\s*$)/,
                  punctuation: /[(),.]/
                }
              },
              // Usage
              {
                pattern: /(^[\t ]*)\+.+/m,
                lookbehind: true,
                inside: {
                  name: {
                    pattern: /^\+\w+/,
                    alias: "function"
                  },
                  rest: Prism3.languages.javascript
                }
              }
            ],
            script: {
              pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
              lookbehind: true,
              inside: Prism3.languages.javascript
            },
            "plain-text": {
              pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]).+/m,
              lookbehind: true
            },
            tag: {
              pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
              lookbehind: true,
              inside: {
                attributes: [
                  {
                    pattern: /&[^(]+\([^)]+\)/,
                    inside: Prism3.languages.javascript
                  },
                  {
                    pattern: /\([^)]+\)/,
                    inside: {
                      "attr-value": {
                        pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
                        lookbehind: true,
                        inside: Prism3.languages.javascript
                      },
                      "attr-name": /[\w-]+(?=\s*!?=|\s*[,)])/,
                      punctuation: /[!=(),]+/
                    }
                  }
                ],
                punctuation: /:/,
                "attr-id": /#[\w\-]+/,
                "attr-class": /\.[\w\-]+/
              }
            },
            code: [
              {
                pattern: /(^[\t ]*(?:-|!?=)).+/m,
                lookbehind: true,
                inside: Prism3.languages.javascript
              }
            ],
            punctuation: /[.\-!=|]+/
          };
          var filter_pattern = /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source;
          var filters = [
            {
              filter: "atpl",
              language: "twig"
            },
            {
              filter: "coffee",
              language: "coffeescript"
            },
            "ejs",
            "handlebars",
            "less",
            "livescript",
            "markdown",
            {
              filter: "sass",
              language: "scss"
            },
            "stylus"
          ];
          var all_filters = {};
          for (var i = 0, l2 = filters.length; i < l2; i++) {
            var filter = filters[i];
            filter = typeof filter === "string" ? {
              filter,
              language: filter
            } : filter;
            if (Prism3.languages[filter.language]) {
              all_filters["filter-" + filter.filter] = {
                pattern: RegExp(
                  filter_pattern.replace("<filter_name>", function() {
                    return filter.filter;
                  }),
                  "m"
                ),
                lookbehind: true,
                inside: {
                  "filter-name": {
                    pattern: /^:[\w-]+/,
                    alias: "variable"
                  },
                  text: {
                    pattern: /\S[\s\S]*/,
                    alias: [filter.language, "language-" + filter.language],
                    inside: Prism3.languages[filter.language]
                  }
                }
              };
            }
          }
          Prism3.languages.insertBefore("pug", "filter", all_filters);
        })(Prism2);
      }
      return pug_1;
    }
    var puppet_1;
    var hasRequiredPuppet;
    function requirePuppet() {
      if (hasRequiredPuppet)
        return puppet_1;
      hasRequiredPuppet = 1;
      puppet_1 = puppet;
      puppet.displayName = "puppet";
      puppet.aliases = [];
      function puppet(Prism2) {
        (function(Prism3) {
          Prism3.languages.puppet = {
            heredoc: [
              // Matches the content of a quoted heredoc string (subject to interpolation)
              {
                pattern: /(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
                lookbehind: true,
                alias: "string",
                inside: {
                  // Matches the end tag
                  punctuation: /(?=\S).*\S(?= *$)/
                  // See interpolation below
                }
              },
              // Matches the content of an unquoted heredoc string (no interpolation)
              {
                pattern: /(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
                lookbehind: true,
                greedy: true,
                alias: "string",
                inside: {
                  // Matches the end tag
                  punctuation: /(?=\S).*\S(?= *$)/
                }
              },
              // Matches the start tag of heredoc strings
              {
                pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
                alias: "string",
                inside: {
                  punctuation: {
                    pattern: /(\().+?(?=\))/,
                    lookbehind: true
                  }
                }
              }
            ],
            "multiline-comment": {
              pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
              lookbehind: true,
              greedy: true,
              alias: "comment"
            },
            regex: {
              // Must be prefixed with the keyword "node" or a non-word char
              pattern: /((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
              lookbehind: true,
              greedy: true,
              inside: {
                // Extended regexes must have the x flag. They can contain single-line comments.
                "extended-regex": {
                  pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
                  inside: {
                    comment: /#.*/
                  }
                }
              }
            },
            comment: {
              pattern: /(^|[^\\])#.*/,
              lookbehind: true,
              greedy: true
            },
            string: {
              // Allow for one nested level of double quotes inside interpolation
              pattern: /(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|\$(?!\{)|(?!\1)[^\\$]|\\[\s\S])*\1/,
              greedy: true,
              inside: {
                "double-quoted": {
                  pattern: /^"[\s\S]*"$/,
                  inside: {
                    // See interpolation below
                  }
                }
              }
            },
            variable: {
              pattern: /\$(?:::)?\w+(?:::\w+)*/,
              inside: {
                punctuation: /::/
              }
            },
            "attr-name": /(?:\b\w+|\*)(?=\s*=>)/,
            function: [
              {
                pattern: /(\.)(?!\d)\w+/,
                lookbehind: true
              },
              /\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/
            ],
            number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
            boolean: /\b(?:false|true)\b/,
            // Includes words reserved for future use
            keyword: /\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
            datatype: {
              pattern: /\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
              alias: "symbol"
            },
            operator: /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
            punctuation: /[\[\]{}().,;]|:+/
          };
          var interpolation = [
            {
              // Allow for one nested level of braces inside interpolation
              pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
              lookbehind: true,
              inside: {
                "short-variable": {
                  // Negative look-ahead prevent wrong highlighting of functions
                  pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
                  lookbehind: true,
                  alias: "variable",
                  inside: {
                    punctuation: /::/
                  }
                },
                delimiter: {
                  pattern: /^\$/,
                  alias: "variable"
                },
                rest: Prism3.languages.puppet
              }
            },
            {
              pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
              lookbehind: true,
              alias: "variable",
              inside: {
                punctuation: /::/
              }
            }
          ];
          Prism3.languages.puppet["heredoc"][0].inside.interpolation = interpolation;
          Prism3.languages.puppet["string"].inside["double-quoted"].inside.interpolation = interpolation;
        })(Prism2);
      }
      return puppet_1;
    }
    var pure_1;
    var hasRequiredPure;
    function requirePure() {
      if (hasRequiredPure)
        return pure_1;
      hasRequiredPure = 1;
      pure_1 = pure;
      pure.displayName = "pure";
      pure.aliases = [];
      function pure(Prism2) {
        (function(Prism3) {
          Prism3.languages.pure = {
            comment: [
              {
                pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
                lookbehind: true
              },
              {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true
              },
              /#!.+/
            ],
            "inline-lang": {
              pattern: /%<[\s\S]+?%>/,
              greedy: true,
              inside: {
                lang: {
                  pattern: /(^%< *)-\*-.+?-\*-/,
                  lookbehind: true,
                  alias: "comment"
                },
                delimiter: {
                  pattern: /^%<.*|%>$/,
                  alias: "punctuation"
                }
              }
            },
            string: {
              pattern: /"(?:\\.|[^"\\\r\n])*"/,
              greedy: true
            },
            number: {
              // The look-behind prevents wrong highlighting of the .. operator
              pattern: /((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?L?)/i,
              lookbehind: true
            },
            keyword: /\b(?:NULL|ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
            function: /\b(?:abs|add_(?:addr|constdef|(?:fundef|interface|macdef|typedef)(?:_at)?|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_c?string(?:_pointer)?|byte_(?:matrix|pointer)|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|sentry|short|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
            special: {
              pattern: /\b__[a-z]+__\b/i,
              alias: "builtin"
            },
            // Any combination of operator chars can be an operator
            // eslint-disable-next-line no-misleading-character-class
            operator: /(?:[!"#$%&'*+,\-.\/:<=>?@\\^`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]|\b_+\b)+|\b(?:and|div|mod|not|or)\b/,
            // FIXME: How can we prevent | and , to be highlighted as operator when they are used alone?
            punctuation: /[(){}\[\];,|]/
          };
          var inlineLanguages = [
            "c",
            {
              lang: "c++",
              alias: "cpp"
            },
            "fortran"
          ];
          var inlineLanguageRe = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
          inlineLanguages.forEach(function(lang) {
            var alias2 = lang;
            if (typeof lang !== "string") {
              alias2 = lang.alias;
              lang = lang.lang;
            }
            if (Prism3.languages[alias2]) {
              var o = {};
              o["inline-lang-" + alias2] = {
                pattern: RegExp(
                  inlineLanguageRe.replace(
                    "<lang>",
                    lang.replace(/([.+*?\/\\(){}\[\]])/g, "\\$1")
                  ),
                  "i"
                ),
                inside: Prism3.util.clone(Prism3.languages.pure["inline-lang"].inside)
              };
              o["inline-lang-" + alias2].inside.rest = Prism3.util.clone(
                Prism3.languages[alias2]
              );
              Prism3.languages.insertBefore("pure", "inline-lang", o);
            }
          });
          if (Prism3.languages.c) {
            Prism3.languages.pure["inline-lang"].inside.rest = Prism3.util.clone(
              Prism3.languages.c
            );
          }
        })(Prism2);
      }
      return pure_1;
    }
    var purebasic_1;
    var hasRequiredPurebasic;
    function requirePurebasic() {
      if (hasRequiredPurebasic)
        return purebasic_1;
      hasRequiredPurebasic = 1;
      purebasic_1 = purebasic;
      purebasic.displayName = "purebasic";
      purebasic.aliases = [];
      function purebasic(Prism2) {
        Prism2.languages.purebasic = Prism2.languages.extend("clike", {
          comment: /;.*/,
          keyword: /\b(?:align|and|as|break|calldebugger|case|compilercase|compilerdefault|compilerelse|compilerelseif|compilerendif|compilerendselect|compilererror|compilerif|compilerselect|continue|data|datasection|debug|debuglevel|declare|declarec|declarecdll|declaredll|declaremodule|default|define|dim|disableasm|disabledebugger|disableexplicit|else|elseif|enableasm|enabledebugger|enableexplicit|end|enddatasection|enddeclaremodule|endenumeration|endif|endimport|endinterface|endmacro|endmodule|endprocedure|endselect|endstructure|endstructureunion|endwith|enumeration|extends|fakereturn|for|foreach|forever|global|gosub|goto|if|import|importc|includebinary|includefile|includepath|interface|macro|module|newlist|newmap|next|not|or|procedure|procedurec|procedurecdll|proceduredll|procedurereturn|protected|prototype|prototypec|read|redim|repeat|restore|return|runtime|select|shared|static|step|structure|structureunion|swap|threaded|to|until|wend|while|with|xincludefile|xor)\b/i,
          function: /\b\w+(?:\.\w+)?\s*(?=\()/,
          number: /(?:\$[\da-f]+|\b-?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\b/i,
          operator: /(?:@\*?|\?|\*)\w+|-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*/@]/
        });
        Prism2.languages.insertBefore("purebasic", "keyword", {
          tag: /#\w+\$?/,
          asm: {
            pattern: /(^[\t ]*)!.*/m,
            lookbehind: true,
            alias: "tag",
            inside: {
              comment: /;.*/,
              string: {
                pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
                greedy: true
              },
              // Anonymous label references, i.e.: jmp @b
              "label-reference-anonymous": {
                pattern: /(!\s*j[a-z]+\s+)@[fb]/i,
                lookbehind: true,
                alias: "fasm-label"
              },
              // Named label reference, i.e.: jne label1
              "label-reference-addressed": {
                pattern: /(!\s*j[a-z]+\s+)[A-Z._?$@][\w.?$@~#]*/i,
                lookbehind: true,
                alias: "fasm-label"
              },
              keyword: [
                /\b(?:extern|global)\b[^;\r\n]*/i,
                /\b(?:CPU|DEFAULT|FLOAT)\b.*/
              ],
              function: {
                pattern: /^([\t ]*!\s*)[\da-z]+(?=\s|$)/im,
                lookbehind: true
              },
              "function-inline": {
                pattern: /(:\s*)[\da-z]+(?=\s)/i,
                lookbehind: true,
                alias: "function"
              },
              label: {
                pattern: /^([\t ]*!\s*)[A-Za-z._?$@][\w.?$@~#]*(?=:)/m,
                lookbehind: true,
                alias: "fasm-label"
              },
              register: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s|mm\d+)\b/i,
              number: /(?:\b|-|(?=\$))(?:0[hx](?:[\da-f]*\.)?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
              operator: /[\[\]*+\-/%<>=&|$!,.:]/
            }
          }
        });
        delete Prism2.languages.purebasic["class-name"];
        delete Prism2.languages.purebasic["boolean"];
        Prism2.languages.pbfasm = Prism2.languages["purebasic"];
      }
      return purebasic_1;
    }
    var purescript_1;
    var hasRequiredPurescript;
    function requirePurescript() {
      if (hasRequiredPurescript)
        return purescript_1;
      hasRequiredPurescript = 1;
      var refractorHaskell = requireHaskell();
      purescript_1 = purescript;
      purescript.displayName = "purescript";
      purescript.aliases = ["purs"];
      function purescript(Prism2) {
        Prism2.register(refractorHaskell);
        Prism2.languages.purescript = Prism2.languages.extend("haskell", {
          keyword: /\b(?:ado|case|class|data|derive|do|else|forall|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b|∀/,
          "import-statement": {
            // The imported or hidden names are not included in this import
            // statement. This is because we want to highlight those exactly like
            // we do for the names in the program.
            pattern: /(^[\t ]*)import\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*(?:\s+as\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
            lookbehind: true,
            inside: {
              keyword: /\b(?:as|hiding|import)\b/,
              punctuation: /\./
            }
          },
          // These are builtin functions only. Constructors are highlighted later as a constant.
          builtin: /\b(?:absurd|add|ap|append|apply|between|bind|bottom|clamp|compare|comparing|compose|conj|const|degree|discard|disj|div|eq|flap|flip|gcd|identity|ifM|join|lcm|liftA1|liftM1|map|max|mempty|min|mod|mul|negate|not|notEq|one|otherwise|recip|show|sub|top|unit|unless|unlessM|void|when|whenM|zero)\b/,
          operator: [
            // Infix operators
            Prism2.languages.haskell.operator[0],
            // ASCII operators
            Prism2.languages.haskell.operator[2],
            // All UTF16 Unicode operator symbols
            // This regex is equivalent to /(?=[\x80-\uFFFF])[\p{gc=Math_Symbol}\p{gc=Currency_Symbol}\p{Modifier_Symbol}\p{Other_Symbol}]/u
            // See https://github.com/PrismJS/prism/issues/3006 for more details.
            /[\xa2-\xa6\xa8\xa9\xac\xae-\xb1\xb4\xb8\xd7\xf7\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384\u0385\u03f6\u0482\u058d-\u058f\u0606-\u0608\u060b\u060e\u060f\u06de\u06e9\u06fd\u06fe\u07f6\u07fe\u07ff\u09f2\u09f3\u09fa\u09fb\u0af1\u0b70\u0bf3-\u0bfa\u0c7f\u0d4f\u0d79\u0e3f\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u0fd5-\u0fd8\u109e\u109f\u1390-\u1399\u166d\u17db\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u2052\u207a-\u207c\u208a-\u208c\u20a0-\u20bf\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u2140-\u2144\u214a-\u214d\u214f\u218a\u218b\u2190-\u2307\u230c-\u2328\u232b-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2767\u2794-\u27c4\u27c7-\u27e5\u27f0-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2b73\u2b76-\u2b95\u2b97-\u2bff\u2ce5-\u2cea\u2e50\u2e51\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua700-\ua716\ua720\ua721\ua789\ua78a\ua828-\ua82b\ua836-\ua839\uaa77-\uaa79\uab5b\uab6a\uab6b\ufb29\ufbb2-\ufbc1\ufdfc\ufdfd\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]/
          ]
        });
        Prism2.languages.purs = Prism2.languages.purescript;
      }
      return purescript_1;
    }
    var python_1;
    var hasRequiredPython;
    function requirePython() {
      if (hasRequiredPython)
        return python_1;
      hasRequiredPython = 1;
      python_1 = python;
      python.displayName = "python";
      python.aliases = ["py"];
      function python(Prism2) {
        Prism2.languages.python = {
          comment: {
            pattern: /(^|[^\\])#.*/,
            lookbehind: true,
            greedy: true
          },
          "string-interpolation": {
            pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
            greedy: true,
            inside: {
              interpolation: {
                // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
                pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
                lookbehind: true,
                inside: {
                  "format-spec": {
                    pattern: /(:)[^:(){}]+(?=\}$)/,
                    lookbehind: true
                  },
                  "conversion-option": {
                    pattern: /![sra](?=[:}]$)/,
                    alias: "punctuation"
                  },
                  rest: null
                }
              },
              string: /[\s\S]+/
            }
          },
          "triple-quoted-string": {
            pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
            greedy: true,
            alias: "string"
          },
          string: {
            pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
            greedy: true
          },
          function: {
            pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
            lookbehind: true
          },
          "class-name": {
            pattern: /(\bclass\s+)\w+/i,
            lookbehind: true
          },
          decorator: {
            pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
            lookbehind: true,
            alias: ["annotation", "punctuation"],
            inside: {
              punctuation: /\./
            }
          },
          keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
          builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
          boolean: /\b(?:False|None|True)\b/,
          number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
          operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
          punctuation: /[{}[\];(),.:]/
        };
        Prism2.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism2.languages.python;
        Prism2.languages.py = Prism2.languages.python;
      }
      return python_1;
    }
    var q_1;
    var hasRequiredQ;
    function requireQ() {
      if (hasRequiredQ)
        return q_1;
      hasRequiredQ = 1;
      q_1 = q2;
      q2.displayName = "q";
      q2.aliases = [];
      function q2(Prism2) {
        Prism2.languages.q = {
          string: /"(?:\\.|[^"\\\r\n])*"/,
          comment: [
            // From http://code.kx.com/wiki/Reference/Slash:
            // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
            {
              pattern: /([\t )\]}])\/.*/,
              lookbehind: true,
              greedy: true
            },
            // From http://code.kx.com/wiki/Reference/Slash:
            // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
            // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
            // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
            // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
            {
              pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
              lookbehind: true,
              greedy: true
            },
            // From http://code.kx.com/wiki/Reference/Slash:
            // A \ on a line by itself with no preceding matching / will comment to end of file.
            {
              pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
              greedy: true
            },
            {
              pattern: /^#!.+/m,
              greedy: true
            }
          ],
          symbol: /`(?::\S+|[\w.]*)/,
          datetime: {
            pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
            alias: "number"
          },
          // The negative look-ahead prevents bad highlighting
          // of verbs 0: and 1:
          number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
          keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
          adverb: {
            pattern: /['\/\\]:?|\beach\b/,
            alias: "function"
          },
          verb: {
            pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
            alias: "operator"
          },
          punctuation: /[(){}\[\];.]/
        };
      }
      return q_1;
    }
    var qml_1;
    var hasRequiredQml;
    function requireQml() {
      if (hasRequiredQml)
        return qml_1;
      hasRequiredQml = 1;
      qml_1 = qml;
      qml.displayName = "qml";
      qml.aliases = [];
      function qml(Prism2) {
        (function(Prism3) {
          var jsString = /"(?:\\.|[^\\"\r\n])*"|'(?:\\.|[^\\'\r\n])*'/.source;
          var jsComment = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source;
          var jsExpr = /(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/.source.replace(/<string>/g, function() {
            return jsString;
          }).replace(/<comment>/g, function() {
            return jsComment;
          });
          for (var i = 0; i < 2; i++) {
            jsExpr = jsExpr.replace(/<expr>/g, function() {
              return jsExpr;
            });
          }
          jsExpr = jsExpr.replace(/<expr>/g, "[^\\s\\S]");
          Prism3.languages.qml = {
            comment: {
              pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
              greedy: true
            },
            "javascript-function": {
              pattern: RegExp(
                /((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(
                  /<js>/g,
                  function() {
                    return jsExpr;
                  }
                ),
                "m"
              ),
              lookbehind: true,
              greedy: true,
              alias: "language-javascript",
              inside: Prism3.languages.javascript
            },
            "class-name": {
              pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
              lookbehind: true
            },
            property: [
              {
                pattern: /((?:^|[;{])[ \t]*)(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
                lookbehind: true
              },
              {
                pattern: /((?:^|[;{])[ \t]*)property[ \t]+(?!\d)\w+(?:\.\w+)*[ \t]+(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
                lookbehind: true,
                inside: {
                  keyword: /^property/,
                  property: /\w+(?:\.\w+)*/
                }
              }
            ],
            "javascript-expression": {
              pattern: RegExp(
                /(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(
                  /<js>/g,
                  function() {
                    return jsExpr;
                  }
                ),
                "m"
              ),
              lookbehind: true,
              greedy: true,
              alias: "language-javascript",
              inside: Prism3.languages.javascript
            },
            string: {
              pattern: /"(?:\\.|[^\\"\r\n])*"/,
              greedy: true
            },
            keyword: /\b(?:as|import|on)\b/,
            punctuation: /[{}[\]:;,]/
          };
        })(Prism2);
      }
      return qml_1;
    }
    var qore_1;
    var hasRequiredQore;
    function requireQore() {
      if (hasRequiredQore)
        return qore_1;
      hasRequiredQore = 1;
      qore_1 = qore;
      qore.displayName = "qore";
      qore.aliases = [];
      function qore(Prism2) {
        Prism2.languages.qore = Prism2.languages.extend("clike", {
          comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
            lookbehind: true
          },
          // Overridden to allow unescaped multi-line strings
          string: {
            pattern: /("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
            greedy: true
          },
          keyword: /\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
          boolean: /\b(?:false|true)\b/i,
          function: /\$?\b(?!\d)\w+(?=\()/,
          number: /\b(?:0b[01]+|0x(?:[\da-f]*\.)?[\da-fp\-]+|(?:\d+(?:\.\d+)?|\.\d+)(?:e\d+)?[df]|(?:\d+(?:\.\d+)?|\.\d+))\b/i,
          operator: {
            pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
            lookbehind: true
          },
          variable: /\$(?!\d)\w+\b/
        });
      }
      return qore_1;
    }
    var qsharp_1;
    var hasRequiredQsharp;
    function requireQsharp() {
      if (hasRequiredQsharp)
        return qsharp_1;
      hasRequiredQsharp = 1;
      qsharp_1 = qsharp;
      qsharp.displayName = "qsharp";
      qsharp.aliases = ["qs"];
      function qsharp(Prism2) {
        (function(Prism3) {
          function replace2(pattern, replacements) {
            return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
              return "(?:" + replacements[+index2] + ")";
            });
          }
          function re2(pattern, replacements, flags) {
            return RegExp(replace2(pattern, replacements), flags || "");
          }
          function nested(pattern, depthLog2) {
            for (var i = 0; i < depthLog2; i++) {
              pattern = pattern.replace(/<<self>>/g, function() {
                return "(?:" + pattern + ")";
              });
            }
            return pattern.replace(/<<self>>/g, "[^\\s\\S]");
          }
          var keywordKinds = {
            // keywords which represent a return or variable type
            type: "Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero",
            // all other keywords
            other: "Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within"
          };
          function keywordsToPattern(words) {
            return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
          }
          var keywords = RegExp(
            keywordsToPattern(keywordKinds.type + " " + keywordKinds.other)
          );
          var identifier = /\b[A-Za-z_]\w*\b/.source;
          var qualifiedName = replace2(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [identifier]);
          var typeInside = {
            keyword: keywords,
            punctuation: /[<>()?,.:[\]]/
          };
          var regularString = /"(?:\\.|[^\\"])*"/.source;
          Prism3.languages.qsharp = Prism3.languages.extend("clike", {
            comment: /\/\/.*/,
            string: [
              {
                pattern: re2(/(^|[^$\\])<<0>>/.source, [regularString]),
                lookbehind: true,
                greedy: true
              }
            ],
            "class-name": [
              {
                // open Microsoft.Quantum.Canon;
                // open Microsoft.Quantum.Canon as CN;
                pattern: re2(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [
                  qualifiedName
                ]),
                lookbehind: true,
                inside: typeInside
              },
              {
                // namespace Quantum.App1;
                pattern: re2(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [qualifiedName]),
                lookbehind: true,
                inside: typeInside
              }
            ],
            keyword: keywords,
            number: /(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
            operator: /\band=|\bor=|\band\b|\bnot\b|\bor\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
            punctuation: /::|[{}[\];(),.:]/
          });
          Prism3.languages.insertBefore("qsharp", "number", {
            range: {
              pattern: /\.\./,
              alias: "operator"
            }
          });
          var interpolationExpr = nested(
            replace2(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [regularString]),
            2
          );
          Prism3.languages.insertBefore("qsharp", "string", {
            "interpolation-string": {
              pattern: re2(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [interpolationExpr]),
              greedy: true,
              inside: {
                interpolation: {
                  pattern: re2(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [
                    interpolationExpr
                  ]),
                  lookbehind: true,
                  inside: {
                    punctuation: /^\{|\}$/,
                    expression: {
                      pattern: /[\s\S]+/,
                      alias: "language-qsharp",
                      inside: Prism3.languages.qsharp
                    }
                  }
                },
                string: /[\s\S]+/
              }
            }
          });
        })(Prism2);
        Prism2.languages.qs = Prism2.languages.qsharp;
      }
      return qsharp_1;
    }
    var r_1;
    var hasRequiredR;
    function requireR() {
      if (hasRequiredR)
        return r_1;
      hasRequiredR = 1;
      r_1 = r2;
      r2.displayName = "r";
      r2.aliases = [];
      function r2(Prism2) {
        Prism2.languages.r = {
          comment: /#.*/,
          string: {
            pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          "percent-operator": {
            // Includes user-defined operators
            // and %%, %*%, %/%, %in%, %o%, %x%
            pattern: /%[^%\s]*%/,
            alias: "operator"
          },
          boolean: /\b(?:FALSE|TRUE)\b/,
          ellipsis: /\.\.(?:\.|\d+)/,
          number: [
            /\b(?:Inf|NaN)\b/,
            /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
          ],
          keyword: /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
          operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
          punctuation: /[(){}\[\],;]/
        };
      }
      return r_1;
    }
    var racket_1;
    var hasRequiredRacket;
    function requireRacket() {
      if (hasRequiredRacket)
        return racket_1;
      hasRequiredRacket = 1;
      var refractorScheme = requireScheme();
      racket_1 = racket;
      racket.displayName = "racket";
      racket.aliases = ["rkt"];
      function racket(Prism2) {
        Prism2.register(refractorScheme);
        Prism2.languages.racket = Prism2.languages.extend("scheme", {
          "lambda-parameter": {
            // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.
            // this will just prevent false positives of the `function` pattern
            pattern: /([(\[]lambda\s+[(\[])[^()\[\]'\s]+/,
            lookbehind: true
          }
        });
        Prism2.languages.insertBefore("racket", "string", {
          lang: {
            pattern: /^#lang.+/m,
            greedy: true,
            alias: "keyword"
          }
        });
        Prism2.languages.rkt = Prism2.languages.racket;
      }
      return racket_1;
    }
    var reason_1;
    var hasRequiredReason;
    function requireReason() {
      if (hasRequiredReason)
        return reason_1;
      hasRequiredReason = 1;
      reason_1 = reason;
      reason.displayName = "reason";
      reason.aliases = [];
      function reason(Prism2) {
        Prism2.languages.reason = Prism2.languages.extend("clike", {
          string: {
            pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
            greedy: true
          },
          // 'class-name' must be matched *after* 'constructor' defined below
          "class-name": /\b[A-Z]\w*/,
          keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
          operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
        });
        Prism2.languages.insertBefore("reason", "class-name", {
          char: {
            pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
            greedy: true
          },
          // Negative look-ahead prevents from matching things like String.capitalize
          constructor: /\b[A-Z]\w*\b(?!\s*\.)/,
          label: {
            pattern: /\b[a-z]\w*(?=::)/,
            alias: "symbol"
          }
        });
        delete Prism2.languages.reason.function;
      }
      return reason_1;
    }
    var regex_1;
    var hasRequiredRegex;
    function requireRegex() {
      if (hasRequiredRegex)
        return regex_1;
      hasRequiredRegex = 1;
      regex_1 = regex;
      regex.displayName = "regex";
      regex.aliases = [];
      function regex(Prism2) {
        (function(Prism3) {
          var specialEscape = {
            pattern: /\\[\\(){}[\]^$+*?|.]/,
            alias: "escape"
          };
          var escape2 = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
          var charSet = {
            pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
            alias: "class-name"
          };
          var charSetWithoutDot = {
            pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
            alias: "class-name"
          };
          var rangeChar = "(?:[^\\\\-]|" + escape2.source + ")";
          var range = RegExp(rangeChar + "-" + rangeChar);
          var groupName = {
            pattern: /(<|')[^<>']+(?=[>']$)/,
            lookbehind: true,
            alias: "variable"
          };
          Prism3.languages.regex = {
            "char-class": {
              pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
              lookbehind: true,
              inside: {
                "char-class-negation": {
                  pattern: /(^\[)\^/,
                  lookbehind: true,
                  alias: "operator"
                },
                "char-class-punctuation": {
                  pattern: /^\[|\]$/,
                  alias: "punctuation"
                },
                range: {
                  pattern: range,
                  inside: {
                    escape: escape2,
                    "range-punctuation": {
                      pattern: /-/,
                      alias: "operator"
                    }
                  }
                },
                "special-escape": specialEscape,
                "char-set": charSetWithoutDot,
                escape: escape2
              }
            },
            "special-escape": specialEscape,
            "char-set": charSet,
            backreference: [
              {
                // a backreference which is not an octal escape
                pattern: /\\(?![123][0-7]{2})[1-9]/,
                alias: "keyword"
              },
              {
                pattern: /\\k<[^<>']+>/,
                alias: "keyword",
                inside: {
                  "group-name": groupName
                }
              }
            ],
            anchor: {
              pattern: /[$^]|\\[ABbGZz]/,
              alias: "function"
            },
            escape: escape2,
            group: [
              {
                // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
                // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
                // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
                pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
                alias: "punctuation",
                inside: {
                  "group-name": groupName
                }
              },
              {
                pattern: /\)/,
                alias: "punctuation"
              }
            ],
            quantifier: {
              pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
              alias: "number"
            },
            alternation: {
              pattern: /\|/,
              alias: "keyword"
            }
          };
        })(Prism2);
      }
      return regex_1;
    }
    var rego_1;
    var hasRequiredRego;
    function requireRego() {
      if (hasRequiredRego)
        return rego_1;
      hasRequiredRego = 1;
      rego_1 = rego;
      rego.displayName = "rego";
      rego.aliases = [];
      function rego(Prism2) {
        Prism2.languages.rego = {
          comment: /#.*/,
          property: {
            pattern: /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
            lookbehind: true,
            greedy: true
          },
          string: {
            pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
            lookbehind: true,
            greedy: true
          },
          keyword: /\b(?:as|default|else|import|not|null|package|set(?=\s*\()|some|with)\b/,
          boolean: /\b(?:false|true)\b/,
          function: {
            pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
            inside: {
              namespace: /\b\w+\b(?=\s*\.)/,
              punctuation: /\./
            }
          },
          number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
          operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
          punctuation: /[,;.\[\]{}()]/
        };
      }
      return rego_1;
    }
    var renpy_1;
    var hasRequiredRenpy;
    function requireRenpy() {
      if (hasRequiredRenpy)
        return renpy_1;
      hasRequiredRenpy = 1;
      renpy_1 = renpy;
      renpy.displayName = "renpy";
      renpy.aliases = ["rpy"];
      function renpy(Prism2) {
        Prism2.languages.renpy = {
          comment: {
            pattern: /(^|[^\\])#.+/,
            lookbehind: true
          },
          string: {
            pattern: /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\])*\2|(?:^#?(?:(?:[0-9a-fA-F]){3}|[0-9a-fA-F]{6})$)/m,
            greedy: true
          },
          function: /\b[a-z_]\w*(?=\()/i,
          property: /\b(?:Update|UpdateVersion|action|activate_sound|adv_nvl_transition|after_load_transition|align|alpha|alt|anchor|antialias|area|auto|background|bar_invert|bar_resizing|bar_vertical|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_reverse|box_wrap|can_update|caret|child|color|crop|default_afm_enable|default_afm_time|default_fullscreen|default_text_cps|developer|directory_name|drag_handle|drag_joined|drag_name|drag_raise|draggable|dragged|drop_shadow|drop_shadow_color|droppable|dropped|easein|easeout|edgescroll|end_game_transition|end_splash_transition|enter_replay_transition|enter_sound|enter_transition|enter_yesno_transition|executable_name|exit_replay_transition|exit_sound|exit_transition|exit_yesno_transition|fadein|fadeout|first_indent|first_spacing|fit_first|focus|focus_mask|font|foreground|game_main_transition|get_installed_packages|google_play_key|google_play_salt|ground|has_music|has_sound|has_voice|height|help|hinting|hover|hover_background|hover_color|hover_sound|hovered|hyperlink_functions|idle|idle_color|image_style|include_update|insensitive|insensitive_background|insensitive_color|inside|intra_transition|italic|justify|kerning|keyboard_focus|language|layer_clipping|layers|layout|left_bar|left_gutter|left_margin|left_padding|length|line_leading|line_overlap_split|line_spacing|linear|main_game_transition|main_menu_music|maximum|min_width|minimum|minwidth|modal|mouse|mousewheel|name|narrator_menu|newline_indent|nvl_adv_transition|offset|order_reverse|outlines|overlay_functions|pos|position|prefix|radius|range|rest_indent|right_bar|right_gutter|right_margin|right_padding|rotate|rotate_pad|ruby_style|sample_sound|save_directory|say_attribute_transition|screen_height|screen_width|scrollbars|selected_hover|selected_hover_color|selected_idle|selected_idle_color|selected_insensitive|show_side_image|show_two_window|side_spacing|side_xpos|side_ypos|size|size_group|slow_cps|slow_cps_multiplier|spacing|strikethrough|subpixel|text_align|text_style|text_xpos|text_y_fudge|text_ypos|thumb|thumb_offset|thumb_shadow|thumbnail_height|thumbnail_width|time|top_bar|top_gutter|top_margin|top_padding|translations|underline|unscrollable|update|value|version|version_name|version_tuple|vertical|width|window_hide_transition|window_icon|window_left_padding|window_show_transition|window_title|windows_icon|xadjustment|xalign|xanchor|xanchoraround|xaround|xcenter|xfill|xinitial|xmargin|xmaximum|xminimum|xoffset|xofsset|xpadding|xpos|xsize|xzoom|yadjustment|yalign|yanchor|yanchoraround|yaround|ycenter|yfill|yinitial|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|ysizexysize|yzoom|zoom|zorder)\b/,
          tag: /\b(?:bar|block|button|buttoscreenn|drag|draggroup|fixed|frame|grid|[hv]box|hotbar|hotspot|image|imagebutton|imagemap|input|key|label|menu|mm_menu_frame|mousearea|nvl|parallel|screen|self|side|tag|text|textbutton|timer|vbar|viewport|window)\b|\$/,
          keyword: /\b(?:None|add|adjustment|alignaround|allow|angle|animation|around|as|assert|behind|box_layout|break|build|cache|call|center|changed|child_size|choice|circles|class|clear|clicked|clipping|clockwise|config|contains|continue|corner1|corner2|counterclockwise|def|default|define|del|delay|disabled|disabled_text|dissolve|elif|else|event|except|exclude|exec|expression|fade|finally|for|from|function|global|gm_root|has|hide|id|if|import|in|init|is|jump|knot|lambda|left|less_rounded|mm_root|movie|music|null|on|onlayer|pass|pause|persistent|play|print|python|queue|raise|random|renpy|repeat|return|right|rounded_window|scene|scope|set|show|slow|slow_abortable|slow_done|sound|stop|store|style|style_group|substitute|suffix|theme|transform|transform_anchor|transpose|try|ui|unhovered|updater|use|voice|while|widget|widget_hover|widget_selected|widget_text|yield)\b/,
          boolean: /\b(?:[Ff]alse|[Tt]rue)\b/,
          number: /(?:\b(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?)|\B\.\d+)(?:e[+-]?\d+)?j?/i,
          operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:and|at|not|or|with)\b/,
          punctuation: /[{}[\];(),.:]/
        };
        Prism2.languages.rpy = Prism2.languages.renpy;
      }
      return renpy_1;
    }
    var rest_1;
    var hasRequiredRest;
    function requireRest() {
      if (hasRequiredRest)
        return rest_1;
      hasRequiredRest = 1;
      rest_1 = rest;
      rest.displayName = "rest";
      rest.aliases = [];
      function rest(Prism2) {
        Prism2.languages.rest = {
          table: [
            {
              pattern: /(^[\t ]*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1[+|].+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/m,
              lookbehind: true,
              inside: {
                punctuation: /\||(?:\+[=-]+)+\+/
              }
            },
            {
              pattern: /(^[\t ]*)=+ [ =]*=(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1=+ [ =]*=(?=(?:\r?\n|\r){2}|\s*$)/m,
              lookbehind: true,
              inside: {
                punctuation: /[=-]+/
              }
            }
          ],
          // Directive-like patterns
          "substitution-def": {
            pattern: /(^[\t ]*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
            lookbehind: true,
            inside: {
              substitution: {
                pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
                alias: "attr-value",
                inside: {
                  punctuation: /^\||\|$/
                }
              },
              directive: {
                pattern: /( )(?! )[^:]+::/,
                lookbehind: true,
                alias: "function",
                inside: {
                  punctuation: /::$/
                }
              }
            }
          },
          "link-target": [
            {
              pattern: /(^[\t ]*\.\. )\[[^\]]+\]/m,
              lookbehind: true,
              alias: "string",
              inside: {
                punctuation: /^\[|\]$/
              }
            },
            {
              pattern: /(^[\t ]*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
              lookbehind: true,
              alias: "string",
              inside: {
                punctuation: /^_|:$/
              }
            }
          ],
          directive: {
            pattern: /(^[\t ]*\.\. )[^:]+::/m,
            lookbehind: true,
            alias: "function",
            inside: {
              punctuation: /::$/
            }
          },
          comment: {
            // The two alternatives try to prevent highlighting of blank comments
            pattern: /(^[\t ]*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
            lookbehind: true
          },
          title: [
            // Overlined and underlined
            {
              pattern: /^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
              inside: {
                punctuation: /^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
                important: /.+/
              }
            },
            // Underlined only
            {
              pattern: /(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
              lookbehind: true,
              inside: {
                punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
                important: /.+/
              }
            }
          ],
          hr: {
            pattern: /((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
            lookbehind: true,
            alias: "punctuation"
          },
          field: {
            pattern: /(^[\t ]*):[^:\r\n]+:(?= )/m,
            lookbehind: true,
            alias: "attr-name"
          },
          "command-line-option": {
            pattern: /(^[\t ]*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
            lookbehind: true,
            alias: "symbol"
          },
          "literal-block": {
            pattern: /::(?:\r?\n|\r){2}([ \t]+)(?![ \t]).+(?:(?:\r?\n|\r)\1.+)*/,
            inside: {
              "literal-block-punctuation": {
                pattern: /^::/,
                alias: "punctuation"
              }
            }
          },
          "quoted-literal-block": {
            pattern: /::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
            inside: {
              "literal-block-punctuation": {
                pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
                alias: "punctuation"
              }
            }
          },
          "list-bullet": {
            pattern: /(^[\t ]*)(?:[*+\-•‣⁃]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
            lookbehind: true,
            alias: "punctuation"
          },
          "doctest-block": {
            pattern: /(^[\t ]*)>>> .+(?:(?:\r?\n|\r).+)*/m,
            lookbehind: true,
            inside: {
              punctuation: /^>>>/
            }
          },
          inline: [
            {
              pattern: /(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s)(?:(?!\2).)*\S\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
              lookbehind: true,
              inside: {
                bold: {
                  pattern: /(^\*\*).+(?=\*\*$)/,
                  lookbehind: true
                },
                italic: {
                  pattern: /(^\*).+(?=\*$)/,
                  lookbehind: true
                },
                "inline-literal": {
                  pattern: /(^``).+(?=``$)/,
                  lookbehind: true,
                  alias: "symbol"
                },
                role: {
                  pattern: /^:[^:]+:|:[^:]+:$/,
                  alias: "function",
                  inside: {
                    punctuation: /^:|:$/
                  }
                },
                "interpreted-text": {
                  pattern: /(^`).+(?=`$)/,
                  lookbehind: true,
                  alias: "attr-value"
                },
                substitution: {
                  pattern: /(^\|).+(?=\|$)/,
                  lookbehind: true,
                  alias: "attr-value"
                },
                punctuation: /\*\*?|``?|\|/
              }
            }
          ],
          link: [
            {
              pattern: /\[[^\[\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
              alias: "string",
              inside: {
                punctuation: /^\[|\]_$/
              }
            },
            {
              pattern: /(?:\b[a-z\d]+(?:[_.:+][a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
              alias: "string",
              inside: {
                punctuation: /^_?`|`$|`?_?_$/
              }
            }
          ],
          // Line block start,
          // quote attribution,
          // explicit markup start,
          // and anonymous hyperlink target shortcut (__)
          punctuation: {
            pattern: /(^[\t ]*)(?:\|(?= |$)|(?:---?|—|\.\.|__)(?= )|\.\.$)/m,
            lookbehind: true
          }
        };
      }
      return rest_1;
    }
    var rip_1;
    var hasRequiredRip;
    function requireRip() {
      if (hasRequiredRip)
        return rip_1;
      hasRequiredRip = 1;
      rip_1 = rip;
      rip.displayName = "rip";
      rip.aliases = [];
      function rip(Prism2) {
        Prism2.languages.rip = {
          comment: {
            pattern: /#.*/,
            greedy: true
          },
          char: {
            pattern: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,
            greedy: true
          },
          string: {
            pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          regex: {
            pattern: /(^|[^/])\/(?!\/)(?:\[[^\n\r\]]*\]|\\.|[^/\\\r\n\[])+\/(?=\s*(?:$|[\r\n,.;})]))/,
            lookbehind: true,
            greedy: true
          },
          keyword: /(?:=>|->)|\b(?:case|catch|class|else|exit|finally|if|raise|return|switch|try)\b/,
          builtin: /@|\bSystem\b/,
          boolean: /\b(?:false|true)\b/,
          date: /\b\d{4}-\d{2}-\d{2}\b/,
          time: /\b\d{2}:\d{2}:\d{2}\b/,
          datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
          symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
          number: /[+-]?\b(?:\d+\.\d+|\d+)\b/,
          punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
          reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
        };
      }
      return rip_1;
    }
    var roboconf_1;
    var hasRequiredRoboconf;
    function requireRoboconf() {
      if (hasRequiredRoboconf)
        return roboconf_1;
      hasRequiredRoboconf = 1;
      roboconf_1 = roboconf;
      roboconf.displayName = "roboconf";
      roboconf.aliases = [];
      function roboconf(Prism2) {
        Prism2.languages.roboconf = {
          comment: /#.*/,
          keyword: {
            pattern: /(^|\s)(?:(?:external|import)\b|(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{))/,
            lookbehind: true
          },
          component: {
            pattern: /[\w-]+(?=[ \t]*\{)/,
            alias: "variable"
          },
          property: /[\w.-]+(?=[ \t]*:)/,
          value: {
            pattern: /(=[ \t]*(?![ \t]))[^,;]+/,
            lookbehind: true,
            alias: "attr-value"
          },
          optional: {
            pattern: /\(optional\)/,
            alias: "builtin"
          },
          wildcard: {
            pattern: /(\.)\*/,
            lookbehind: true,
            alias: "operator"
          },
          punctuation: /[{},.;:=]/
        };
      }
      return roboconf_1;
    }
    var robotframework_1;
    var hasRequiredRobotframework;
    function requireRobotframework() {
      if (hasRequiredRobotframework)
        return robotframework_1;
      hasRequiredRobotframework = 1;
      robotframework_1 = robotframework;
      robotframework.displayName = "robotframework";
      robotframework.aliases = [];
      function robotframework(Prism2) {
        (function(Prism3) {
          var comment = {
            pattern: /(^[ \t]*| {2}|\t)#.*/m,
            lookbehind: true,
            greedy: true
          };
          var variable = {
            pattern: /((?:^|[^\\])(?:\\{2})*)[$@&%]\{(?:[^{}\r\n]|\{[^{}\r\n]*\})*\}/,
            lookbehind: true,
            inside: {
              punctuation: /^[$@&%]\{|\}$/
            }
          };
          function createSection(name2, inside) {
            var extendecInside = {};
            extendecInside["section-header"] = {
              pattern: /^ ?\*{3}.+?\*{3}/,
              alias: "keyword"
            };
            for (var token in inside) {
              extendecInside[token] = inside[token];
            }
            extendecInside["tag"] = {
              pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
              lookbehind: true,
              inside: {
                punctuation: /\[|\]/
              }
            };
            extendecInside["variable"] = variable;
            extendecInside["comment"] = comment;
            return {
              pattern: RegExp(
                /^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(
                  /<name>/g,
                  function() {
                    return name2;
                  }
                ),
                "im"
              ),
              alias: "section",
              inside: extendecInside
            };
          }
          var docTag = {
            pattern: /(\[Documentation\](?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
            lookbehind: true,
            alias: "string"
          };
          var testNameLike = {
            pattern: /([\r\n] ?)(?!#)(?:\S(?:[ \t]\S)*)+/,
            lookbehind: true,
            alias: "function",
            inside: {
              variable
            }
          };
          var testPropertyLike = {
            pattern: /([\r\n](?: {2}|\t)[ \t]*)(?!\[|\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
            lookbehind: true,
            inside: {
              variable
            }
          };
          Prism3.languages["robotframework"] = {
            settings: createSection("Settings", {
              documentation: {
                pattern: /([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
                lookbehind: true,
                alias: "string"
              },
              property: {
                pattern: /([\r\n] ?)(?!\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
                lookbehind: true
              }
            }),
            variables: createSection("Variables"),
            "test-cases": createSection("Test Cases", {
              "test-name": testNameLike,
              documentation: docTag,
              property: testPropertyLike
            }),
            keywords: createSection("Keywords", {
              "keyword-name": testNameLike,
              documentation: docTag,
              property: testPropertyLike
            }),
            tasks: createSection("Tasks", {
              "task-name": testNameLike,
              documentation: docTag,
              property: testPropertyLike
            }),
            comment
          };
          Prism3.languages.robot = Prism3.languages["robotframework"];
        })(Prism2);
      }
      return robotframework_1;
    }
    var rust_1;
    var hasRequiredRust;
    function requireRust() {
      if (hasRequiredRust)
        return rust_1;
      hasRequiredRust = 1;
      rust_1 = rust;
      rust.displayName = "rust";
      rust.aliases = [];
      function rust(Prism2) {
        (function(Prism3) {
          var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
          for (var i = 0; i < 2; i++) {
            multilineComment = multilineComment.replace(/<self>/g, function() {
              return multilineComment;
            });
          }
          multilineComment = multilineComment.replace(/<self>/g, function() {
            return /[^\s\S]/.source;
          });
          Prism3.languages.rust = {
            comment: [
              {
                pattern: RegExp(/(^|[^\\])/.source + multilineComment),
                lookbehind: true,
                greedy: true
              },
              {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
              }
            ],
            string: {
              pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
              greedy: true
            },
            char: {
              pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
              greedy: true
            },
            attribute: {
              pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
              greedy: true,
              alias: "attr-name",
              inside: {
                string: null
                // see below
              }
            },
            // Closure params should not be confused with bitwise OR |
            "closure-params": {
              pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
              lookbehind: true,
              greedy: true,
              inside: {
                "closure-punctuation": {
                  pattern: /^\||\|$/,
                  alias: "punctuation"
                },
                rest: null
                // see below
              }
            },
            "lifetime-annotation": {
              pattern: /'\w+/,
              alias: "symbol"
            },
            "fragment-specifier": {
              pattern: /(\$\w+:)[a-z]+/,
              lookbehind: true,
              alias: "punctuation"
            },
            variable: /\$\w+/,
            "function-definition": {
              pattern: /(\bfn\s+)\w+/,
              lookbehind: true,
              alias: "function"
            },
            "type-definition": {
              pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
              lookbehind: true,
              alias: "class-name"
            },
            "module-declaration": [
              {
                pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
                lookbehind: true,
                alias: "namespace"
              },
              {
                pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
                lookbehind: true,
                alias: "namespace",
                inside: {
                  punctuation: /::/
                }
              }
            ],
            keyword: [
              // https://github.com/rust-lang/reference/blob/master/src/keywords.md
              /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
              // primitives and str
              // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
              /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
            ],
            // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
            // and Rust's naming conventions recommend snake_case anyway.
            // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
            function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
            macro: {
              pattern: /\b\w+!/,
              alias: "property"
            },
            constant: /\b[A-Z_][A-Z_\d]+\b/,
            "class-name": /\b[A-Z]\w*\b/,
            namespace: {
              pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
              inside: {
                punctuation: /::/
              }
            },
            // Hex, oct, bin, dec numbers with visual separators and type suffix
            number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
            boolean: /\b(?:false|true)\b/,
            punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
            operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
          };
          Prism3.languages.rust["closure-params"].inside.rest = Prism3.languages.rust;
          Prism3.languages.rust["attribute"].inside["string"] = Prism3.languages.rust["string"];
        })(Prism2);
      }
      return rust_1;
    }
    var sas_1;
    var hasRequiredSas;
    function requireSas() {
      if (hasRequiredSas)
        return sas_1;
      hasRequiredSas = 1;
      sas_1 = sas;
      sas.displayName = "sas";
      sas.aliases = [];
      function sas(Prism2) {
        (function(Prism3) {
          var stringPattern = /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))/.source;
          var number2 = /\b(?:\d[\da-f]*x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i;
          var numericConstant = {
            pattern: RegExp(stringPattern + "[bx]"),
            alias: "number"
          };
          var macroVariable = {
            pattern: /&[a-z_]\w*/i
          };
          var macroKeyword = {
            pattern: /((?:^|\s|=|\())%(?:ABORT|BY|CMS|COPY|DISPLAY|DO|ELSE|END|EVAL|GLOBAL|GO|GOTO|IF|INC|INCLUDE|INDEX|INPUT|KTRIM|LENGTH|LET|LIST|LOCAL|PUT|QKTRIM|QSCAN|QSUBSTR|QSYSFUNC|QUPCASE|RETURN|RUN|SCAN|SUBSTR|SUPERQ|SYMDEL|SYMEXIST|SYMGLOBL|SYMLOCAL|SYSCALL|SYSEVALF|SYSEXEC|SYSFUNC|SYSGET|SYSRPUT|THEN|TO|TSO|UNQUOTE|UNTIL|UPCASE|WHILE|WINDOW)\b/i,
            lookbehind: true,
            alias: "keyword"
          };
          var step = {
            pattern: /(^|\s)(?:proc\s+\w+|data(?!=)|quit|run)\b/i,
            alias: "keyword",
            lookbehind: true
          };
          var comment = [
            /\/\*[\s\S]*?\*\//,
            {
              pattern: /(^[ \t]*|;\s*)\*[^;]*;/m,
              lookbehind: true
            }
          ];
          var string2 = {
            pattern: RegExp(stringPattern),
            greedy: true
          };
          var punctuation = /[$%@.(){}\[\];,\\]/;
          var func = {
            pattern: /%?\b\w+(?=\()/,
            alias: "keyword"
          };
          var args = {
            function: func,
            "arg-value": {
              pattern: /(=\s*)[A-Z\.]+/i,
              lookbehind: true
            },
            operator: /=/,
            "macro-variable": macroVariable,
            arg: {
              pattern: /[A-Z]+/i,
              alias: "keyword"
            },
            number: number2,
            "numeric-constant": numericConstant,
            punctuation,
            string: string2
          };
          var format = {
            pattern: /\b(?:format|put)\b=?[\w'$.]+/i,
            inside: {
              keyword: /^(?:format|put)(?==)/i,
              equals: /=/,
              format: {
                pattern: /(?:\w|\$\d)+\.\d?/,
                alias: "number"
              }
            }
          };
          var altformat = {
            pattern: /\b(?:format|put)\s+[\w']+(?:\s+[$.\w]+)+(?=;)/i,
            inside: {
              keyword: /^(?:format|put)/i,
              format: {
                pattern: /[\w$]+\.\d?/,
                alias: "number"
              }
            }
          };
          var globalStatements = {
            pattern: /((?:^|\s)=?)(?:catname|checkpoint execute_always|dm|endsas|filename|footnote|%include|libname|%list|lock|missing|options|page|resetline|%run|sasfile|skip|sysecho|title\d?)\b/i,
            lookbehind: true,
            alias: "keyword"
          };
          var submitStatement = {
            pattern: /(^|\s)(?:submit(?:\s+(?:load|norun|parseonly))?|endsubmit)\b/i,
            lookbehind: true,
            alias: "keyword"
          };
          var actionSets = /aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/.source;
          var casActions = {
            pattern: RegExp(
              /(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(
                /<act>/g,
                function() {
                  return actionSets;
                }
              ),
              "i"
            ),
            lookbehind: true,
            inside: {
              keyword: RegExp(
                /(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function() {
                  return actionSets;
                }),
                "i"
              ),
              action: {
                pattern: /(?:action)/i,
                alias: "keyword"
              },
              comment,
              function: func,
              "arg-value": args["arg-value"],
              operator: args.operator,
              argument: args.arg,
              number: number2,
              "numeric-constant": numericConstant,
              punctuation,
              string: string2
            }
          };
          var keywords = {
            pattern: /((?:^|\s)=?)(?:after|analysis|and|array|barchart|barwidth|begingraph|by|call|cas|cbarline|cfill|class(?:lev)?|close|column|computed?|contains|continue|data(?==)|define|delete|describe|document|do\s+over|do|dol|drop|dul|else|end(?:comp|source)?|entryTitle|eval(?:uate)?|exec(?:ute)?|exit|file(?:name)?|fill(?:attrs)?|flist|fnc|function(?:list)?|global|goto|group(?:by)?|headline|headskip|histogram|if|infile|keep|keylabel|keyword|label|layout|leave|legendlabel|length|libname|loadactionset|merge|midpoints|_?null_|name|noobs|nowd|ods|options|or|otherwise|out(?:put)?|over(?:lay)?|plot|print|put|raise|ranexp|rannor|rbreak|retain|return|select|session|sessref|set|source|statgraph|sum|summarize|table|temp|terminate|then\s+do|then|title\d?|to|var|when|where|xaxisopts|y2axisopts|yaxisopts)\b/i,
            lookbehind: true
          };
          Prism3.languages.sas = {
            datalines: {
              pattern: /^([ \t]*)(?:cards|(?:data)?lines);[\s\S]+?^[ \t]*;/im,
              lookbehind: true,
              alias: "string",
              inside: {
                keyword: {
                  pattern: /^(?:cards|(?:data)?lines)/i
                },
                punctuation: /;/
              }
            },
            "proc-sql": {
              pattern: /(^proc\s+(?:fed)?sql(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
              lookbehind: true,
              inside: {
                sql: {
                  pattern: RegExp(
                    /^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(
                      /<str>/g,
                      function() {
                        return stringPattern;
                      }
                    ),
                    "im"
                  ),
                  alias: "language-sql",
                  inside: Prism3.languages.sql
                },
                "global-statements": globalStatements,
                "sql-statements": {
                  pattern: /(^|\s)(?:disconnect\s+from|begin|commit|exec(?:ute)?|reset|rollback|validate)\b/i,
                  lookbehind: true,
                  alias: "keyword"
                },
                number: number2,
                "numeric-constant": numericConstant,
                punctuation,
                string: string2
              }
            },
            "proc-groovy": {
              pattern: /(^proc\s+groovy(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
              lookbehind: true,
              inside: {
                comment,
                groovy: {
                  pattern: RegExp(
                    /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
                      /<str>/g,
                      function() {
                        return stringPattern;
                      }
                    ),
                    "im"
                  ),
                  lookbehind: true,
                  alias: "language-groovy",
                  inside: Prism3.languages.groovy
                },
                keyword: keywords,
                "submit-statement": submitStatement,
                "global-statements": globalStatements,
                number: number2,
                "numeric-constant": numericConstant,
                punctuation,
                string: string2
              }
            },
            "proc-lua": {
              pattern: /(^proc\s+lua(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
              lookbehind: true,
              inside: {
                comment,
                lua: {
                  pattern: RegExp(
                    /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
                      /<str>/g,
                      function() {
                        return stringPattern;
                      }
                    ),
                    "im"
                  ),
                  lookbehind: true,
                  alias: "language-lua",
                  inside: Prism3.languages.lua
                },
                keyword: keywords,
                "submit-statement": submitStatement,
                "global-statements": globalStatements,
                number: number2,
                "numeric-constant": numericConstant,
                punctuation,
                string: string2
              }
            },
            "proc-cas": {
              pattern: /(^proc\s+cas(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|quit|data);|(?![\s\S]))/im,
              lookbehind: true,
              inside: {
                comment,
                "statement-var": {
                  pattern: /((?:^|\s)=?)saveresult\s[^;]+/im,
                  lookbehind: true,
                  inside: {
                    statement: {
                      pattern: /^saveresult\s+\S+/i,
                      inside: {
                        keyword: /^(?:saveresult)/i
                      }
                    },
                    rest: args
                  }
                },
                "cas-actions": casActions,
                statement: {
                  pattern: /((?:^|\s)=?)(?:default|(?:un)?set|on|output|upload)[^;]+/im,
                  lookbehind: true,
                  inside: args
                },
                step,
                keyword: keywords,
                function: func,
                format,
                altformat,
                "global-statements": globalStatements,
                number: number2,
                "numeric-constant": numericConstant,
                punctuation,
                string: string2
              }
            },
            "proc-args": {
              pattern: RegExp(
                /(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(
                  /<str>/g,
                  function() {
                    return stringPattern;
                  }
                ),
                "im"
              ),
              lookbehind: true,
              inside: args
            },
            /*Special keywords within macros*/
            "macro-keyword": macroKeyword,
            "macro-variable": macroVariable,
            "macro-string-functions": {
              pattern: /((?:^|\s|=))%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)\(.*?(?:[^%]\))/i,
              lookbehind: true,
              inside: {
                function: {
                  pattern: /%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)/i,
                  alias: "keyword"
                },
                "macro-keyword": macroKeyword,
                "macro-variable": macroVariable,
                "escaped-char": {
                  pattern: /%['"()<>=¬^~;,#]/
                },
                punctuation
              }
            },
            "macro-declaration": {
              pattern: /^%macro[^;]+(?=;)/im,
              inside: {
                keyword: /%macro/i
              }
            },
            "macro-end": {
              pattern: /^%mend[^;]+(?=;)/im,
              inside: {
                keyword: /%mend/i
              }
            },
            /*%_zscore(headcir, _lhc, _mhc, _shc, headcz, headcpct, _Fheadcz); */
            macro: {
              pattern: /%_\w+(?=\()/,
              alias: "keyword"
            },
            input: {
              pattern: /\binput\s[-\w\s/*.$&]+;/i,
              inside: {
                input: {
                  alias: "keyword",
                  pattern: /^input/i
                },
                comment,
                number: number2,
                "numeric-constant": numericConstant
              }
            },
            "options-args": {
              pattern: /(^options)[-'"|/\\<>*+=:()\w\s]*(?=;)/im,
              lookbehind: true,
              inside: args
            },
            "cas-actions": casActions,
            comment,
            function: func,
            format,
            altformat,
            "numeric-constant": numericConstant,
            datetime: {
              // '1jan2013'd, '9:25:19pm't, '18jan2003:9:27:05am'dt
              pattern: RegExp(stringPattern + "(?:dt?|t)"),
              alias: "number"
            },
            string: string2,
            step,
            keyword: keywords,
            // In SAS Studio syntax highlighting, these operators are styled like keywords
            "operator-keyword": {
              pattern: /\b(?:eq|ge|gt|in|le|lt|ne|not)\b/i,
              alias: "operator"
            },
            // Decimal (1.2e23), hexadecimal (0c1x)
            number: number2,
            operator: /\*\*?|\|\|?|!!?|¦¦?|<[>=]?|>[<=]?|[-+\/=&]|[~¬^]=?/,
            punctuation
          };
        })(Prism2);
      }
      return sas_1;
    }
    var sass_1;
    var hasRequiredSass;
    function requireSass() {
      if (hasRequiredSass)
        return sass_1;
      hasRequiredSass = 1;
      sass_1 = sass;
      sass.displayName = "sass";
      sass.aliases = [];
      function sass(Prism2) {
        (function(Prism3) {
          Prism3.languages.sass = Prism3.languages.extend("css", {
            // Sass comments don't need to be closed, only indented
            comment: {
              pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
              lookbehind: true,
              greedy: true
            }
          });
          Prism3.languages.insertBefore("sass", "atrule", {
            // We want to consume the whole line
            "atrule-line": {
              // Includes support for = and + shortcuts
              pattern: /^(?:[ \t]*)[@+=].+/m,
              greedy: true,
              inside: {
                atrule: /(?:@[\w-]+|[+=])/
              }
            }
          });
          delete Prism3.languages.sass.atrule;
          var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
          var operator = [
            /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
            {
              pattern: /(\s)-(?=\s)/,
              lookbehind: true
            }
          ];
          Prism3.languages.insertBefore("sass", "property", {
            // We want to consume the whole line
            "variable-line": {
              pattern: /^[ \t]*\$.+/m,
              greedy: true,
              inside: {
                punctuation: /:/,
                variable,
                operator
              }
            },
            // We want to consume the whole line
            "property-line": {
              pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
              greedy: true,
              inside: {
                property: [
                  /[^:\s]+(?=\s*:)/,
                  {
                    pattern: /(:)[^:\s]+/,
                    lookbehind: true
                  }
                ],
                punctuation: /:/,
                variable,
                operator,
                important: Prism3.languages.sass.important
              }
            }
          });
          delete Prism3.languages.sass.property;
          delete Prism3.languages.sass.important;
          Prism3.languages.insertBefore("sass", "punctuation", {
            selector: {
              pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
              lookbehind: true,
              greedy: true
            }
          });
        })(Prism2);
      }
      return sass_1;
    }
    var scala_1;
    var hasRequiredScala;
    function requireScala() {
      if (hasRequiredScala)
        return scala_1;
      hasRequiredScala = 1;
      var refractorJava = requireJava();
      scala_1 = scala;
      scala.displayName = "scala";
      scala.aliases = [];
      function scala(Prism2) {
        Prism2.register(refractorJava);
        Prism2.languages.scala = Prism2.languages.extend("java", {
          "triple-quoted-string": {
            pattern: /"""[\s\S]*?"""/,
            greedy: true,
            alias: "string"
          },
          string: {
            pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          keyword: /<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,
          number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
          builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
          symbol: /'[^\d\s\\]\w*/
        });
        Prism2.languages.insertBefore("scala", "triple-quoted-string", {
          "string-interpolation": {
            pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
            greedy: true,
            inside: {
              id: {
                pattern: /^\w+/,
                greedy: true,
                alias: "function"
              },
              escape: {
                pattern: /\\\$"|\$[$"]/,
                greedy: true,
                alias: "symbol"
              },
              interpolation: {
                pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
                greedy: true,
                inside: {
                  punctuation: /^\$\{?|\}$/,
                  expression: {
                    pattern: /[\s\S]+/,
                    inside: Prism2.languages.scala
                  }
                }
              },
              string: /[\s\S]+/
            }
          }
        });
        delete Prism2.languages.scala["class-name"];
        delete Prism2.languages.scala["function"];
      }
      return scala_1;
    }
    var scss_1;
    var hasRequiredScss;
    function requireScss() {
      if (hasRequiredScss)
        return scss_1;
      hasRequiredScss = 1;
      scss_1 = scss;
      scss.displayName = "scss";
      scss.aliases = [];
      function scss(Prism2) {
        Prism2.languages.scss = Prism2.languages.extend("css", {
          comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
            lookbehind: true
          },
          atrule: {
            pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
            inside: {
              rule: /@[\w-]+/
              // See rest below
            }
          },
          // url, compassified
          url: /(?:[-a-z]+-)?url(?=\()/i,
          // CSS selector regex is not appropriate for Sass
          // since there can be lot more things (var, @ directive, nesting..)
          // a selector must start at the end of a property or after a brace (end of other rules or nesting)
          // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
          // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
          // can "pass" as a selector- e.g: proper#{$erty})
          // this one was hard to do, so please be careful if you edit this one :)
          selector: {
            // Initial look-ahead is used to prevent matching of blank selectors
            pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
            inside: {
              parent: {
                pattern: /&/,
                alias: "important"
              },
              placeholder: /%[-\w]+/,
              variable: /\$[-\w]+|#\{\$[-\w]+\}/
            }
          },
          property: {
            pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
            inside: {
              variable: /\$[-\w]+|#\{\$[-\w]+\}/
            }
          }
        });
        Prism2.languages.insertBefore("scss", "atrule", {
          keyword: [
            /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
            {
              pattern: /( )(?:from|through)(?= )/,
              lookbehind: true
            }
          ]
        });
        Prism2.languages.insertBefore("scss", "important", {
          // var and interpolated vars
          variable: /\$[-\w]+|#\{\$[-\w]+\}/
        });
        Prism2.languages.insertBefore("scss", "function", {
          "module-modifier": {
            pattern: /\b(?:as|hide|show|with)\b/i,
            alias: "keyword"
          },
          placeholder: {
            pattern: /%[-\w]+/,
            alias: "selector"
          },
          statement: {
            pattern: /\B!(?:default|optional)\b/i,
            alias: "keyword"
          },
          boolean: /\b(?:false|true)\b/,
          null: {
            pattern: /\bnull\b/,
            alias: "keyword"
          },
          operator: {
            pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
            lookbehind: true
          }
        });
        Prism2.languages.scss["atrule"].inside.rest = Prism2.languages.scss;
      }
      return scss_1;
    }
    var shellSession_1;
    var hasRequiredShellSession;
    function requireShellSession() {
      if (hasRequiredShellSession)
        return shellSession_1;
      hasRequiredShellSession = 1;
      var refractorBash = requireBash();
      shellSession_1 = shellSession;
      shellSession.displayName = "shellSession";
      shellSession.aliases = [];
      function shellSession(Prism2) {
        Prism2.register(refractorBash);
        (function(Prism3) {
          var strings = [
            // normal string
            /"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
            /'[^']*'/.source,
            /\$'(?:[^'\\]|\\[\s\S])*'/.source,
            // here doc
            // 2 capturing groups
            /<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
          ].join("|");
          Prism3.languages["shell-session"] = {
            command: {
              pattern: RegExp(
                // user info
                /^/.source + "(?:" + // <user> ":" ( <path> )?
                (/[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/.source + "|" + // <path>
                // Since the path pattern is quite general, we will require it to start with a special character to
                // prevent false positives.
                /[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source) + ")?" + // shell symbol
                /[$#%](?=\s)/.source + // bash command
                /(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(
                  /<<str>>/g,
                  function() {
                    return strings;
                  }
                ),
                "m"
              ),
              greedy: true,
              inside: {
                info: {
                  // foo@bar:~/files$ exit
                  // foo@bar$ exit
                  // ~/files$ exit
                  pattern: /^[^#$%]+/,
                  alias: "punctuation",
                  inside: {
                    user: /^[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+/,
                    punctuation: /:/,
                    path: /[\s\S]+/
                  }
                },
                bash: {
                  pattern: /(^[$#%]\s*)\S[\s\S]*/,
                  lookbehind: true,
                  alias: "language-bash",
                  inside: Prism3.languages.bash
                },
                "shell-symbol": {
                  pattern: /^[$#%]/,
                  alias: "important"
                }
              }
            },
            output: /.(?:.*(?:[\r\n]|.$))*/
          };
          Prism3.languages["sh-session"] = Prism3.languages["shellsession"] = Prism3.languages["shell-session"];
        })(Prism2);
      }
      return shellSession_1;
    }
    var smali_1;
    var hasRequiredSmali;
    function requireSmali() {
      if (hasRequiredSmali)
        return smali_1;
      hasRequiredSmali = 1;
      smali_1 = smali;
      smali.displayName = "smali";
      smali.aliases = [];
      function smali(Prism2) {
        Prism2.languages.smali = {
          comment: /#.*/,
          string: {
            pattern: /"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\(?:.|u[\da-fA-F]{4}))'/,
            greedy: true
          },
          "class-name": {
            pattern: /(^|[^L])L(?:(?:\w+|`[^`\r\n]*`)\/)*(?:[\w$]+|`[^`\r\n]*`)(?=\s*;)/,
            lookbehind: true,
            inside: {
              "class-name": {
                pattern: /(^L|\/)(?:[\w$]+|`[^`\r\n]*`)$/,
                lookbehind: true
              },
              namespace: {
                pattern: /^(L)(?:(?:\w+|`[^`\r\n]*`)\/)+/,
                lookbehind: true,
                inside: {
                  punctuation: /\//
                }
              },
              builtin: /^L/
            }
          },
          builtin: [
            {
              // Reference: https://github.com/JesusFreke/smali/wiki/TypesMethodsAndFields#types
              pattern: /([();\[])[BCDFIJSVZ]+/,
              lookbehind: true
            },
            {
              // e.g. .field mWifiOnUid:I
              pattern: /([\w$>]:)[BCDFIJSVZ]/,
              lookbehind: true
            }
          ],
          keyword: [
            {
              pattern: /(\.end\s+)[\w-]+/,
              lookbehind: true
            },
            {
              pattern: /(^|[^\w.-])\.(?!\d)[\w-]+/,
              lookbehind: true
            },
            {
              pattern: /(^|[^\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\w.-])/,
              lookbehind: true
            }
          ],
          function: {
            pattern: /(^|[^\w.-])(?:\w+|<[\w$-]+>)(?=\()/,
            lookbehind: true
          },
          field: {
            pattern: /[\w$]+(?=:)/,
            alias: "variable"
          },
          register: {
            pattern: /(^|[^\w.-])[vp]\d(?![\w.-])/,
            lookbehind: true,
            alias: "variable"
          },
          boolean: {
            pattern: /(^|[^\w.-])(?:false|true)(?![\w.-])/,
            lookbehind: true
          },
          number: {
            pattern: /(^|[^/\w.-])-?(?:NAN|INFINITY|0x(?:[\dA-F]+(?:\.[\dA-F]*)?|\.[\dA-F]+)(?:p[+-]?[\dA-F]+)?|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)[dflst]?(?![\w.-])/i,
            lookbehind: true
          },
          label: {
            pattern: /(:)\w+/,
            lookbehind: true,
            alias: "property"
          },
          operator: /->|\.\.|[\[=]/,
          punctuation: /[{}(),;:]/
        };
      }
      return smali_1;
    }
    var smalltalk_1;
    var hasRequiredSmalltalk;
    function requireSmalltalk() {
      if (hasRequiredSmalltalk)
        return smalltalk_1;
      hasRequiredSmalltalk = 1;
      smalltalk_1 = smalltalk;
      smalltalk.displayName = "smalltalk";
      smalltalk.aliases = [];
      function smalltalk(Prism2) {
        Prism2.languages.smalltalk = {
          comment: {
            pattern: /"(?:""|[^"])*"/,
            greedy: true
          },
          char: {
            pattern: /\$./,
            greedy: true
          },
          string: {
            pattern: /'(?:''|[^'])*'/,
            greedy: true
          },
          symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
          "block-arguments": {
            pattern: /(\[\s*):[^\[|]*\|/,
            lookbehind: true,
            inside: {
              variable: /:[\da-z]+/i,
              punctuation: /\|/
            }
          },
          "temporary-variables": {
            pattern: /\|[^|]+\|/,
            inside: {
              variable: /[\da-z]+/i,
              punctuation: /\|/
            }
          },
          keyword: /\b(?:new|nil|self|super)\b/,
          boolean: /\b(?:false|true)\b/,
          number: [
            /\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/,
            /\b\d+(?:\.\d+)?(?:e-?\d+)?/
          ],
          operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
          punctuation: /[.;:?\[\](){}]/
        };
      }
      return smalltalk_1;
    }
    var smarty_1;
    var hasRequiredSmarty;
    function requireSmarty() {
      if (hasRequiredSmarty)
        return smarty_1;
      hasRequiredSmarty = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      smarty_1 = smarty;
      smarty.displayName = "smarty";
      smarty.aliases = [];
      function smarty(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        (function(Prism3) {
          Prism3.languages.smarty = {
            comment: {
              pattern: /^\{\*[\s\S]*?\*\}/,
              greedy: true
            },
            "embedded-php": {
              pattern: /^\{php\}[\s\S]*?\{\/php\}/,
              greedy: true,
              inside: {
                smarty: {
                  pattern: /^\{php\}|\{\/php\}$/,
                  inside: null
                  // see below
                },
                php: {
                  pattern: /[\s\S]+/,
                  alias: "language-php",
                  inside: Prism3.languages.php
                }
              }
            },
            string: [
              {
                pattern: /"(?:\\.|[^"\\\r\n])*"/,
                greedy: true,
                inside: {
                  interpolation: {
                    pattern: /\{[^{}]*\}|`[^`]*`/,
                    inside: {
                      "interpolation-punctuation": {
                        pattern: /^[{`]|[`}]$/,
                        alias: "punctuation"
                      },
                      expression: {
                        pattern: /[\s\S]+/,
                        inside: null
                        // see below
                      }
                    }
                  },
                  variable: /\$\w+/
                }
              },
              {
                pattern: /'(?:\\.|[^'\\\r\n])*'/,
                greedy: true
              }
            ],
            keyword: {
              pattern: /(^\{\/?)[a-z_]\w*\b(?!\()/i,
              lookbehind: true,
              greedy: true
            },
            delimiter: {
              pattern: /^\{\/?|\}$/,
              greedy: true,
              alias: "punctuation"
            },
            number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
            variable: [
              /\$(?!\d)\w+/,
              /#(?!\d)\w+#/,
              {
                pattern: /(\.|->|\w\s*=)(?!\d)\w+\b(?!\()/,
                lookbehind: true
              },
              {
                pattern: /(\[)(?!\d)\w+(?=\])/,
                lookbehind: true
              }
            ],
            function: {
              pattern: /(\|\s*)@?[a-z_]\w*|\b[a-z_]\w*(?=\()/i,
              lookbehind: true
            },
            "attr-name": /\b[a-z_]\w*(?=\s*=)/i,
            boolean: /\b(?:false|no|off|on|true|yes)\b/,
            punctuation: /[\[\](){}.,:`]|->/,
            operator: [
              /[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
              /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
              /\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/
            ]
          };
          Prism3.languages.smarty["embedded-php"].inside.smarty.inside = Prism3.languages.smarty;
          Prism3.languages.smarty.string[0].inside.interpolation.inside.expression.inside = Prism3.languages.smarty;
          var string2 = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/;
          var smartyPattern = RegExp(
            // comments
            /\{\*[\s\S]*?\*\}/.source + "|" + // php tags
            /\{php\}[\s\S]*?\{\/php\}/.source + "|" + // smarty blocks
            /\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source.replace(
              /<str>/g,
              function() {
                return string2.source;
              }
            ),
            "g"
          );
          Prism3.hooks.add("before-tokenize", function(env2) {
            var smartyLiteralStart = "{literal}";
            var smartyLiteralEnd = "{/literal}";
            var smartyLiteralMode = false;
            Prism3.languages["markup-templating"].buildPlaceholders(
              env2,
              "smarty",
              smartyPattern,
              function(match) {
                if (match === smartyLiteralEnd) {
                  smartyLiteralMode = false;
                }
                if (!smartyLiteralMode) {
                  if (match === smartyLiteralStart) {
                    smartyLiteralMode = true;
                  }
                  return true;
                }
                return false;
              }
            );
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            Prism3.languages["markup-templating"].tokenizePlaceholders(env2, "smarty");
          });
        })(Prism2);
      }
      return smarty_1;
    }
    var sml_1;
    var hasRequiredSml;
    function requireSml() {
      if (hasRequiredSml)
        return sml_1;
      hasRequiredSml = 1;
      sml_1 = sml;
      sml.displayName = "sml";
      sml.aliases = ["smlnj"];
      function sml(Prism2) {
        (function(Prism3) {
          var keywords = /\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
          Prism3.languages.sml = {
            // allow one level of nesting
            comment: /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
            string: {
              pattern: /#?"(?:[^"\\]|\\.)*"/,
              greedy: true
            },
            "class-name": [
              {
                // This is only an approximation since the real grammar is context-free
                //
                // Why the main loop so complex?
                // The main loop is approximately the same as /(?:\s*(?:[*,]|->)\s*<TERMINAL>)*/ which is, obviously, a lot
                // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be
                // followed by a long identifier.
                pattern: RegExp(
                  /((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function() {
                    return /\s*(?:[*,]|->)/.source;
                  }).replace(/<TERMINAL>/g, function() {
                    return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/.source;
                  }).replace(/<LONG-ID>/g, function() {
                    return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source;
                  }).replace(/<KEYWORD>/g, function() {
                    return keywords.source;
                  }),
                  "i"
                ),
                lookbehind: true,
                greedy: true,
                inside: null
                // see below
              },
              {
                pattern: /((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
                lookbehind: true
              }
            ],
            function: {
              pattern: /((?:^|[^\w'])fun\s+)[a-z_][\w'.]*/i,
              lookbehind: true
            },
            keyword: keywords,
            variable: {
              pattern: /(^|[^\w'])'[\w']*/,
              lookbehind: true
            },
            number: /~?\b(?:\d+(?:\.\d+)?(?:e~?\d+)?|0x[\da-f]+)\b/i,
            word: {
              pattern: /\b0w(?:\d+|x[\da-f]+)\b/i,
              alias: "constant"
            },
            boolean: /\b(?:false|true)\b/i,
            operator: /\.\.\.|:[>=:]|=>?|->|[<>]=?|[!+\-*/^#|@~]/,
            punctuation: /[(){}\[\].:,;]/
          };
          Prism3.languages.sml["class-name"][0].inside = Prism3.languages.sml;
          Prism3.languages.smlnj = Prism3.languages.sml;
        })(Prism2);
      }
      return sml_1;
    }
    var solidity_1;
    var hasRequiredSolidity;
    function requireSolidity() {
      if (hasRequiredSolidity)
        return solidity_1;
      hasRequiredSolidity = 1;
      solidity_1 = solidity;
      solidity.displayName = "solidity";
      solidity.aliases = ["sol"];
      function solidity(Prism2) {
        Prism2.languages.solidity = Prism2.languages.extend("clike", {
          "class-name": {
            pattern: /(\b(?:contract|enum|interface|library|new|struct|using)\s+)(?!\d)[\w$]+/,
            lookbehind: true
          },
          keyword: /\b(?:_|anonymous|as|assembly|assert|break|calldata|case|constant|constructor|continue|contract|default|delete|do|else|emit|enum|event|external|for|from|function|if|import|indexed|inherited|interface|internal|is|let|library|mapping|memory|modifier|new|payable|pragma|private|public|pure|require|returns?|revert|selfdestruct|solidity|storage|struct|suicide|switch|this|throw|using|var|view|while)\b/,
          operator: /=>|->|:=|=:|\*\*|\+\+|--|\|\||&&|<<=?|>>=?|[-+*/%^&|<>!=]=?|[~?]/
        });
        Prism2.languages.insertBefore("solidity", "keyword", {
          builtin: /\b(?:address|bool|byte|u?int(?:8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?|string|bytes(?:[1-9]|[12]\d|3[0-2])?)\b/
        });
        Prism2.languages.insertBefore("solidity", "number", {
          version: {
            pattern: /([<>]=?|\^)\d+\.\d+\.\d+\b/,
            lookbehind: true,
            alias: "number"
          }
        });
        Prism2.languages.sol = Prism2.languages.solidity;
      }
      return solidity_1;
    }
    var solutionFile_1;
    var hasRequiredSolutionFile;
    function requireSolutionFile() {
      if (hasRequiredSolutionFile)
        return solutionFile_1;
      hasRequiredSolutionFile = 1;
      solutionFile_1 = solutionFile;
      solutionFile.displayName = "solutionFile";
      solutionFile.aliases = [];
      function solutionFile(Prism2) {
        (function(Prism3) {
          var guid = {
            // https://en.wikipedia.org/wiki/Universally_unique_identifier#Format
            pattern: /\{[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}\}/i,
            alias: "constant",
            inside: {
              punctuation: /[{}]/
            }
          };
          Prism3.languages["solution-file"] = {
            comment: {
              pattern: /#.*/,
              greedy: true
            },
            string: {
              pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
              greedy: true,
              inside: {
                guid
              }
            },
            object: {
              // Foo
              //   Bar("abs") = 9
              //   EndBar
              //   Prop = TRUE
              // EndFoo
              pattern: /^([ \t]*)(?:([A-Z]\w*)\b(?=.*(?:\r\n?|\n)(?:\1[ \t].*(?:\r\n?|\n))*\1End\2(?=[ \t]*$))|End[A-Z]\w*(?=[ \t]*$))/m,
              lookbehind: true,
              greedy: true,
              alias: "keyword"
            },
            property: {
              pattern: /^([ \t]*)(?!\s)[^\r\n"#=()]*[^\s"#=()](?=\s*=)/m,
              lookbehind: true,
              inside: {
                guid
              }
            },
            guid,
            number: /\b\d+(?:\.\d+)*\b/,
            boolean: /\b(?:FALSE|TRUE)\b/,
            operator: /=/,
            punctuation: /[(),]/
          };
          Prism3.languages["sln"] = Prism3.languages["solution-file"];
        })(Prism2);
      }
      return solutionFile_1;
    }
    var soy_1;
    var hasRequiredSoy;
    function requireSoy() {
      if (hasRequiredSoy)
        return soy_1;
      hasRequiredSoy = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      soy_1 = soy;
      soy.displayName = "soy";
      soy.aliases = [];
      function soy(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        (function(Prism3) {
          var stringPattern = /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
          var numberPattern = /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-F]+\b/;
          Prism3.languages.soy = {
            comment: [
              /\/\*[\s\S]*?\*\//,
              {
                pattern: /(\s)\/\/.*/,
                lookbehind: true,
                greedy: true
              }
            ],
            "command-arg": {
              pattern: /(\{+\/?\s*(?:alias|call|delcall|delpackage|deltemplate|namespace|template)\s+)\.?[\w.]+/,
              lookbehind: true,
              alias: "string",
              inside: {
                punctuation: /\./
              }
            },
            parameter: {
              pattern: /(\{+\/?\s*@?param\??\s+)\.?[\w.]+/,
              lookbehind: true,
              alias: "variable"
            },
            keyword: [
              {
                pattern: /(\{+\/?[^\S\r\n]*)(?:\\[nrt]|alias|call|case|css|default|delcall|delpackage|deltemplate|else(?:if)?|fallbackmsg|for(?:each)?|if(?:empty)?|lb|let|literal|msg|namespace|nil|@?param\??|rb|sp|switch|template|xid)/,
                lookbehind: true
              },
              /\b(?:any|as|attributes|bool|css|float|html|in|int|js|list|map|null|number|string|uri)\b/
            ],
            delimiter: {
              pattern: /^\{+\/?|\/?\}+$/,
              alias: "punctuation"
            },
            property: /\w+(?==)/,
            variable: {
              pattern: /\$[^\W\d]\w*(?:\??(?:\.\w+|\[[^\]]+\]))*/,
              inside: {
                string: {
                  pattern: stringPattern,
                  greedy: true
                },
                number: numberPattern,
                punctuation: /[\[\].?]/
              }
            },
            string: {
              pattern: stringPattern,
              greedy: true
            },
            function: [
              /\w+(?=\()/,
              {
                pattern: /(\|[^\S\r\n]*)\w+/,
                lookbehind: true
              }
            ],
            boolean: /\b(?:false|true)\b/,
            number: numberPattern,
            operator: /\?:?|<=?|>=?|==?|!=|[+*/%-]|\b(?:and|not|or)\b/,
            punctuation: /[{}()\[\]|.,:]/
          };
          Prism3.hooks.add("before-tokenize", function(env2) {
            var soyPattern = /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g;
            var soyLitteralStart = "{literal}";
            var soyLitteralEnd = "{/literal}";
            var soyLitteralMode = false;
            Prism3.languages["markup-templating"].buildPlaceholders(
              env2,
              "soy",
              soyPattern,
              function(match) {
                if (match === soyLitteralEnd) {
                  soyLitteralMode = false;
                }
                if (!soyLitteralMode) {
                  if (match === soyLitteralStart) {
                    soyLitteralMode = true;
                  }
                  return true;
                }
                return false;
              }
            );
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            Prism3.languages["markup-templating"].tokenizePlaceholders(env2, "soy");
          });
        })(Prism2);
      }
      return soy_1;
    }
    var turtle_1;
    var hasRequiredTurtle;
    function requireTurtle() {
      if (hasRequiredTurtle)
        return turtle_1;
      hasRequiredTurtle = 1;
      turtle_1 = turtle;
      turtle.displayName = "turtle";
      turtle.aliases = [];
      function turtle(Prism2) {
        Prism2.languages.turtle = {
          comment: {
            pattern: /#.*/,
            greedy: true
          },
          "multiline-string": {
            pattern: /"""(?:(?:""?)?(?:[^"\\]|\\.))*"""|'''(?:(?:''?)?(?:[^'\\]|\\.))*'''/,
            greedy: true,
            alias: "string",
            inside: {
              comment: /#.*/
            }
          },
          string: {
            pattern: /"(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*'/,
            greedy: true
          },
          url: {
            pattern: /<(?:[^\x00-\x20<>"{}|^`\\]|\\(?:u[\da-fA-F]{4}|U[\da-fA-F]{8}))*>/,
            greedy: true,
            inside: {
              punctuation: /[<>]/
            }
          },
          function: {
            pattern: /(?:(?![-.\d\xB7])[-.\w\xB7\xC0-\uFFFD]+)?:(?:(?![-.])(?:[-.:\w\xC0-\uFFFD]|%[\da-f]{2}|\\.)+)?/i,
            inside: {
              "local-name": {
                pattern: /([^:]*:)[\s\S]+/,
                lookbehind: true
              },
              prefix: {
                pattern: /[\s\S]+/,
                inside: {
                  punctuation: /:/
                }
              }
            }
          },
          number: /[+-]?\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
          punctuation: /[{}.,;()[\]]|\^\^/,
          boolean: /\b(?:false|true)\b/,
          keyword: [/(?:\ba|@prefix|@base)\b|=/, /\b(?:base|graph|prefix)\b/i],
          tag: {
            pattern: /@[a-z]+(?:-[a-z\d]+)*/i,
            inside: {
              punctuation: /@/
            }
          }
        };
        Prism2.languages.trig = Prism2.languages["turtle"];
      }
      return turtle_1;
    }
    var sparql_1;
    var hasRequiredSparql;
    function requireSparql() {
      if (hasRequiredSparql)
        return sparql_1;
      hasRequiredSparql = 1;
      var refractorTurtle = requireTurtle();
      sparql_1 = sparql;
      sparql.displayName = "sparql";
      sparql.aliases = ["rq"];
      function sparql(Prism2) {
        Prism2.register(refractorTurtle);
        Prism2.languages.sparql = Prism2.languages.extend("turtle", {
          boolean: /\b(?:false|true)\b/i,
          variable: {
            pattern: /[?$]\w+/,
            greedy: true
          }
        });
        Prism2.languages.insertBefore("sparql", "punctuation", {
          keyword: [
            /\b(?:A|ADD|ALL|AS|ASC|ASK|BNODE|BY|CLEAR|CONSTRUCT|COPY|CREATE|DATA|DEFAULT|DELETE|DESC|DESCRIBE|DISTINCT|DROP|EXISTS|FILTER|FROM|GROUP|HAVING|INSERT|INTO|LIMIT|LOAD|MINUS|MOVE|NAMED|NOT|NOW|OFFSET|OPTIONAL|ORDER|RAND|REDUCED|SELECT|SEPARATOR|SERVICE|SILENT|STRUUID|UNION|USING|UUID|VALUES|WHERE)\b/i,
            /\b(?:ABS|AVG|BIND|BOUND|CEIL|COALESCE|CONCAT|CONTAINS|COUNT|DATATYPE|DAY|ENCODE_FOR_URI|FLOOR|GROUP_CONCAT|HOURS|IF|IRI|isBLANK|isIRI|isLITERAL|isNUMERIC|isURI|LANG|LANGMATCHES|LCASE|MAX|MD5|MIN|MINUTES|MONTH|REGEX|REPLACE|ROUND|sameTerm|SAMPLE|SECONDS|SHA1|SHA256|SHA384|SHA512|STR|STRAFTER|STRBEFORE|STRDT|STRENDS|STRLANG|STRLEN|STRSTARTS|SUBSTR|SUM|TIMEZONE|TZ|UCASE|URI|YEAR)\b(?=\s*\()/i,
            /\b(?:BASE|GRAPH|PREFIX)\b/i
          ]
        });
        Prism2.languages.rq = Prism2.languages.sparql;
      }
      return sparql_1;
    }
    var splunkSpl_1;
    var hasRequiredSplunkSpl;
    function requireSplunkSpl() {
      if (hasRequiredSplunkSpl)
        return splunkSpl_1;
      hasRequiredSplunkSpl = 1;
      splunkSpl_1 = splunkSpl;
      splunkSpl.displayName = "splunkSpl";
      splunkSpl.aliases = [];
      function splunkSpl(Prism2) {
        Prism2.languages["splunk-spl"] = {
          comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
          string: {
            pattern: /"(?:\\.|[^\\"])*"/,
            greedy: true
          },
          // https://docs.splunk.com/Documentation/Splunk/7.3.0/SearchReference/ListOfSearchCommands
          keyword: /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
          "operator-word": {
            pattern: /\b(?:and|as|by|not|or|xor)\b/i,
            alias: "operator"
          },
          function: /\b\w+(?=\s*\()/,
          property: /\b\w+(?=\s*=(?!=))/,
          date: {
            // MM/DD/YYYY(:HH:MM:SS)?
            pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
            alias: "number"
          },
          number: /\b\d+(?:\.\d+)?\b/,
          boolean: /\b(?:f|false|t|true)\b/i,
          operator: /[<>=]=?|[-+*/%|]/,
          punctuation: /[()[\],]/
        };
      }
      return splunkSpl_1;
    }
    var sqf_1;
    var hasRequiredSqf;
    function requireSqf() {
      if (hasRequiredSqf)
        return sqf_1;
      hasRequiredSqf = 1;
      sqf_1 = sqf;
      sqf.displayName = "sqf";
      sqf.aliases = [];
      function sqf(Prism2) {
        Prism2.languages.sqf = Prism2.languages.extend("clike", {
          string: {
            pattern: /"(?:(?:"")?[^"])*"(?!")|'(?:[^'])*'/,
            greedy: true
          },
          keyword: /\b(?:breakOut|breakTo|call|case|catch|default|do|echo|else|execFSM|execVM|exitWith|for|forEach|forEachMember|forEachMemberAgent|forEachMemberTeam|from|goto|if|nil|preprocessFile|preprocessFileLineNumbers|private|scopeName|spawn|step|switch|then|throw|to|try|while|with)\b/i,
          boolean: /\b(?:false|true)\b/i,
          function: /\b(?:abs|accTime|acos|action|actionIDs|actionKeys|actionKeysImages|actionKeysNames|actionKeysNamesArray|actionName|actionParams|activateAddons|activatedAddons|activateKey|add3DENConnection|add3DENEventHandler|add3DENLayer|addAction|addBackpack|addBackpackCargo|addBackpackCargoGlobal|addBackpackGlobal|addCamShake|addCuratorAddons|addCuratorCameraArea|addCuratorEditableObjects|addCuratorEditingArea|addCuratorPoints|addEditorObject|addEventHandler|addForce|addForceGeneratorRTD|addGoggles|addGroupIcon|addHandgunItem|addHeadgear|addItem|addItemCargo|addItemCargoGlobal|addItemPool|addItemToBackpack|addItemToUniform|addItemToVest|addLiveStats|addMagazine|addMagazineAmmoCargo|addMagazineCargo|addMagazineCargoGlobal|addMagazineGlobal|addMagazinePool|addMagazines|addMagazineTurret|addMenu|addMenuItem|addMissionEventHandler|addMPEventHandler|addMusicEventHandler|addOwnedMine|addPlayerScores|addPrimaryWeaponItem|addPublicVariableEventHandler|addRating|addResources|addScore|addScoreSide|addSecondaryWeaponItem|addSwitchableUnit|addTeamMember|addToRemainsCollector|addTorque|addUniform|addVehicle|addVest|addWaypoint|addWeapon|addWeaponCargo|addWeaponCargoGlobal|addWeaponGlobal|addWeaponItem|addWeaponPool|addWeaponTurret|admin|agent|agents|AGLToASL|aimedAtTarget|aimPos|airDensityCurveRTD|airDensityRTD|airplaneThrottle|airportSide|AISFinishHeal|alive|all3DENEntities|allAirports|allControls|allCurators|allCutLayers|allDead|allDeadMen|allDisplays|allGroups|allMapMarkers|allMines|allMissionObjects|allow3DMode|allowCrewInImmobile|allowCuratorLogicIgnoreAreas|allowDamage|allowDammage|allowFileOperations|allowFleeing|allowGetIn|allowSprint|allPlayers|allSimpleObjects|allSites|allTurrets|allUnits|allUnitsUAV|allVariables|ammo|ammoOnPylon|animate|animateBay|animateDoor|animatePylon|animateSource|animationNames|animationPhase|animationSourcePhase|animationState|append|apply|armoryPoints|arrayIntersect|asin|ASLToAGL|ASLToATL|assert|assignAsCargo|assignAsCargoIndex|assignAsCommander|assignAsDriver|assignAsGunner|assignAsTurret|assignCurator|assignedCargo|assignedCommander|assignedDriver|assignedGunner|assignedItems|assignedTarget|assignedTeam|assignedVehicle|assignedVehicleRole|assignItem|assignTeam|assignToAirport|atan|atan2|atg|ATLToASL|attachedObject|attachedObjects|attachedTo|attachObject|attachTo|attackEnabled|backpack|backpackCargo|backpackContainer|backpackItems|backpackMagazines|backpackSpaceFor|behaviour|benchmark|binocular|blufor|boundingBox|boundingBoxReal|boundingCenter|briefingName|buildingExit|buildingPos|buldozer_EnableRoadDiag|buldozer_IsEnabledRoadDiag|buldozer_LoadNewRoads|buldozer_reloadOperMap|buttonAction|buttonSetAction|cadetMode|callExtension|camCommand|camCommit|camCommitPrepared|camCommitted|camConstuctionSetParams|camCreate|camDestroy|cameraEffect|cameraEffectEnableHUD|cameraInterest|cameraOn|cameraView|campaignConfigFile|camPreload|camPreloaded|camPrepareBank|camPrepareDir|camPrepareDive|camPrepareFocus|camPrepareFov|camPrepareFovRange|camPreparePos|camPrepareRelPos|camPrepareTarget|camSetBank|camSetDir|camSetDive|camSetFocus|camSetFov|camSetFovRange|camSetPos|camSetRelPos|camSetTarget|camTarget|camUseNVG|canAdd|canAddItemToBackpack|canAddItemToUniform|canAddItemToVest|cancelSimpleTaskDestination|canFire|canMove|canSlingLoad|canStand|canSuspend|canTriggerDynamicSimulation|canUnloadInCombat|canVehicleCargo|captive|captiveNum|cbChecked|cbSetChecked|ceil|channelEnabled|cheatsEnabled|checkAIFeature|checkVisibility|civilian|className|clear3DENAttribute|clear3DENInventory|clearAllItemsFromBackpack|clearBackpackCargo|clearBackpackCargoGlobal|clearForcesRTD|clearGroupIcons|clearItemCargo|clearItemCargoGlobal|clearItemPool|clearMagazineCargo|clearMagazineCargoGlobal|clearMagazinePool|clearOverlay|clearRadio|clearVehicleInit|clearWeaponCargo|clearWeaponCargoGlobal|clearWeaponPool|clientOwner|closeDialog|closeDisplay|closeOverlay|collapseObjectTree|collect3DENHistory|collectiveRTD|combatMode|commandArtilleryFire|commandChat|commander|commandFire|commandFollow|commandFSM|commandGetOut|commandingMenu|commandMove|commandRadio|commandStop|commandSuppressiveFire|commandTarget|commandWatch|comment|commitOverlay|compile|compileFinal|completedFSM|composeText|configClasses|configFile|configHierarchy|configName|configNull|configProperties|configSourceAddonList|configSourceMod|configSourceModList|confirmSensorTarget|connectTerminalToUAV|controlNull|controlsGroupCtrl|copyFromClipboard|copyToClipboard|copyWaypoints|cos|count|countEnemy|countFriendly|countSide|countType|countUnknown|create3DENComposition|create3DENEntity|createAgent|createCenter|createDialog|createDiaryLink|createDiaryRecord|createDiarySubject|createDisplay|createGearDialog|createGroup|createGuardedPoint|createLocation|createMarker|createMarkerLocal|createMenu|createMine|createMissionDisplay|createMPCampaignDisplay|createSimpleObject|createSimpleTask|createSite|createSoundSource|createTask|createTeam|createTrigger|createUnit|createVehicle|createVehicleCrew|createVehicleLocal|crew|ctAddHeader|ctAddRow|ctClear|ctCurSel|ctData|ctFindHeaderRows|ctFindRowHeader|ctHeaderControls|ctHeaderCount|ctRemoveHeaders|ctRemoveRows|ctrlActivate|ctrlAddEventHandler|ctrlAngle|ctrlAutoScrollDelay|ctrlAutoScrollRewind|ctrlAutoScrollSpeed|ctrlChecked|ctrlClassName|ctrlCommit|ctrlCommitted|ctrlCreate|ctrlDelete|ctrlEnable|ctrlEnabled|ctrlFade|ctrlHTMLLoaded|ctrlIDC|ctrlIDD|ctrlMapAnimAdd|ctrlMapAnimClear|ctrlMapAnimCommit|ctrlMapAnimDone|ctrlMapCursor|ctrlMapMouseOver|ctrlMapScale|ctrlMapScreenToWorld|ctrlMapWorldToScreen|ctrlModel|ctrlModelDirAndUp|ctrlModelScale|ctrlParent|ctrlParentControlsGroup|ctrlPosition|ctrlRemoveAllEventHandlers|ctrlRemoveEventHandler|ctrlScale|ctrlSetActiveColor|ctrlSetAngle|ctrlSetAutoScrollDelay|ctrlSetAutoScrollRewind|ctrlSetAutoScrollSpeed|ctrlSetBackgroundColor|ctrlSetChecked|ctrlSetDisabledColor|ctrlSetEventHandler|ctrlSetFade|ctrlSetFocus|ctrlSetFont|ctrlSetFontH1|ctrlSetFontH1B|ctrlSetFontH2|ctrlSetFontH2B|ctrlSetFontH3|ctrlSetFontH3B|ctrlSetFontH4|ctrlSetFontH4B|ctrlSetFontH5|ctrlSetFontH5B|ctrlSetFontH6|ctrlSetFontH6B|ctrlSetFontHeight|ctrlSetFontHeightH1|ctrlSetFontHeightH2|ctrlSetFontHeightH3|ctrlSetFontHeightH4|ctrlSetFontHeightH5|ctrlSetFontHeightH6|ctrlSetFontHeightSecondary|ctrlSetFontP|ctrlSetFontPB|ctrlSetFontSecondary|ctrlSetForegroundColor|ctrlSetModel|ctrlSetModelDirAndUp|ctrlSetModelScale|ctrlSetPixelPrecision|ctrlSetPosition|ctrlSetScale|ctrlSetStructuredText|ctrlSetText|ctrlSetTextColor|ctrlSetTextColorSecondary|ctrlSetTextSecondary|ctrlSetTooltip|ctrlSetTooltipColorBox|ctrlSetTooltipColorShade|ctrlSetTooltipColorText|ctrlShow|ctrlShown|ctrlText|ctrlTextHeight|ctrlTextSecondary|ctrlTextWidth|ctrlType|ctrlVisible|ctRowControls|ctRowCount|ctSetCurSel|ctSetData|ctSetHeaderTemplate|ctSetRowTemplate|ctSetValue|ctValue|curatorAddons|curatorCamera|curatorCameraArea|curatorCameraAreaCeiling|curatorCoef|curatorEditableObjects|curatorEditingArea|curatorEditingAreaType|curatorMouseOver|curatorPoints|curatorRegisteredObjects|curatorSelected|curatorWaypointCost|current3DENOperation|currentChannel|currentCommand|currentMagazine|currentMagazineDetail|currentMagazineDetailTurret|currentMagazineTurret|currentMuzzle|currentNamespace|currentTask|currentTasks|currentThrowable|currentVisionMode|currentWaypoint|currentWeapon|currentWeaponMode|currentWeaponTurret|currentZeroing|cursorObject|cursorTarget|customChat|customRadio|cutFadeOut|cutObj|cutRsc|cutText|damage|date|dateToNumber|daytime|deActivateKey|debriefingText|debugFSM|debugLog|deg|delete3DENEntities|deleteAt|deleteCenter|deleteCollection|deleteEditorObject|deleteGroup|deleteGroupWhenEmpty|deleteIdentity|deleteLocation|deleteMarker|deleteMarkerLocal|deleteRange|deleteResources|deleteSite|deleteStatus|deleteTeam|deleteVehicle|deleteVehicleCrew|deleteWaypoint|detach|detectedMines|diag_activeMissionFSMs|diag_activeScripts|diag_activeSQFScripts|diag_activeSQSScripts|diag_captureFrame|diag_captureFrameToFile|diag_captureSlowFrame|diag_codePerformance|diag_drawMode|diag_dynamicSimulationEnd|diag_enable|diag_enabled|diag_fps|diag_fpsMin|diag_frameNo|diag_lightNewLoad|diag_list|diag_log|diag_logSlowFrame|diag_mergeConfigFile|diag_recordTurretLimits|diag_setLightNew|diag_tickTime|diag_toggle|dialog|diarySubjectExists|didJIP|didJIPOwner|difficulty|difficultyEnabled|difficultyEnabledRTD|difficultyOption|direction|directSay|disableAI|disableCollisionWith|disableConversation|disableDebriefingStats|disableMapIndicators|disableNVGEquipment|disableRemoteSensors|disableSerialization|disableTIEquipment|disableUAVConnectability|disableUserInput|displayAddEventHandler|displayCtrl|displayNull|displayParent|displayRemoveAllEventHandlers|displayRemoveEventHandler|displaySetEventHandler|dissolveTeam|distance|distance2D|distanceSqr|distributionRegion|do3DENAction|doArtilleryFire|doFire|doFollow|doFSM|doGetOut|doMove|doorPhase|doStop|doSuppressiveFire|doTarget|doWatch|drawArrow|drawEllipse|drawIcon|drawIcon3D|drawLine|drawLine3D|drawLink|drawLocation|drawPolygon|drawRectangle|drawTriangle|driver|drop|dynamicSimulationDistance|dynamicSimulationDistanceCoef|dynamicSimulationEnabled|dynamicSimulationSystemEnabled|east|edit3DENMissionAttributes|editObject|editorSetEventHandler|effectiveCommander|emptyPositions|enableAI|enableAIFeature|enableAimPrecision|enableAttack|enableAudioFeature|enableAutoStartUpRTD|enableAutoTrimRTD|enableCamShake|enableCaustics|enableChannel|enableCollisionWith|enableCopilot|enableDebriefingStats|enableDiagLegend|enableDynamicSimulation|enableDynamicSimulationSystem|enableEndDialog|enableEngineArtillery|enableEnvironment|enableFatigue|enableGunLights|enableInfoPanelComponent|enableIRLasers|enableMimics|enablePersonTurret|enableRadio|enableReload|enableRopeAttach|enableSatNormalOnDetail|enableSaving|enableSentences|enableSimulation|enableSimulationGlobal|enableStamina|enableStressDamage|enableTeamSwitch|enableTraffic|enableUAVConnectability|enableUAVWaypoints|enableVehicleCargo|enableVehicleSensor|enableWeaponDisassembly|endl|endLoadingScreen|endMission|engineOn|enginesIsOnRTD|enginesPowerRTD|enginesRpmRTD|enginesTorqueRTD|entities|environmentEnabled|estimatedEndServerTime|estimatedTimeLeft|evalObjectArgument|everyBackpack|everyContainer|exec|execEditorScript|exp|expectedDestination|exportJIPMessages|eyeDirection|eyePos|face|faction|fadeMusic|fadeRadio|fadeSound|fadeSpeech|failMission|fillWeaponsFromPool|find|findCover|findDisplay|findEditorObject|findEmptyPosition|findEmptyPositionReady|findIf|findNearestEnemy|finishMissionInit|finite|fire|fireAtTarget|firstBackpack|flag|flagAnimationPhase|flagOwner|flagSide|flagTexture|fleeing|floor|flyInHeight|flyInHeightASL|fog|fogForecast|fogParams|forceAddUniform|forceAtPositionRTD|forcedMap|forceEnd|forceFlagTexture|forceFollowRoad|forceGeneratorRTD|forceMap|forceRespawn|forceSpeed|forceWalk|forceWeaponFire|forceWeatherChange|forgetTarget|format|formation|formationDirection|formationLeader|formationMembers|formationPosition|formationTask|formatText|formLeader|freeLook|fromEditor|fuel|fullCrew|gearIDCAmmoCount|gearSlotAmmoCount|gearSlotData|get3DENActionState|get3DENAttribute|get3DENCamera|get3DENConnections|get3DENEntity|get3DENEntityID|get3DENGrid|get3DENIconsVisible|get3DENLayerEntities|get3DENLinesVisible|get3DENMissionAttribute|get3DENMouseOver|get3DENSelected|getAimingCoef|getAllEnvSoundControllers|getAllHitPointsDamage|getAllOwnedMines|getAllSoundControllers|getAmmoCargo|getAnimAimPrecision|getAnimSpeedCoef|getArray|getArtilleryAmmo|getArtilleryComputerSettings|getArtilleryETA|getAssignedCuratorLogic|getAssignedCuratorUnit|getBackpackCargo|getBleedingRemaining|getBurningValue|getCameraViewDirection|getCargoIndex|getCenterOfMass|getClientState|getClientStateNumber|getCompatiblePylonMagazines|getConnectedUAV|getContainerMaxLoad|getCursorObjectParams|getCustomAimCoef|getDammage|getDescription|getDir|getDirVisual|getDLCAssetsUsage|getDLCAssetsUsageByName|getDLCs|getDLCUsageTime|getEditorCamera|getEditorMode|getEditorObjectScope|getElevationOffset|getEngineTargetRpmRTD|getEnvSoundController|getFatigue|getFieldManualStartPage|getForcedFlagTexture|getFriend|getFSMVariable|getFuelCargo|getGroupIcon|getGroupIconParams|getGroupIcons|getHideFrom|getHit|getHitIndex|getHitPointDamage|getItemCargo|getMagazineCargo|getMarkerColor|getMarkerPos|getMarkerSize|getMarkerType|getMass|getMissionConfig|getMissionConfigValue|getMissionDLCs|getMissionLayerEntities|getMissionLayers|getModelInfo|getMousePosition|getMusicPlayedTime|getNumber|getObjectArgument|getObjectChildren|getObjectDLC|getObjectMaterials|getObjectProxy|getObjectTextures|getObjectType|getObjectViewDistance|getOxygenRemaining|getPersonUsedDLCs|getPilotCameraDirection|getPilotCameraPosition|getPilotCameraRotation|getPilotCameraTarget|getPlateNumber|getPlayerChannel|getPlayerScores|getPlayerUID|getPlayerUIDOld|getPos|getPosASL|getPosASLVisual|getPosASLW|getPosATL|getPosATLVisual|getPosVisual|getPosWorld|getPylonMagazines|getRelDir|getRelPos|getRemoteSensorsDisabled|getRepairCargo|getResolution|getRotorBrakeRTD|getShadowDistance|getShotParents|getSlingLoad|getSoundController|getSoundControllerResult|getSpeed|getStamina|getStatValue|getSuppression|getTerrainGrid|getTerrainHeightASL|getText|getTotalDLCUsageTime|getTrimOffsetRTD|getUnitLoadout|getUnitTrait|getUserMFDText|getUserMFDValue|getVariable|getVehicleCargo|getWeaponCargo|getWeaponSway|getWingsOrientationRTD|getWingsPositionRTD|getWPPos|glanceAt|globalChat|globalRadio|goggles|group|groupChat|groupFromNetId|groupIconSelectable|groupIconsVisible|groupId|groupOwner|groupRadio|groupSelectedUnits|groupSelectUnit|grpNull|gunner|gusts|halt|handgunItems|handgunMagazine|handgunWeapon|handsHit|hasInterface|hasPilotCamera|hasWeapon|hcAllGroups|hcGroupParams|hcLeader|hcRemoveAllGroups|hcRemoveGroup|hcSelected|hcSelectGroup|hcSetGroup|hcShowBar|hcShownBar|headgear|hideBody|hideObject|hideObjectGlobal|hideSelection|hint|hintC|hintCadet|hintSilent|hmd|hostMission|htmlLoad|HUDMovementLevels|humidity|image|importAllGroups|importance|in|inArea|inAreaArray|incapacitatedState|independent|inflame|inflamed|infoPanel|infoPanelComponentEnabled|infoPanelComponents|infoPanels|inGameUISetEventHandler|inheritsFrom|initAmbientLife|inPolygon|inputAction|inRangeOfArtillery|insertEditorObject|intersect|is3DEN|is3DENMultiplayer|isAbleToBreathe|isAgent|isAimPrecisionEnabled|isArray|isAutoHoverOn|isAutonomous|isAutoStartUpEnabledRTD|isAutotest|isAutoTrimOnRTD|isBleeding|isBurning|isClass|isCollisionLightOn|isCopilotEnabled|isDamageAllowed|isDedicated|isDLCAvailable|isEngineOn|isEqualTo|isEqualType|isEqualTypeAll|isEqualTypeAny|isEqualTypeArray|isEqualTypeParams|isFilePatchingEnabled|isFlashlightOn|isFlatEmpty|isForcedWalk|isFormationLeader|isGroupDeletedWhenEmpty|isHidden|isInRemainsCollector|isInstructorFigureEnabled|isIRLaserOn|isKeyActive|isKindOf|isLaserOn|isLightOn|isLocalized|isManualFire|isMarkedForCollection|isMultiplayer|isMultiplayerSolo|isNil|isNull|isNumber|isObjectHidden|isObjectRTD|isOnRoad|isPipEnabled|isPlayer|isRealTime|isRemoteExecuted|isRemoteExecutedJIP|isServer|isShowing3DIcons|isSimpleObject|isSprintAllowed|isStaminaEnabled|isSteamMission|isStreamFriendlyUIEnabled|isStressDamageEnabled|isText|isTouchingGround|isTurnedOut|isTutHintsEnabled|isUAVConnectable|isUAVConnected|isUIContext|isUniformAllowed|isVehicleCargo|isVehicleRadarOn|isVehicleSensorEnabled|isWalking|isWeaponDeployed|isWeaponRested|itemCargo|items|itemsWithMagazines|join|joinAs|joinAsSilent|joinSilent|joinString|kbAddDatabase|kbAddDatabaseTargets|kbAddTopic|kbHasTopic|kbReact|kbRemoveTopic|kbTell|kbWasSaid|keyImage|keyName|knowsAbout|land|landAt|landResult|language|laserTarget|lbAdd|lbClear|lbColor|lbColorRight|lbCurSel|lbData|lbDelete|lbIsSelected|lbPicture|lbPictureRight|lbSelection|lbSetColor|lbSetColorRight|lbSetCurSel|lbSetData|lbSetPicture|lbSetPictureColor|lbSetPictureColorDisabled|lbSetPictureColorSelected|lbSetPictureRight|lbSetPictureRightColor|lbSetPictureRightColorDisabled|lbSetPictureRightColorSelected|lbSetSelectColor|lbSetSelectColorRight|lbSetSelected|lbSetText|lbSetTextRight|lbSetTooltip|lbSetValue|lbSize|lbSort|lbSortByValue|lbText|lbTextRight|lbValue|leader|leaderboardDeInit|leaderboardGetRows|leaderboardInit|leaderboardRequestRowsFriends|leaderboardRequestRowsGlobal|leaderboardRequestRowsGlobalAroundUser|leaderboardsRequestUploadScore|leaderboardsRequestUploadScoreKeepBest|leaderboardState|leaveVehicle|libraryCredits|libraryDisclaimers|lifeState|lightAttachObject|lightDetachObject|lightIsOn|lightnings|limitSpeed|linearConversion|lineBreak|lineIntersects|lineIntersectsObjs|lineIntersectsSurfaces|lineIntersectsWith|linkItem|list|listObjects|listRemoteTargets|listVehicleSensors|ln|lnbAddArray|lnbAddColumn|lnbAddRow|lnbClear|lnbColor|lnbColorRight|lnbCurSelRow|lnbData|lnbDeleteColumn|lnbDeleteRow|lnbGetColumnsPosition|lnbPicture|lnbPictureRight|lnbSetColor|lnbSetColorRight|lnbSetColumnsPos|lnbSetCurSelRow|lnbSetData|lnbSetPicture|lnbSetPictureColor|lnbSetPictureColorRight|lnbSetPictureColorSelected|lnbSetPictureColorSelectedRight|lnbSetPictureRight|lnbSetText|lnbSetTextRight|lnbSetValue|lnbSize|lnbSort|lnbSortByValue|lnbText|lnbTextRight|lnbValue|load|loadAbs|loadBackpack|loadFile|loadGame|loadIdentity|loadMagazine|loadOverlay|loadStatus|loadUniform|loadVest|local|localize|locationNull|locationPosition|lock|lockCameraTo|lockCargo|lockDriver|locked|lockedCargo|lockedDriver|lockedTurret|lockIdentity|lockTurret|lockWP|log|logEntities|logNetwork|logNetworkTerminate|lookAt|lookAtPos|magazineCargo|magazines|magazinesAllTurrets|magazinesAmmo|magazinesAmmoCargo|magazinesAmmoFull|magazinesDetail|magazinesDetailBackpack|magazinesDetailUniform|magazinesDetailVest|magazinesTurret|magazineTurretAmmo|mapAnimAdd|mapAnimClear|mapAnimCommit|mapAnimDone|mapCenterOnCamera|mapGridPosition|markAsFinishedOnSteam|markerAlpha|markerBrush|markerColor|markerDir|markerPos|markerShape|markerSize|markerText|markerType|max|members|menuAction|menuAdd|menuChecked|menuClear|menuCollapse|menuData|menuDelete|menuEnable|menuEnabled|menuExpand|menuHover|menuPicture|menuSetAction|menuSetCheck|menuSetData|menuSetPicture|menuSetValue|menuShortcut|menuShortcutText|menuSize|menuSort|menuText|menuURL|menuValue|min|mineActive|mineDetectedBy|missionConfigFile|missionDifficulty|missionName|missionNamespace|missionStart|missionVersion|modelToWorld|modelToWorldVisual|modelToWorldVisualWorld|modelToWorldWorld|modParams|moonIntensity|moonPhase|morale|move|move3DENCamera|moveInAny|moveInCargo|moveInCommander|moveInDriver|moveInGunner|moveInTurret|moveObjectToEnd|moveOut|moveTime|moveTo|moveToCompleted|moveToFailed|musicVolume|name|nameSound|nearEntities|nearestBuilding|nearestLocation|nearestLocations|nearestLocationWithDubbing|nearestObject|nearestObjects|nearestTerrainObjects|nearObjects|nearObjectsReady|nearRoads|nearSupplies|nearTargets|needReload|netId|netObjNull|newOverlay|nextMenuItemIndex|nextWeatherChange|nMenuItems|numberOfEnginesRTD|numberToDate|objectCurators|objectFromNetId|objectParent|objNull|objStatus|onBriefingGear|onBriefingGroup|onBriefingNotes|onBriefingPlan|onBriefingTeamSwitch|onCommandModeChanged|onDoubleClick|onEachFrame|onGroupIconClick|onGroupIconOverEnter|onGroupIconOverLeave|onHCGroupSelectionChanged|onMapSingleClick|onPlayerConnected|onPlayerDisconnected|onPreloadFinished|onPreloadStarted|onShowNewObject|onTeamSwitch|openCuratorInterface|openDLCPage|openDSInterface|openMap|openSteamApp|openYoutubeVideo|opfor|orderGetIn|overcast|overcastForecast|owner|param|params|parseNumber|parseSimpleArray|parseText|parsingNamespace|particlesQuality|pi|pickWeaponPool|pitch|pixelGrid|pixelGridBase|pixelGridNoUIScale|pixelH|pixelW|playableSlotsNumber|playableUnits|playAction|playActionNow|player|playerRespawnTime|playerSide|playersNumber|playGesture|playMission|playMove|playMoveNow|playMusic|playScriptedMission|playSound|playSound3D|position|positionCameraToWorld|posScreenToWorld|posWorldToScreen|ppEffectAdjust|ppEffectCommit|ppEffectCommitted|ppEffectCreate|ppEffectDestroy|ppEffectEnable|ppEffectEnabled|ppEffectForceInNVG|precision|preloadCamera|preloadObject|preloadSound|preloadTitleObj|preloadTitleRsc|primaryWeapon|primaryWeaponItems|primaryWeaponMagazine|priority|processDiaryLink|processInitCommands|productVersion|profileName|profileNamespace|profileNameSteam|progressLoadingScreen|progressPosition|progressSetPosition|publicVariable|publicVariableClient|publicVariableServer|pushBack|pushBackUnique|putWeaponPool|queryItemsPool|queryMagazinePool|queryWeaponPool|rad|radioChannelAdd|radioChannelCreate|radioChannelRemove|radioChannelSetCallSign|radioChannelSetLabel|radioVolume|rain|rainbow|random|rank|rankId|rating|rectangular|registeredTasks|registerTask|reload|reloadEnabled|remoteControl|remoteExec|remoteExecCall|remoteExecutedOwner|remove3DENConnection|remove3DENEventHandler|remove3DENLayer|removeAction|removeAll3DENEventHandlers|removeAllActions|removeAllAssignedItems|removeAllContainers|removeAllCuratorAddons|removeAllCuratorCameraAreas|removeAllCuratorEditingAreas|removeAllEventHandlers|removeAllHandgunItems|removeAllItems|removeAllItemsWithMagazines|removeAllMissionEventHandlers|removeAllMPEventHandlers|removeAllMusicEventHandlers|removeAllOwnedMines|removeAllPrimaryWeaponItems|removeAllWeapons|removeBackpack|removeBackpackGlobal|removeCuratorAddons|removeCuratorCameraArea|removeCuratorEditableObjects|removeCuratorEditingArea|removeDrawIcon|removeDrawLinks|removeEventHandler|removeFromRemainsCollector|removeGoggles|removeGroupIcon|removeHandgunItem|removeHeadgear|removeItem|removeItemFromBackpack|removeItemFromUniform|removeItemFromVest|removeItems|removeMagazine|removeMagazineGlobal|removeMagazines|removeMagazinesTurret|removeMagazineTurret|removeMenuItem|removeMissionEventHandler|removeMPEventHandler|removeMusicEventHandler|removeOwnedMine|removePrimaryWeaponItem|removeSecondaryWeaponItem|removeSimpleTask|removeSwitchableUnit|removeTeamMember|removeUniform|removeVest|removeWeapon|removeWeaponAttachmentCargo|removeWeaponCargo|removeWeaponGlobal|removeWeaponTurret|reportRemoteTarget|requiredVersion|resetCamShake|resetSubgroupDirection|resistance|resize|resources|respawnVehicle|restartEditorCamera|reveal|revealMine|reverse|reversedMouseY|roadAt|roadsConnectedTo|roleDescription|ropeAttachedObjects|ropeAttachedTo|ropeAttachEnabled|ropeAttachTo|ropeCreate|ropeCut|ropeDestroy|ropeDetach|ropeEndPosition|ropeLength|ropes|ropeUnwind|ropeUnwound|rotorsForcesRTD|rotorsRpmRTD|round|runInitScript|safeZoneH|safeZoneW|safeZoneWAbs|safeZoneX|safeZoneXAbs|safeZoneY|save3DENInventory|saveGame|saveIdentity|saveJoysticks|saveOverlay|saveProfileNamespace|saveStatus|saveVar|savingEnabled|say|say2D|say3D|score|scoreSide|screenshot|screenToWorld|scriptDone|scriptName|scriptNull|scudState|secondaryWeapon|secondaryWeaponItems|secondaryWeaponMagazine|select|selectBestPlaces|selectDiarySubject|selectedEditorObjects|selectEditorObject|selectionNames|selectionPosition|selectLeader|selectMax|selectMin|selectNoPlayer|selectPlayer|selectRandom|selectRandomWeighted|selectWeapon|selectWeaponTurret|sendAUMessage|sendSimpleCommand|sendTask|sendTaskResult|sendUDPMessage|serverCommand|serverCommandAvailable|serverCommandExecutable|serverName|serverTime|set|set3DENAttribute|set3DENAttributes|set3DENGrid|set3DENIconsVisible|set3DENLayer|set3DENLinesVisible|set3DENLogicType|set3DENMissionAttribute|set3DENMissionAttributes|set3DENModelsVisible|set3DENObjectType|set3DENSelected|setAccTime|setActualCollectiveRTD|setAirplaneThrottle|setAirportSide|setAmmo|setAmmoCargo|setAmmoOnPylon|setAnimSpeedCoef|setAperture|setApertureNew|setArmoryPoints|setAttributes|setAutonomous|setBehaviour|setBleedingRemaining|setBrakesRTD|setCameraInterest|setCamShakeDefParams|setCamShakeParams|setCamUseTI|setCaptive|setCenterOfMass|setCollisionLight|setCombatMode|setCompassOscillation|setConvoySeparation|setCuratorCameraAreaCeiling|setCuratorCoef|setCuratorEditingAreaType|setCuratorWaypointCost|setCurrentChannel|setCurrentTask|setCurrentWaypoint|setCustomAimCoef|setCustomWeightRTD|setDamage|setDammage|setDate|setDebriefingText|setDefaultCamera|setDestination|setDetailMapBlendPars|setDir|setDirection|setDrawIcon|setDriveOnPath|setDropInterval|setDynamicSimulationDistance|setDynamicSimulationDistanceCoef|setEditorMode|setEditorObjectScope|setEffectCondition|setEngineRpmRTD|setFace|setFaceAnimation|setFatigue|setFeatureType|setFlagAnimationPhase|setFlagOwner|setFlagSide|setFlagTexture|setFog|setForceGeneratorRTD|setFormation|setFormationTask|setFormDir|setFriend|setFromEditor|setFSMVariable|setFuel|setFuelCargo|setGroupIcon|setGroupIconParams|setGroupIconsSelectable|setGroupIconsVisible|setGroupId|setGroupIdGlobal|setGroupOwner|setGusts|setHideBehind|setHit|setHitIndex|setHitPointDamage|setHorizonParallaxCoef|setHUDMovementLevels|setIdentity|setImportance|setInfoPanel|setLeader|setLightAmbient|setLightAttenuation|setLightBrightness|setLightColor|setLightDayLight|setLightFlareMaxDistance|setLightFlareSize|setLightIntensity|setLightnings|setLightUseFlare|setLocalWindParams|setMagazineTurretAmmo|setMarkerAlpha|setMarkerAlphaLocal|setMarkerBrush|setMarkerBrushLocal|setMarkerColor|setMarkerColorLocal|setMarkerDir|setMarkerDirLocal|setMarkerPos|setMarkerPosLocal|setMarkerShape|setMarkerShapeLocal|setMarkerSize|setMarkerSizeLocal|setMarkerText|setMarkerTextLocal|setMarkerType|setMarkerTypeLocal|setMass|setMimic|setMousePosition|setMusicEffect|setMusicEventHandler|setName|setNameSound|setObjectArguments|setObjectMaterial|setObjectMaterialGlobal|setObjectProxy|setObjectTexture|setObjectTextureGlobal|setObjectViewDistance|setOvercast|setOwner|setOxygenRemaining|setParticleCircle|setParticleClass|setParticleFire|setParticleParams|setParticleRandom|setPilotCameraDirection|setPilotCameraRotation|setPilotCameraTarget|setPilotLight|setPiPEffect|setPitch|setPlateNumber|setPlayable|setPlayerRespawnTime|setPos|setPosASL|setPosASL2|setPosASLW|setPosATL|setPosition|setPosWorld|setPylonLoadOut|setPylonsPriority|setRadioMsg|setRain|setRainbow|setRandomLip|setRank|setRectangular|setRepairCargo|setRotorBrakeRTD|setShadowDistance|setShotParents|setSide|setSimpleTaskAlwaysVisible|setSimpleTaskCustomData|setSimpleTaskDescription|setSimpleTaskDestination|setSimpleTaskTarget|setSimpleTaskType|setSimulWeatherLayers|setSize|setSkill|setSlingLoad|setSoundEffect|setSpeaker|setSpeech|setSpeedMode|setStamina|setStaminaScheme|setStatValue|setSuppression|setSystemOfUnits|setTargetAge|setTaskMarkerOffset|setTaskResult|setTaskState|setTerrainGrid|setText|setTimeMultiplier|setTitleEffect|setToneMapping|setToneMappingParams|setTrafficDensity|setTrafficDistance|setTrafficGap|setTrafficSpeed|setTriggerActivation|setTriggerArea|setTriggerStatements|setTriggerText|setTriggerTimeout|setTriggerType|setType|setUnconscious|setUnitAbility|setUnitLoadout|setUnitPos|setUnitPosWeak|setUnitRank|setUnitRecoilCoefficient|setUnitTrait|setUnloadInCombat|setUserActionText|setUserMFDText|setUserMFDValue|setVariable|setVectorDir|setVectorDirAndUp|setVectorUp|setVehicleAmmo|setVehicleAmmoDef|setVehicleArmor|setVehicleCargo|setVehicleId|setVehicleInit|setVehicleLock|setVehiclePosition|setVehicleRadar|setVehicleReceiveRemoteTargets|setVehicleReportOwnPosition|setVehicleReportRemoteTargets|setVehicleTIPars|setVehicleVarName|setVelocity|setVelocityModelSpace|setVelocityTransformation|setViewDistance|setVisibleIfTreeCollapsed|setWantedRpmRTD|setWaves|setWaypointBehaviour|setWaypointCombatMode|setWaypointCompletionRadius|setWaypointDescription|setWaypointForceBehaviour|setWaypointFormation|setWaypointHousePosition|setWaypointLoiterRadius|setWaypointLoiterType|setWaypointName|setWaypointPosition|setWaypointScript|setWaypointSpeed|setWaypointStatements|setWaypointTimeout|setWaypointType|setWaypointVisible|setWeaponReloadingTime|setWind|setWindDir|setWindForce|setWindStr|setWingForceScaleRTD|setWPPos|show3DIcons|showChat|showCinemaBorder|showCommandingMenu|showCompass|showCuratorCompass|showGPS|showHUD|showLegend|showMap|shownArtilleryComputer|shownChat|shownCompass|shownCuratorCompass|showNewEditorObject|shownGPS|shownHUD|shownMap|shownPad|shownRadio|shownScoretable|shownUAVFeed|shownWarrant|shownWatch|showPad|showRadio|showScoretable|showSubtitles|showUAVFeed|showWarrant|showWatch|showWaypoint|showWaypoints|side|sideAmbientLife|sideChat|sideEmpty|sideEnemy|sideFriendly|sideLogic|sideRadio|sideUnknown|simpleTasks|simulationEnabled|simulCloudDensity|simulCloudOcclusion|simulInClouds|simulWeatherSync|sin|size|sizeOf|skill|skillFinal|skipTime|sleep|sliderPosition|sliderRange|sliderSetPosition|sliderSetRange|sliderSetSpeed|sliderSpeed|slingLoadAssistantShown|soldierMagazines|someAmmo|sort|soundVolume|speaker|speed|speedMode|splitString|sqrt|squadParams|stance|startLoadingScreen|stop|stopEngineRTD|stopped|str|sunOrMoon|supportInfo|suppressFor|surfaceIsWater|surfaceNormal|surfaceType|swimInDepth|switchableUnits|switchAction|switchCamera|switchGesture|switchLight|switchMove|synchronizedObjects|synchronizedTriggers|synchronizedWaypoints|synchronizeObjectsAdd|synchronizeObjectsRemove|synchronizeTrigger|synchronizeWaypoint|systemChat|systemOfUnits|tan|targetKnowledge|targets|targetsAggregate|targetsQuery|taskAlwaysVisible|taskChildren|taskCompleted|taskCustomData|taskDescription|taskDestination|taskHint|taskMarkerOffset|taskNull|taskParent|taskResult|taskState|taskType|teamMember|teamMemberNull|teamName|teams|teamSwitch|teamSwitchEnabled|teamType|terminate|terrainIntersect|terrainIntersectASL|terrainIntersectAtASL|text|textLog|textLogFormat|tg|time|timeMultiplier|titleCut|titleFadeOut|titleObj|titleRsc|titleText|toArray|toFixed|toLower|toString|toUpper|triggerActivated|triggerActivation|triggerArea|triggerAttachedVehicle|triggerAttachObject|triggerAttachVehicle|triggerDynamicSimulation|triggerStatements|triggerText|triggerTimeout|triggerTimeoutCurrent|triggerType|turretLocal|turretOwner|turretUnit|tvAdd|tvClear|tvCollapse|tvCollapseAll|tvCount|tvCurSel|tvData|tvDelete|tvExpand|tvExpandAll|tvPicture|tvPictureRight|tvSetColor|tvSetCurSel|tvSetData|tvSetPicture|tvSetPictureColor|tvSetPictureColorDisabled|tvSetPictureColorSelected|tvSetPictureRight|tvSetPictureRightColor|tvSetPictureRightColorDisabled|tvSetPictureRightColorSelected|tvSetSelectColor|tvSetText|tvSetTooltip|tvSetValue|tvSort|tvSortByValue|tvText|tvTooltip|tvValue|type|typeName|typeOf|UAVControl|uiNamespace|uiSleep|unassignCurator|unassignItem|unassignTeam|unassignVehicle|underwater|uniform|uniformContainer|uniformItems|uniformMagazines|unitAddons|unitAimPosition|unitAimPositionVisual|unitBackpack|unitIsUAV|unitPos|unitReady|unitRecoilCoefficient|units|unitsBelowHeight|unlinkItem|unlockAchievement|unregisterTask|updateDrawIcon|updateMenuItem|updateObjectTree|useAIOperMapObstructionTest|useAISteeringComponent|useAudioTimeForMoves|userInputDisabled|vectorAdd|vectorCos|vectorCrossProduct|vectorDiff|vectorDir|vectorDirVisual|vectorDistance|vectorDistanceSqr|vectorDotProduct|vectorFromTo|vectorMagnitude|vectorMagnitudeSqr|vectorModelToWorld|vectorModelToWorldVisual|vectorMultiply|vectorNormalized|vectorUp|vectorUpVisual|vectorWorldToModel|vectorWorldToModelVisual|vehicle|vehicleCargoEnabled|vehicleChat|vehicleRadio|vehicleReceiveRemoteTargets|vehicleReportOwnPosition|vehicleReportRemoteTargets|vehicles|vehicleVarName|velocity|velocityModelSpace|verifySignature|vest|vestContainer|vestItems|vestMagazines|viewDistance|visibleCompass|visibleGPS|visibleMap|visiblePosition|visiblePositionASL|visibleScoretable|visibleWatch|waitUntil|waves|waypointAttachedObject|waypointAttachedVehicle|waypointAttachObject|waypointAttachVehicle|waypointBehaviour|waypointCombatMode|waypointCompletionRadius|waypointDescription|waypointForceBehaviour|waypointFormation|waypointHousePosition|waypointLoiterRadius|waypointLoiterType|waypointName|waypointPosition|waypoints|waypointScript|waypointsEnabledUAV|waypointShow|waypointSpeed|waypointStatements|waypointTimeout|waypointTimeoutCurrent|waypointType|waypointVisible|weaponAccessories|weaponAccessoriesCargo|weaponCargo|weaponDirection|weaponInertia|weaponLowered|weapons|weaponsItems|weaponsItemsCargo|weaponState|weaponsTurret|weightRTD|west|WFSideText|wind|windDir|windRTD|windStr|wingsForcesRTD|worldName|worldSize|worldToModel|worldToModelVisual|worldToScreen)\b/i,
          number: /(?:\$|\b0x)[\da-f]+\b|(?:\B\.\d+|\b\d+(?:\.\d+)?)(?:e[+-]?\d+)?\b/i,
          operator: /##|>>|&&|\|\||[!=<>]=?|[-+*/%#^]|\b(?:and|mod|not|or)\b/i,
          "magic-variable": {
            pattern: /\b(?:this|thisList|thisTrigger|_exception|_fnc_scriptName|_fnc_scriptNameParent|_forEachIndex|_this|_thisEventHandler|_thisFSM|_thisScript|_x)\b/i,
            alias: "keyword"
          },
          constant: /\bDIK(?:_[a-z\d]+)+\b/i
        });
        Prism2.languages.insertBefore("sqf", "string", {
          macro: {
            pattern: /(^[ \t]*)#[a-z](?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
            lookbehind: true,
            greedy: true,
            alias: "property",
            inside: {
              directive: {
                pattern: /#[a-z]+\b/i,
                alias: "keyword"
              },
              comment: Prism2.languages.sqf.comment
            }
          }
        });
        delete Prism2.languages.sqf["class-name"];
      }
      return sqf_1;
    }
    var squirrel_1;
    var hasRequiredSquirrel;
    function requireSquirrel() {
      if (hasRequiredSquirrel)
        return squirrel_1;
      hasRequiredSquirrel = 1;
      squirrel_1 = squirrel;
      squirrel.displayName = "squirrel";
      squirrel.aliases = [];
      function squirrel(Prism2) {
        Prism2.languages.squirrel = Prism2.languages.extend("clike", {
          comment: [
            Prism2.languages.clike["comment"][0],
            {
              pattern: /(^|[^\\:])(?:\/\/|#).*/,
              lookbehind: true,
              greedy: true
            }
          ],
          string: {
            pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
            lookbehind: true,
            greedy: true
          },
          "class-name": {
            pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
            lookbehind: true,
            inside: {
              punctuation: /\./
            }
          },
          keyword: /\b(?:__FILE__|__LINE__|base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield)\b/,
          number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
          operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
          punctuation: /[(){}\[\],;.]/
        });
        Prism2.languages.insertBefore("squirrel", "string", {
          char: {
            pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
            lookbehind: true,
            greedy: true
          }
        });
        Prism2.languages.insertBefore("squirrel", "operator", {
          "attribute-punctuation": {
            pattern: /<\/|\/>/,
            alias: "important"
          },
          lambda: {
            pattern: /@(?=\()/,
            alias: "operator"
          }
        });
      }
      return squirrel_1;
    }
    var stan_1;
    var hasRequiredStan;
    function requireStan() {
      if (hasRequiredStan)
        return stan_1;
      hasRequiredStan = 1;
      stan_1 = stan;
      stan.displayName = "stan";
      stan.aliases = [];
      function stan(Prism2) {
        (function(Prism3) {
          var higherOrderFunctions = /\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
          Prism3.languages.stan = {
            comment: /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
            string: {
              // String literals can contain spaces and any printable ASCII characters except for " and \
              // https://mc-stan.org/docs/2_24/reference-manual/print-statements-section.html#string-literals
              pattern: /"[\x20\x21\x23-\x5B\x5D-\x7E]*"/,
              greedy: true
            },
            directive: {
              pattern: /^([ \t]*)#include\b.*/m,
              lookbehind: true,
              alias: "property"
            },
            "function-arg": {
              pattern: RegExp(
                "(" + higherOrderFunctions.source + /\s*\(\s*/.source + ")" + /[a-zA-Z]\w*/.source
              ),
              lookbehind: true,
              alias: "function"
            },
            constraint: {
              pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
              lookbehind: true,
              inside: {
                expression: {
                  pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
                  lookbehind: true,
                  inside: null
                  // see below
                },
                property: /\b[a-z]\w*(?=\s*=)/i,
                operator: /=/,
                punctuation: /^<|>$|,/
              }
            },
            keyword: [
              {
                pattern: /\bdata(?=\s*\{)|\b(?:functions|generated|model|parameters|quantities|transformed)\b/,
                alias: "program-block"
              },
              /\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\b/,
              // these are functions that are known to take another function as their first argument.
              higherOrderFunctions
            ],
            function: /\b[a-z]\w*(?=\s*\()/i,
            number: /(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:E[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
            boolean: /\b(?:false|true)\b/,
            operator: /<-|\.[*/]=?|\|\|?|&&|[!=<>+\-*/]=?|['^%~?:]/,
            punctuation: /[()\[\]{},;]/
          };
          Prism3.languages.stan.constraint.inside.expression.inside = Prism3.languages.stan;
        })(Prism2);
      }
      return stan_1;
    }
    var stylus_1;
    var hasRequiredStylus;
    function requireStylus() {
      if (hasRequiredStylus)
        return stylus_1;
      hasRequiredStylus = 1;
      stylus_1 = stylus;
      stylus.displayName = "stylus";
      stylus.aliases = [];
      function stylus(Prism2) {
        (function(Prism3) {
          var unit = {
            pattern: /(\b\d+)(?:%|[a-z]+)/,
            lookbehind: true
          };
          var number2 = {
            pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
            lookbehind: true
          };
          var inside = {
            comment: {
              pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
              lookbehind: true
            },
            url: {
              pattern: /\burl\((["']?).*?\1\)/i,
              greedy: true
            },
            string: {
              pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
              greedy: true
            },
            interpolation: null,
            // See below
            func: null,
            // See below
            important: /\B!(?:important|optional)\b/i,
            keyword: {
              pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
              lookbehind: true
            },
            hexcode: /#[\da-f]{3,6}/i,
            color: [
              /\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
              {
                pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
                inside: {
                  unit,
                  number: number2,
                  function: /[\w-]+(?=\()/,
                  punctuation: /[(),]/
                }
              }
            ],
            entity: /\\[\da-f]{1,8}/i,
            unit,
            boolean: /\b(?:false|true)\b/,
            operator: [
              // We want non-word chars around "-" because it is
              // accepted in property names.
              /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
            ],
            number: number2,
            punctuation: /[{}()\[\];:,]/
          };
          inside["interpolation"] = {
            pattern: /\{[^\r\n}:]+\}/,
            alias: "variable",
            inside: {
              delimiter: {
                pattern: /^\{|\}$/,
                alias: "punctuation"
              },
              rest: inside
            }
          };
          inside["func"] = {
            pattern: /[\w-]+\([^)]*\).*/,
            inside: {
              function: /^[^(]+/,
              rest: inside
            }
          };
          Prism3.languages.stylus = {
            "atrule-declaration": {
              pattern: /(^[ \t]*)@.+/m,
              lookbehind: true,
              inside: {
                atrule: /^@[\w-]+/,
                rest: inside
              }
            },
            "variable-declaration": {
              pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
              lookbehind: true,
              inside: {
                variable: /^\S+/,
                rest: inside
              }
            },
            statement: {
              pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
              lookbehind: true,
              inside: {
                keyword: /^\S+/,
                rest: inside
              }
            },
            // A property/value pair cannot end with a comma or a brace
            // It cannot have indented content unless it ended with a semicolon
            "property-declaration": {
              pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
              lookbehind: true,
              inside: {
                property: {
                  pattern: /^[^\s:]+/,
                  inside: {
                    interpolation: inside.interpolation
                  }
                },
                rest: inside
              }
            },
            // A selector can contain parentheses only as part of a pseudo-element
            // It can span multiple lines.
            // It must end with a comma or an accolade or have indented content.
            selector: {
              pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
              lookbehind: true,
              inside: {
                interpolation: inside.interpolation,
                comment: inside.comment,
                punctuation: /[{},]/
              }
            },
            func: inside.func,
            string: inside.string,
            comment: {
              pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
              lookbehind: true,
              greedy: true
            },
            interpolation: inside.interpolation,
            punctuation: /[{}()\[\];:.]/
          };
        })(Prism2);
      }
      return stylus_1;
    }
    var swift_1;
    var hasRequiredSwift;
    function requireSwift() {
      if (hasRequiredSwift)
        return swift_1;
      hasRequiredSwift = 1;
      swift_1 = swift;
      swift.displayName = "swift";
      swift.aliases = [];
      function swift(Prism2) {
        Prism2.languages.swift = {
          comment: {
            // Nested comments are supported up to 2 levels
            pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
            lookbehind: true,
            greedy: true
          },
          "string-literal": [
            // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
            {
              pattern: RegExp(
                /(^|[^"#])/.source + "(?:" + // single-line string
                /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + // multi-line string
                /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                interpolation: {
                  pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
                  lookbehind: true,
                  inside: null
                  // see below
                },
                "interpolation-punctuation": {
                  pattern: /^\)|\\\($/,
                  alias: "punctuation"
                },
                punctuation: /\\(?=[\r\n])/,
                string: /[\s\S]+/
              }
            },
            {
              pattern: RegExp(
                /(^|[^"#])(#+)/.source + "(?:" + // single-line string
                /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + // multi-line string
                /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                interpolation: {
                  pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
                  lookbehind: true,
                  inside: null
                  // see below
                },
                "interpolation-punctuation": {
                  pattern: /^\)|\\#+\($/,
                  alias: "punctuation"
                },
                string: /[\s\S]+/
              }
            }
          ],
          directive: {
            // directives with conditions
            pattern: RegExp(
              /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + // This regex is a little complex. It's equivalent to this:
              //   (?:![ \t]*)?(?:\b\w+\b(?:[ \t]*<round>)?|<round>)(?:[ \t]*(?:&&|\|\|))?
              // where <round> is a general parentheses expression.
              /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
            ),
            alias: "property",
            inside: {
              "directive-name": /^#\w+/,
              boolean: /\b(?:false|true)\b/,
              number: /\b\d+(?:\.\d+)*\b/,
              operator: /!|&&|\|\||[<>]=?/,
              punctuation: /[(),]/
            }
          },
          literal: {
            pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
            alias: "constant"
          },
          "other-directive": {
            pattern: /#\w+\b/,
            alias: "property"
          },
          attribute: {
            pattern: /@\w+/,
            alias: "atrule"
          },
          "function-definition": {
            pattern: /(\bfunc\s+)\w+/,
            lookbehind: true,
            alias: "function"
          },
          label: {
            // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
            pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
            lookbehind: true,
            alias: "important"
          },
          keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
          boolean: /\b(?:false|true)\b/,
          nil: {
            pattern: /\bnil\b/,
            alias: "constant"
          },
          "short-argument": /\$\d+\b/,
          omit: {
            pattern: /\b_\b/,
            alias: "keyword"
          },
          number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
          // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
          "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
          function: /\b[a-z_]\w*(?=\s*\()/i,
          constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
          // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
          // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
          // This regex only supports ASCII operators.
          operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
          punctuation: /[{}[\]();,.:\\]/
        };
        Prism2.languages.swift["string-literal"].forEach(function(rule) {
          rule.inside["interpolation"].inside = Prism2.languages.swift;
        });
      }
      return swift_1;
    }
    var systemd_1;
    var hasRequiredSystemd;
    function requireSystemd() {
      if (hasRequiredSystemd)
        return systemd_1;
      hasRequiredSystemd = 1;
      systemd_1 = systemd;
      systemd.displayName = "systemd";
      systemd.aliases = [];
      function systemd(Prism2) {
        (function(Prism3) {
          var comment = {
            pattern: /^[;#].*/m,
            greedy: true
          };
          var quotesSource = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
          Prism3.languages.systemd = {
            comment,
            section: {
              pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
              greedy: true,
              inside: {
                punctuation: /^\[|\]$/,
                "section-name": {
                  pattern: /[\s\S]+/,
                  alias: "selector"
                }
              }
            },
            key: {
              pattern: /^[^\s=]+(?=[ \t]*=)/m,
              greedy: true,
              alias: "attr-name"
            },
            value: {
              // This pattern is quite complex because of two properties:
              //  1) Quotes (strings) must be preceded by a space. Since we can't use lookbehinds, we have to "resolve"
              //     the lookbehind. You will see this in the main loop where spaces are handled separately.
              //  2) Line continuations.
              //     After line continuations, empty lines and comments are ignored so we have to consume them.
              pattern: RegExp(
                /(=[ \t]*(?!\s))/.source + // the value either starts with quotes or not
                "(?:" + quotesSource + '|(?=[^"\r\n]))(?:' + (/[^\s\\]/.source + // handle spaces separately because of quotes
                '|[ 	]+(?:(?![ 	"])|' + quotesSource + ")|" + /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source) + ")*"
              ),
              lookbehind: true,
              greedy: true,
              alias: "attr-value",
              inside: {
                comment,
                quoted: {
                  pattern: RegExp(/(^|\s)/.source + quotesSource),
                  lookbehind: true,
                  greedy: true
                },
                punctuation: /\\$/m,
                boolean: {
                  pattern: /^(?:false|no|off|on|true|yes)$/,
                  greedy: true
                }
              }
            },
            punctuation: /=/
          };
        })(Prism2);
      }
      return systemd_1;
    }
    var t4Templating_1;
    var hasRequiredT4Templating;
    function requireT4Templating() {
      if (hasRequiredT4Templating)
        return t4Templating_1;
      hasRequiredT4Templating = 1;
      t4Templating_1 = t4Templating;
      t4Templating.displayName = "t4Templating";
      t4Templating.aliases = [];
      function t4Templating(Prism2) {
        (function(Prism3) {
          function createBlock(prefix, inside, contentAlias) {
            return {
              pattern: RegExp("<#" + prefix + "[\\s\\S]*?#>"),
              alias: "block",
              inside: {
                delimiter: {
                  pattern: RegExp("^<#" + prefix + "|#>$"),
                  alias: "important"
                },
                content: {
                  pattern: /[\s\S]+/,
                  inside,
                  alias: contentAlias
                }
              }
            };
          }
          function createT4(insideLang) {
            var grammar = Prism3.languages[insideLang];
            var className = "language-" + insideLang;
            return {
              block: {
                pattern: /<#[\s\S]+?#>/,
                inside: {
                  directive: createBlock("@", {
                    "attr-value": {
                      pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
                      inside: {
                        punctuation: /^=|^["']|["']$/
                      }
                    },
                    keyword: /\b\w+(?=\s)/,
                    "attr-name": /\b\w+/
                  }),
                  expression: createBlock("=", grammar, className),
                  "class-feature": createBlock("\\+", grammar, className),
                  standard: createBlock("", grammar, className)
                }
              }
            };
          }
          Prism3.languages["t4-templating"] = Object.defineProperty({}, "createT4", {
            value: createT4
          });
        })(Prism2);
      }
      return t4Templating_1;
    }
    var t4Cs_1;
    var hasRequiredT4Cs;
    function requireT4Cs() {
      if (hasRequiredT4Cs)
        return t4Cs_1;
      hasRequiredT4Cs = 1;
      var refractorT4Templating = requireT4Templating();
      var refractorCsharp = requireCsharp();
      t4Cs_1 = t4Cs;
      t4Cs.displayName = "t4Cs";
      t4Cs.aliases = [];
      function t4Cs(Prism2) {
        Prism2.register(refractorT4Templating);
        Prism2.register(refractorCsharp);
        Prism2.languages.t4 = Prism2.languages["t4-cs"] = Prism2.languages["t4-templating"].createT4("csharp");
      }
      return t4Cs_1;
    }
    var vbnet_1;
    var hasRequiredVbnet;
    function requireVbnet() {
      if (hasRequiredVbnet)
        return vbnet_1;
      hasRequiredVbnet = 1;
      var refractorBasic = requireBasic();
      vbnet_1 = vbnet;
      vbnet.displayName = "vbnet";
      vbnet.aliases = [];
      function vbnet(Prism2) {
        Prism2.register(refractorBasic);
        Prism2.languages.vbnet = Prism2.languages.extend("basic", {
          comment: [
            {
              pattern: /(?:!|REM\b).+/i,
              inside: {
                keyword: /^REM/i
              }
            },
            {
              pattern: /(^|[^\\:])'.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          string: {
            pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
            lookbehind: true,
            greedy: true
          },
          keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
          punctuation: /[,;:(){}]/
        });
      }
      return vbnet_1;
    }
    var t4Vb_1;
    var hasRequiredT4Vb;
    function requireT4Vb() {
      if (hasRequiredT4Vb)
        return t4Vb_1;
      hasRequiredT4Vb = 1;
      var refractorT4Templating = requireT4Templating();
      var refractorVbnet = requireVbnet();
      t4Vb_1 = t4Vb;
      t4Vb.displayName = "t4Vb";
      t4Vb.aliases = [];
      function t4Vb(Prism2) {
        Prism2.register(refractorT4Templating);
        Prism2.register(refractorVbnet);
        Prism2.languages["t4-vb"] = Prism2.languages["t4-templating"].createT4("vbnet");
      }
      return t4Vb_1;
    }
    var yaml_1;
    var hasRequiredYaml;
    function requireYaml() {
      if (hasRequiredYaml)
        return yaml_1;
      hasRequiredYaml = 1;
      yaml_1 = yaml;
      yaml.displayName = "yaml";
      yaml.aliases = ["yml"];
      function yaml(Prism2) {
        (function(Prism3) {
          var anchorOrAlias = /[*&][^\s[\]{},]+/;
          var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
          var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
          var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
            /<PLAIN>/g,
            function() {
              return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
            }
          );
          var string2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
          function createValuePattern(value, flags) {
            flags = (flags || "").replace(/m/g, "") + "m";
            var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
              return properties;
            }).replace(/<<value>>/g, function() {
              return value;
            });
            return RegExp(pattern, flags);
          }
          Prism3.languages.yaml = {
            scalar: {
              pattern: RegExp(
                /([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
                  /<<prop>>/g,
                  function() {
                    return properties;
                  }
                )
              ),
              lookbehind: true,
              alias: "string"
            },
            comment: /#.*/,
            key: {
              pattern: RegExp(
                /((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
                  return properties;
                }).replace(/<<key>>/g, function() {
                  return "(?:" + plainKey + "|" + string2 + ")";
                })
              ),
              lookbehind: true,
              greedy: true,
              alias: "atrule"
            },
            directive: {
              pattern: /(^[ \t]*)%.+/m,
              lookbehind: true,
              alias: "important"
            },
            datetime: {
              pattern: createValuePattern(
                /\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source
              ),
              lookbehind: true,
              alias: "number"
            },
            boolean: {
              pattern: createValuePattern(/false|true/.source, "i"),
              lookbehind: true,
              alias: "important"
            },
            null: {
              pattern: createValuePattern(/null|~/.source, "i"),
              lookbehind: true,
              alias: "important"
            },
            string: {
              pattern: createValuePattern(string2),
              lookbehind: true,
              greedy: true
            },
            number: {
              pattern: createValuePattern(
                /[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source,
                "i"
              ),
              lookbehind: true
            },
            tag,
            important: anchorOrAlias,
            punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
          };
          Prism3.languages.yml = Prism3.languages.yaml;
        })(Prism2);
      }
      return yaml_1;
    }
    var tap_1;
    var hasRequiredTap;
    function requireTap() {
      if (hasRequiredTap)
        return tap_1;
      hasRequiredTap = 1;
      var refractorYaml = requireYaml();
      tap_1 = tap;
      tap.displayName = "tap";
      tap.aliases = [];
      function tap(Prism2) {
        Prism2.register(refractorYaml);
        Prism2.languages.tap = {
          fail: /not ok[^#{\n\r]*/,
          pass: /ok[^#{\n\r]*/,
          pragma: /pragma [+-][a-z]+/,
          bailout: /bail out!.*/i,
          version: /TAP version \d+/i,
          plan: /\b\d+\.\.\d+(?: +#.*)?/,
          subtest: {
            pattern: /# Subtest(?:: .*)?/,
            greedy: true
          },
          punctuation: /[{}]/,
          directive: /#.*/,
          yamlish: {
            pattern: /(^[ \t]*)---[\s\S]*?[\r\n][ \t]*\.\.\.$/m,
            lookbehind: true,
            inside: Prism2.languages.yaml,
            alias: "language-yaml"
          }
        };
      }
      return tap_1;
    }
    var tcl_1;
    var hasRequiredTcl;
    function requireTcl() {
      if (hasRequiredTcl)
        return tcl_1;
      hasRequiredTcl = 1;
      tcl_1 = tcl;
      tcl.displayName = "tcl";
      tcl.aliases = [];
      function tcl(Prism2) {
        Prism2.languages.tcl = {
          comment: {
            pattern: /(^|[^\\])#.*/,
            lookbehind: true
          },
          string: {
            pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,
            greedy: true
          },
          variable: [
            {
              pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/,
              lookbehind: true
            },
            {
              pattern: /(\$)\{[^}]+\}/,
              lookbehind: true
            },
            {
              pattern: /(^[\t ]*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
              lookbehind: true
            }
          ],
          function: {
            pattern: /(^[\t ]*proc[ \t]+)\S+/m,
            lookbehind: true
          },
          builtin: [
            {
              pattern: /(^[\t ]*)(?:break|class|continue|error|eval|exit|for|foreach|if|proc|return|switch|while)\b/m,
              lookbehind: true
            },
            /\b(?:else|elseif)\b/
          ],
          scope: {
            pattern: /(^[\t ]*)(?:global|upvar|variable)\b/m,
            lookbehind: true,
            alias: "constant"
          },
          keyword: {
            pattern: /(^[\t ]*|\[)(?:Safe_Base|Tcl|after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|scan|seek|set|socket|source|split|string|subst|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|test|vars|wordBreak(?:After|Before))|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
            lookbehind: true
          },
          operator: /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|in|ne|ni)\b/,
          punctuation: /[{}()\[\]]/
        };
      }
      return tcl_1;
    }
    var textile_1;
    var hasRequiredTextile;
    function requireTextile() {
      if (hasRequiredTextile)
        return textile_1;
      hasRequiredTextile = 1;
      textile_1 = textile;
      textile.displayName = "textile";
      textile.aliases = [];
      function textile(Prism2) {
        (function(Prism3) {
          var modifierRegex = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source;
          var parenthesesRegex = /\)|\((?![^|()\n]+\))/.source;
          function withModifier(source, flags) {
            return RegExp(
              source.replace(/<MOD>/g, function() {
                return "(?:" + modifierRegex + ")";
              }).replace(/<PAR>/g, function() {
                return "(?:" + parenthesesRegex + ")";
              }),
              flags || ""
            );
          }
          var modifierTokens = {
            css: {
              pattern: /\{[^{}]+\}/,
              inside: {
                rest: Prism3.languages.css
              }
            },
            "class-id": {
              pattern: /(\()[^()]+(?=\))/,
              lookbehind: true,
              alias: "attr-value"
            },
            lang: {
              pattern: /(\[)[^\[\]]+(?=\])/,
              lookbehind: true,
              alias: "attr-value"
            },
            // Anything else is punctuation (the first pattern is for row/col spans inside tables)
            punctuation: /[\\\/]\d+|\S/
          };
          var textile2 = Prism3.languages.textile = Prism3.languages.extend("markup", {
            phrase: {
              pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
              lookbehind: true,
              inside: {
                // h1. Header 1
                "block-tag": {
                  pattern: withModifier(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
                  inside: {
                    modifier: {
                      pattern: withModifier(
                        /(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source
                      ),
                      lookbehind: true,
                      inside: modifierTokens
                    },
                    tag: /^[a-z]\w*/,
                    punctuation: /\.$/
                  }
                },
                // # List item
                // * List item
                list: {
                  pattern: withModifier(/^[*#]+<MOD>*\s+\S.*/.source, "m"),
                  inside: {
                    modifier: {
                      pattern: withModifier(/(^[*#]+)<MOD>+/.source),
                      lookbehind: true,
                      inside: modifierTokens
                    },
                    punctuation: /^[*#]+/
                  }
                },
                // | cell | cell | cell |
                table: {
                  // Modifiers can be applied to the row: {color:red}.|1|2|3|
                  // or the cell: |{color:red}.1|2|3|
                  pattern: withModifier(
                    /^(?:(?:<MOD>|<PAR>|[<>=^~])+\.\s*)?(?:\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.))[^|]*)+\|/.source,
                    "m"
                  ),
                  inside: {
                    modifier: {
                      // Modifiers for rows after the first one are
                      // preceded by a pipe and a line feed
                      pattern: withModifier(
                        /(^|\|(?:\r?\n|\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+(?=\.)/.source
                      ),
                      lookbehind: true,
                      inside: modifierTokens
                    },
                    punctuation: /\||^\./
                  }
                },
                inline: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: withModifier(
                    /(^|[^a-zA-Z\d])(\*\*|__|\?\?|[*_%@+\-^~])<MOD>*.+?\2(?![a-zA-Z\d])/.source
                  ),
                  lookbehind: true,
                  inside: {
                    // Note: superscripts and subscripts are not handled specifically
                    // *bold*, **bold**
                    bold: {
                      // eslint-disable-next-line regexp/no-super-linear-backtracking
                      pattern: withModifier(/(^(\*\*?)<MOD>*).+?(?=\2)/.source),
                      lookbehind: true
                    },
                    // _italic_, __italic__
                    italic: {
                      // eslint-disable-next-line regexp/no-super-linear-backtracking
                      pattern: withModifier(/(^(__?)<MOD>*).+?(?=\2)/.source),
                      lookbehind: true
                    },
                    // ??cite??
                    cite: {
                      // eslint-disable-next-line regexp/no-super-linear-backtracking
                      pattern: withModifier(/(^\?\?<MOD>*).+?(?=\?\?)/.source),
                      lookbehind: true,
                      alias: "string"
                    },
                    // @code@
                    code: {
                      // eslint-disable-next-line regexp/no-super-linear-backtracking
                      pattern: withModifier(/(^@<MOD>*).+?(?=@)/.source),
                      lookbehind: true,
                      alias: "keyword"
                    },
                    // +inserted+
                    inserted: {
                      // eslint-disable-next-line regexp/no-super-linear-backtracking
                      pattern: withModifier(/(^\+<MOD>*).+?(?=\+)/.source),
                      lookbehind: true
                    },
                    // -deleted-
                    deleted: {
                      // eslint-disable-next-line regexp/no-super-linear-backtracking
                      pattern: withModifier(/(^-<MOD>*).+?(?=-)/.source),
                      lookbehind: true
                    },
                    // %span%
                    span: {
                      // eslint-disable-next-line regexp/no-super-linear-backtracking
                      pattern: withModifier(/(^%<MOD>*).+?(?=%)/.source),
                      lookbehind: true
                    },
                    modifier: {
                      pattern: withModifier(
                        /(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source
                      ),
                      lookbehind: true,
                      inside: modifierTokens
                    },
                    punctuation: /[*_%?@+\-^~]+/
                  }
                },
                // [alias]http://example.com
                "link-ref": {
                  pattern: /^\[[^\]]+\]\S+$/m,
                  inside: {
                    string: {
                      pattern: /(^\[)[^\]]+(?=\])/,
                      lookbehind: true
                    },
                    url: {
                      pattern: /(^\])\S+$/,
                      lookbehind: true
                    },
                    punctuation: /[\[\]]/
                  }
                },
                // "text":http://example.com
                // "text":link-ref
                link: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: withModifier(
                    /"<MOD>*[^"]+":.+?(?=[^\w/]?(?:\s|$))/.source
                  ),
                  inside: {
                    text: {
                      // eslint-disable-next-line regexp/no-super-linear-backtracking
                      pattern: withModifier(/(^"<MOD>*)[^"]+(?=")/.source),
                      lookbehind: true
                    },
                    modifier: {
                      pattern: withModifier(/(^")<MOD>+/.source),
                      lookbehind: true,
                      inside: modifierTokens
                    },
                    url: {
                      pattern: /(:).+/,
                      lookbehind: true
                    },
                    punctuation: /[":]/
                  }
                },
                // !image.jpg!
                // !image.jpg(Title)!:http://example.com
                image: {
                  pattern: withModifier(
                    /!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\s()]+(?:\([^)]+\))?!(?::.+?(?=[^\w/]?(?:\s|$)))?/.source
                  ),
                  inside: {
                    source: {
                      pattern: withModifier(
                        /(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\s()]+(?:\([^)]+\))?(?=!)/.source
                      ),
                      lookbehind: true,
                      alias: "url"
                    },
                    modifier: {
                      pattern: withModifier(/(^!)(?:<MOD>|<PAR>|[<>=])+/.source),
                      lookbehind: true,
                      inside: modifierTokens
                    },
                    url: {
                      pattern: /(:).+/,
                      lookbehind: true
                    },
                    punctuation: /[!:]/
                  }
                },
                // Footnote[1]
                footnote: {
                  pattern: /\b\[\d+\]/,
                  alias: "comment",
                  inside: {
                    punctuation: /\[|\]/
                  }
                },
                // CSS(Cascading Style Sheet)
                acronym: {
                  pattern: /\b[A-Z\d]+\([^)]+\)/,
                  inside: {
                    comment: {
                      pattern: /(\()[^()]+(?=\))/,
                      lookbehind: true
                    },
                    punctuation: /[()]/
                  }
                },
                // Prism(C)
                mark: {
                  pattern: /\b\((?:C|R|TM)\)/,
                  alias: "comment",
                  inside: {
                    punctuation: /[()]/
                  }
                }
              }
            }
          });
          var phraseInside = textile2["phrase"].inside;
          var nestedPatterns = {
            inline: phraseInside["inline"],
            link: phraseInside["link"],
            image: phraseInside["image"],
            footnote: phraseInside["footnote"],
            acronym: phraseInside["acronym"],
            mark: phraseInside["mark"]
          };
          textile2.tag.pattern = /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;
          var phraseInlineInside = phraseInside["inline"].inside;
          phraseInlineInside["bold"].inside = nestedPatterns;
          phraseInlineInside["italic"].inside = nestedPatterns;
          phraseInlineInside["inserted"].inside = nestedPatterns;
          phraseInlineInside["deleted"].inside = nestedPatterns;
          phraseInlineInside["span"].inside = nestedPatterns;
          var phraseTableInside = phraseInside["table"].inside;
          phraseTableInside["inline"] = nestedPatterns["inline"];
          phraseTableInside["link"] = nestedPatterns["link"];
          phraseTableInside["image"] = nestedPatterns["image"];
          phraseTableInside["footnote"] = nestedPatterns["footnote"];
          phraseTableInside["acronym"] = nestedPatterns["acronym"];
          phraseTableInside["mark"] = nestedPatterns["mark"];
        })(Prism2);
      }
      return textile_1;
    }
    var toml_1;
    var hasRequiredToml;
    function requireToml() {
      if (hasRequiredToml)
        return toml_1;
      hasRequiredToml = 1;
      toml_1 = toml;
      toml.displayName = "toml";
      toml.aliases = [];
      function toml(Prism2) {
        (function(Prism3) {
          var key = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
          function insertKey(pattern) {
            return pattern.replace(/__/g, function() {
              return key;
            });
          }
          Prism3.languages.toml = {
            comment: {
              pattern: /#.*/,
              greedy: true
            },
            table: {
              pattern: RegExp(
                insertKey(
                  /(^[\t ]*\[\s*(?:\[\s*)?)__(?:\s*\.\s*__)*(?=\s*\])/.source
                ),
                "m"
              ),
              lookbehind: true,
              greedy: true,
              alias: "class-name"
            },
            key: {
              pattern: RegExp(
                insertKey(/(^[\t ]*|[{,]\s*)__(?:\s*\.\s*__)*(?=\s*=)/.source),
                "m"
              ),
              lookbehind: true,
              greedy: true,
              alias: "property"
            },
            string: {
              pattern: /"""(?:\\[\s\S]|[^\\])*?"""|'''[\s\S]*?'''|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*"/,
              greedy: true
            },
            date: [
              {
                // Offset Date-Time, Local Date-Time, Local Date
                pattern: /\b\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)?\b/i,
                alias: "number"
              },
              {
                // Local Time
                pattern: /\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b/,
                alias: "number"
              }
            ],
            number: /(?:\b0(?:x[\da-zA-Z]+(?:_[\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\b|[-+]?\b\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?\b|[-+]?\b(?:inf|nan)\b/,
            boolean: /\b(?:false|true)\b/,
            punctuation: /[.,=[\]{}]/
          };
        })(Prism2);
      }
      return toml_1;
    }
    var tremor_1;
    var hasRequiredTremor;
    function requireTremor() {
      if (hasRequiredTremor)
        return tremor_1;
      hasRequiredTremor = 1;
      tremor_1 = tremor;
      tremor.displayName = "tremor";
      tremor.aliases = [];
      function tremor(Prism2) {
        (function(Prism3) {
          Prism3.languages.tremor = {
            comment: {
              pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
              lookbehind: true
            },
            "interpolated-string": null,
            // see below
            extractor: {
              pattern: /\b[a-z_]\w*\|(?:[^\r\n\\|]|\\(?:\r\n|[\s\S]))*\|/i,
              greedy: true,
              inside: {
                regex: {
                  pattern: /(^re)\|[\s\S]+/,
                  lookbehind: true
                },
                function: /^\w+/,
                value: /\|[\s\S]+/
              }
            },
            identifier: {
              pattern: /`[^`]*`/,
              greedy: true
            },
            function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())\b/,
            keyword: /\b(?:args|as|by|case|config|connect|connector|const|copy|create|default|define|deploy|drop|each|emit|end|erase|event|flow|fn|for|from|group|having|insert|into|intrinsic|let|links|match|merge|mod|move|of|operator|patch|pipeline|recur|script|select|set|sliding|state|stream|to|tumbling|update|use|when|where|window|with)\b/,
            boolean: /\b(?:false|null|true)\b/i,
            number: /\b(?:0b[01_]*|0x[0-9a-fA-F_]*|\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee][+-]?[\d_]+)?)\b/,
            "pattern-punctuation": {
              pattern: /%(?=[({[])/,
              alias: "punctuation"
            },
            operator: /[-+*\/%~!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?>?=?|(?:absent|and|not|or|present|xor)\b/,
            punctuation: /::|[;\[\]()\{\},.:]/
          };
          var interpolationPattern = /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/.source;
          Prism3.languages.tremor["interpolated-string"] = {
            pattern: RegExp(
              /(^|[^\\])/.source + '(?:"""(?:' + /[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source + "|" + interpolationPattern + ')*"""|"(?:' + /[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source + "|" + interpolationPattern + ')*")'
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              interpolation: {
                pattern: RegExp(interpolationPattern),
                inside: {
                  punctuation: /^#\{|\}$/,
                  expression: {
                    pattern: /[\s\S]+/,
                    inside: Prism3.languages.tremor
                  }
                }
              },
              string: /[\s\S]+/
            }
          };
          Prism3.languages.troy = Prism3.languages["tremor"];
          Prism3.languages.trickle = Prism3.languages["tremor"];
        })(Prism2);
      }
      return tremor_1;
    }
    var tsx_1;
    var hasRequiredTsx;
    function requireTsx() {
      if (hasRequiredTsx)
        return tsx_1;
      hasRequiredTsx = 1;
      var refractorJsx = requireJsx();
      var refractorTypescript = requireTypescript();
      tsx_1 = tsx;
      tsx.displayName = "tsx";
      tsx.aliases = [];
      function tsx(Prism2) {
        Prism2.register(refractorJsx);
        Prism2.register(refractorTypescript);
        (function(Prism3) {
          var typescript = Prism3.util.clone(Prism3.languages.typescript);
          Prism3.languages.tsx = Prism3.languages.extend("jsx", typescript);
          delete Prism3.languages.tsx["parameter"];
          delete Prism3.languages.tsx["literal-property"];
          var tag = Prism3.languages.tsx.tag;
          tag.pattern = RegExp(
            /(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")",
            tag.pattern.flags
          );
          tag.lookbehind = true;
        })(Prism2);
      }
      return tsx_1;
    }
    var tt2_1;
    var hasRequiredTt2;
    function requireTt2() {
      if (hasRequiredTt2)
        return tt2_1;
      hasRequiredTt2 = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      tt2_1 = tt2;
      tt2.displayName = "tt2";
      tt2.aliases = [];
      function tt2(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        (function(Prism3) {
          Prism3.languages.tt2 = Prism3.languages.extend("clike", {
            comment: /#.*|\[%#[\s\S]*?%\]/,
            keyword: /\b(?:BLOCK|CALL|CASE|CATCH|CLEAR|DEBUG|DEFAULT|ELSE|ELSIF|END|FILTER|FINAL|FOREACH|GET|IF|IN|INCLUDE|INSERT|LAST|MACRO|META|NEXT|PERL|PROCESS|RAWPERL|RETURN|SET|STOP|SWITCH|TAGS|THROW|TRY|UNLESS|USE|WHILE|WRAPPER)\b/,
            punctuation: /[[\]{},()]/
          });
          Prism3.languages.insertBefore("tt2", "number", {
            operator: /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
            variable: {
              pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i
            }
          });
          Prism3.languages.insertBefore("tt2", "keyword", {
            delimiter: {
              pattern: /^(?:\[%|%%)-?|-?%\]$/,
              alias: "punctuation"
            }
          });
          Prism3.languages.insertBefore("tt2", "string", {
            "single-quoted-string": {
              pattern: /'[^\\']*(?:\\[\s\S][^\\']*)*'/,
              greedy: true,
              alias: "string"
            },
            "double-quoted-string": {
              pattern: /"[^\\"]*(?:\\[\s\S][^\\"]*)*"/,
              greedy: true,
              alias: "string",
              inside: {
                variable: {
                  pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i
                }
              }
            }
          });
          delete Prism3.languages.tt2.string;
          Prism3.hooks.add("before-tokenize", function(env2) {
            var tt2Pattern = /\[%[\s\S]+?%\]/g;
            Prism3.languages["markup-templating"].buildPlaceholders(
              env2,
              "tt2",
              tt2Pattern
            );
          });
          Prism3.hooks.add("after-tokenize", function(env2) {
            Prism3.languages["markup-templating"].tokenizePlaceholders(env2, "tt2");
          });
        })(Prism2);
      }
      return tt2_1;
    }
    var twig_1;
    var hasRequiredTwig;
    function requireTwig() {
      if (hasRequiredTwig)
        return twig_1;
      hasRequiredTwig = 1;
      var refractorMarkupTemplating = requireMarkupTemplating();
      twig_1 = twig;
      twig.displayName = "twig";
      twig.aliases = [];
      function twig(Prism2) {
        Prism2.register(refractorMarkupTemplating);
        Prism2.languages.twig = {
          comment: /^\{#[\s\S]*?#\}$/,
          "tag-name": {
            pattern: /(^\{%-?\s*)\w+/,
            lookbehind: true,
            alias: "keyword"
          },
          delimiter: {
            pattern: /^\{[{%]-?|-?[%}]\}$/,
            alias: "punctuation"
          },
          string: {
            pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            inside: {
              punctuation: /^['"]|['"]$/
            }
          },
          keyword: /\b(?:even|if|odd)\b/,
          boolean: /\b(?:false|null|true)\b/,
          number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
          operator: [
            {
              pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
              lookbehind: true
            },
            /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
          ],
          punctuation: /[()\[\]{}:.,]/
        };
        Prism2.hooks.add("before-tokenize", function(env2) {
          if (env2.language !== "twig") {
            return;
          }
          var pattern = /\{(?:#[\s\S]*?#|%[\s\S]*?%|\{[\s\S]*?\})\}/g;
          Prism2.languages["markup-templating"].buildPlaceholders(env2, "twig", pattern);
        });
        Prism2.hooks.add("after-tokenize", function(env2) {
          Prism2.languages["markup-templating"].tokenizePlaceholders(env2, "twig");
        });
      }
      return twig_1;
    }
    var typoscript_1;
    var hasRequiredTyposcript;
    function requireTyposcript() {
      if (hasRequiredTyposcript)
        return typoscript_1;
      hasRequiredTyposcript = 1;
      typoscript_1 = typoscript;
      typoscript.displayName = "typoscript";
      typoscript.aliases = ["tsconfig"];
      function typoscript(Prism2) {
        (function(Prism3) {
          var keywords = /\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
          Prism3.languages.typoscript = {
            comment: [
              {
                // multiline comments /* */
                pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                lookbehind: true
              },
              {
                // double-slash comments - ignored when backslashes or colon is found in front
                // also ignored whenever directly after an equal-sign, because it would probably be an url without protocol
                pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
                lookbehind: true,
                greedy: true
              },
              {
                // hash comments - ignored when leading quote is found for hex colors in strings
                pattern: /(^|[^"'])#.*/,
                lookbehind: true,
                greedy: true
              }
            ],
            function: [
              {
                // old include style
                pattern: /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
                inside: {
                  string: {
                    pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
                    inside: {
                      keyword: keywords
                    }
                  },
                  keyword: {
                    pattern: /INCLUDE_TYPOSCRIPT/
                  }
                }
              },
              {
                // new include style
                pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
                inside: {
                  string: /"[^"\r\n]*"|'[^'\r\n]*'/
                }
              }
            ],
            string: {
              pattern: /^([^=]*=[< ]?)(?:(?!\]\n).)*/,
              lookbehind: true,
              inside: {
                function: /\{\$.*\}/,
                // constants include
                keyword: keywords,
                number: /^\d+$/,
                punctuation: /[,|:]/
              }
            },
            keyword: keywords,
            number: {
              // special highlighting for indexes of arrays in tags
              pattern: /\b\d+\s*[.{=]/,
              inside: {
                operator: /[.{=]/
              }
            },
            tag: {
              pattern: /\.?[-\w\\]+\.?/,
              inside: {
                punctuation: /\./
              }
            },
            punctuation: /[{}[\];(),.:|]/,
            operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
          };
          Prism3.languages.tsconfig = Prism3.languages.typoscript;
        })(Prism2);
      }
      return typoscript_1;
    }
    var unrealscript_1;
    var hasRequiredUnrealscript;
    function requireUnrealscript() {
      if (hasRequiredUnrealscript)
        return unrealscript_1;
      hasRequiredUnrealscript = 1;
      unrealscript_1 = unrealscript;
      unrealscript.displayName = "unrealscript";
      unrealscript.aliases = ["uc", "uscript"];
      function unrealscript(Prism2) {
        Prism2.languages.unrealscript = {
          comment: /\/\/.*|\/\*[\s\S]*?\*\//,
          string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          category: {
            pattern: /(\b(?:(?:autoexpand|hide|show)categories|var)\s*\()[^()]+(?=\))/,
            lookbehind: true,
            greedy: true,
            alias: "property"
          },
          metadata: {
            pattern: /(\w\s*)<\s*\w+\s*=[^<>|=\r\n]+(?:\|\s*\w+\s*=[^<>|=\r\n]+)*>/,
            lookbehind: true,
            greedy: true,
            inside: {
              property: /\b\w+(?=\s*=)/,
              operator: /=/,
              punctuation: /[<>|]/
            }
          },
          macro: {
            pattern: /`\w+/,
            alias: "property"
          },
          "class-name": {
            pattern: /(\b(?:class|enum|extends|interface|state(?:\(\))?|struct|within)\s+)\w+/,
            lookbehind: true
          },
          keyword: /\b(?:abstract|actor|array|auto|autoexpandcategories|bool|break|byte|case|class|classgroup|client|coerce|collapsecategories|config|const|continue|default|defaultproperties|delegate|dependson|deprecated|do|dontcollapsecategories|editconst|editinlinenew|else|enum|event|exec|export|extends|final|float|for|forcescriptorder|foreach|function|goto|guid|hidecategories|hidedropdown|if|ignores|implements|inherits|input|int|interface|iterator|latent|local|material|name|native|nativereplication|noexport|nontransient|noteditinlinenew|notplaceable|operator|optional|out|pawn|perobjectconfig|perobjectlocalized|placeable|postoperator|preoperator|private|protected|reliable|replication|return|server|showcategories|simulated|singular|state|static|string|struct|structdefault|structdefaultproperties|switch|texture|transient|travel|unreliable|until|var|vector|while|within)\b/,
          function: /\b[a-z_]\w*(?=\s*\()/i,
          boolean: /\b(?:false|true)\b/,
          number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
          // https://docs.unrealengine.com/udk/Three/UnrealScriptExpressions.html
          operator: />>|<<|--|\+\+|\*\*|[-+*/~!=<>$@]=?|&&?|\|\|?|\^\^?|[?:%]|\b(?:ClockwiseFrom|Cross|Dot)\b/,
          punctuation: /[()[\]{};,.]/
        };
        Prism2.languages.uc = Prism2.languages.uscript = Prism2.languages.unrealscript;
      }
      return unrealscript_1;
    }
    var uorazor_1;
    var hasRequiredUorazor;
    function requireUorazor() {
      if (hasRequiredUorazor)
        return uorazor_1;
      hasRequiredUorazor = 1;
      uorazor_1 = uorazor;
      uorazor.displayName = "uorazor";
      uorazor.aliases = [];
      function uorazor(Prism2) {
        Prism2.languages.uorazor = {
          "comment-hash": {
            pattern: /#.*/,
            alias: "comment",
            greedy: true
          },
          "comment-slash": {
            pattern: /\/\/.*/,
            alias: "comment",
            greedy: true
          },
          string: {
            pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            inside: {
              punctuation: /^['"]|['"]$/
            },
            greedy: true
          },
          "source-layers": {
            pattern: /\b(?:arms|backpack|blue|bracelet|cancel|clear|cloak|criminal|earrings|enemy|facialhair|friend|friendly|gloves|gray|grey|ground|hair|head|innerlegs|innertorso|innocent|lefthand|middletorso|murderer|neck|nonfriendly|onehandedsecondary|outerlegs|outertorso|pants|red|righthand|ring|self|shirt|shoes|talisman|waist)\b/i,
            alias: "function"
          },
          "source-commands": {
            pattern: /\b(?:alliance|attack|cast|clearall|clearignore|clearjournal|clearlist|clearsysmsg|createlist|createtimer|dclick|dclicktype|dclickvar|dress|dressconfig|drop|droprelloc|emote|getlabel|guild|gumpclose|gumpresponse|hotkey|ignore|lasttarget|lift|lifttype|menu|menuresponse|msg|org|organize|organizer|overhead|pause|poplist|potion|promptresponse|pushlist|removelist|removetimer|rename|restock|say|scav|scavenger|script|setability|setlasttarget|setskill|settimer|setvar|sysmsg|target|targetloc|targetrelloc|targettype|undress|unignore|unsetvar|useobject|useonce|useskill|usetype|virtue|wait|waitforgump|waitformenu|waitforprompt|waitforstat|waitforsysmsg|waitfortarget|walk|wfsysmsg|wft|whisper|yell)\b/,
            alias: "function"
          },
          "tag-name": {
            pattern: /(^\{%-?\s*)\w+/,
            lookbehind: true,
            alias: "keyword"
          },
          delimiter: {
            pattern: /^\{[{%]-?|-?[%}]\}$/,
            alias: "punctuation"
          },
          function: /\b(?:atlist|close|closest|count|counter|counttype|dead|dex|diffhits|diffmana|diffstam|diffweight|find|findbuff|finddebuff|findlayer|findtype|findtypelist|followers|gumpexists|hidden|hits|hp|hue|human|humanoid|ingump|inlist|insysmessage|insysmsg|int|invul|lhandempty|list|listexists|mana|maxhits|maxhp|maxmana|maxstam|maxweight|monster|mounted|name|next|noto|paralyzed|poisoned|position|prev|previous|queued|rand|random|rhandempty|skill|stam|str|targetexists|timer|timerexists|varexist|warmode|weight)\b/,
          keyword: /\b(?:and|as|break|continue|else|elseif|endfor|endif|endwhile|for|if|loop|not|or|replay|stop|while)\b/,
          boolean: /\b(?:false|null|true)\b/,
          number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
          operator: [
            {
              pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
              lookbehind: true
            },
            /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
          ],
          punctuation: /[()\[\]{}:.,]/
        };
      }
      return uorazor_1;
    }
    var uri_1;
    var hasRequiredUri;
    function requireUri() {
      if (hasRequiredUri)
        return uri_1;
      hasRequiredUri = 1;
      uri_1 = uri;
      uri.displayName = "uri";
      uri.aliases = ["url"];
      function uri(Prism2) {
        Prism2.languages.uri = {
          scheme: {
            pattern: /^[a-z][a-z0-9+.-]*:/im,
            greedy: true,
            inside: {
              "scheme-delimiter": /:$/
            }
          },
          fragment: {
            pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
            inside: {
              "fragment-delimiter": /^#/
            }
          },
          query: {
            pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
            inside: {
              "query-delimiter": {
                pattern: /^\?/,
                greedy: true
              },
              "pair-delimiter": /[&;]/,
              pair: {
                pattern: /^[^=][\s\S]*/,
                inside: {
                  key: /^[^=]+/,
                  value: {
                    pattern: /(^=)[\s\S]+/,
                    lookbehind: true
                  }
                }
              }
            }
          },
          authority: {
            pattern: RegExp(
              /^\/\//.source + // [ userinfo "@" ]
              /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source + // host
              ("(?:" + // IP-literal
              /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source + "|" + // IPv4address or registered name
              /[\w\-.~!$&'()*+,;=%]*/.source + ")") + // [ ":" port ]
              /(?::\d*)?/.source,
              "m"
            ),
            inside: {
              "authority-delimiter": /^\/\//,
              "user-info-segment": {
                pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
                inside: {
                  "user-info-delimiter": /@$/,
                  "user-info": /^[\w\-.~!$&'()*+,;=%:]+/
                }
              },
              "port-segment": {
                pattern: /:\d*$/,
                inside: {
                  "port-delimiter": /^:/,
                  port: /^\d+/
                }
              },
              host: {
                pattern: /[\s\S]+/,
                inside: {
                  "ip-literal": {
                    pattern: /^\[[\s\S]+\]$/,
                    inside: {
                      "ip-literal-delimiter": /^\[|\]$/,
                      "ipv-future": /^v[\s\S]+/,
                      "ipv6-address": /^[\s\S]+/
                    }
                  },
                  "ipv4-address": /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]\d{0,2})$/
                }
              }
            }
          },
          path: {
            pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
            inside: {
              "path-separator": /\//
            }
          }
        };
        Prism2.languages.url = Prism2.languages.uri;
      }
      return uri_1;
    }
    var v_1;
    var hasRequiredV;
    function requireV() {
      if (hasRequiredV)
        return v_1;
      hasRequiredV = 1;
      v_1 = v2;
      v2.displayName = "v";
      v2.aliases = [];
      function v2(Prism2) {
        (function(Prism3) {
          var interpolationExpr = {
            pattern: /[\s\S]+/,
            inside: null
          };
          Prism3.languages.v = Prism3.languages.extend("clike", {
            string: {
              pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
              alias: "quoted-string",
              greedy: true,
              inside: {
                interpolation: {
                  pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
                  lookbehind: true,
                  inside: {
                    "interpolation-variable": {
                      pattern: /^\$\w[\s\S]*$/,
                      alias: "variable"
                    },
                    "interpolation-punctuation": {
                      pattern: /^\$\{|\}$/,
                      alias: "punctuation"
                    },
                    "interpolation-expression": interpolationExpr
                  }
                }
              }
            },
            "class-name": {
              pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
              lookbehind: true
            },
            keyword: /(?:\b(?:__global|as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:else|for|if)|#(?:flag|include))\b/,
            number: /\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
            operator: /~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
            builtin: /\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
          });
          interpolationExpr.inside = Prism3.languages.v;
          Prism3.languages.insertBefore("v", "string", {
            char: {
              pattern: /`(?:\\`|\\?[^`]{1,2})`/,
              // using {1,2} instead of `u` flag for compatibility
              alias: "rune"
            }
          });
          Prism3.languages.insertBefore("v", "operator", {
            attribute: {
              pattern: /(^[\t ]*)\[(?:deprecated|direct_array_access|flag|inline|live|ref_only|typedef|unsafe_fn|windows_stdcall)\]/m,
              lookbehind: true,
              alias: "annotation",
              inside: {
                punctuation: /[\[\]]/,
                keyword: /\w+/
              }
            },
            generic: {
              pattern: /<\w+>(?=\s*[\)\{])/,
              inside: {
                punctuation: /[<>]/,
                "class-name": /\w+/
              }
            }
          });
          Prism3.languages.insertBefore("v", "function", {
            "generic-function": {
              // e.g. foo<T>( ...
              pattern: /\b\w+\s*<\w+>(?=\()/,
              inside: {
                function: /^\w+/,
                generic: {
                  pattern: /<\w+>/,
                  inside: Prism3.languages.v.generic.inside
                }
              }
            }
          });
        })(Prism2);
      }
      return v_1;
    }
    var vala_1;
    var hasRequiredVala;
    function requireVala() {
      if (hasRequiredVala)
        return vala_1;
      hasRequiredVala = 1;
      vala_1 = vala;
      vala.displayName = "vala";
      vala.aliases = [];
      function vala(Prism2) {
        Prism2.languages.vala = Prism2.languages.extend("clike", {
          // Classes copied from prism-csharp
          "class-name": [
            {
              // (Foo bar, Bar baz)
              pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=(?:\?\s+|\*?\s+\*?)\w)/,
              inside: {
                punctuation: /\./
              }
            },
            {
              // [Foo]
              pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
              lookbehind: true,
              inside: {
                punctuation: /\./
              }
            },
            {
              // class Foo : Bar
              pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
              lookbehind: true,
              inside: {
                punctuation: /\./
              }
            },
            {
              // class Foo
              pattern: /((?:\b(?:class|enum|interface|new|struct)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
              lookbehind: true,
              inside: {
                punctuation: /\./
              }
            }
          ],
          keyword: /\b(?:abstract|as|assert|async|base|bool|break|case|catch|char|class|const|construct|continue|default|delegate|delete|do|double|dynamic|else|ensures|enum|errordomain|extern|finally|float|for|foreach|get|if|in|inline|int|int16|int32|int64|int8|interface|internal|is|lock|long|namespace|new|null|out|override|owned|params|private|protected|public|ref|requires|return|set|short|signal|sizeof|size_t|ssize_t|static|string|struct|switch|this|throw|throws|try|typeof|uchar|uint|uint16|uint32|uint64|uint8|ulong|unichar|unowned|ushort|using|value|var|virtual|void|volatile|weak|while|yield)\b/i,
          function: /\b\w+(?=\s*\()/,
          number: /(?:\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?:f|u?l?)?/i,
          operator: /\+\+|--|&&|\|\||<<=?|>>=?|=>|->|~|[+\-*\/%&^|=!<>]=?|\?\??|\.\.\./,
          punctuation: /[{}[\];(),.:]/,
          constant: /\b[A-Z0-9_]+\b/
        });
        Prism2.languages.insertBefore("vala", "string", {
          "raw-string": {
            pattern: /"""[\s\S]*?"""/,
            greedy: true,
            alias: "string"
          },
          "template-string": {
            pattern: /@"[\s\S]*?"/,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /\$(?:\([^)]*\)|[a-zA-Z]\w*)/,
                inside: {
                  delimiter: {
                    pattern: /^\$\(?|\)$/,
                    alias: "punctuation"
                  },
                  rest: Prism2.languages.vala
                }
              },
              string: /[\s\S]+/
            }
          }
        });
        Prism2.languages.insertBefore("vala", "keyword", {
          regex: {
            pattern: /\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[imsx]{0,4}(?=\s*(?:$|[\r\n,.;})\]]))/,
            greedy: true,
            inside: {
              "regex-source": {
                pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                lookbehind: true,
                alias: "language-regex",
                inside: Prism2.languages.regex
              },
              "regex-delimiter": /^\//,
              "regex-flags": /^[a-z]+$/
            }
          }
        });
      }
      return vala_1;
    }
    var velocity_1;
    var hasRequiredVelocity;
    function requireVelocity() {
      if (hasRequiredVelocity)
        return velocity_1;
      hasRequiredVelocity = 1;
      velocity_1 = velocity;
      velocity.displayName = "velocity";
      velocity.aliases = [];
      function velocity(Prism2) {
        (function(Prism3) {
          Prism3.languages.velocity = Prism3.languages.extend("markup", {});
          var velocity2 = {
            variable: {
              pattern: /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
              lookbehind: true,
              inside: {}
              // See below
            },
            string: {
              pattern: /"[^"]*"|'[^']*'/,
              greedy: true
            },
            number: /\b\d+\b/,
            boolean: /\b(?:false|true)\b/,
            operator: /[=!<>]=?|[+*/%-]|&&|\|\||\.\.|\b(?:eq|g[et]|l[et]|n(?:e|ot))\b/,
            punctuation: /[(){}[\]:,.]/
          };
          velocity2.variable.inside = {
            string: velocity2["string"],
            function: {
              pattern: /([^\w-])[a-z][\w-]*(?=\()/,
              lookbehind: true
            },
            number: velocity2["number"],
            boolean: velocity2["boolean"],
            punctuation: velocity2["punctuation"]
          };
          Prism3.languages.insertBefore("velocity", "comment", {
            unparsed: {
              pattern: /(^|[^\\])#\[\[[\s\S]*?\]\]#/,
              lookbehind: true,
              greedy: true,
              inside: {
                punctuation: /^#\[\[|\]\]#$/
              }
            },
            "velocity-comment": [
              {
                pattern: /(^|[^\\])#\*[\s\S]*?\*#/,
                lookbehind: true,
                greedy: true,
                alias: "comment"
              },
              {
                pattern: /(^|[^\\])##.*/,
                lookbehind: true,
                greedy: true,
                alias: "comment"
              }
            ],
            directive: {
              pattern: /(^|[^\\](?:\\\\)*)#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})(?:\s*\((?:[^()]|\([^()]*\))*\))?/i,
              lookbehind: true,
              inside: {
                keyword: {
                  pattern: /^#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})|\bin\b/,
                  inside: {
                    punctuation: /[{}]/
                  }
                },
                rest: velocity2
              }
            },
            variable: velocity2["variable"]
          });
          Prism3.languages.velocity["tag"].inside["attr-value"].inside.rest = Prism3.languages.velocity;
        })(Prism2);
      }
      return velocity_1;
    }
    var verilog_1;
    var hasRequiredVerilog;
    function requireVerilog() {
      if (hasRequiredVerilog)
        return verilog_1;
      hasRequiredVerilog = 1;
      verilog_1 = verilog;
      verilog.displayName = "verilog";
      verilog.aliases = [];
      function verilog(Prism2) {
        Prism2.languages.verilog = {
          comment: {
            pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
            greedy: true
          },
          string: {
            pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
            greedy: true
          },
          "kernel-function": {
            // support for any kernel function (ex: $display())
            pattern: /\B\$\w+\b/,
            alias: "property"
          },
          // support for user defined constants (ex: `define)
          constant: /\B`\w+\b/,
          function: /\b\w+(?=\()/,
          // support for verilog and system verilog keywords
          keyword: /\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endsequence|endspecify|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
          // bold highlighting for all verilog and system verilog logic blocks
          important: /\b(?:always|always_comb|always_ff|always_latch)\b(?: *@)?/,
          // support for time ticks, vectors, and real numbers
          number: /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b(?:\d*[._])?\d+(?:e[-+]?\d+)?/i,
          operator: /[-+{}^~%*\/?=!<>&|]+/,
          punctuation: /[[\];(),.:]/
        };
      }
      return verilog_1;
    }
    var vhdl_1;
    var hasRequiredVhdl;
    function requireVhdl() {
      if (hasRequiredVhdl)
        return vhdl_1;
      hasRequiredVhdl = 1;
      vhdl_1 = vhdl;
      vhdl.displayName = "vhdl";
      vhdl.aliases = [];
      function vhdl(Prism2) {
        Prism2.languages.vhdl = {
          comment: /--.+/,
          // support for all logic vectors
          "vhdl-vectors": {
            pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
            alias: "number"
          },
          // support for operator overloading included
          "quoted-function": {
            pattern: /"\S+?"(?=\()/,
            alias: "function"
          },
          string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
          constant: /\b(?:library|use)\b/i,
          // support for predefined attributes included
          keyword: /\b(?:'active|'ascending|'base|'delayed|'driving|'driving_value|'event|'high|'image|'instance_name|'last_active|'last_event|'last_value|'left|'leftof|'length|'low|'path_name|'pos|'pred|'quiet|'range|'reverse_range|'right|'rightof|'simple_name|'stable|'succ|'transaction|'val|'value|access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with)\b/i,
          boolean: /\b(?:false|true)\b/i,
          function: /\w+(?=\()/,
          // decimal, based, physical, and exponential numbers supported
          number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
          operator: /[<>]=?|:=|[-+*/&=]|\b(?:abs|and|mod|nand|nor|not|or|rem|rol|ror|sla|sll|sra|srl|xnor|xor)\b/i,
          punctuation: /[{}[\];(),.:]/
        };
      }
      return vhdl_1;
    }
    var vim_1;
    var hasRequiredVim;
    function requireVim() {
      if (hasRequiredVim)
        return vim_1;
      hasRequiredVim = 1;
      vim_1 = vim;
      vim.displayName = "vim";
      vim.aliases = [];
      function vim(Prism2) {
        Prism2.languages.vim = {
          string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
          comment: /".*/,
          function: /\b\w+(?=\()/,
          keyword: /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
          builtin: /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
          number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
          operator: /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
          punctuation: /[{}[\](),;:]/
        };
      }
      return vim_1;
    }
    var visualBasic_1;
    var hasRequiredVisualBasic;
    function requireVisualBasic() {
      if (hasRequiredVisualBasic)
        return visualBasic_1;
      hasRequiredVisualBasic = 1;
      visualBasic_1 = visualBasic;
      visualBasic.displayName = "visualBasic";
      visualBasic.aliases = [];
      function visualBasic(Prism2) {
        Prism2.languages["visual-basic"] = {
          comment: {
            pattern: /(?:['‘’]|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
            inside: {
              keyword: /^REM/i
            }
          },
          directive: {
            pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:\b_[ \t]*(?:\r\n?|\n)|.)+/i,
            alias: "property",
            greedy: true
          },
          string: {
            pattern: /\$?["“”](?:["“”]{2}|[^"“”])*["“”]C?/i,
            greedy: true
          },
          date: {
            pattern: /#[ \t]*(?:\d+([/-])\d+\1\d+(?:[ \t]+(?:\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?))?|\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?)[ \t]*#/i,
            alias: "number"
          },
          number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:[FRD]|U?[ILS])?/i,
          boolean: /\b(?:False|Nothing|True)\b/i,
          keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Until|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Xor)\b/i,
          operator: /[+\-*/\\^<=>&#@$%!]|\b_(?=[ \t]*[\r\n])/,
          punctuation: /[{}().,:?]/
        };
        Prism2.languages.vb = Prism2.languages["visual-basic"];
        Prism2.languages.vba = Prism2.languages["visual-basic"];
      }
      return visualBasic_1;
    }
    var warpscript_1;
    var hasRequiredWarpscript;
    function requireWarpscript() {
      if (hasRequiredWarpscript)
        return warpscript_1;
      hasRequiredWarpscript = 1;
      warpscript_1 = warpscript;
      warpscript.displayName = "warpscript";
      warpscript.aliases = [];
      function warpscript(Prism2) {
        Prism2.languages.warpscript = {
          comment: /#.*|\/\/.*|\/\*[\s\S]*?\*\//,
          string: {
            pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'|<'(?:[^\\']|'(?!>)|\\.)*'>/,
            greedy: true
          },
          variable: /\$\S+/,
          macro: {
            pattern: /@\S+/,
            alias: "property"
          },
          // WarpScript doesn't have any keywords, these are all functions under the control category
          // https://www.warp10.io/tags/control
          keyword: /\b(?:BREAK|CHECKMACRO|CONTINUE|CUDF|DEFINED|DEFINEDMACRO|EVAL|FAIL|FOR|FOREACH|FORSTEP|IFT|IFTE|MSGFAIL|NRETURN|RETHROW|RETURN|SWITCH|TRY|UDF|UNTIL|WHILE)\b/,
          number: /[+-]?\b(?:NaN|Infinity|\d+(?:\.\d*)?(?:[Ee][+-]?\d+)?|0x[\da-fA-F]+|0b[01]+)\b/,
          boolean: /\b(?:F|T|false|true)\b/,
          punctuation: /<%|%>|[{}[\]()]/,
          // Some operators from the "operators" category
          // https://www.warp10.io/tags/operators
          operator: /==|&&?|\|\|?|\*\*?|>>>?|<<|[<>!~]=?|[-/%^]|\+!?|\b(?:AND|NOT|OR)\b/
        };
      }
      return warpscript_1;
    }
    var wasm_1;
    var hasRequiredWasm;
    function requireWasm() {
      if (hasRequiredWasm)
        return wasm_1;
      hasRequiredWasm = 1;
      wasm_1 = wasm;
      wasm.displayName = "wasm";
      wasm.aliases = [];
      function wasm(Prism2) {
        Prism2.languages.wasm = {
          comment: [
            /\(;[\s\S]*?;\)/,
            {
              pattern: /;;.*/,
              greedy: true
            }
          ],
          string: {
            pattern: /"(?:\\[\s\S]|[^"\\])*"/,
            greedy: true
          },
          keyword: [
            {
              pattern: /\b(?:align|offset)=/,
              inside: {
                operator: /=/
              }
            },
            {
              pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
              inside: {
                punctuation: /\./
              }
            },
            /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
          ],
          variable: /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
          number: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
          punctuation: /[()]/
        };
      }
      return wasm_1;
    }
    var webIdl_1;
    var hasRequiredWebIdl;
    function requireWebIdl() {
      if (hasRequiredWebIdl)
        return webIdl_1;
      hasRequiredWebIdl = 1;
      webIdl_1 = webIdl;
      webIdl.displayName = "webIdl";
      webIdl.aliases = [];
      function webIdl(Prism2) {
        (function(Prism3) {
          var id2 = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source;
          var type = "(?:" + /\b(?:unsigned\s+)?long\s+long(?![\w-])/.source + "|" + /\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source + "|" + /(?!(?:unrestricted|unsigned)\b)/.source + id2 + /(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source + ")" + /(?:\s*\?)?/.source;
          var typeInside = {};
          Prism3.languages["web-idl"] = {
            comment: {
              pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
              greedy: true
            },
            string: {
              pattern: /"[^"]*"/,
              greedy: true
            },
            namespace: {
              pattern: RegExp(/(\bnamespace\s+)/.source + id2),
              lookbehind: true
            },
            "class-name": [
              {
                pattern: /(^|[^\w-])(?:iterable|maplike|setlike)\s*<(?:[^<>]|<[^<>]*>)*>/,
                lookbehind: true,
                inside: typeInside
              },
              {
                pattern: RegExp(
                  /(\b(?:attribute|const|deleter|getter|optional|setter)\s+)/.source + type
                ),
                lookbehind: true,
                inside: typeInside
              },
              {
                // callback return type
                pattern: RegExp(
                  "(" + /\bcallback\s+/.source + id2 + /\s*=\s*/.source + ")" + type
                ),
                lookbehind: true,
                inside: typeInside
              },
              {
                // typedef
                pattern: RegExp(/(\btypedef\b\s*)/.source + type),
                lookbehind: true,
                inside: typeInside
              },
              {
                pattern: RegExp(
                  /(\b(?:callback|dictionary|enum|interface(?:\s+mixin)?)\s+)(?!(?:interface|mixin)\b)/.source + id2
                ),
                lookbehind: true
              },
              {
                // inheritance
                pattern: RegExp(/(:\s*)/.source + id2),
                lookbehind: true
              },
              // includes and implements
              RegExp(id2 + /(?=\s+(?:implements|includes)\b)/.source),
              {
                pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + id2),
                lookbehind: true
              },
              {
                // function return type, parameter types, and dictionary members
                pattern: RegExp(
                  type + "(?=" + /\s*(?:\.{3}\s*)?/.source + id2 + /\s*[(),;=]/.source + ")"
                ),
                inside: typeInside
              }
            ],
            builtin: /\b(?:ArrayBuffer|BigInt64Array|BigUint64Array|ByteString|DOMString|DataView|Float32Array|Float64Array|FrozenArray|Int16Array|Int32Array|Int8Array|ObservableArray|Promise|USVString|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray)\b/,
            keyword: [
              /\b(?:async|attribute|callback|const|constructor|deleter|dictionary|enum|getter|implements|includes|inherit|interface|mixin|namespace|null|optional|or|partial|readonly|required|setter|static|stringifier|typedef|unrestricted)\b/,
              // type keywords
              /\b(?:any|bigint|boolean|byte|double|float|iterable|long|maplike|object|octet|record|sequence|setlike|short|symbol|undefined|unsigned|void)\b/
            ],
            boolean: /\b(?:false|true)\b/,
            number: {
              pattern: /(^|[^\w-])-?(?:0x[0-9a-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|NaN|Infinity)(?![\w-])/i,
              lookbehind: true
            },
            operator: /\.{3}|[=:?<>-]/,
            punctuation: /[(){}[\].,;]/
          };
          for (var key in Prism3.languages["web-idl"]) {
            if (key !== "class-name") {
              typeInside[key] = Prism3.languages["web-idl"][key];
            }
          }
          Prism3.languages["webidl"] = Prism3.languages["web-idl"];
        })(Prism2);
      }
      return webIdl_1;
    }
    var wiki_1;
    var hasRequiredWiki;
    function requireWiki() {
      if (hasRequiredWiki)
        return wiki_1;
      hasRequiredWiki = 1;
      wiki_1 = wiki;
      wiki.displayName = "wiki";
      wiki.aliases = [];
      function wiki(Prism2) {
        Prism2.languages.wiki = Prism2.languages.extend("markup", {
          "block-comment": {
            pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
            lookbehind: true,
            alias: "comment"
          },
          heading: {
            pattern: /^(=+)[^=\r\n].*?\1/m,
            inside: {
              punctuation: /^=+|=+$/,
              important: /.+/
            }
          },
          emphasis: {
            // TODO Multi-line
            pattern: /('{2,5}).+?\1/,
            inside: {
              "bold-italic": {
                pattern: /(''''').+?(?=\1)/,
                lookbehind: true,
                alias: ["bold", "italic"]
              },
              bold: {
                pattern: /(''')[^'](?:.*?[^'])?(?=\1)/,
                lookbehind: true
              },
              italic: {
                pattern: /('')[^'](?:.*?[^'])?(?=\1)/,
                lookbehind: true
              },
              punctuation: /^''+|''+$/
            }
          },
          hr: {
            pattern: /^-{4,}/m,
            alias: "punctuation"
          },
          url: [
            /ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:PMID|RFC) +\d+/i,
            /\[\[.+?\]\]|\[.+?\]/
          ],
          variable: [
            /__[A-Z]+__/,
            // FIXME Nested structures should be handled
            // {{formatnum:{{#expr:{{{3}}}}}}}
            /\{{3}.+?\}{3}/,
            /\{\{.+?\}\}/
          ],
          symbol: [/^#redirect/im, /~{3,5}/],
          // Handle table attrs:
          // {|
          // ! style="text-align:left;"| Item
          // |}
          "table-tag": {
            pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
            lookbehind: true,
            inside: {
              "table-bar": {
                pattern: /\|$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.markup["tag"].inside
            }
          },
          punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
        });
        Prism2.languages.insertBefore("wiki", "tag", {
          // Prevent highlighting inside <nowiki>, <source> and <pre> tags
          nowiki: {
            pattern: /<(nowiki|pre|source)\b[^>]*>[\s\S]*?<\/\1>/i,
            inside: {
              tag: {
                pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
                inside: Prism2.languages.markup["tag"].inside
              }
            }
          }
        });
      }
      return wiki_1;
    }
    var wolfram_1;
    var hasRequiredWolfram;
    function requireWolfram() {
      if (hasRequiredWolfram)
        return wolfram_1;
      hasRequiredWolfram = 1;
      wolfram_1 = wolfram;
      wolfram.displayName = "wolfram";
      wolfram.aliases = ["mathematica", "wl", "nb"];
      function wolfram(Prism2) {
        Prism2.languages.wolfram = {
          // Allow one level of nesting - note: regex taken from applescipt
          comment: /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
          string: {
            pattern: /"(?:\\.|[^"\\\r\n])*"/,
            greedy: true
          },
          keyword: /\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
          context: {
            pattern: /\b\w+`+\w*/,
            alias: "class-name"
          },
          blank: {
            pattern: /\b\w+_\b/,
            alias: "regex"
          },
          "global-variable": {
            pattern: /\$\w+/,
            alias: "variable"
          },
          boolean: /\b(?:False|True)\b/,
          number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
          operator: /\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\^|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
          punctuation: /[{}[\];(),.:]/
        };
        Prism2.languages.mathematica = Prism2.languages.wolfram;
        Prism2.languages.wl = Prism2.languages.wolfram;
        Prism2.languages.nb = Prism2.languages.wolfram;
      }
      return wolfram_1;
    }
    var wren_1;
    var hasRequiredWren;
    function requireWren() {
      if (hasRequiredWren)
        return wren_1;
      hasRequiredWren = 1;
      wren_1 = wren;
      wren.displayName = "wren";
      wren.aliases = [];
      function wren(Prism2) {
        Prism2.languages.wren = {
          // Multiline comments in Wren can have nested multiline comments
          // Comments: // and /* */
          comment: [
            {
              // support 3 levels of nesting
              // regex: \/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\/
              pattern: /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
              greedy: true
            },
            {
              pattern: /(^|[^\\:])\/\/.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          // Triple quoted strings are multiline but cannot have interpolation (raw strings)
          // Based on prism-python.js
          "triple-quoted-string": {
            pattern: /"""[\s\S]*?"""/,
            greedy: true,
            alias: "string"
          },
          // see below
          "string-literal": null,
          // #!/usr/bin/env wren on the first line
          hashbang: {
            pattern: /^#!\/.+/,
            greedy: true,
            alias: "comment"
          },
          // Attributes are special keywords to add meta data to classes
          attribute: {
            // #! attributes are stored in class properties
            // #!myvar = true
            // #attributes are not stored and dismissed at compilation
            pattern: /#!?[ \t\u3000]*\w+/,
            alias: "keyword"
          },
          "class-name": [
            {
              // class definition
              // class Meta {}
              pattern: /(\bclass\s+)\w+/,
              lookbehind: true
            },
            // A class must always start with an uppercase.
            // File.read
            /\b[A-Z][a-z\d_]*\b/
          ],
          // A constant can be a variable, class, property or method. Just named in all uppercase letters
          constant: /\b[A-Z][A-Z\d_]*\b/,
          null: {
            pattern: /\bnull\b/,
            alias: "keyword"
          },
          keyword: /\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
          boolean: /\b(?:false|true)\b/,
          number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
          // Functions can be Class.method()
          function: /\b[a-z_]\w*(?=\s*[({])/i,
          operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
          punctuation: /[\[\](){}.,;]/
        };
        Prism2.languages.wren["string-literal"] = {
          // A single quote string is multiline and can have interpolation (similar to JS backticks ``)
          pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
          lookbehind: true,
          greedy: true,
          inside: {
            interpolation: {
              // "%(interpolation)"
              pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
              lookbehind: true,
              inside: {
                expression: {
                  pattern: /^(%\()[\s\S]+(?=\)$)/,
                  lookbehind: true,
                  inside: Prism2.languages.wren
                },
                "interpolation-punctuation": {
                  pattern: /^%\(|\)$/,
                  alias: "punctuation"
                }
              }
            },
            string: /[\s\S]+/
          }
        };
      }
      return wren_1;
    }
    var xeora_1;
    var hasRequiredXeora;
    function requireXeora() {
      if (hasRequiredXeora)
        return xeora_1;
      hasRequiredXeora = 1;
      xeora_1 = xeora;
      xeora.displayName = "xeora";
      xeora.aliases = ["xeoracube"];
      function xeora(Prism2) {
        (function(Prism3) {
          Prism3.languages.xeora = Prism3.languages.extend("markup", {
            constant: {
              pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
              inside: {
                punctuation: {
                  pattern: /\$/
                }
              }
            },
            variable: {
              pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
              inside: {
                punctuation: {
                  pattern: /[$.]/
                },
                operator: {
                  pattern: /#+|[-+*~=^@]/
                }
              }
            },
            "function-inline": {
              pattern: /\$F:[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\$/,
              inside: {
                variable: {
                  pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
                  inside: {
                    punctuation: {
                      pattern: /[,.|]/
                    },
                    operator: {
                      pattern: /#+|[-+*~=^@]/
                    }
                  }
                },
                punctuation: {
                  pattern: /\$\w:|[$:?.,|]/
                }
              },
              alias: "function"
            },
            "function-block": {
              pattern: /\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
              inside: {
                punctuation: {
                  pattern: /[$:{}?.,|]/
                }
              },
              alias: "function"
            },
            "directive-inline": {
              pattern: /\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\/\w.]+\$/,
              inside: {
                punctuation: {
                  pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
                  inside: {
                    tag: {
                      pattern: /#\d/
                    }
                  }
                }
              },
              alias: "function"
            },
            "directive-block-open": {
              pattern: /\$\w+:\{|\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\w.]+:\{(?:![A-Z]+)?/,
              inside: {
                punctuation: {
                  pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
                  inside: {
                    tag: {
                      pattern: /#\d/
                    }
                  }
                },
                attribute: {
                  pattern: /![A-Z]+$/,
                  inside: {
                    punctuation: {
                      pattern: /!/
                    }
                  },
                  alias: "keyword"
                }
              },
              alias: "function"
            },
            "directive-block-separator": {
              pattern: /\}:[-\w.]+:\{/,
              inside: {
                punctuation: {
                  pattern: /[:{}]/
                }
              },
              alias: "function"
            },
            "directive-block-close": {
              pattern: /\}:[-\w.]+\$/,
              inside: {
                punctuation: {
                  pattern: /[:{}$]/
                }
              },
              alias: "function"
            }
          });
          Prism3.languages.insertBefore(
            "inside",
            "punctuation",
            {
              variable: Prism3.languages.xeora["function-inline"].inside["variable"]
            },
            Prism3.languages.xeora["function-block"]
          );
          Prism3.languages.xeoracube = Prism3.languages.xeora;
        })(Prism2);
      }
      return xeora_1;
    }
    var xmlDoc_1;
    var hasRequiredXmlDoc;
    function requireXmlDoc() {
      if (hasRequiredXmlDoc)
        return xmlDoc_1;
      hasRequiredXmlDoc = 1;
      xmlDoc_1 = xmlDoc;
      xmlDoc.displayName = "xmlDoc";
      xmlDoc.aliases = [];
      function xmlDoc(Prism2) {
        (function(Prism3) {
          function insertDocComment(lang, docComment) {
            if (Prism3.languages[lang]) {
              Prism3.languages.insertBefore(lang, "comment", {
                "doc-comment": docComment
              });
            }
          }
          var tag = Prism3.languages.markup.tag;
          var slashDocComment = {
            pattern: /\/\/\/.*/,
            greedy: true,
            alias: "comment",
            inside: {
              tag
            }
          };
          var tickDocComment = {
            pattern: /'''.*/,
            greedy: true,
            alias: "comment",
            inside: {
              tag
            }
          };
          insertDocComment("csharp", slashDocComment);
          insertDocComment("fsharp", slashDocComment);
          insertDocComment("vbnet", tickDocComment);
        })(Prism2);
      }
      return xmlDoc_1;
    }
    var xojo_1;
    var hasRequiredXojo;
    function requireXojo() {
      if (hasRequiredXojo)
        return xojo_1;
      hasRequiredXojo = 1;
      xojo_1 = xojo;
      xojo.displayName = "xojo";
      xojo.aliases = [];
      function xojo(Prism2) {
        Prism2.languages.xojo = {
          comment: {
            pattern: /(?:'|\/\/|Rem\b).+/i,
            greedy: true
          },
          string: {
            pattern: /"(?:""|[^"])*"/,
            greedy: true
          },
          number: [/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i, /&[bchou][a-z\d]+/i],
          directive: {
            pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\b/i,
            alias: "property"
          },
          keyword: /\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\b/i,
          operator: /<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\b/i,
          punctuation: /[.,;:()]/
        };
      }
      return xojo_1;
    }
    var xquery_1;
    var hasRequiredXquery;
    function requireXquery() {
      if (hasRequiredXquery)
        return xquery_1;
      hasRequiredXquery = 1;
      xquery_1 = xquery;
      xquery.displayName = "xquery";
      xquery.aliases = [];
      function xquery(Prism2) {
        (function(Prism3) {
          Prism3.languages.xquery = Prism3.languages.extend("markup", {
            "xquery-comment": {
              pattern: /\(:[\s\S]*?:\)/,
              greedy: true,
              alias: "comment"
            },
            string: {
              pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
              greedy: true
            },
            extension: {
              pattern: /\(#.+?#\)/,
              alias: "symbol"
            },
            variable: /\$[-\w:]+/,
            axis: {
              pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
              lookbehind: true,
              alias: "operator"
            },
            "keyword-operator": {
              pattern: /(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
              lookbehind: true,
              alias: "operator"
            },
            keyword: {
              pattern: /(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
              lookbehind: true
            },
            function: /[\w-]+(?::[\w-]+)*(?=\s*\()/,
            "xquery-element": {
              pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
              lookbehind: true,
              alias: "tag"
            },
            "xquery-attribute": {
              pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
              lookbehind: true,
              alias: "attr-name"
            },
            builtin: {
              pattern: /(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
              lookbehind: true
            },
            number: /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
            operator: [
              /[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/,
              {
                pattern: /(\s)-(?=\s)/,
                lookbehind: true
              }
            ],
            punctuation: /[[\](){},;:/]/
          });
          Prism3.languages.xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
          Prism3.languages.xquery["tag"].inside["attr-value"].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/;
          Prism3.languages.xquery["tag"].inside["attr-value"].inside["punctuation"] = /^="|"$/;
          Prism3.languages.xquery["tag"].inside["attr-value"].inside["expression"] = {
            // Allow for two levels of nesting
            pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
            inside: Prism3.languages.xquery,
            alias: "language-xquery"
          };
          var stringifyToken = function(token) {
            if (typeof token === "string") {
              return token;
            }
            if (typeof token.content === "string") {
              return token.content;
            }
            return token.content.map(stringifyToken).join("");
          };
          var walkTokens = function(tokens) {
            var openedTags = [];
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              var notTagNorBrace = false;
              if (typeof token !== "string") {
                if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
                  if (token.content[0].content[0].content === "</") {
                    if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
                      openedTags.pop();
                    }
                  } else {
                    if (token.content[token.content.length - 1].content === "/>")
                      ;
                    else {
                      openedTags.push({
                        tagName: stringifyToken(token.content[0].content[1]),
                        openedBraces: 0
                      });
                    }
                  }
                } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{" && // Ignore `{{`
                (!tokens[i + 1] || tokens[i + 1].type !== "punctuation" || tokens[i + 1].content !== "{") && (!tokens[i - 1] || tokens[i - 1].type !== "plain-text" || tokens[i - 1].content !== "{")) {
                  openedTags[openedTags.length - 1].openedBraces++;
                } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
                  openedTags[openedTags.length - 1].openedBraces--;
                } else if (token.type !== "comment") {
                  notTagNorBrace = true;
                }
              }
              if (notTagNorBrace || typeof token === "string") {
                if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
                  var plainText = stringifyToken(token);
                  if (i < tokens.length - 1 && (typeof tokens[i + 1] === "string" || tokens[i + 1].type === "plain-text")) {
                    plainText += stringifyToken(tokens[i + 1]);
                    tokens.splice(i + 1, 1);
                  }
                  if (i > 0 && (typeof tokens[i - 1] === "string" || tokens[i - 1].type === "plain-text")) {
                    plainText = stringifyToken(tokens[i - 1]) + plainText;
                    tokens.splice(i - 1, 1);
                    i--;
                  }
                  if (/^\s+$/.test(plainText)) {
                    tokens[i] = plainText;
                  } else {
                    tokens[i] = new Prism3.Token(
                      "plain-text",
                      plainText,
                      null,
                      plainText
                    );
                  }
                }
              }
              if (token.content && typeof token.content !== "string") {
                walkTokens(token.content);
              }
            }
          };
          Prism3.hooks.add("after-tokenize", function(env2) {
            if (env2.language !== "xquery") {
              return;
            }
            walkTokens(env2.tokens);
          });
        })(Prism2);
      }
      return xquery_1;
    }
    var yang_1;
    var hasRequiredYang;
    function requireYang() {
      if (hasRequiredYang)
        return yang_1;
      hasRequiredYang = 1;
      yang_1 = yang;
      yang.displayName = "yang";
      yang.aliases = [];
      function yang(Prism2) {
        Prism2.languages.yang = {
          // https://tools.ietf.org/html/rfc6020#page-34
          // http://www.yang-central.org/twiki/bin/view/Main/YangExamples
          comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
          string: {
            pattern: /"(?:[^\\"]|\\.)*"|'[^']*'/,
            greedy: true
          },
          keyword: {
            pattern: /(^|[{};\r\n][ \t]*)[a-z_][\w.-]*/i,
            lookbehind: true
          },
          namespace: {
            pattern: /(\s)[a-z_][\w.-]*(?=:)/i,
            lookbehind: true
          },
          boolean: /\b(?:false|true)\b/,
          operator: /\+/,
          punctuation: /[{};:]/
        };
      }
      return yang_1;
    }
    var zig_1;
    var hasRequiredZig;
    function requireZig() {
      if (hasRequiredZig)
        return zig_1;
      hasRequiredZig = 1;
      zig_1 = zig;
      zig.displayName = "zig";
      zig.aliases = [];
      function zig(Prism2) {
        (function(Prism3) {
          function literal(str) {
            return function() {
              return str;
            };
          }
          var keyword = /\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/;
          var IDENTIFIER = "\\b(?!" + keyword.source + ")(?!\\d)\\w+\\b";
          var ALIGN = /align\s*\((?:[^()]|\([^()]*\))*\)/.source;
          var PREFIX_TYPE_OP = /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(
            /<ALIGN>/g,
            literal(ALIGN)
          );
          var SUFFIX_EXPR = /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(
            /<ID>/g,
            literal(IDENTIFIER)
          );
          var TYPE = "(?!\\s)(?:!?\\s*(?:" + PREFIX_TYPE_OP + "\\s*)*" + SUFFIX_EXPR + ")+";
          Prism3.languages.zig = {
            comment: [
              {
                pattern: /\/\/[/!].*/,
                alias: "doc-comment"
              },
              /\/{2}.*/
            ],
            string: [
              {
                // "string" and c"string"
                pattern: /(^|[^\\@])c?"(?:[^"\\\r\n]|\\.)*"/,
                lookbehind: true,
                greedy: true
              },
              {
                // multiline strings and c-strings
                pattern: /([\r\n])([ \t]+c?\\{2}).*(?:(?:\r\n?|\n)\2.*)*/,
                lookbehind: true,
                greedy: true
              }
            ],
            char: {
              // characters 'a', '\n', '\xFF', '\u{10FFFF}'
              pattern: /(^|[^\\])'(?:[^'\\\r\n]|[\uD800-\uDFFF]{2}|\\(?:.|x[a-fA-F\d]{2}|u\{[a-fA-F\d]{1,6}\}))'/,
              lookbehind: true,
              greedy: true
            },
            builtin: /\B@(?!\d)\w+(?=\s*\()/,
            label: {
              pattern: /(\b(?:break|continue)\s*:\s*)\w+\b|\b(?!\d)\w+\b(?=\s*:\s*(?:\{|while\b))/,
              lookbehind: true
            },
            "class-name": [
              // const Foo = struct {};
              /\b(?!\d)\w+(?=\s*=\s*(?:(?:extern|packed)\s+)?(?:enum|struct|union)\s*[({])/,
              {
                // const x: i32 = 9;
                // var x: Bar;
                // fn foo(x: bool, y: f32) void {}
                pattern: RegExp(
                  /(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))
                ),
                lookbehind: true,
                inside: null
                // see below
              },
              {
                // extern fn foo(x: f64) f64; (optional alignment)
                pattern: RegExp(
                  /(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))
                ),
                lookbehind: true,
                inside: null
                // see below
              }
            ],
            "builtin-type": {
              pattern: /\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\b/,
              alias: "keyword"
            },
            keyword,
            function: /\b(?!\d)\w+(?=\s*\()/,
            number: /\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\d]+(?:\.[a-fA-F\d]*)?(?:[pP][+-]?[a-fA-F\d]+)?|\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\b/,
            boolean: /\b(?:false|true)\b/,
            operator: /\.[*?]|\.{2,3}|[-=]>|\*\*|\+\+|\|\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,
            punctuation: /[.:,;(){}[\]]/
          };
          Prism3.languages.zig["class-name"].forEach(function(obj) {
            if (obj.inside === null) {
              obj.inside = Prism3.languages.zig;
            }
          });
        })(Prism2);
      }
      return zig_1;
    }
    var refractor = core;
    var refractor_1 = refractor;
    refractor.register(requireAbap());
    refractor.register(requireAbnf());
    refractor.register(requireActionscript());
    refractor.register(requireAda());
    refractor.register(requireAgda());
    refractor.register(requireAl());
    refractor.register(requireAntlr4());
    refractor.register(requireApacheconf());
    refractor.register(requireApex());
    refractor.register(requireApl());
    refractor.register(requireApplescript());
    refractor.register(requireAql());
    refractor.register(requireArduino());
    refractor.register(requireArff());
    refractor.register(requireAsciidoc());
    refractor.register(requireAsm6502());
    refractor.register(requireAsmatmel());
    refractor.register(requireAspnet());
    refractor.register(requireAutohotkey());
    refractor.register(requireAutoit());
    refractor.register(requireAvisynth());
    refractor.register(requireAvroIdl());
    refractor.register(requireBash());
    refractor.register(requireBasic());
    refractor.register(requireBatch());
    refractor.register(requireBbcode());
    refractor.register(requireBicep());
    refractor.register(requireBirb());
    refractor.register(requireBison());
    refractor.register(requireBnf());
    refractor.register(requireBrainfuck());
    refractor.register(requireBrightscript());
    refractor.register(requireBro());
    refractor.register(requireBsl());
    refractor.register(requireC());
    refractor.register(requireCfscript());
    refractor.register(requireChaiscript());
    refractor.register(requireCil());
    refractor.register(requireClojure());
    refractor.register(requireCmake());
    refractor.register(requireCobol());
    refractor.register(requireCoffeescript());
    refractor.register(requireConcurnas());
    refractor.register(requireCoq());
    refractor.register(requireCpp());
    refractor.register(requireCrystal());
    refractor.register(requireCsharp());
    refractor.register(requireCshtml());
    refractor.register(requireCsp());
    refractor.register(requireCssExtras());
    refractor.register(requireCsv());
    refractor.register(requireCypher());
    refractor.register(requireD());
    refractor.register(requireDart());
    refractor.register(requireDataweave());
    refractor.register(requireDax());
    refractor.register(requireDhall());
    refractor.register(requireDiff());
    refractor.register(requireDjango());
    refractor.register(requireDnsZoneFile());
    refractor.register(requireDocker());
    refractor.register(requireDot());
    refractor.register(requireEbnf());
    refractor.register(requireEditorconfig());
    refractor.register(requireEiffel());
    refractor.register(requireEjs());
    refractor.register(requireElixir());
    refractor.register(requireElm());
    refractor.register(requireErb());
    refractor.register(requireErlang());
    refractor.register(requireEtlua());
    refractor.register(requireExcelFormula());
    refractor.register(requireFactor());
    refractor.register(require_false());
    refractor.register(requireFirestoreSecurityRules());
    refractor.register(requireFlow());
    refractor.register(requireFortran());
    refractor.register(requireFsharp());
    refractor.register(requireFtl());
    refractor.register(requireGap());
    refractor.register(requireGcode());
    refractor.register(requireGdscript());
    refractor.register(requireGedcom());
    refractor.register(requireGherkin());
    refractor.register(requireGit());
    refractor.register(requireGlsl());
    refractor.register(requireGml());
    refractor.register(requireGn());
    refractor.register(requireGoModule());
    refractor.register(requireGo());
    refractor.register(requireGraphql());
    refractor.register(requireGroovy());
    refractor.register(requireHaml());
    refractor.register(requireHandlebars());
    refractor.register(requireHaskell());
    refractor.register(requireHaxe());
    refractor.register(requireHcl());
    refractor.register(requireHlsl());
    refractor.register(requireHoon());
    refractor.register(requireHpkp());
    refractor.register(requireHsts());
    refractor.register(requireHttp());
    refractor.register(requireIchigojam());
    refractor.register(requireIcon());
    refractor.register(requireIcuMessageFormat());
    refractor.register(requireIdris());
    refractor.register(requireIecst());
    refractor.register(requireIgnore());
    refractor.register(requireInform7());
    refractor.register(requireIni());
    refractor.register(requireIo());
    refractor.register(requireJ());
    refractor.register(requireJava());
    refractor.register(requireJavadoc());
    refractor.register(requireJavadoclike());
    refractor.register(requireJavastacktrace());
    refractor.register(requireJexl());
    refractor.register(requireJolie());
    refractor.register(requireJq());
    refractor.register(requireJsExtras());
    refractor.register(requireJsTemplates());
    refractor.register(requireJsdoc());
    refractor.register(requireJson());
    refractor.register(requireJson5());
    refractor.register(requireJsonp());
    refractor.register(requireJsstacktrace());
    refractor.register(requireJsx());
    refractor.register(requireJulia());
    refractor.register(requireKeepalived());
    refractor.register(requireKeyman());
    refractor.register(requireKotlin());
    refractor.register(requireKumir());
    refractor.register(requireKusto());
    refractor.register(requireLatex());
    refractor.register(requireLatte());
    refractor.register(requireLess());
    refractor.register(requireLilypond());
    refractor.register(requireLiquid());
    refractor.register(requireLisp());
    refractor.register(requireLivescript());
    refractor.register(requireLlvm());
    refractor.register(requireLog());
    refractor.register(requireLolcode());
    refractor.register(requireLua());
    refractor.register(requireMagma());
    refractor.register(requireMakefile());
    refractor.register(requireMarkdown());
    refractor.register(requireMarkupTemplating());
    refractor.register(requireMatlab());
    refractor.register(requireMaxscript());
    refractor.register(requireMel());
    refractor.register(requireMermaid());
    refractor.register(requireMizar());
    refractor.register(requireMongodb());
    refractor.register(requireMonkey());
    refractor.register(requireMoonscript());
    refractor.register(requireN1ql());
    refractor.register(requireN4js());
    refractor.register(requireNand2tetrisHdl());
    refractor.register(requireNaniscript());
    refractor.register(requireNasm());
    refractor.register(requireNeon());
    refractor.register(requireNevod());
    refractor.register(requireNginx());
    refractor.register(requireNim());
    refractor.register(requireNix());
    refractor.register(requireNsis());
    refractor.register(requireObjectivec());
    refractor.register(requireOcaml());
    refractor.register(requireOpencl());
    refractor.register(requireOpenqasm());
    refractor.register(requireOz());
    refractor.register(requireParigp());
    refractor.register(requireParser());
    refractor.register(requirePascal());
    refractor.register(requirePascaligo());
    refractor.register(requirePcaxis());
    refractor.register(requirePeoplecode());
    refractor.register(requirePerl());
    refractor.register(requirePhpExtras());
    refractor.register(requirePhp());
    refractor.register(requirePhpdoc());
    refractor.register(requirePlsql());
    refractor.register(requirePowerquery());
    refractor.register(requirePowershell());
    refractor.register(requireProcessing());
    refractor.register(requireProlog());
    refractor.register(requirePromql());
    refractor.register(requireProperties());
    refractor.register(requireProtobuf());
    refractor.register(requirePsl());
    refractor.register(requirePug());
    refractor.register(requirePuppet());
    refractor.register(requirePure());
    refractor.register(requirePurebasic());
    refractor.register(requirePurescript());
    refractor.register(requirePython());
    refractor.register(requireQ());
    refractor.register(requireQml());
    refractor.register(requireQore());
    refractor.register(requireQsharp());
    refractor.register(requireR());
    refractor.register(requireRacket());
    refractor.register(requireReason());
    refractor.register(requireRegex());
    refractor.register(requireRego());
    refractor.register(requireRenpy());
    refractor.register(requireRest());
    refractor.register(requireRip());
    refractor.register(requireRoboconf());
    refractor.register(requireRobotframework());
    refractor.register(requireRuby());
    refractor.register(requireRust());
    refractor.register(requireSas());
    refractor.register(requireSass());
    refractor.register(requireScala());
    refractor.register(requireScheme());
    refractor.register(requireScss());
    refractor.register(requireShellSession());
    refractor.register(requireSmali());
    refractor.register(requireSmalltalk());
    refractor.register(requireSmarty());
    refractor.register(requireSml());
    refractor.register(requireSolidity());
    refractor.register(requireSolutionFile());
    refractor.register(requireSoy());
    refractor.register(requireSparql());
    refractor.register(requireSplunkSpl());
    refractor.register(requireSqf());
    refractor.register(requireSql());
    refractor.register(requireSquirrel());
    refractor.register(requireStan());
    refractor.register(requireStylus());
    refractor.register(requireSwift());
    refractor.register(requireSystemd());
    refractor.register(requireT4Cs());
    refractor.register(requireT4Templating());
    refractor.register(requireT4Vb());
    refractor.register(requireTap());
    refractor.register(requireTcl());
    refractor.register(requireTextile());
    refractor.register(requireToml());
    refractor.register(requireTremor());
    refractor.register(requireTsx());
    refractor.register(requireTt2());
    refractor.register(requireTurtle());
    refractor.register(requireTwig());
    refractor.register(requireTypescript());
    refractor.register(requireTyposcript());
    refractor.register(requireUnrealscript());
    refractor.register(requireUorazor());
    refractor.register(requireUri());
    refractor.register(requireV());
    refractor.register(requireVala());
    refractor.register(requireVbnet());
    refractor.register(requireVelocity());
    refractor.register(requireVerilog());
    refractor.register(requireVhdl());
    refractor.register(requireVim());
    refractor.register(requireVisualBasic());
    refractor.register(requireWarpscript());
    refractor.register(requireWasm());
    refractor.register(requireWebIdl());
    refractor.register(requireWiki());
    refractor.register(requireWolfram());
    refractor.register(requireWren());
    refractor.register(requireXeora());
    refractor.register(requireXmlDoc());
    refractor.register(requireXojo());
    refractor.register(requireXquery());
    refractor.register(requireYaml());
    refractor.register(requireYang());
    refractor.register(requireZig());
    var highlighter = highlight$1(refractor_1, defaultStyle);
    highlighter.supportedLanguages = supportedLanguages;
    const SyntaxHighlighter = highlighter;
    function typeofJsonValue(value) {
      let t2 = typeof value;
      if (t2 == "object") {
        if (Array.isArray(value))
          return "array";
        if (value === null)
          return "null";
      }
      return t2;
    }
    function isJsonObject(value) {
      return value !== null && typeof value == "object" && !Array.isArray(value);
    }
    let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    let decTable = [];
    for (let i = 0; i < encTable.length; i++)
      decTable[encTable[i].charCodeAt(0)] = i;
    decTable["-".charCodeAt(0)] = encTable.indexOf("+");
    decTable["_".charCodeAt(0)] = encTable.indexOf("/");
    function base64decode(base64Str) {
      let es = base64Str.length * 3 / 4;
      if (base64Str[base64Str.length - 2] == "=")
        es -= 2;
      else if (base64Str[base64Str.length - 1] == "=")
        es -= 1;
      let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p2 = 0;
      for (let i = 0; i < base64Str.length; i++) {
        b = decTable[base64Str.charCodeAt(i)];
        if (b === void 0) {
          switch (base64Str[i]) {
            case "=":
              groupPos = 0;
            case "\n":
            case "\r":
            case "	":
            case " ":
              continue;
            default:
              throw Error(`invalid base64 string.`);
          }
        }
        switch (groupPos) {
          case 0:
            p2 = b;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = p2 << 2 | (b & 48) >> 4;
            p2 = b;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = (p2 & 15) << 4 | (b & 60) >> 2;
            p2 = b;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = (p2 & 3) << 6 | b;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1)
        throw Error(`invalid base64 string.`);
      return bytes.subarray(0, bytePos);
    }
    function base64encode(bytes) {
      let base64 = "", groupPos = 0, b, p2 = 0;
      for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
          case 0:
            base64 += encTable[b >> 2];
            p2 = (b & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += encTable[p2 | b >> 4];
            p2 = (b & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += encTable[p2 | b >> 6];
            base64 += encTable[b & 63];
            groupPos = 0;
            break;
        }
      }
      if (groupPos) {
        base64 += encTable[p2];
        base64 += "=";
        if (groupPos == 1)
          base64 += "=";
      }
      return base64;
    }
    var UnknownFieldHandler;
    (function(UnknownFieldHandler2) {
      UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
      UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data2) => {
        let container = is(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
        container.push({ no: fieldNo, wireType, data: data2 });
      };
      UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
        for (let { no, wireType, data: data2 } of UnknownFieldHandler2.list(message))
          writer.tag(no, wireType).raw(data2);
      };
      UnknownFieldHandler2.list = (message, fieldNo) => {
        if (is(message)) {
          let all2 = message[UnknownFieldHandler2.symbol];
          return fieldNo ? all2.filter((uf2) => uf2.no == fieldNo) : all2;
        }
        return [];
      };
      UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
      const is = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
    })(UnknownFieldHandler || (UnknownFieldHandler = {}));
    function mergeBinaryOptions(a, b) {
      return Object.assign(Object.assign({}, a), b);
    }
    var WireType;
    (function(WireType2) {
      WireType2[WireType2["Varint"] = 0] = "Varint";
      WireType2[WireType2["Bit64"] = 1] = "Bit64";
      WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
      WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
      WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
      WireType2[WireType2["Bit32"] = 5] = "Bit32";
    })(WireType || (WireType = {}));
    function varint64read() {
      let lowBits = 0;
      let highBits = 0;
      for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 127) << shift;
        if ((b & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      let middleByte = this.buf[this.pos++];
      lowBits |= (middleByte & 15) << 28;
      highBits = (middleByte & 112) >> 4;
      if ((middleByte & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
      for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 127) << shift;
        if ((b & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      throw new Error("invalid varint");
    }
    function varint64write(lo, hi2, bytes) {
      for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !(shift >>> 7 == 0 && hi2 == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes.push(byte);
        if (!hasNext) {
          return;
        }
      }
      const splitBits = lo >>> 28 & 15 | (hi2 & 7) << 4;
      const hasMoreBits = !(hi2 >> 3 == 0);
      bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
      if (!hasMoreBits) {
        return;
      }
      for (let i = 3; i < 31; i = i + 7) {
        const shift = hi2 >>> i;
        const hasNext = !(shift >>> 7 == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes.push(byte);
        if (!hasNext) {
          return;
        }
      }
      bytes.push(hi2 >>> 31 & 1);
    }
    const TWO_PWR_32_DBL$1 = (1 << 16) * (1 << 16);
    function int64fromString(dec) {
      let minus = dec[0] == "-";
      if (minus)
        dec = dec.slice(1);
      const base = 1e6;
      let lowBits = 0;
      let highBits = 0;
      function add1e6digit(begin, end) {
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        if (lowBits >= TWO_PWR_32_DBL$1) {
          highBits = highBits + (lowBits / TWO_PWR_32_DBL$1 | 0);
          lowBits = lowBits % TWO_PWR_32_DBL$1;
        }
      }
      add1e6digit(-24, -18);
      add1e6digit(-18, -12);
      add1e6digit(-12, -6);
      add1e6digit(-6);
      return [minus, lowBits, highBits];
    }
    function int64toString(bitsLow, bitsHigh) {
      if (bitsHigh <= 2097151) {
        return "" + (TWO_PWR_32_DBL$1 * bitsHigh + (bitsLow >>> 0));
      }
      let low = bitsLow & 16777215;
      let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
      let high = bitsHigh >> 16 & 65535;
      let digitA = low + mid * 6777216 + high * 6710656;
      let digitB = mid + high * 8147497;
      let digitC = high * 2;
      let base = 1e7;
      if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
      }
      if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
      }
      function decimalFrom1e7(digit1e7, needLeadingZeros) {
        let partial = digit1e7 ? String(digit1e7) : "";
        if (needLeadingZeros) {
          return "0000000".slice(partial.length) + partial;
        }
        return partial;
      }
      return decimalFrom1e7(
        digitC,
        /*needLeadingZeros=*/
        0
      ) + decimalFrom1e7(
        digitB,
        /*needLeadingZeros=*/
        digitC
      ) + // If the final 1e7 digit didn't need leading zeros, we would have
      // returned via the trivial code path at the top.
      decimalFrom1e7(
        digitA,
        /*needLeadingZeros=*/
        1
      );
    }
    function varint32write(value, bytes) {
      if (value >= 0) {
        while (value > 127) {
          bytes.push(value & 127 | 128);
          value = value >>> 7;
        }
        bytes.push(value);
      } else {
        for (let i = 0; i < 9; i++) {
          bytes.push(value & 127 | 128);
          value = value >> 7;
        }
        bytes.push(1);
      }
    }
    function varint32read() {
      let b = this.buf[this.pos++];
      let result = b & 127;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 7;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 14;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 21;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 15) << 28;
      for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
      if ((b & 128) != 0)
        throw new Error("invalid varint");
      this.assertBounds();
      return result >>> 0;
    }
    function detectBi() {
      const dv = new DataView(new ArrayBuffer(8));
      const ok2 = globalThis.BigInt !== void 0 && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
      return ok2 ? {
        MIN: BigInt("-9223372036854775808"),
        MAX: BigInt("9223372036854775807"),
        UMIN: BigInt("0"),
        UMAX: BigInt("18446744073709551615"),
        C: BigInt,
        V: dv
      } : void 0;
    }
    const BI = detectBi();
    function assertBi(bi2) {
      if (!bi2)
        throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
    }
    const RE_DECIMAL_STR = /^-?[0-9]+$/;
    const TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
    class SharedPbLong {
      /**
       * Create a new instance with the given bits.
       */
      constructor(lo, hi2) {
        this.lo = lo | 0;
        this.hi = hi2 | 0;
      }
      /**
       * Is this instance equal to 0?
       */
      isZero() {
        return this.lo == 0 && this.hi == 0;
      }
      /**
       * Convert to a native number.
       */
      toNumber() {
        let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
        if (!Number.isSafeInteger(result))
          throw new Error("cannot convert to safe number");
        return result;
      }
    }
    class PbULong extends SharedPbLong {
      /**
       * Create instance from a `string`, `number` or `bigint`.
       */
      static from(value) {
        if (BI)
          switch (typeof value) {
            case "string":
              if (value == "0")
                return this.ZERO;
              if (value == "")
                throw new Error("string is no integer");
              value = BI.C(value);
            case "number":
              if (value === 0)
                return this.ZERO;
              value = BI.C(value);
            case "bigint":
              if (!value)
                return this.ZERO;
              if (value < BI.UMIN)
                throw new Error("signed value for ulong");
              if (value > BI.UMAX)
                throw new Error("ulong too large");
              BI.V.setBigUint64(0, value, true);
              return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
          }
        else
          switch (typeof value) {
            case "string":
              if (value == "0")
                return this.ZERO;
              value = value.trim();
              if (!RE_DECIMAL_STR.test(value))
                throw new Error("string is no integer");
              let [minus, lo, hi2] = int64fromString(value);
              if (minus)
                throw new Error("signed value");
              return new PbULong(lo, hi2);
            case "number":
              if (value == 0)
                return this.ZERO;
              if (!Number.isSafeInteger(value))
                throw new Error("number is no integer");
              if (value < 0)
                throw new Error("signed value for ulong");
              return new PbULong(value, value / TWO_PWR_32_DBL);
          }
        throw new Error("unknown value " + typeof value);
      }
      /**
       * Convert to decimal string.
       */
      toString() {
        return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
      }
      /**
       * Convert to native bigint.
       */
      toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigUint64(0, true);
      }
    }
    PbULong.ZERO = new PbULong(0, 0);
    class PbLong extends SharedPbLong {
      /**
       * Create instance from a `string`, `number` or `bigint`.
       */
      static from(value) {
        if (BI)
          switch (typeof value) {
            case "string":
              if (value == "0")
                return this.ZERO;
              if (value == "")
                throw new Error("string is no integer");
              value = BI.C(value);
            case "number":
              if (value === 0)
                return this.ZERO;
              value = BI.C(value);
            case "bigint":
              if (!value)
                return this.ZERO;
              if (value < BI.MIN)
                throw new Error("ulong too small");
              if (value > BI.MAX)
                throw new Error("ulong too large");
              BI.V.setBigInt64(0, value, true);
              return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
          }
        else
          switch (typeof value) {
            case "string":
              if (value == "0")
                return this.ZERO;
              value = value.trim();
              if (!RE_DECIMAL_STR.test(value))
                throw new Error("string is no integer");
              let [minus, lo, hi2] = int64fromString(value);
              let pbl = new PbLong(lo, hi2);
              return minus ? pbl.negate() : pbl;
            case "number":
              if (value == 0)
                return this.ZERO;
              if (!Number.isSafeInteger(value))
                throw new Error("number is no integer");
              return value > 0 ? new PbLong(value, value / TWO_PWR_32_DBL) : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
          }
        throw new Error("unknown value " + typeof value);
      }
      /**
       * Do we have a minus sign?
       */
      isNegative() {
        return (this.hi & 2147483648) !== 0;
      }
      /**
       * Negate two's complement.
       * Invert all the bits and add one to the result.
       */
      negate() {
        let hi2 = ~this.hi, lo = this.lo;
        if (lo)
          lo = ~lo + 1;
        else
          hi2 += 1;
        return new PbLong(lo, hi2);
      }
      /**
       * Convert to decimal string.
       */
      toString() {
        if (BI)
          return this.toBigInt().toString();
        if (this.isNegative()) {
          let n2 = this.negate();
          return "-" + int64toString(n2.lo, n2.hi);
        }
        return int64toString(this.lo, this.hi);
      }
      /**
       * Convert to native bigint.
       */
      toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigInt64(0, true);
      }
    }
    PbLong.ZERO = new PbLong(0, 0);
    const defaultsRead$1 = {
      readUnknownField: true,
      readerFactory: (bytes) => new BinaryReader(bytes)
    };
    function binaryReadOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsRead$1), options) : defaultsRead$1;
    }
    class BinaryReader {
      constructor(buf, textDecoder) {
        this.varint64 = varint64read;
        this.uint32 = varint32read;
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
          fatal: true,
          ignoreBOM: true
        });
      }
      /**
       * Reads a tag - field number and wire type.
       */
      tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
          throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
      }
      /**
       * Skip one element on the wire and return the skipped data.
       * Supports WireType.StartGroup since v2.0.0-alpha.23.
       */
      skip(wireType) {
        let start = this.pos;
        switch (wireType) {
          case WireType.Varint:
            while (this.buf[this.pos++] & 128) {
            }
            break;
          case WireType.Bit64:
            this.pos += 4;
          case WireType.Bit32:
            this.pos += 4;
            break;
          case WireType.LengthDelimited:
            let len = this.uint32();
            this.pos += len;
            break;
          case WireType.StartGroup:
            let t2;
            while ((t2 = this.tag()[1]) !== WireType.EndGroup) {
              this.skip(t2);
            }
            break;
          default:
            throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
      }
      /**
       * Throws error if position in byte array is out of range.
       */
      assertBounds() {
        if (this.pos > this.len)
          throw new RangeError("premature EOF");
      }
      /**
       * Read a `int32` field, a signed 32 bit varint.
       */
      int32() {
        return this.uint32() | 0;
      }
      /**
       * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
       */
      sint32() {
        let zze = this.uint32();
        return zze >>> 1 ^ -(zze & 1);
      }
      /**
       * Read a `int64` field, a signed 64-bit varint.
       */
      int64() {
        return new PbLong(...this.varint64());
      }
      /**
       * Read a `uint64` field, an unsigned 64-bit varint.
       */
      uint64() {
        return new PbULong(...this.varint64());
      }
      /**
       * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64() {
        let [lo, hi2] = this.varint64();
        let s = -(lo & 1);
        lo = (lo >>> 1 | (hi2 & 1) << 31) ^ s;
        hi2 = hi2 >>> 1 ^ s;
        return new PbLong(lo, hi2);
      }
      /**
       * Read a `bool` field, a variant.
       */
      bool() {
        let [lo, hi2] = this.varint64();
        return lo !== 0 || hi2 !== 0;
      }
      /**
       * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
       */
      fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
       */
      sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
       */
      fixed64() {
        return new PbULong(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
       */
      sfixed64() {
        return new PbLong(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `float` field, 32-bit floating point number.
       */
      float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `double` field, a 64-bit floating point number.
       */
      double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
      }
      /**
       * Read a `bytes` field, length-delimited arbitrary data.
       */
      bytes() {
        let len = this.uint32();
        let start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
      }
      /**
       * Read a `string` field, length-delimited data converted to UTF-8 text.
       */
      string() {
        return this.textDecoder.decode(this.bytes());
      }
    }
    function assert$1(condition, msg) {
      if (!condition) {
        throw new Error(msg);
      }
    }
    function assertNever(value, msg) {
      throw new Error(msg !== null && msg !== void 0 ? msg : "Unexpected object: " + value);
    }
    const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
    function assertInt32(arg) {
      if (typeof arg !== "number")
        throw new Error("invalid int 32: " + typeof arg);
      if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
        throw new Error("invalid int 32: " + arg);
    }
    function assertUInt32(arg) {
      if (typeof arg !== "number")
        throw new Error("invalid uint 32: " + typeof arg);
      if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
        throw new Error("invalid uint 32: " + arg);
    }
    function assertFloat32(arg) {
      if (typeof arg !== "number")
        throw new Error("invalid float 32: " + typeof arg);
      if (!Number.isFinite(arg))
        return;
      if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
        throw new Error("invalid float 32: " + arg);
    }
    const defaultsWrite$1 = {
      writeUnknownFields: true,
      writerFactory: () => new BinaryWriter()
    };
    function binaryWriteOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsWrite$1), options) : defaultsWrite$1;
    }
    class BinaryWriter {
      constructor(textEncoder) {
        this.stack = [];
        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
        this.chunks = [];
        this.buf = [];
      }
      /**
       * Return all bytes written and reset this writer.
       */
      finish() {
        this.chunks.push(new Uint8Array(this.buf));
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
          len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
          bytes.set(this.chunks[i], offset);
          offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
      }
      /**
       * Start a new fork for length-delimited data like a message
       * or a packed repeated field.
       *
       * Must be joined later with `join()`.
       */
      fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
      }
      /**
       * Join the last fork. Write its length and bytes, then
       * return to the previous state.
       */
      join() {
        let chunk = this.finish();
        let prev = this.stack.pop();
        if (!prev)
          throw new Error("invalid state, fork stack empty");
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
      }
      /**
       * Writes a tag (field number and wire type).
       *
       * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
       *
       * Generated code should compute the tag ahead of time and call `uint32()`.
       */
      tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
      }
      /**
       * Write a chunk of raw bytes.
       */
      raw(chunk) {
        if (this.buf.length) {
          this.chunks.push(new Uint8Array(this.buf));
          this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
      }
      /**
       * Write a `uint32` value, an unsigned 32 bit varint.
       */
      uint32(value) {
        assertUInt32(value);
        while (value > 127) {
          this.buf.push(value & 127 | 128);
          value = value >>> 7;
        }
        this.buf.push(value);
        return this;
      }
      /**
       * Write a `int32` value, a signed 32 bit varint.
       */
      int32(value) {
        assertInt32(value);
        varint32write(value, this.buf);
        return this;
      }
      /**
       * Write a `bool` value, a variant.
       */
      bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
      }
      /**
       * Write a `bytes` value, length-delimited arbitrary data.
       */
      bytes(value) {
        this.uint32(value.byteLength);
        return this.raw(value);
      }
      /**
       * Write a `string` value, length-delimited data converted to UTF-8 text.
       */
      string(value) {
        let chunk = this.textEncoder.encode(value);
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
      }
      /**
       * Write a `float` value, 32-bit floating point number.
       */
      float(value) {
        assertFloat32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `double` value, a 64-bit floating point number.
       */
      double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
       */
      fixed32(value) {
        assertUInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
       */
      sfixed32(value) {
        assertInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
       */
      sint32(value) {
        assertInt32(value);
        value = (value << 1 ^ value >> 31) >>> 0;
        varint32write(value, this.buf);
        return this;
      }
      /**
       * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
       */
      sfixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = PbLong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
      }
      /**
       * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
       */
      fixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = PbULong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
      }
      /**
       * Write a `int64` value, a signed 64-bit varint.
       */
      int64(value) {
        let long = PbLong.from(value);
        varint64write(long.lo, long.hi, this.buf);
        return this;
      }
      /**
       * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64(value) {
        let long = PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi2 = (long.hi << 1 | long.lo >>> 31) ^ sign;
        varint64write(lo, hi2, this.buf);
        return this;
      }
      /**
       * Write a `uint64` value, an unsigned 64-bit varint.
       */
      uint64(value) {
        let long = PbULong.from(value);
        varint64write(long.lo, long.hi, this.buf);
        return this;
      }
    }
    const defaultsWrite = {
      emitDefaultValues: false,
      enumAsInteger: false,
      useProtoFieldName: false,
      prettySpaces: 0
    }, defaultsRead = {
      ignoreUnknownFields: false
    };
    function jsonReadOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
    }
    function jsonWriteOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
    }
    function mergeJsonOptions(a, b) {
      var _a, _b;
      let c = Object.assign(Object.assign({}, a), b);
      c.typeRegistry = [...(_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : [], ...(_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : []];
      return c;
    }
    const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");
    function lowerCamelCase(snakeCase) {
      let capNext = false;
      const sb2 = [];
      for (let i = 0; i < snakeCase.length; i++) {
        let next = snakeCase.charAt(i);
        if (next == "_") {
          capNext = true;
        } else if (/\d/.test(next)) {
          sb2.push(next);
          capNext = true;
        } else if (capNext) {
          sb2.push(next.toUpperCase());
          capNext = false;
        } else if (i == 0) {
          sb2.push(next.toLowerCase());
        } else {
          sb2.push(next);
        }
      }
      return sb2.join("");
    }
    var ScalarType;
    (function(ScalarType2) {
      ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
      ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
      ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
      ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
      ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
      ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
      ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
      ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
      ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
      ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
      ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
      ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
      ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
      ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
      ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
    })(ScalarType || (ScalarType = {}));
    var LongType;
    (function(LongType2) {
      LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
      LongType2[LongType2["STRING"] = 1] = "STRING";
      LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
    })(LongType || (LongType = {}));
    var RepeatType;
    (function(RepeatType2) {
      RepeatType2[RepeatType2["NO"] = 0] = "NO";
      RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
      RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
    })(RepeatType || (RepeatType = {}));
    function normalizeFieldInfo(field) {
      var _a, _b, _c, _d;
      field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);
      field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
      field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
      field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
      return field;
    }
    function isOneofGroup(any) {
      if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
        return false;
      }
      switch (typeof any.oneofKind) {
        case "string":
          if (any[any.oneofKind] === void 0)
            return false;
          return Object.keys(any).length == 2;
        case "undefined":
          return Object.keys(any).length == 1;
        default:
          return false;
      }
    }
    class ReflectionTypeCheck {
      constructor(info2) {
        var _a;
        this.fields = (_a = info2.fields) !== null && _a !== void 0 ? _a : [];
      }
      prepare() {
        if (this.data)
          return;
        const req = [], known = [], oneofs = [];
        for (let field of this.fields) {
          if (field.oneof) {
            if (!oneofs.includes(field.oneof)) {
              oneofs.push(field.oneof);
              req.push(field.oneof);
              known.push(field.oneof);
            }
          } else {
            known.push(field.localName);
            switch (field.kind) {
              case "scalar":
              case "enum":
                if (!field.opt || field.repeat)
                  req.push(field.localName);
                break;
              case "message":
                if (field.repeat)
                  req.push(field.localName);
                break;
              case "map":
                req.push(field.localName);
                break;
            }
          }
        }
        this.data = { req, known, oneofs: Object.values(oneofs) };
      }
      /**
       * Is the argument a valid message as specified by the
       * reflection information?
       *
       * Checks all field types recursively. The `depth`
       * specifies how deep into the structure the check will be.
       *
       * With a depth of 0, only the presence of fields
       * is checked.
       *
       * With a depth of 1 or more, the field types are checked.
       *
       * With a depth of 2 or more, the members of map, repeated
       * and message fields are checked.
       *
       * Message fields will be checked recursively with depth - 1.
       *
       * The number of map entries / repeated values being checked
       * is < depth.
       */
      is(message, depth, allowExcessProperties = false) {
        if (depth < 0)
          return true;
        if (message === null || message === void 0 || typeof message != "object")
          return false;
        this.prepare();
        let keys2 = Object.keys(message), data2 = this.data;
        if (keys2.length < data2.req.length || data2.req.some((n2) => !keys2.includes(n2)))
          return false;
        if (!allowExcessProperties) {
          if (keys2.some((k2) => !data2.known.includes(k2)))
            return false;
        }
        if (depth < 1) {
          return true;
        }
        for (const name2 of data2.oneofs) {
          const group = message[name2];
          if (!isOneofGroup(group))
            return false;
          if (group.oneofKind === void 0)
            continue;
          const field = this.fields.find((f2) => f2.localName === group.oneofKind);
          if (!field)
            return false;
          if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
            return false;
        }
        for (const field of this.fields) {
          if (field.oneof !== void 0)
            continue;
          if (!this.field(message[field.localName], field, allowExcessProperties, depth))
            return false;
        }
        return true;
      }
      field(arg, field, allowExcessProperties, depth) {
        let repeated = field.repeat;
        switch (field.kind) {
          case "scalar":
            if (arg === void 0)
              return field.opt;
            if (repeated)
              return this.scalars(arg, field.T, depth, field.L);
            return this.scalar(arg, field.T, field.L);
          case "enum":
            if (arg === void 0)
              return field.opt;
            if (repeated)
              return this.scalars(arg, ScalarType.INT32, depth);
            return this.scalar(arg, ScalarType.INT32);
          case "message":
            if (arg === void 0)
              return true;
            if (repeated)
              return this.messages(arg, field.T(), allowExcessProperties, depth);
            return this.message(arg, field.T(), allowExcessProperties, depth);
          case "map":
            if (typeof arg != "object" || arg === null)
              return false;
            if (depth < 2)
              return true;
            if (!this.mapKeys(arg, field.K, depth))
              return false;
            switch (field.V.kind) {
              case "scalar":
                return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
              case "enum":
                return this.scalars(Object.values(arg), ScalarType.INT32, depth);
              case "message":
                return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
            }
            break;
        }
        return true;
      }
      message(arg, type, allowExcessProperties, depth) {
        if (allowExcessProperties) {
          return type.isAssignable(arg, depth);
        }
        return type.is(arg, depth);
      }
      messages(arg, type, allowExcessProperties, depth) {
        if (!Array.isArray(arg))
          return false;
        if (depth < 2)
          return true;
        if (allowExcessProperties) {
          for (let i = 0; i < arg.length && i < depth; i++)
            if (!type.isAssignable(arg[i], depth - 1))
              return false;
        } else {
          for (let i = 0; i < arg.length && i < depth; i++)
            if (!type.is(arg[i], depth - 1))
              return false;
        }
        return true;
      }
      scalar(arg, type, longType) {
        let argType = typeof arg;
        switch (type) {
          case ScalarType.UINT64:
          case ScalarType.FIXED64:
          case ScalarType.INT64:
          case ScalarType.SFIXED64:
          case ScalarType.SINT64:
            switch (longType) {
              case LongType.BIGINT:
                return argType == "bigint";
              case LongType.NUMBER:
                return argType == "number" && !isNaN(arg);
              default:
                return argType == "string";
            }
          case ScalarType.BOOL:
            return argType == "boolean";
          case ScalarType.STRING:
            return argType == "string";
          case ScalarType.BYTES:
            return arg instanceof Uint8Array;
          case ScalarType.DOUBLE:
          case ScalarType.FLOAT:
            return argType == "number" && !isNaN(arg);
          default:
            return argType == "number" && Number.isInteger(arg);
        }
      }
      scalars(arg, type, depth, longType) {
        if (!Array.isArray(arg))
          return false;
        if (depth < 2)
          return true;
        if (Array.isArray(arg)) {
          for (let i = 0; i < arg.length && i < depth; i++)
            if (!this.scalar(arg[i], type, longType))
              return false;
        }
        return true;
      }
      mapKeys(map2, type, depth) {
        let keys2 = Object.keys(map2);
        switch (type) {
          case ScalarType.INT32:
          case ScalarType.FIXED32:
          case ScalarType.SFIXED32:
          case ScalarType.SINT32:
          case ScalarType.UINT32:
            return this.scalars(keys2.slice(0, depth).map((k2) => parseInt(k2)), type, depth);
          case ScalarType.BOOL:
            return this.scalars(keys2.slice(0, depth).map((k2) => k2 == "true" ? true : k2 == "false" ? false : k2), type, depth);
          default:
            return this.scalars(keys2, type, depth, LongType.STRING);
        }
      }
    }
    function reflectionLongConvert(long, type) {
      switch (type) {
        case LongType.BIGINT:
          return long.toBigInt();
        case LongType.NUMBER:
          return long.toNumber();
        default:
          return long.toString();
      }
    }
    class ReflectionJsonReader {
      constructor(info2) {
        this.info = info2;
      }
      prepare() {
        var _a;
        if (this.fMap === void 0) {
          this.fMap = {};
          const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
          for (const field of fieldsInput) {
            this.fMap[field.name] = field;
            this.fMap[field.jsonName] = field;
            this.fMap[field.localName] = field;
          }
        }
      }
      // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
      assert(condition, fieldName, jsonValue) {
        if (!condition) {
          let what = typeofJsonValue(jsonValue);
          if (what == "number" || what == "boolean")
            what = jsonValue.toString();
          throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
        }
      }
      /**
       * Reads a message from canonical JSON format into the target message.
       *
       * Repeated fields are appended. Map entries are added, overwriting
       * existing keys.
       *
       * If a message field is already present, it will be merged with the
       * new data.
       */
      read(input, message, options) {
        this.prepare();
        const oneofsHandled = [];
        for (const [jsonKey, jsonValue] of Object.entries(input)) {
          const field = this.fMap[jsonKey];
          if (!field) {
            if (!options.ignoreUnknownFields)
              throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
            continue;
          }
          const localName = field.localName;
          let target;
          if (field.oneof) {
            if (oneofsHandled.includes(field.oneof))
              throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
            oneofsHandled.push(field.oneof);
            target = message[field.oneof] = {
              oneofKind: localName
            };
          } else {
            target = message;
          }
          if (field.kind == "map") {
            if (jsonValue === null) {
              continue;
            }
            this.assert(isJsonObject(jsonValue), field.name, jsonValue);
            const fieldObj = target[localName];
            for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
              this.assert(jsonObjValue !== null, field.name + " map value", null);
              let val;
              switch (field.V.kind) {
                case "message":
                  val = field.V.T().internalJsonRead(jsonObjValue, options);
                  break;
                case "enum":
                  val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                  if (val === false)
                    continue;
                  break;
                case "scalar":
                  val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                  break;
              }
              this.assert(val !== void 0, field.name + " map value", jsonObjValue);
              let key = jsonObjKey;
              if (field.K == ScalarType.BOOL)
                key = key == "true" ? true : key == "false" ? false : key;
              key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
              fieldObj[key] = val;
            }
          } else if (field.repeat) {
            if (jsonValue === null)
              continue;
            this.assert(Array.isArray(jsonValue), field.name, jsonValue);
            const fieldArr = target[localName];
            for (const jsonItem of jsonValue) {
              this.assert(jsonItem !== null, field.name, null);
              let val;
              switch (field.kind) {
                case "message":
                  val = field.T().internalJsonRead(jsonItem, options);
                  break;
                case "enum":
                  val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                  if (val === false)
                    continue;
                  break;
                case "scalar":
                  val = this.scalar(jsonItem, field.T, field.L, field.name);
                  break;
              }
              this.assert(val !== void 0, field.name, jsonValue);
              fieldArr.push(val);
            }
          } else {
            switch (field.kind) {
              case "message":
                if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
                  this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
                  continue;
                }
                target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                break;
              case "enum":
                let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                if (val === false)
                  continue;
                target[localName] = val;
                break;
              case "scalar":
                target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                break;
            }
          }
        }
      }
      /**
       * Returns `false` for unrecognized string representations.
       *
       * google.protobuf.NullValue accepts only JSON `null`.
       */
      enum(type, json, fieldName, ignoreUnknownFields) {
        if (type[0] == "google.protobuf.NullValue")
          assert$1(json === null, `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
        if (json === null)
          return 0;
        switch (typeof json) {
          case "number":
            assert$1(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
            return json;
          case "string":
            let localEnumName = json;
            if (type[2] && json.substring(0, type[2].length) === type[2])
              localEnumName = json.substring(type[2].length);
            let enumNumber = type[1][localEnumName];
            if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
              return false;
            }
            assert$1(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
            return enumNumber;
        }
        assert$1(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
      }
      scalar(json, type, longType, fieldName) {
        let e;
        try {
          switch (type) {
            case ScalarType.DOUBLE:
            case ScalarType.FLOAT:
              if (json === null)
                return 0;
              if (json === "NaN")
                return Number.NaN;
              if (json === "Infinity")
                return Number.POSITIVE_INFINITY;
              if (json === "-Infinity")
                return Number.NEGATIVE_INFINITY;
              if (json === "") {
                e = "empty string";
                break;
              }
              if (typeof json == "string" && json.trim().length !== json.length) {
                e = "extra whitespace";
                break;
              }
              if (typeof json != "string" && typeof json != "number") {
                break;
              }
              let float = Number(json);
              if (Number.isNaN(float)) {
                e = "not a number";
                break;
              }
              if (!Number.isFinite(float)) {
                e = "too large or small";
                break;
              }
              if (type == ScalarType.FLOAT)
                assertFloat32(float);
              return float;
            case ScalarType.INT32:
            case ScalarType.FIXED32:
            case ScalarType.SFIXED32:
            case ScalarType.SINT32:
            case ScalarType.UINT32:
              if (json === null)
                return 0;
              let int32;
              if (typeof json == "number")
                int32 = json;
              else if (json === "")
                e = "empty string";
              else if (typeof json == "string") {
                if (json.trim().length !== json.length)
                  e = "extra whitespace";
                else
                  int32 = Number(json);
              }
              if (int32 === void 0)
                break;
              if (type == ScalarType.UINT32)
                assertUInt32(int32);
              else
                assertInt32(int32);
              return int32;
            case ScalarType.INT64:
            case ScalarType.SFIXED64:
            case ScalarType.SINT64:
              if (json === null)
                return reflectionLongConvert(PbLong.ZERO, longType);
              if (typeof json != "number" && typeof json != "string")
                break;
              return reflectionLongConvert(PbLong.from(json), longType);
            case ScalarType.FIXED64:
            case ScalarType.UINT64:
              if (json === null)
                return reflectionLongConvert(PbULong.ZERO, longType);
              if (typeof json != "number" && typeof json != "string")
                break;
              return reflectionLongConvert(PbULong.from(json), longType);
            case ScalarType.BOOL:
              if (json === null)
                return false;
              if (typeof json !== "boolean")
                break;
              return json;
            case ScalarType.STRING:
              if (json === null)
                return "";
              if (typeof json !== "string") {
                e = "extra whitespace";
                break;
              }
              try {
                encodeURIComponent(json);
              } catch (e2) {
                e2 = "invalid UTF8";
                break;
              }
              return json;
            case ScalarType.BYTES:
              if (json === null || json === "")
                return new Uint8Array(0);
              if (typeof json !== "string")
                break;
              return base64decode(json);
          }
        } catch (error) {
          e = error.message;
        }
        this.assert(false, fieldName + (e ? " - " + e : ""), json);
      }
    }
    class ReflectionJsonWriter {
      constructor(info2) {
        var _a;
        this.fields = (_a = info2.fields) !== null && _a !== void 0 ? _a : [];
      }
      /**
       * Converts the message to a JSON object, based on the field descriptors.
       */
      write(message, options) {
        const json = {}, source = message;
        for (const field of this.fields) {
          if (!field.oneof) {
            let jsonValue2 = this.field(field, source[field.localName], options);
            if (jsonValue2 !== void 0)
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
            continue;
          }
          const group = source[field.oneof];
          if (group.oneofKind !== field.localName)
            continue;
          const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
          let jsonValue = this.field(field, group[field.localName], opt);
          assert$1(jsonValue !== void 0);
          json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
        }
        return json;
      }
      field(field, value, options) {
        let jsonValue = void 0;
        if (field.kind == "map") {
          assert$1(typeof value == "object" && value !== null);
          const jsonObj = {};
          switch (field.V.kind) {
            case "scalar":
              for (const [entryKey, entryValue] of Object.entries(value)) {
                const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                assert$1(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
            case "message":
              const messageType = field.V.T();
              for (const [entryKey, entryValue] of Object.entries(value)) {
                const val = this.message(messageType, entryValue, field.name, options);
                assert$1(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
            case "enum":
              const enumInfo = field.V.T();
              for (const [entryKey, entryValue] of Object.entries(value)) {
                assert$1(entryValue === void 0 || typeof entryValue == "number");
                const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                assert$1(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
          }
          if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
            jsonValue = jsonObj;
        } else if (field.repeat) {
          assert$1(Array.isArray(value));
          const jsonArr = [];
          switch (field.kind) {
            case "scalar":
              for (let i = 0; i < value.length; i++) {
                const val = this.scalar(field.T, value[i], field.name, field.opt, true);
                assert$1(val !== void 0);
                jsonArr.push(val);
              }
              break;
            case "enum":
              const enumInfo = field.T();
              for (let i = 0; i < value.length; i++) {
                assert$1(value[i] === void 0 || typeof value[i] == "number");
                const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
                assert$1(val !== void 0);
                jsonArr.push(val);
              }
              break;
            case "message":
              const messageType = field.T();
              for (let i = 0; i < value.length; i++) {
                const val = this.message(messageType, value[i], field.name, options);
                assert$1(val !== void 0);
                jsonArr.push(val);
              }
              break;
          }
          if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
            jsonValue = jsonArr;
        } else {
          switch (field.kind) {
            case "scalar":
              jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
              break;
            case "enum":
              jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
              break;
            case "message":
              jsonValue = this.message(field.T(), value, field.name, options);
              break;
          }
        }
        return jsonValue;
      }
      /**
       * Returns `null` for google.protobuf.NullValue.
       */
      enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
        if (type[0] == "google.protobuf.NullValue")
          return null;
        if (value === void 0) {
          assert$1(optional);
          return void 0;
        }
        if (value === 0 && !emitDefaultValues && !optional)
          return void 0;
        assert$1(typeof value == "number");
        assert$1(Number.isInteger(value));
        if (enumAsInteger || !type[1].hasOwnProperty(value))
          return value;
        if (type[2])
          return type[2] + type[1][value];
        return type[1][value];
      }
      message(type, value, fieldName, options) {
        if (value === void 0)
          return options.emitDefaultValues ? null : void 0;
        return type.internalJsonWrite(value, options);
      }
      scalar(type, value, fieldName, optional, emitDefaultValues) {
        if (value === void 0) {
          assert$1(optional);
          return void 0;
        }
        const ed2 = emitDefaultValues || optional;
        switch (type) {
          case ScalarType.INT32:
          case ScalarType.SFIXED32:
          case ScalarType.SINT32:
            if (value === 0)
              return ed2 ? 0 : void 0;
            assertInt32(value);
            return value;
          case ScalarType.FIXED32:
          case ScalarType.UINT32:
            if (value === 0)
              return ed2 ? 0 : void 0;
            assertUInt32(value);
            return value;
          case ScalarType.FLOAT:
            assertFloat32(value);
          case ScalarType.DOUBLE:
            if (value === 0)
              return ed2 ? 0 : void 0;
            assert$1(typeof value == "number");
            if (Number.isNaN(value))
              return "NaN";
            if (value === Number.POSITIVE_INFINITY)
              return "Infinity";
            if (value === Number.NEGATIVE_INFINITY)
              return "-Infinity";
            return value;
          case ScalarType.STRING:
            if (value === "")
              return ed2 ? "" : void 0;
            assert$1(typeof value == "string");
            return value;
          case ScalarType.BOOL:
            if (value === false)
              return ed2 ? false : void 0;
            assert$1(typeof value == "boolean");
            return value;
          case ScalarType.UINT64:
          case ScalarType.FIXED64:
            assert$1(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
            let ulong = PbULong.from(value);
            if (ulong.isZero() && !ed2)
              return void 0;
            return ulong.toString();
          case ScalarType.INT64:
          case ScalarType.SFIXED64:
          case ScalarType.SINT64:
            assert$1(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
            let long = PbLong.from(value);
            if (long.isZero() && !ed2)
              return void 0;
            return long.toString();
          case ScalarType.BYTES:
            assert$1(value instanceof Uint8Array);
            if (!value.byteLength)
              return ed2 ? "" : void 0;
            return base64encode(value);
        }
      }
    }
    function reflectionScalarDefault(type, longType = LongType.STRING) {
      switch (type) {
        case ScalarType.BOOL:
          return false;
        case ScalarType.UINT64:
        case ScalarType.FIXED64:
          return reflectionLongConvert(PbULong.ZERO, longType);
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
          return reflectionLongConvert(PbLong.ZERO, longType);
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
          return 0;
        case ScalarType.BYTES:
          return new Uint8Array(0);
        case ScalarType.STRING:
          return "";
        default:
          return 0;
      }
    }
    class ReflectionBinaryReader {
      constructor(info2) {
        this.info = info2;
      }
      prepare() {
        var _a;
        if (!this.fieldNoToField) {
          const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
          this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
        }
      }
      /**
       * Reads a message from binary format into the target message.
       *
       * Repeated fields are appended. Map entries are added, overwriting
       * existing keys.
       *
       * If a message field is already present, it will be merged with the
       * new data.
       */
      read(reader, message, options, length) {
        this.prepare();
        const end = length === void 0 ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
          if (!field) {
            let u2 = options.readUnknownField;
            if (u2 == "throw")
              throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
            let d = reader.skip(wireType);
            if (u2 !== false)
              (u2 === true ? UnknownFieldHandler.onRead : u2)(this.info.typeName, message, fieldNo, wireType, d);
            continue;
          }
          let target = message, repeated = field.repeat, localName = field.localName;
          if (field.oneof) {
            target = target[field.oneof];
            if (target.oneofKind !== localName)
              target = message[field.oneof] = {
                oneofKind: localName
              };
          }
          switch (field.kind) {
            case "scalar":
            case "enum":
              let T2 = field.kind == "enum" ? ScalarType.INT32 : field.T;
              let L2 = field.kind == "scalar" ? field.L : void 0;
              if (repeated) {
                let arr = target[localName];
                if (wireType == WireType.LengthDelimited && T2 != ScalarType.STRING && T2 != ScalarType.BYTES) {
                  let e = reader.uint32() + reader.pos;
                  while (reader.pos < e)
                    arr.push(this.scalar(reader, T2, L2));
                } else
                  arr.push(this.scalar(reader, T2, L2));
              } else
                target[localName] = this.scalar(reader, T2, L2);
              break;
            case "message":
              if (repeated) {
                let arr = target[localName];
                let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                arr.push(msg);
              } else
                target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
              break;
            case "map":
              let [mapKey, mapVal] = this.mapEntry(field, reader, options);
              target[localName][mapKey] = mapVal;
              break;
          }
        }
      }
      /**
       * Read a map field, expecting key field = 1, value field = 2
       */
      mapEntry(field, reader, options) {
        let length = reader.uint32();
        let end = reader.pos + length;
        let key = void 0;
        let val = void 0;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              if (field.K == ScalarType.BOOL)
                key = reader.bool().toString();
              else
                key = this.scalar(reader, field.K, LongType.STRING);
              break;
            case 2:
              switch (field.V.kind) {
                case "scalar":
                  val = this.scalar(reader, field.V.T, field.V.L);
                  break;
                case "enum":
                  val = reader.int32();
                  break;
                case "message":
                  val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                  break;
              }
              break;
            default:
              throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
          }
        }
        if (key === void 0) {
          let keyRaw = reflectionScalarDefault(field.K);
          key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
        }
        if (val === void 0)
          switch (field.V.kind) {
            case "scalar":
              val = reflectionScalarDefault(field.V.T, field.V.L);
              break;
            case "enum":
              val = 0;
              break;
            case "message":
              val = field.V.T().create();
              break;
          }
        return [key, val];
      }
      scalar(reader, type, longType) {
        switch (type) {
          case ScalarType.INT32:
            return reader.int32();
          case ScalarType.STRING:
            return reader.string();
          case ScalarType.BOOL:
            return reader.bool();
          case ScalarType.DOUBLE:
            return reader.double();
          case ScalarType.FLOAT:
            return reader.float();
          case ScalarType.INT64:
            return reflectionLongConvert(reader.int64(), longType);
          case ScalarType.UINT64:
            return reflectionLongConvert(reader.uint64(), longType);
          case ScalarType.FIXED64:
            return reflectionLongConvert(reader.fixed64(), longType);
          case ScalarType.FIXED32:
            return reader.fixed32();
          case ScalarType.BYTES:
            return reader.bytes();
          case ScalarType.UINT32:
            return reader.uint32();
          case ScalarType.SFIXED32:
            return reader.sfixed32();
          case ScalarType.SFIXED64:
            return reflectionLongConvert(reader.sfixed64(), longType);
          case ScalarType.SINT32:
            return reader.sint32();
          case ScalarType.SINT64:
            return reflectionLongConvert(reader.sint64(), longType);
        }
      }
    }
    class ReflectionBinaryWriter {
      constructor(info2) {
        this.info = info2;
      }
      prepare() {
        if (!this.fields) {
          const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
          this.fields = fieldsInput.sort((a, b) => a.no - b.no);
        }
      }
      /**
       * Writes the message to binary format.
       */
      write(message, writer, options) {
        this.prepare();
        for (const field of this.fields) {
          let value, emitDefault, repeated = field.repeat, localName = field.localName;
          if (field.oneof) {
            const group = message[field.oneof];
            if (group.oneofKind !== localName)
              continue;
            value = group[localName];
            emitDefault = true;
          } else {
            value = message[localName];
            emitDefault = false;
          }
          switch (field.kind) {
            case "scalar":
            case "enum":
              let T2 = field.kind == "enum" ? ScalarType.INT32 : field.T;
              if (repeated) {
                assert$1(Array.isArray(value));
                if (repeated == RepeatType.PACKED)
                  this.packed(writer, T2, field.no, value);
                else
                  for (const item of value)
                    this.scalar(writer, T2, field.no, item, true);
              } else if (value === void 0)
                assert$1(field.opt);
              else
                this.scalar(writer, T2, field.no, value, emitDefault || field.opt);
              break;
            case "message":
              if (repeated) {
                assert$1(Array.isArray(value));
                for (const item of value)
                  this.message(writer, options, field.T(), field.no, item);
              } else {
                this.message(writer, options, field.T(), field.no, value);
              }
              break;
            case "map":
              assert$1(typeof value == "object" && value !== null);
              for (const [key, val] of Object.entries(value))
                this.mapEntry(writer, options, field, key, val);
              break;
          }
        }
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 === true ? UnknownFieldHandler.onWrite : u2)(this.info.typeName, message, writer);
      }
      mapEntry(writer, options, field, key, value) {
        writer.tag(field.no, WireType.LengthDelimited);
        writer.fork();
        let keyValue = key;
        switch (field.K) {
          case ScalarType.INT32:
          case ScalarType.FIXED32:
          case ScalarType.UINT32:
          case ScalarType.SFIXED32:
          case ScalarType.SINT32:
            keyValue = Number.parseInt(key);
            break;
          case ScalarType.BOOL:
            assert$1(key == "true" || key == "false");
            keyValue = key == "true";
            break;
        }
        this.scalar(writer, field.K, 1, keyValue, true);
        switch (field.V.kind) {
          case "scalar":
            this.scalar(writer, field.V.T, 2, value, true);
            break;
          case "enum":
            this.scalar(writer, ScalarType.INT32, 2, value, true);
            break;
          case "message":
            this.message(writer, options, field.V.T(), 2, value);
            break;
        }
        writer.join();
      }
      message(writer, options, handler, fieldNo, value) {
        if (value === void 0)
          return;
        handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
        writer.join();
      }
      /**
       * Write a single scalar value.
       */
      scalar(writer, type, fieldNo, value, emitDefault) {
        let [wireType, method, isDefault] = this.scalarInfo(type, value);
        if (!isDefault || emitDefault) {
          writer.tag(fieldNo, wireType);
          writer[method](value);
        }
      }
      /**
       * Write an array of scalar values in packed format.
       */
      packed(writer, type, fieldNo, value) {
        if (!value.length)
          return;
        assert$1(type !== ScalarType.BYTES && type !== ScalarType.STRING);
        writer.tag(fieldNo, WireType.LengthDelimited);
        writer.fork();
        let [, method] = this.scalarInfo(type);
        for (let i = 0; i < value.length; i++)
          writer[method](value[i]);
        writer.join();
      }
      /**
       * Get information for writing a scalar value.
       *
       * Returns tuple:
       * [0]: appropriate WireType
       * [1]: name of the appropriate method of IBinaryWriter
       * [2]: whether the given value is a default value
       *
       * If argument `value` is omitted, [2] is always false.
       */
      scalarInfo(type, value) {
        let t2 = WireType.Varint;
        let m2;
        let i = value === void 0;
        let d = value === 0;
        switch (type) {
          case ScalarType.INT32:
            m2 = "int32";
            break;
          case ScalarType.STRING:
            d = i || !value.length;
            t2 = WireType.LengthDelimited;
            m2 = "string";
            break;
          case ScalarType.BOOL:
            d = value === false;
            m2 = "bool";
            break;
          case ScalarType.UINT32:
            m2 = "uint32";
            break;
          case ScalarType.DOUBLE:
            t2 = WireType.Bit64;
            m2 = "double";
            break;
          case ScalarType.FLOAT:
            t2 = WireType.Bit32;
            m2 = "float";
            break;
          case ScalarType.INT64:
            d = i || PbLong.from(value).isZero();
            m2 = "int64";
            break;
          case ScalarType.UINT64:
            d = i || PbULong.from(value).isZero();
            m2 = "uint64";
            break;
          case ScalarType.FIXED64:
            d = i || PbULong.from(value).isZero();
            t2 = WireType.Bit64;
            m2 = "fixed64";
            break;
          case ScalarType.BYTES:
            d = i || !value.byteLength;
            t2 = WireType.LengthDelimited;
            m2 = "bytes";
            break;
          case ScalarType.FIXED32:
            t2 = WireType.Bit32;
            m2 = "fixed32";
            break;
          case ScalarType.SFIXED32:
            t2 = WireType.Bit32;
            m2 = "sfixed32";
            break;
          case ScalarType.SFIXED64:
            d = i || PbLong.from(value).isZero();
            t2 = WireType.Bit64;
            m2 = "sfixed64";
            break;
          case ScalarType.SINT32:
            m2 = "sint32";
            break;
          case ScalarType.SINT64:
            d = i || PbLong.from(value).isZero();
            m2 = "sint64";
            break;
        }
        return [t2, m2, i || d];
      }
    }
    function reflectionCreate(type) {
      const msg = {};
      Object.defineProperty(msg, MESSAGE_TYPE, { enumerable: false, value: type });
      for (let field of type.fields) {
        let name2 = field.localName;
        if (field.opt)
          continue;
        if (field.oneof)
          msg[field.oneof] = { oneofKind: void 0 };
        else if (field.repeat)
          msg[name2] = [];
        else
          switch (field.kind) {
            case "scalar":
              msg[name2] = reflectionScalarDefault(field.T, field.L);
              break;
            case "enum":
              msg[name2] = 0;
              break;
            case "map":
              msg[name2] = {};
              break;
          }
      }
      return msg;
    }
    function reflectionMergePartial(info2, target, source) {
      let fieldValue, input = source, output;
      for (let field of info2.fields) {
        let name2 = field.localName;
        if (field.oneof) {
          const group = input[field.oneof];
          if ((group === null || group === void 0 ? void 0 : group.oneofKind) == void 0) {
            continue;
          }
          fieldValue = group[name2];
          output = target[field.oneof];
          output.oneofKind = group.oneofKind;
          if (fieldValue == void 0) {
            delete output[name2];
            continue;
          }
        } else {
          fieldValue = input[name2];
          output = target;
          if (fieldValue == void 0) {
            continue;
          }
        }
        if (field.repeat)
          output[name2].length = fieldValue.length;
        switch (field.kind) {
          case "scalar":
          case "enum":
            if (field.repeat)
              for (let i = 0; i < fieldValue.length; i++)
                output[name2][i] = fieldValue[i];
            else
              output[name2] = fieldValue;
            break;
          case "message":
            let T2 = field.T();
            if (field.repeat)
              for (let i = 0; i < fieldValue.length; i++)
                output[name2][i] = T2.create(fieldValue[i]);
            else if (output[name2] === void 0)
              output[name2] = T2.create(fieldValue);
            else
              T2.mergePartial(output[name2], fieldValue);
            break;
          case "map":
            switch (field.V.kind) {
              case "scalar":
              case "enum":
                Object.assign(output[name2], fieldValue);
                break;
              case "message":
                let T3 = field.V.T();
                for (let k2 of Object.keys(fieldValue))
                  output[name2][k2] = T3.create(fieldValue[k2]);
                break;
            }
            break;
        }
      }
    }
    function reflectionEquals(info2, a, b) {
      if (a === b)
        return true;
      if (!a || !b)
        return false;
      for (let field of info2.fields) {
        let localName = field.localName;
        let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
        let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
        switch (field.kind) {
          case "enum":
          case "scalar":
            let t2 = field.kind == "enum" ? ScalarType.INT32 : field.T;
            if (!(field.repeat ? repeatedPrimitiveEq(t2, val_a, val_b) : primitiveEq(t2, val_a, val_b)))
              return false;
            break;
          case "map":
            if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
              return false;
            break;
          case "message":
            let T2 = field.T();
            if (!(field.repeat ? repeatedMsgEq(T2, val_a, val_b) : T2.equals(val_a, val_b)))
              return false;
            break;
        }
      }
      return true;
    }
    const objectValues = Object.values;
    function primitiveEq(type, a, b) {
      if (a === b)
        return true;
      if (type !== ScalarType.BYTES)
        return false;
      let ba = a;
      let bb2 = b;
      if (ba.length !== bb2.length)
        return false;
      for (let i = 0; i < ba.length; i++)
        if (ba[i] != bb2[i])
          return false;
      return true;
    }
    function repeatedPrimitiveEq(type, a, b) {
      if (a.length !== b.length)
        return false;
      for (let i = 0; i < a.length; i++)
        if (!primitiveEq(type, a[i], b[i]))
          return false;
      return true;
    }
    function repeatedMsgEq(type, a, b) {
      if (a.length !== b.length)
        return false;
      for (let i = 0; i < a.length; i++)
        if (!type.equals(a[i], b[i]))
          return false;
      return true;
    }
    class MessageType {
      constructor(name2, fields, options) {
        this.defaultCheckDepth = 16;
        this.typeName = name2;
        this.fields = fields.map(normalizeFieldInfo);
        this.options = options !== null && options !== void 0 ? options : {};
        this.refTypeCheck = new ReflectionTypeCheck(this);
        this.refJsonReader = new ReflectionJsonReader(this);
        this.refJsonWriter = new ReflectionJsonWriter(this);
        this.refBinReader = new ReflectionBinaryReader(this);
        this.refBinWriter = new ReflectionBinaryWriter(this);
      }
      create(value) {
        let message = reflectionCreate(this);
        if (value !== void 0) {
          reflectionMergePartial(this, message, value);
        }
        return message;
      }
      /**
       * Clone the message.
       *
       * Unknown fields are discarded.
       */
      clone(message) {
        let copy2 = this.create();
        reflectionMergePartial(this, copy2, message);
        return copy2;
      }
      /**
       * Determines whether two message of the same type have the same field values.
       * Checks for deep equality, traversing repeated fields, oneof groups, maps
       * and messages recursively.
       * Will also return true if both messages are `undefined`.
       */
      equals(a, b) {
        return reflectionEquals(this, a, b);
      }
      /**
       * Is the given value assignable to our message type
       * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
       */
      is(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, false);
      }
      /**
       * Is the given value assignable to our message type,
       * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
       */
      isAssignable(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, true);
      }
      /**
       * Copy partial data into the target message.
       */
      mergePartial(target, source) {
        reflectionMergePartial(this, target, source);
      }
      /**
       * Create a new message from binary format.
       */
      fromBinary(data2, options) {
        let opt = binaryReadOptions(options);
        return this.internalBinaryRead(opt.readerFactory(data2), data2.byteLength, opt);
      }
      /**
       * Read a new message from a JSON value.
       */
      fromJson(json, options) {
        return this.internalJsonRead(json, jsonReadOptions(options));
      }
      /**
       * Read a new message from a JSON string.
       * This is equivalent to `T.fromJson(JSON.parse(json))`.
       */
      fromJsonString(json, options) {
        let value = JSON.parse(json);
        return this.fromJson(value, options);
      }
      /**
       * Write the message to canonical JSON value.
       */
      toJson(message, options) {
        return this.internalJsonWrite(message, jsonWriteOptions(options));
      }
      /**
       * Convert the message to canonical JSON string.
       * This is equivalent to `JSON.stringify(T.toJson(t))`
       */
      toJsonString(message, options) {
        var _a;
        let value = this.toJson(message, options);
        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
      }
      /**
       * Write the message to binary format.
       */
      toBinary(message, options) {
        let opt = binaryWriteOptions(options);
        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
      }
      /**
       * This is an internal method. If you just want to read a message from
       * JSON, use `fromJson()` or `fromJsonString()`.
       *
       * Reads JSON value and merges the fields into the target
       * according to protobuf rules. If the target is omitted,
       * a new instance is created first.
       */
      internalJsonRead(json, options, target) {
        if (json !== null && typeof json == "object" && !Array.isArray(json)) {
          let message = target !== null && target !== void 0 ? target : this.create();
          this.refJsonReader.read(json, message, options);
          return message;
        }
        throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
      }
      /**
       * This is an internal method. If you just want to write a message
       * to JSON, use `toJson()` or `toJsonString().
       *
       * Writes JSON value and returns it.
       */
      internalJsonWrite(message, options) {
        return this.refJsonWriter.write(message, options);
      }
      /**
       * This is an internal method. If you just want to write a message
       * in binary format, use `toBinary()`.
       *
       * Serializes the message in binary format and appends it to the given
       * writer. Returns passed writer.
       */
      internalBinaryWrite(message, writer, options) {
        this.refBinWriter.write(message, writer, options);
        return writer;
      }
      /**
       * This is an internal method. If you just want to read a message from
       * binary data, use `fromBinary()`.
       *
       * Reads data from binary format and merges the fields into
       * the target according to protobuf rules. If the target is
       * omitted, a new instance is created first.
       */
      internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create();
        this.refBinReader.read(reader, message, options, length);
        return message;
      }
    }
    function normalizeMethodInfo(method, service) {
      var _a, _b, _c;
      let m2 = method;
      m2.service = service;
      m2.localName = (_a = m2.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(m2.name);
      m2.serverStreaming = !!m2.serverStreaming;
      m2.clientStreaming = !!m2.clientStreaming;
      m2.options = (_b = m2.options) !== null && _b !== void 0 ? _b : {};
      m2.idempotency = (_c = m2.idempotency) !== null && _c !== void 0 ? _c : void 0;
      return m2;
    }
    class ServiceType {
      constructor(typeName, methods, options) {
        this.typeName = typeName;
        this.methods = methods.map((i) => normalizeMethodInfo(i, this));
        this.options = options !== null && options !== void 0 ? options : {};
      }
    }
    class RpcError extends Error {
      constructor(message, code2 = "UNKNOWN", meta) {
        super(message);
        this.name = "RpcError";
        Object.setPrototypeOf(this, new.target.prototype);
        this.code = code2;
        this.meta = meta !== null && meta !== void 0 ? meta : {};
      }
      toString() {
        const l2 = [this.name + ": " + this.message];
        if (this.code) {
          l2.push("");
          l2.push("Code: " + this.code);
        }
        if (this.serviceName && this.methodName) {
          l2.push("Method: " + this.serviceName + "/" + this.methodName);
        }
        let m2 = Object.entries(this.meta);
        if (m2.length) {
          l2.push("");
          l2.push("Meta:");
          for (let [k2, v2] of m2) {
            l2.push(`  ${k2}: ${v2}`);
          }
        }
        return l2.join("\n");
      }
    }
    function mergeRpcOptions(defaults2, options) {
      if (!options)
        return defaults2;
      let o = {};
      copy(defaults2, o);
      copy(options, o);
      for (let key of Object.keys(options)) {
        let val = options[key];
        switch (key) {
          case "jsonOptions":
            o.jsonOptions = mergeJsonOptions(defaults2.jsonOptions, o.jsonOptions);
            break;
          case "binaryOptions":
            o.binaryOptions = mergeBinaryOptions(defaults2.binaryOptions, o.binaryOptions);
            break;
          case "meta":
            o.meta = {};
            copy(defaults2.meta, o.meta);
            copy(options.meta, o.meta);
            break;
          case "interceptors":
            o.interceptors = defaults2.interceptors ? defaults2.interceptors.concat(val) : val.concat();
            break;
        }
      }
      return o;
    }
    function copy(a, into) {
      if (!a)
        return;
      let c = into;
      for (let [k2, v2] of Object.entries(a)) {
        if (v2 instanceof Date)
          c[k2] = new Date(v2.getTime());
        else if (Array.isArray(v2))
          c[k2] = v2.concat();
        else
          c[k2] = v2;
      }
    }
    var DeferredState;
    (function(DeferredState2) {
      DeferredState2[DeferredState2["PENDING"] = 0] = "PENDING";
      DeferredState2[DeferredState2["REJECTED"] = 1] = "REJECTED";
      DeferredState2[DeferredState2["RESOLVED"] = 2] = "RESOLVED";
    })(DeferredState || (DeferredState = {}));
    class Deferred {
      /**
       * @param preventUnhandledRejectionWarning - prevents the warning
       * "Unhandled Promise rejection" by adding a noop rejection handler.
       * Working with calls returned from the runtime-rpc package in an
       * async function usually means awaiting one call property after
       * the other. This means that the "status" is not being awaited when
       * an earlier await for the "headers" is rejected. This causes the
       * "unhandled promise reject" warning. A more correct behaviour for
       * calls might be to become aware whether at least one of the
       * promises is handled and swallow the rejection warning for the
       * others.
       */
      constructor(preventUnhandledRejectionWarning = true) {
        this._state = DeferredState.PENDING;
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
        if (preventUnhandledRejectionWarning) {
          this._promise.catch((_) => {
          });
        }
      }
      /**
       * Get the current state of the promise.
       */
      get state() {
        return this._state;
      }
      /**
       * Get the deferred promise.
       */
      get promise() {
        return this._promise;
      }
      /**
       * Resolve the promise. Throws if the promise is already resolved or rejected.
       */
      resolve(value) {
        if (this.state !== DeferredState.PENDING)
          throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
        this._resolve(value);
        this._state = DeferredState.RESOLVED;
      }
      /**
       * Reject the promise. Throws if the promise is already resolved or rejected.
       */
      reject(reason) {
        if (this.state !== DeferredState.PENDING)
          throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
        this._reject(reason);
        this._state = DeferredState.REJECTED;
      }
      /**
       * Resolve the promise. Ignore if not pending.
       */
      resolvePending(val) {
        if (this._state === DeferredState.PENDING)
          this.resolve(val);
      }
      /**
       * Reject the promise. Ignore if not pending.
       */
      rejectPending(reason) {
        if (this._state === DeferredState.PENDING)
          this.reject(reason);
      }
    }
    class RpcOutputStreamController {
      constructor() {
        this._lis = {
          nxt: [],
          msg: [],
          err: [],
          cmp: []
        };
        this._closed = false;
      }
      // --- RpcOutputStream callback API
      onNext(callback) {
        return this.addLis(callback, this._lis.nxt);
      }
      onMessage(callback) {
        return this.addLis(callback, this._lis.msg);
      }
      onError(callback) {
        return this.addLis(callback, this._lis.err);
      }
      onComplete(callback) {
        return this.addLis(callback, this._lis.cmp);
      }
      addLis(callback, list2) {
        list2.push(callback);
        return () => {
          let i = list2.indexOf(callback);
          if (i >= 0)
            list2.splice(i, 1);
        };
      }
      // remove all listeners
      clearLis() {
        for (let l2 of Object.values(this._lis))
          l2.splice(0, l2.length);
      }
      // --- Controller API
      /**
       * Is this stream already closed by a completion or error?
       */
      get closed() {
        return this._closed !== false;
      }
      /**
       * Emit message, close with error, or close successfully, but only one
       * at a time.
       * Can be used to wrap a stream by using the other stream's `onNext`.
       */
      notifyNext(message, error, complete) {
        assert$1((message ? 1 : 0) + (error ? 1 : 0) + (complete ? 1 : 0) <= 1, "only one emission at a time");
        if (message)
          this.notifyMessage(message);
        if (error)
          this.notifyError(error);
        if (complete)
          this.notifyComplete();
      }
      /**
       * Emits a new message. Throws if stream is closed.
       *
       * Triggers onNext and onMessage callbacks.
       */
      notifyMessage(message) {
        assert$1(!this.closed, "stream is closed");
        this.pushIt({ value: message, done: false });
        this._lis.msg.forEach((l2) => l2(message));
        this._lis.nxt.forEach((l2) => l2(message, void 0, false));
      }
      /**
       * Closes the stream with an error. Throws if stream is closed.
       *
       * Triggers onNext and onError callbacks.
       */
      notifyError(error) {
        assert$1(!this.closed, "stream is closed");
        this._closed = error;
        this.pushIt(error);
        this._lis.err.forEach((l2) => l2(error));
        this._lis.nxt.forEach((l2) => l2(void 0, error, false));
        this.clearLis();
      }
      /**
       * Closes the stream successfully. Throws if stream is closed.
       *
       * Triggers onNext and onComplete callbacks.
       */
      notifyComplete() {
        assert$1(!this.closed, "stream is closed");
        this._closed = true;
        this.pushIt({ value: null, done: true });
        this._lis.cmp.forEach((l2) => l2());
        this._lis.nxt.forEach((l2) => l2(void 0, void 0, true));
        this.clearLis();
      }
      /**
       * Creates an async iterator (that can be used with `for await {...}`)
       * to consume the stream.
       *
       * Some things to note:
       * - If an error occurs, the `for await` will throw it.
       * - If an error occurred before the `for await` was started, `for await`
       *   will re-throw it.
       * - If the stream is already complete, the `for await` will be empty.
       * - If your `for await` consumes slower than the stream produces,
       *   for example because you are relaying messages in a slow operation,
       *   messages are queued.
       */
      [Symbol.asyncIterator]() {
        if (!this._itState) {
          this._itState = { q: [] };
        }
        if (this._closed === true)
          this.pushIt({ value: null, done: true });
        else if (this._closed !== false)
          this.pushIt(this._closed);
        return {
          next: () => {
            let state = this._itState;
            assert$1(state, "bad state");
            assert$1(!state.p, "iterator contract broken");
            let first = state.q.shift();
            if (first)
              return "value" in first ? Promise.resolve(first) : Promise.reject(first);
            state.p = new Deferred();
            return state.p.promise;
          }
        };
      }
      // "push" a new iterator result.
      // this either resolves a pending promise, or enqueues the result.
      pushIt(result) {
        let state = this._itState;
        if (!state)
          return;
        if (state.p) {
          const p2 = state.p;
          assert$1(p2.state == DeferredState.PENDING, "iterator contract broken");
          "value" in result ? p2.resolve(result) : p2.reject(result);
          delete state.p;
        } else {
          state.q.push(result);
        }
      }
    }
    var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    class UnaryCall {
      constructor(method, requestHeaders, request, headers, response, status, trailers) {
        this.method = method;
        this.requestHeaders = requestHeaders;
        this.request = request;
        this.headers = headers;
        this.response = response;
        this.status = status;
        this.trailers = trailers;
      }
      /**
       * If you are only interested in the final outcome of this call,
       * you can await it to receive a `FinishedUnaryCall`.
       */
      then(onfulfilled, onrejected) {
        return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
      }
      promiseFinished() {
        return __awaiter$2(this, void 0, void 0, function* () {
          let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
          return {
            method: this.method,
            requestHeaders: this.requestHeaders,
            request: this.request,
            headers,
            response,
            status,
            trailers
          };
        });
      }
    }
    var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    class ServerStreamingCall {
      constructor(method, requestHeaders, request, headers, response, status, trailers) {
        this.method = method;
        this.requestHeaders = requestHeaders;
        this.request = request;
        this.headers = headers;
        this.responses = response;
        this.status = status;
        this.trailers = trailers;
      }
      /**
       * Instead of awaiting the response status and trailers, you can
       * just as well await this call itself to receive the server outcome.
       * You should first setup some listeners to the `request` to
       * see the actual messages the server replied with.
       */
      then(onfulfilled, onrejected) {
        return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
      }
      promiseFinished() {
        return __awaiter$1(this, void 0, void 0, function* () {
          let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
          return {
            method: this.method,
            requestHeaders: this.requestHeaders,
            request: this.request,
            headers,
            status,
            trailers
          };
        });
      }
    }
    function stackIntercept(kind, transport, method, options, input) {
      var _a, _b, _c, _d;
      if (kind == "unary") {
        let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
        for (const curr of ((_a = options.interceptors) !== null && _a !== void 0 ? _a : []).filter((i) => i.interceptUnary).reverse()) {
          const next = tail;
          tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);
        }
        return tail(method, input, options);
      }
      if (kind == "serverStreaming") {
        let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
        for (const curr of ((_b = options.interceptors) !== null && _b !== void 0 ? _b : []).filter((i) => i.interceptServerStreaming).reverse()) {
          const next = tail;
          tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);
        }
        return tail(method, input, options);
      }
      if (kind == "clientStreaming") {
        let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
        for (const curr of ((_c = options.interceptors) !== null && _c !== void 0 ? _c : []).filter((i) => i.interceptClientStreaming).reverse()) {
          const next = tail;
          tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);
        }
        return tail(method, options);
      }
      if (kind == "duplex") {
        let tail = (mtd, opt) => transport.duplex(mtd, opt);
        for (const curr of ((_d = options.interceptors) !== null && _d !== void 0 ? _d : []).filter((i) => i.interceptDuplex).reverse()) {
          const next = tail;
          tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);
        }
        return tail(method, options);
      }
      assertNever(kind);
    }
    class SimulatorInfo$Type extends MessageType {
      constructor() {
        super("api.unsafe.cockpit.SimulatorInfo", [
          {
            no: 1,
            name: "simulator_ip",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "brain_ip",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { simulatorIp: "", brainIp: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string simulator_ip */
            1:
              message.simulatorIp = reader.string();
              break;
            case /* string brain_ip */
            2:
              message.brainIp = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.simulatorIp !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.simulatorIp);
        if (message.brainIp !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.brainIp);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const SimulatorInfo = new SimulatorInfo$Type();
    let Void$Type$1 = class Void$Type extends MessageType {
      constructor() {
        super("api.unsafe.cockpit.Void", []);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
      }
      internalBinaryWrite(message, writer, options) {
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    };
    const Void$1 = new Void$Type$1();
    class Id$Type extends MessageType {
      constructor() {
        super("api.unsafe.cockpit.Id", [
          {
            no: 1,
            name: "widget_id",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          {
            no: 2,
            name: "element_id",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { widgetId: 0, elementId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint32 widget_id */
            1:
              message.widgetId = reader.uint32();
              break;
            case /* string element_id */
            2:
              message.elementId = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.widgetId !== 0)
          writer.tag(1, WireType.Varint).uint32(message.widgetId);
        if (message.elementId !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.elementId);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Id = new Id$Type();
    class Update$Type extends MessageType {
      constructor() {
        super("api.unsafe.cockpit.Update", [
          {
            no: 1,
            name: "widget_id",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          { no: 2, name: "widget_update", kind: "message", oneof: "what", T: () => Update_WidgetUpdate },
          { no: 3, name: "doc_update", kind: "message", oneof: "what", T: () => Update_DocUpdate },
          { no: 4, name: "widget_remove", kind: "message", oneof: "what", T: () => Update_WidgetRemove }
        ]);
      }
      create(value) {
        const message = { widgetId: 0, what: { oneofKind: void 0 } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint32 widget_id */
            1:
              message.widgetId = reader.uint32();
              break;
            case /* api.unsafe.cockpit.Update.WidgetUpdate widget_update */
            2:
              message.what = {
                oneofKind: "widgetUpdate",
                widgetUpdate: Update_WidgetUpdate.internalBinaryRead(reader, reader.uint32(), options, message.what.widgetUpdate)
              };
              break;
            case /* api.unsafe.cockpit.Update.DocUpdate doc_update */
            3:
              message.what = {
                oneofKind: "docUpdate",
                docUpdate: Update_DocUpdate.internalBinaryRead(reader, reader.uint32(), options, message.what.docUpdate)
              };
              break;
            case /* api.unsafe.cockpit.Update.WidgetRemove widget_remove */
            4:
              message.what = {
                oneofKind: "widgetRemove",
                widgetRemove: Update_WidgetRemove.internalBinaryRead(reader, reader.uint32(), options, message.what.widgetRemove)
              };
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.widgetId !== 0)
          writer.tag(1, WireType.Varint).uint32(message.widgetId);
        if (message.what.oneofKind === "widgetUpdate")
          Update_WidgetUpdate.internalBinaryWrite(message.what.widgetUpdate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        if (message.what.oneofKind === "docUpdate")
          Update_DocUpdate.internalBinaryWrite(message.what.docUpdate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        if (message.what.oneofKind === "widgetRemove")
          Update_WidgetRemove.internalBinaryWrite(message.what.widgetRemove, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Update = new Update$Type();
    class Update_WidgetUpdate$Type extends MessageType {
      constructor() {
        super("api.unsafe.cockpit.Update.WidgetUpdate", [
          {
            no: 1,
            name: "content_json",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { contentJson: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string content_json */
            1:
              message.contentJson = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.contentJson !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.contentJson);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Update_WidgetUpdate = new Update_WidgetUpdate$Type();
    class Update_DocUpdate$Type extends MessageType {
      constructor() {
        super("api.unsafe.cockpit.Update.DocUpdate", [
          {
            no: 1,
            name: "doc",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { doc: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string doc */
            1:
              message.doc = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.doc !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.doc);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Update_DocUpdate = new Update_DocUpdate$Type();
    class Update_WidgetRemove$Type extends MessageType {
      constructor() {
        super("api.unsafe.cockpit.Update.WidgetRemove", []);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
      }
      internalBinaryWrite(message, writer, options) {
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Update_WidgetRemove = new Update_WidgetRemove$Type();
    let StatusUpdate$Type$1 = class StatusUpdate$Type extends MessageType {
      constructor() {
        super("api.unsafe.cockpit.StatusUpdate", [
          { no: 1, name: "updates", kind: "message", repeat: 1, T: () => Update }
        ]);
      }
      create(value) {
        const message = { updates: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* repeated api.unsafe.cockpit.Update updates */
            1:
              message.updates.push(Update.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        for (let i = 0; i < message.updates.length; i++)
          Update.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    };
    const StatusUpdate$1 = new StatusUpdate$Type$1();
    const CockpitGui = new ServiceType("api.unsafe.cockpit.CockpitGui", [
      { name: "getUpdates", serverStreaming: true, options: {}, I: Void$1, O: StatusUpdate$1 },
      { name: "buttonPressed", options: {}, I: Id, O: Void$1 },
      { name: "buttonUnPressed", options: {}, I: Id, O: Void$1 },
      { name: "getSimulatorInfo", options: {}, I: Void$1, O: SimulatorInfo }
    ]);
    class CockpitGuiClient {
      constructor(_transport) {
        this._transport = _transport;
        this.typeName = CockpitGui.typeName;
        this.methods = CockpitGui.methods;
        this.options = CockpitGui.options;
      }
      /**
       * @generated from protobuf rpc: getUpdates(api.unsafe.cockpit.Void) returns (stream api.unsafe.cockpit.StatusUpdate);
       */
      getUpdates(input, options) {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: buttonPressed(api.unsafe.cockpit.Id) returns (api.unsafe.cockpit.Void);
       */
      buttonPressed(input, options) {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: buttonUnPressed(api.unsafe.cockpit.Id) returns (api.unsafe.cockpit.Void);
       */
      buttonUnPressed(input, options) {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: getSimulatorInfo(api.unsafe.cockpit.Void) returns (api.unsafe.cockpit.SimulatorInfo);
       */
      getSimulatorInfo(input, options) {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
    }
    var ResourceType = /* @__PURE__ */ ((ResourceType2) => {
      ResourceType2[ResourceType2["GOLD"] = 0] = "GOLD";
      ResourceType2[ResourceType2["IRON"] = 1] = "IRON";
      ResourceType2[ResourceType2["PLATIN"] = 2] = "PLATIN";
      ResourceType2[ResourceType2["STONE"] = 3] = "STONE";
      ResourceType2[ResourceType2["URAN"] = 4] = "URAN";
      ResourceType2[ResourceType2["IRIDIUM"] = 5] = "IRIDIUM";
      return ResourceType2;
    })(ResourceType || {});
    class Void$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Void", []);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
      }
      internalBinaryWrite(message, writer, options) {
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Void = new Void$Type();
    class Vec$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Vec", [
          {
            no: 1,
            name: "x",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 2,
            name: "y",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 3,
            name: "angle",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          }
        ]);
      }
      create(value) {
        const message = { x: 0, y: 0, angle: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* double x */
            1:
              message.x = reader.double();
              break;
            case /* double y */
            2:
              message.y = reader.double();
              break;
            case /* double angle */
            3:
              message.angle = reader.double();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.x !== 0)
          writer.tag(1, WireType.Bit64).double(message.x);
        if (message.y !== 0)
          writer.tag(2, WireType.Bit64).double(message.y);
        if (message.angle !== 0)
          writer.tag(3, WireType.Bit64).double(message.angle);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Vec = new Vec$Type();
    class PhysicalObject$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.PhysicalObject", [
          { no: 1, name: "pos", kind: "message", T: () => Vec },
          { no: 2, name: "velocity", kind: "message", T: () => Vec }
        ]);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.Vec pos */
            1:
              message.pos = Vec.internalBinaryRead(reader, reader.uint32(), options, message.pos);
              break;
            case /* api.unsafe.gui.Vec velocity */
            2:
              message.velocity = Vec.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.pos)
          Vec.internalBinaryWrite(message.pos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.velocity)
          Vec.internalBinaryWrite(message.velocity, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const PhysicalObject = new PhysicalObject$Type();
    class Thruster$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Thruster", [
          {
            no: 1,
            name: "strength",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          }
        ]);
      }
      create(value) {
        const message = { strength: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* double strength */
            1:
              message.strength = reader.double();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.strength !== 0)
          writer.tag(1, WireType.Bit64).double(message.strength);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Thruster = new Thruster$Type();
    class ShipThrusters$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.ShipThrusters", [
          { no: 1, name: "back", kind: "message", T: () => Thruster },
          { no: 2, name: "front", kind: "message", T: () => Thruster },
          { no: 3, name: "front_left", kind: "message", T: () => Thruster },
          { no: 4, name: "front_right", kind: "message", T: () => Thruster },
          { no: 5, name: "bottom_left", kind: "message", T: () => Thruster },
          { no: 6, name: "bottom_right", kind: "message", T: () => Thruster }
        ]);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.Thruster back */
            1:
              message.back = Thruster.internalBinaryRead(reader, reader.uint32(), options, message.back);
              break;
            case /* api.unsafe.gui.Thruster front */
            2:
              message.front = Thruster.internalBinaryRead(reader, reader.uint32(), options, message.front);
              break;
            case /* api.unsafe.gui.Thruster front_left */
            3:
              message.frontLeft = Thruster.internalBinaryRead(reader, reader.uint32(), options, message.frontLeft);
              break;
            case /* api.unsafe.gui.Thruster front_right */
            4:
              message.frontRight = Thruster.internalBinaryRead(reader, reader.uint32(), options, message.frontRight);
              break;
            case /* api.unsafe.gui.Thruster bottom_left */
            5:
              message.bottomLeft = Thruster.internalBinaryRead(reader, reader.uint32(), options, message.bottomLeft);
              break;
            case /* api.unsafe.gui.Thruster bottom_right */
            6:
              message.bottomRight = Thruster.internalBinaryRead(reader, reader.uint32(), options, message.bottomRight);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.back)
          Thruster.internalBinaryWrite(message.back, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.front)
          Thruster.internalBinaryWrite(message.front, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        if (message.frontLeft)
          Thruster.internalBinaryWrite(message.frontLeft, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        if (message.frontRight)
          Thruster.internalBinaryWrite(message.frontRight, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        if (message.bottomLeft)
          Thruster.internalBinaryWrite(message.bottomLeft, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        if (message.bottomRight)
          Thruster.internalBinaryWrite(message.bottomRight, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const ShipThrusters = new ShipThrusters$Type();
    class Ship$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Ship", [
          { no: 1, name: "physical", kind: "message", T: () => PhysicalObject },
          { no: 2, name: "thrusters", kind: "message", T: () => ShipThrusters }
        ]);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.PhysicalObject physical */
            1:
              message.physical = PhysicalObject.internalBinaryRead(reader, reader.uint32(), options, message.physical);
              break;
            case /* api.unsafe.gui.ShipThrusters thrusters */
            2:
              message.thrusters = ShipThrusters.internalBinaryRead(reader, reader.uint32(), options, message.thrusters);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.physical)
          PhysicalObject.internalBinaryWrite(message.physical, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.thrusters)
          ShipThrusters.internalBinaryWrite(message.thrusters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Ship$1 = new Ship$Type();
    class Asteroid$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Asteroid", [
          { no: 1, name: "physical", kind: "message", T: () => PhysicalObject }
        ]);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.PhysicalObject physical */
            1:
              message.physical = PhysicalObject.internalBinaryRead(reader, reader.uint32(), options, message.physical);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.physical)
          PhysicalObject.internalBinaryWrite(message.physical, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Asteroid$1 = new Asteroid$Type();
    class MineableAsteroid$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.MineableAsteroid", [
          { no: 1, name: "physical", kind: "message", T: () => PhysicalObject }
        ]);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.PhysicalObject physical */
            1:
              message.physical = PhysicalObject.internalBinaryRead(reader, reader.uint32(), options, message.physical);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.physical)
          PhysicalObject.internalBinaryWrite(message.physical, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const MineableAsteroid$1 = new MineableAsteroid$Type();
    class SpaceStation$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.SpaceStation", [
          { no: 1, name: "physical", kind: "message", T: () => PhysicalObject },
          {
            no: 2,
            name: "moving_current_target",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          { no: 3, name: "moving_between_positions", kind: "message", repeat: 1, T: () => Vec },
          {
            no: 4,
            name: "is_moving_between_positions",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          }
        ]);
      }
      create(value) {
        const message = { movingCurrentTarget: 0, movingBetweenPositions: [], isMovingBetweenPositions: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.PhysicalObject physical */
            1:
              message.physical = PhysicalObject.internalBinaryRead(reader, reader.uint32(), options, message.physical);
              break;
            case /* uint32 moving_current_target */
            2:
              message.movingCurrentTarget = reader.uint32();
              break;
            case /* repeated api.unsafe.gui.Vec moving_between_positions */
            3:
              message.movingBetweenPositions.push(Vec.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* bool is_moving_between_positions */
            4:
              message.isMovingBetweenPositions = reader.bool();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.physical)
          PhysicalObject.internalBinaryWrite(message.physical, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.movingCurrentTarget !== 0)
          writer.tag(2, WireType.Varint).uint32(message.movingCurrentTarget);
        for (let i = 0; i < message.movingBetweenPositions.length; i++)
          Vec.internalBinaryWrite(message.movingBetweenPositions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        if (message.isMovingBetweenPositions !== false)
          writer.tag(4, WireType.Varint).bool(message.isMovingBetweenPositions);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const SpaceStation$1 = new SpaceStation$Type();
    class ResourceInHold$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.ResourceInHold", [
          { no: 1, name: "type", kind: "enum", T: () => ["api.unsafe.gui.ResourceType", ResourceType] },
          {
            no: 2,
            name: "amount",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          }
        ]);
      }
      create(value) {
        const message = { type: 0, amount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.ResourceType type */
            1:
              message.type = reader.int32();
              break;
            case /* uint32 amount */
            2:
              message.amount = reader.uint32();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.type !== 0)
          writer.tag(1, WireType.Varint).int32(message.type);
        if (message.amount !== 0)
          writer.tag(2, WireType.Varint).uint32(message.amount);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const ResourceInHold = new ResourceInHold$Type();
    class MissionId$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.MissionId", [
          {
            no: 1,
            name: "value",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string value */
            1:
              message.value = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.value !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const MissionId = new MissionId$Type();
    class ActiveMission$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.ActiveMission", [
          { no: 1, name: "id", kind: "message", T: () => MissionId },
          {
            no: 2,
            name: "step",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          }
        ]);
      }
      create(value) {
        const message = { step: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.MissionId id */
            1:
              message.id = MissionId.internalBinaryRead(reader, reader.uint32(), options, message.id);
              break;
            case /* uint32 step */
            2:
              message.step = reader.uint32();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.id)
          MissionId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.step !== 0)
          writer.tag(2, WireType.Varint).uint32(message.step);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const ActiveMission = new ActiveMission$Type();
    class CargoHoldState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CargoHoldState", [
          { no: 1, name: "slots", kind: "map", K: 9, V: { kind: "message", T: () => CargoHoldState_Slot } },
          { no: 2, name: "opt_current_robot_activity", kind: "message", repeat: 1, T: () => CargoHoldState_Movement }
        ]);
      }
      create(value) {
        const message = { slots: {}, optCurrentRobotActivity: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* map<string, api.unsafe.gui.CargoHoldState.Slot> slots */
            1:
              this.binaryReadMap1(message.slots, reader, options);
              break;
            case /* repeated api.unsafe.gui.CargoHoldState.Movement opt_current_robot_activity */
            2:
              message.optCurrentRobotActivity.push(CargoHoldState_Movement.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      binaryReadMap1(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = CargoHoldState_Slot.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.CargoHoldState.slots");
          }
        }
        map2[key ?? ""] = val ?? CargoHoldState_Slot.create();
      }
      internalBinaryWrite(message, writer, options) {
        for (let k2 of Object.keys(message.slots)) {
          writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          CargoHoldState_Slot.internalBinaryWrite(message.slots[k2], writer, options);
          writer.join().join();
        }
        for (let i = 0; i < message.optCurrentRobotActivity.length; i++)
          CargoHoldState_Movement.internalBinaryWrite(message.optCurrentRobotActivity[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CargoHoldState = new CargoHoldState$Type();
    class CargoHoldState_SlotPos$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CargoHoldState.SlotPos", [
          {
            no: 1,
            name: "x",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          {
            no: 2,
            name: "y",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          }
        ]);
      }
      create(value) {
        const message = { x: 0, y: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint32 x */
            1:
              message.x = reader.uint32();
              break;
            case /* uint32 y */
            2:
              message.y = reader.uint32();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.x !== 0)
          writer.tag(1, WireType.Varint).uint32(message.x);
        if (message.y !== 0)
          writer.tag(2, WireType.Varint).uint32(message.y);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CargoHoldState_SlotPos = new CargoHoldState_SlotPos$Type();
    class CargoHoldState_Slot$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CargoHoldState.Slot", [
          { no: 3, name: "opt_holds", kind: "enum", repeat: 1, T: () => ["api.unsafe.gui.ResourceType", ResourceType] }
        ]);
      }
      create(value) {
        const message = { optHolds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* repeated api.unsafe.gui.ResourceType opt_holds */
            3:
              if (wireType === WireType.LengthDelimited)
                for (let e = reader.int32() + reader.pos; reader.pos < e; )
                  message.optHolds.push(reader.int32());
              else
                message.optHolds.push(reader.int32());
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.optHolds.length) {
          writer.tag(3, WireType.LengthDelimited).fork();
          for (let i = 0; i < message.optHolds.length; i++)
            writer.int32(message.optHolds[i]);
          writer.join();
        }
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CargoHoldState_Slot = new CargoHoldState_Slot$Type();
    class CargoHoldState_Movement$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CargoHoldState.Movement", [
          {
            no: 1,
            name: "started",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          { no: 2, name: "a", kind: "message", T: () => CargoHoldState_SlotPos },
          { no: 3, name: "b", kind: "message", T: () => CargoHoldState_SlotPos }
        ]);
      }
      create(value) {
        const message = { started: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint64 started */
            1:
              message.started = reader.uint64().toBigInt();
              break;
            case /* api.unsafe.gui.CargoHoldState.SlotPos a */
            2:
              message.a = CargoHoldState_SlotPos.internalBinaryRead(reader, reader.uint32(), options, message.a);
              break;
            case /* api.unsafe.gui.CargoHoldState.SlotPos b */
            3:
              message.b = CargoHoldState_SlotPos.internalBinaryRead(reader, reader.uint32(), options, message.b);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.started !== 0n)
          writer.tag(1, WireType.Varint).uint64(message.started);
        if (message.a)
          CargoHoldState_SlotPos.internalBinaryWrite(message.a, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        if (message.b)
          CargoHoldState_SlotPos.internalBinaryWrite(message.b, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CargoHoldState_Movement = new CargoHoldState_Movement$Type();
    class ItemId$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.ItemId", [
          {
            no: 1,
            name: "value",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string value */
            1:
              message.value = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.value !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const ItemId = new ItemId$Type();
    class Group$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Group", [
          {
            no: 1,
            name: "display_name",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          { no: 2, name: "ship", kind: "message", T: () => Ship$1 },
          {
            no: 3,
            name: "credits",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          { no: 4, name: "items", kind: "message", repeat: 1, T: () => ItemId },
          { no: 5, name: "active_missions", kind: "message", repeat: 1, T: () => ActiveMission },
          { no: 6, name: "finished_missions", kind: "message", repeat: 1, T: () => MissionId },
          {
            no: 7,
            name: "laser_is_active_since",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 8,
            name: "laser_is_cooling_down_until",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 9,
            name: "laser_angle",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 10,
            name: "laser_is_mining_since",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 11,
            name: "laser_last_resource_collect",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 12,
            name: "laser_is_enabled_since",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          { no: 13, name: "cargo_hold", kind: "message", T: () => CargoHoldState },
          { no: 14, name: "station_in_reach_since", kind: "map", K: 9, V: {
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          } },
          { no: 15, name: "station_in_reach_since_with_laser", kind: "map", K: 9, V: {
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          } },
          {
            no: 17,
            name: "mission_moving_station_name",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 19,
            name: "per_group_missions_for_6_offset",
            kind: "scalar",
            T: 5
            /*ScalarType.INT32*/
          },
          {
            no: 21,
            name: "per_class_missions_for_6_offset",
            kind: "scalar",
            T: 5
            /*ScalarType.INT32*/
          },
          {
            no: 20,
            name: "counts_for_class_missions",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          { no: 16, name: "chat_script_states", kind: "map", K: 9, V: { kind: "message", T: () => Group_ChatScriptState } },
          { no: 18, name: "members", kind: "map", K: 9, V: { kind: "message", T: () => Group_Member } }
        ]);
      }
      create(value) {
        const message = { displayName: "", credits: 0n, items: [], activeMissions: [], finishedMissions: [], laserIsActiveSince: 0n, laserIsCoolingDownUntil: 0n, laserAngle: 0, laserIsMiningSince: 0n, laserLastResourceCollect: 0n, laserIsEnabledSince: 0n, stationInReachSince: {}, stationInReachSinceWithLaser: {}, missionMovingStationName: "", perGroupMissionsFor6Offset: 0, perClassMissionsFor6Offset: 0, countsForClassMissions: false, chatScriptStates: {}, members: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string display_name */
            1:
              message.displayName = reader.string();
              break;
            case /* api.unsafe.gui.Ship ship */
            2:
              message.ship = Ship$1.internalBinaryRead(reader, reader.uint32(), options, message.ship);
              break;
            case /* uint64 credits */
            3:
              message.credits = reader.uint64().toBigInt();
              break;
            case /* repeated api.unsafe.gui.ItemId items */
            4:
              message.items.push(ItemId.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* repeated api.unsafe.gui.ActiveMission active_missions */
            5:
              message.activeMissions.push(ActiveMission.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* repeated api.unsafe.gui.MissionId finished_missions */
            6:
              message.finishedMissions.push(MissionId.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* uint64 laser_is_active_since */
            7:
              message.laserIsActiveSince = reader.uint64().toBigInt();
              break;
            case /* uint64 laser_is_cooling_down_until */
            8:
              message.laserIsCoolingDownUntil = reader.uint64().toBigInt();
              break;
            case /* double laser_angle */
            9:
              message.laserAngle = reader.double();
              break;
            case /* uint64 laser_is_mining_since */
            10:
              message.laserIsMiningSince = reader.uint64().toBigInt();
              break;
            case /* uint64 laser_last_resource_collect */
            11:
              message.laserLastResourceCollect = reader.uint64().toBigInt();
              break;
            case /* uint64 laser_is_enabled_since */
            12:
              message.laserIsEnabledSince = reader.uint64().toBigInt();
              break;
            case /* api.unsafe.gui.CargoHoldState cargo_hold */
            13:
              message.cargoHold = CargoHoldState.internalBinaryRead(reader, reader.uint32(), options, message.cargoHold);
              break;
            case /* map<string, uint64> station_in_reach_since */
            14:
              this.binaryReadMap14(message.stationInReachSince, reader, options);
              break;
            case /* map<string, uint64> station_in_reach_since_with_laser */
            15:
              this.binaryReadMap15(message.stationInReachSinceWithLaser, reader, options);
              break;
            case /* string mission_moving_station_name */
            17:
              message.missionMovingStationName = reader.string();
              break;
            case /* int32 per_group_missions_for_6_offset */
            19:
              message.perGroupMissionsFor6Offset = reader.int32();
              break;
            case /* int32 per_class_missions_for_6_offset */
            21:
              message.perClassMissionsFor6Offset = reader.int32();
              break;
            case /* bool counts_for_class_missions */
            20:
              message.countsForClassMissions = reader.bool();
              break;
            case /* map<string, api.unsafe.gui.Group.ChatScriptState> chat_script_states */
            16:
              this.binaryReadMap16(message.chatScriptStates, reader, options);
              break;
            case /* map<string, api.unsafe.gui.Group.Member> members */
            18:
              this.binaryReadMap18(message.members, reader, options);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      binaryReadMap14(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = reader.uint64().toBigInt();
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.Group.station_in_reach_since");
          }
        }
        map2[key ?? ""] = val ?? 0n;
      }
      binaryReadMap15(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = reader.uint64().toBigInt();
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.Group.station_in_reach_since_with_laser");
          }
        }
        map2[key ?? ""] = val ?? 0n;
      }
      binaryReadMap16(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = Group_ChatScriptState.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.Group.chat_script_states");
          }
        }
        map2[key ?? ""] = val ?? Group_ChatScriptState.create();
      }
      binaryReadMap18(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = Group_Member.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.Group.members");
          }
        }
        map2[key ?? ""] = val ?? Group_Member.create();
      }
      internalBinaryWrite(message, writer, options) {
        if (message.displayName !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.displayName);
        if (message.ship)
          Ship$1.internalBinaryWrite(message.ship, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        if (message.credits !== 0n)
          writer.tag(3, WireType.Varint).uint64(message.credits);
        for (let i = 0; i < message.items.length; i++)
          ItemId.internalBinaryWrite(message.items[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.activeMissions.length; i++)
          ActiveMission.internalBinaryWrite(message.activeMissions[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.finishedMissions.length; i++)
          MissionId.internalBinaryWrite(message.finishedMissions[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        if (message.laserIsActiveSince !== 0n)
          writer.tag(7, WireType.Varint).uint64(message.laserIsActiveSince);
        if (message.laserIsCoolingDownUntil !== 0n)
          writer.tag(8, WireType.Varint).uint64(message.laserIsCoolingDownUntil);
        if (message.laserAngle !== 0)
          writer.tag(9, WireType.Bit64).double(message.laserAngle);
        if (message.laserIsMiningSince !== 0n)
          writer.tag(10, WireType.Varint).uint64(message.laserIsMiningSince);
        if (message.laserLastResourceCollect !== 0n)
          writer.tag(11, WireType.Varint).uint64(message.laserLastResourceCollect);
        if (message.laserIsEnabledSince !== 0n)
          writer.tag(12, WireType.Varint).uint64(message.laserIsEnabledSince);
        if (message.cargoHold)
          CargoHoldState.internalBinaryWrite(message.cargoHold, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        for (let k2 of Object.keys(message.stationInReachSince))
          writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2).tag(2, WireType.Varint).uint64(message.stationInReachSince[k2]).join();
        for (let k2 of Object.keys(message.stationInReachSinceWithLaser))
          writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2).tag(2, WireType.Varint).uint64(message.stationInReachSinceWithLaser[k2]).join();
        if (message.missionMovingStationName !== "")
          writer.tag(17, WireType.LengthDelimited).string(message.missionMovingStationName);
        if (message.perGroupMissionsFor6Offset !== 0)
          writer.tag(19, WireType.Varint).int32(message.perGroupMissionsFor6Offset);
        if (message.perClassMissionsFor6Offset !== 0)
          writer.tag(21, WireType.Varint).int32(message.perClassMissionsFor6Offset);
        if (message.countsForClassMissions !== false)
          writer.tag(20, WireType.Varint).bool(message.countsForClassMissions);
        for (let k2 of Object.keys(message.chatScriptStates)) {
          writer.tag(16, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          Group_ChatScriptState.internalBinaryWrite(message.chatScriptStates[k2], writer, options);
          writer.join().join();
        }
        for (let k2 of Object.keys(message.members)) {
          writer.tag(18, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          Group_Member.internalBinaryWrite(message.members[k2], writer, options);
          writer.join().join();
        }
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Group = new Group$Type();
    class Group_ChatScriptState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Group.ChatScriptState", [
          {
            no: 1,
            name: "step",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 2,
            name: "since",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 3,
            name: "previous_choices",
            kind: "scalar",
            repeat: 1,
            T: 13
            /*ScalarType.UINT32*/
          }
        ]);
      }
      create(value) {
        const message = { step: 0n, since: 0n, previousChoices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint64 step */
            1:
              message.step = reader.uint64().toBigInt();
              break;
            case /* uint64 since */
            2:
              message.since = reader.uint64().toBigInt();
              break;
            case /* repeated uint32 previous_choices */
            3:
              if (wireType === WireType.LengthDelimited)
                for (let e = reader.int32() + reader.pos; reader.pos < e; )
                  message.previousChoices.push(reader.uint32());
              else
                message.previousChoices.push(reader.uint32());
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.step !== 0n)
          writer.tag(1, WireType.Varint).uint64(message.step);
        if (message.since !== 0n)
          writer.tag(2, WireType.Varint).uint64(message.since);
        if (message.previousChoices.length) {
          writer.tag(3, WireType.LengthDelimited).fork();
          for (let i = 0; i < message.previousChoices.length; i++)
            writer.uint32(message.previousChoices[i]);
          writer.join();
        }
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Group_ChatScriptState = new Group_ChatScriptState$Type();
    class Group_Member$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Group.Member", [
          {
            no: 1,
            name: "per_group_missions_for_6_offset",
            kind: "scalar",
            T: 5
            /*ScalarType.INT32*/
          },
          {
            no: 2,
            name: "per_class_missions_for_6_offset",
            kind: "scalar",
            T: 5
            /*ScalarType.INT32*/
          }
        ]);
      }
      create(value) {
        const message = { perGroupMissionsFor6Offset: 0, perClassMissionsFor6Offset: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* int32 per_group_missions_for_6_offset */
            1:
              message.perGroupMissionsFor6Offset = reader.int32();
              break;
            case /* int32 per_class_missions_for_6_offset */
            2:
              message.perClassMissionsFor6Offset = reader.int32();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.perGroupMissionsFor6Offset !== 0)
          writer.tag(1, WireType.Varint).int32(message.perGroupMissionsFor6Offset);
        if (message.perClassMissionsFor6Offset !== 0)
          writer.tag(2, WireType.Varint).int32(message.perClassMissionsFor6Offset);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Group_Member = new Group_Member$Type();
    class PidControllerState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.PidControllerState", [
          {
            no: 1,
            name: "dt",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 2,
            name: "max",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 3,
            name: "min",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 4,
            name: "kp",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 5,
            name: "kd",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 6,
            name: "ki",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 7,
            name: "err",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 8,
            name: "integral",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          }
        ]);
      }
      create(value) {
        const message = { dt: 0, max: 0, min: 0, kp: 0, kd: 0, ki: 0, err: 0, integral: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* double dt */
            1:
              message.dt = reader.double();
              break;
            case /* double max */
            2:
              message.max = reader.double();
              break;
            case /* double min */
            3:
              message.min = reader.double();
              break;
            case /* double kp */
            4:
              message.kp = reader.double();
              break;
            case /* double kd */
            5:
              message.kd = reader.double();
              break;
            case /* double ki */
            6:
              message.ki = reader.double();
              break;
            case /* double err */
            7:
              message.err = reader.double();
              break;
            case /* double integral */
            8:
              message.integral = reader.double();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.dt !== 0)
          writer.tag(1, WireType.Bit64).double(message.dt);
        if (message.max !== 0)
          writer.tag(2, WireType.Bit64).double(message.max);
        if (message.min !== 0)
          writer.tag(3, WireType.Bit64).double(message.min);
        if (message.kp !== 0)
          writer.tag(4, WireType.Bit64).double(message.kp);
        if (message.kd !== 0)
          writer.tag(5, WireType.Bit64).double(message.kd);
        if (message.ki !== 0)
          writer.tag(6, WireType.Bit64).double(message.ki);
        if (message.err !== 0)
          writer.tag(7, WireType.Bit64).double(message.err);
        if (message.integral !== 0)
          writer.tag(8, WireType.Bit64).double(message.integral);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const PidControllerState = new PidControllerState$Type();
    class EasySteeringState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.EasySteeringState", [
          { no: 1, name: "pid_rotate", kind: "message", T: () => PidControllerState },
          { no: 2, name: "pid_y", kind: "message", T: () => PidControllerState }
        ]);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.PidControllerState pid_rotate */
            1:
              message.pidRotate = PidControllerState.internalBinaryRead(reader, reader.uint32(), options, message.pidRotate);
              break;
            case /* api.unsafe.gui.PidControllerState pid_y */
            2:
              message.pidY = PidControllerState.internalBinaryRead(reader, reader.uint32(), options, message.pidY);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.pidRotate)
          PidControllerState.internalBinaryWrite(message.pidRotate, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.pidY)
          PidControllerState.internalBinaryWrite(message.pidY, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const EasySteeringState = new EasySteeringState$Type();
    class CaptainMorris$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CaptainMorris", [
          {
            no: 1,
            name: "current_target",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          { no: 2, name: "easy_steering", kind: "message", T: () => EasySteeringState },
          { no: 3, name: "ship", kind: "message", T: () => Ship$1 }
        ]);
      }
      create(value) {
        const message = { currentTarget: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint32 current_target */
            1:
              message.currentTarget = reader.uint32();
              break;
            case /* api.unsafe.gui.EasySteeringState easy_steering */
            2:
              message.easySteering = EasySteeringState.internalBinaryRead(reader, reader.uint32(), options, message.easySteering);
              break;
            case /* api.unsafe.gui.Ship ship */
            3:
              message.ship = Ship$1.internalBinaryRead(reader, reader.uint32(), options, message.ship);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.currentTarget !== 0)
          writer.tag(1, WireType.Varint).uint32(message.currentTarget);
        if (message.easySteering)
          EasySteeringState.internalBinaryWrite(message.easySteering, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        if (message.ship)
          Ship$1.internalBinaryWrite(message.ship, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CaptainMorris = new CaptainMorris$Type();
    class GameState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.GameState", [
          {
            no: 1,
            name: "tick",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          { no: 2, name: "groups", kind: "map", K: 9, V: { kind: "message", T: () => Group } },
          { no: 3, name: "space_stations", kind: "map", K: 9, V: { kind: "message", T: () => SpaceStation$1 } },
          { no: 4, name: "asteroids", kind: "message", repeat: 1, T: () => Asteroid$1 },
          { no: 5, name: "mineable_asteroids", kind: "map", K: 9, V: { kind: "message", T: () => MineableAsteroid$1 } },
          {
            no: 7,
            name: "current_research_station_target",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          {
            no: 9,
            name: "secret_key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 21,
            name: "per_group_missions_for_6",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          {
            no: 22,
            name: "per_class_missions_for_6",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          { no: 23, name: "captain_morris", kind: "message", T: () => CaptainMorris },
          {
            no: 24,
            name: "destroyed_mineable_asteroids",
            kind: "scalar",
            repeat: 2,
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 10,
            name: "init_note",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          },
          {
            no: 11,
            name: "missions_for_init_note",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          {
            no: 12,
            name: "random_state",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          { no: 20, name: "chat_script_states", kind: "map", K: 9, V: { kind: "message", T: () => GameState_ChatScriptState } }
        ]);
      }
      create(value) {
        const message = { tick: 0n, groups: {}, spaceStations: {}, asteroids: [], mineableAsteroids: {}, currentResearchStationTarget: 0, secretKey: "", perGroupMissionsFor6: 0, perClassMissionsFor6: 0, destroyedMineableAsteroids: [], initNote: 0, missionsForInitNote: 0, randomState: "", chatScriptStates: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint64 tick */
            1:
              message.tick = reader.uint64().toBigInt();
              break;
            case /* map<string, api.unsafe.gui.Group> groups */
            2:
              this.binaryReadMap2(message.groups, reader, options);
              break;
            case /* map<string, api.unsafe.gui.SpaceStation> space_stations */
            3:
              this.binaryReadMap3(message.spaceStations, reader, options);
              break;
            case /* repeated api.unsafe.gui.Asteroid asteroids */
            4:
              message.asteroids.push(Asteroid$1.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* map<string, api.unsafe.gui.MineableAsteroid> mineable_asteroids */
            5:
              this.binaryReadMap5(message.mineableAsteroids, reader, options);
              break;
            case /* uint32 current_research_station_target */
            7:
              message.currentResearchStationTarget = reader.uint32();
              break;
            case /* string secret_key */
            9:
              message.secretKey = reader.string();
              break;
            case /* uint32 per_group_missions_for_6 */
            21:
              message.perGroupMissionsFor6 = reader.uint32();
              break;
            case /* uint32 per_class_missions_for_6 */
            22:
              message.perClassMissionsFor6 = reader.uint32();
              break;
            case /* api.unsafe.gui.CaptainMorris captain_morris */
            23:
              message.captainMorris = CaptainMorris.internalBinaryRead(reader, reader.uint32(), options, message.captainMorris);
              break;
            case /* repeated string destroyed_mineable_asteroids */
            24:
              message.destroyedMineableAsteroids.push(reader.string());
              break;
            case /* float init_note */
            10:
              message.initNote = reader.float();
              break;
            case /* uint32 missions_for_init_note */
            11:
              message.missionsForInitNote = reader.uint32();
              break;
            case /* string random_state */
            12:
              message.randomState = reader.string();
              break;
            case /* map<string, api.unsafe.gui.GameState.ChatScriptState> chat_script_states */
            20:
              this.binaryReadMap20(message.chatScriptStates, reader, options);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      binaryReadMap2(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = Group.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.GameState.groups");
          }
        }
        map2[key ?? ""] = val ?? Group.create();
      }
      binaryReadMap3(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = SpaceStation$1.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.GameState.space_stations");
          }
        }
        map2[key ?? ""] = val ?? SpaceStation$1.create();
      }
      binaryReadMap5(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = MineableAsteroid$1.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.GameState.mineable_asteroids");
          }
        }
        map2[key ?? ""] = val ?? MineableAsteroid$1.create();
      }
      binaryReadMap20(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = GameState_ChatScriptState.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.GameState.chat_script_states");
          }
        }
        map2[key ?? ""] = val ?? GameState_ChatScriptState.create();
      }
      internalBinaryWrite(message, writer, options) {
        if (message.tick !== 0n)
          writer.tag(1, WireType.Varint).uint64(message.tick);
        for (let k2 of Object.keys(message.groups)) {
          writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          Group.internalBinaryWrite(message.groups[k2], writer, options);
          writer.join().join();
        }
        for (let k2 of Object.keys(message.spaceStations)) {
          writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          SpaceStation$1.internalBinaryWrite(message.spaceStations[k2], writer, options);
          writer.join().join();
        }
        for (let i = 0; i < message.asteroids.length; i++)
          Asteroid$1.internalBinaryWrite(message.asteroids[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        for (let k2 of Object.keys(message.mineableAsteroids)) {
          writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          MineableAsteroid$1.internalBinaryWrite(message.mineableAsteroids[k2], writer, options);
          writer.join().join();
        }
        if (message.currentResearchStationTarget !== 0)
          writer.tag(7, WireType.Varint).uint32(message.currentResearchStationTarget);
        if (message.secretKey !== "")
          writer.tag(9, WireType.LengthDelimited).string(message.secretKey);
        if (message.perGroupMissionsFor6 !== 0)
          writer.tag(21, WireType.Varint).uint32(message.perGroupMissionsFor6);
        if (message.perClassMissionsFor6 !== 0)
          writer.tag(22, WireType.Varint).uint32(message.perClassMissionsFor6);
        if (message.captainMorris)
          CaptainMorris.internalBinaryWrite(message.captainMorris, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.destroyedMineableAsteroids.length; i++)
          writer.tag(24, WireType.LengthDelimited).string(message.destroyedMineableAsteroids[i]);
        if (message.initNote !== 0)
          writer.tag(10, WireType.Bit32).float(message.initNote);
        if (message.missionsForInitNote !== 0)
          writer.tag(11, WireType.Varint).uint32(message.missionsForInitNote);
        if (message.randomState !== "")
          writer.tag(12, WireType.LengthDelimited).string(message.randomState);
        for (let k2 of Object.keys(message.chatScriptStates)) {
          writer.tag(20, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          GameState_ChatScriptState.internalBinaryWrite(message.chatScriptStates[k2], writer, options);
          writer.join().join();
        }
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const GameState = new GameState$Type();
    class GameState_ChatScriptState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.GameState.ChatScriptState", [
          {
            no: 1,
            name: "step",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 2,
            name: "since",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 3,
            name: "previous_choices",
            kind: "scalar",
            repeat: 1,
            T: 13
            /*ScalarType.UINT32*/
          }
        ]);
      }
      create(value) {
        const message = { step: 0n, since: 0n, previousChoices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint64 step */
            1:
              message.step = reader.uint64().toBigInt();
              break;
            case /* uint64 since */
            2:
              message.since = reader.uint64().toBigInt();
              break;
            case /* repeated uint32 previous_choices */
            3:
              if (wireType === WireType.LengthDelimited)
                for (let e = reader.int32() + reader.pos; reader.pos < e; )
                  message.previousChoices.push(reader.uint32());
              else
                message.previousChoices.push(reader.uint32());
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.step !== 0n)
          writer.tag(1, WireType.Varint).uint64(message.step);
        if (message.since !== 0n)
          writer.tag(2, WireType.Varint).uint64(message.since);
        if (message.previousChoices.length) {
          writer.tag(3, WireType.LengthDelimited).fork();
          for (let i = 0; i < message.previousChoices.length; i++)
            writer.uint32(message.previousChoices[i]);
          writer.join();
        }
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const GameState_ChatScriptState = new GameState_ChatScriptState$Type();
    class UiInfo$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.UiInfo", [
          { no: 1, name: "ship", kind: "message", T: () => UiInfo_Ship },
          { no: 2, name: "opt_group", kind: "message", repeat: 1, T: () => UiInfo_Group }
        ]);
      }
      create(value) {
        const message = { optGroup: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.UiInfo.Ship ship */
            1:
              message.ship = UiInfo_Ship.internalBinaryRead(reader, reader.uint32(), options, message.ship);
              break;
            case /* repeated api.unsafe.gui.UiInfo.Group opt_group */
            2:
              message.optGroup.push(UiInfo_Group.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.ship)
          UiInfo_Ship.internalBinaryWrite(message.ship, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.optGroup.length; i++)
          UiInfo_Group.internalBinaryWrite(message.optGroup[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const UiInfo = new UiInfo$Type();
    class UiInfo_Ship$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.UiInfo.Ship", [
          {
            no: 1,
            name: "forward_speed",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          }
        ]);
      }
      create(value) {
        const message = { forwardSpeed: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* float forward_speed */
            1:
              message.forwardSpeed = reader.float();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.forwardSpeed !== 0)
          writer.tag(1, WireType.Bit32).float(message.forwardSpeed);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const UiInfo_Ship = new UiInfo_Ship$Type();
    class UiInfo_Group$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.UiInfo.Group", [
          {
            no: 1,
            name: "thruster_strength",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          },
          {
            no: 2,
            name: "laser_speed_factor",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          },
          {
            no: 3,
            name: "robot_speed_factor",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          },
          {
            no: 4,
            name: "credits",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          { no: 5, name: "members", kind: "map", K: 9, V: { kind: "message", T: () => UiInfo_Group_MemberInfo } }
        ]);
      }
      create(value) {
        const message = { thrusterStrength: 0, laserSpeedFactor: 0, robotSpeedFactor: 0, credits: 0n, members: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* float thruster_strength */
            1:
              message.thrusterStrength = reader.float();
              break;
            case /* float laser_speed_factor */
            2:
              message.laserSpeedFactor = reader.float();
              break;
            case /* float robot_speed_factor */
            3:
              message.robotSpeedFactor = reader.float();
              break;
            case /* uint64 credits */
            4:
              message.credits = reader.uint64().toBigInt();
              break;
            case /* map<string, api.unsafe.gui.UiInfo.Group.MemberInfo> members */
            5:
              this.binaryReadMap5(message.members, reader, options);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      binaryReadMap5(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = UiInfo_Group_MemberInfo.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.UiInfo.Group.members");
          }
        }
        map2[key ?? ""] = val ?? UiInfo_Group_MemberInfo.create();
      }
      internalBinaryWrite(message, writer, options) {
        if (message.thrusterStrength !== 0)
          writer.tag(1, WireType.Bit32).float(message.thrusterStrength);
        if (message.laserSpeedFactor !== 0)
          writer.tag(2, WireType.Bit32).float(message.laserSpeedFactor);
        if (message.robotSpeedFactor !== 0)
          writer.tag(3, WireType.Bit32).float(message.robotSpeedFactor);
        if (message.credits !== 0n)
          writer.tag(4, WireType.Varint).uint64(message.credits);
        for (let k2 of Object.keys(message.members)) {
          writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          UiInfo_Group_MemberInfo.internalBinaryWrite(message.members[k2], writer, options);
          writer.join().join();
        }
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const UiInfo_Group = new UiInfo_Group$Type();
    class UiInfo_Group_MemberInfo$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.UiInfo.Group.MemberInfo", [
          {
            no: 1,
            name: "note_group",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          },
          {
            no: 2,
            name: "note_class",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          },
          {
            no: 3,
            name: "note_total",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          }
        ]);
      }
      create(value) {
        const message = { noteGroup: 0, noteClass: 0, noteTotal: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* float note_group */
            1:
              message.noteGroup = reader.float();
              break;
            case /* float note_class */
            2:
              message.noteClass = reader.float();
              break;
            case /* float note_total */
            3:
              message.noteTotal = reader.float();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.noteGroup !== 0)
          writer.tag(1, WireType.Bit32).float(message.noteGroup);
        if (message.noteClass !== 0)
          writer.tag(2, WireType.Bit32).float(message.noteClass);
        if (message.noteTotal !== 0)
          writer.tag(3, WireType.Bit32).float(message.noteTotal);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const UiInfo_Group_MemberInfo = new UiInfo_Group_MemberInfo$Type();
    class K8sState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.K8sState", [
          { no: 1, name: "targets", kind: "map", K: 9, V: { kind: "message", T: () => K8sState_TargetState } }
        ]);
      }
      create(value) {
        const message = { targets: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* map<string, api.unsafe.gui.K8sState.TargetState> targets */
            1:
              this.binaryReadMap1(message.targets, reader, options);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      binaryReadMap1(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = K8sState_TargetState.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.K8sState.targets");
          }
        }
        map2[key ?? ""] = val ?? K8sState_TargetState.create();
      }
      internalBinaryWrite(message, writer, options) {
        for (let k2 of Object.keys(message.targets)) {
          writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          K8sState_TargetState.internalBinaryWrite(message.targets[k2], writer, options);
          writer.join().join();
        }
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const K8sState = new K8sState$Type();
    class K8sState_TargetState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.K8sState.TargetState", [
          {
            no: 1,
            name: "expected",
            kind: "scalar",
            T: 3,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 2,
            name: "ready",
            kind: "scalar",
            T: 3,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 3,
            name: "unknown",
            kind: "scalar",
            T: 3,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 4,
            name: "ports",
            kind: "scalar",
            repeat: 1,
            T: 13
            /*ScalarType.UINT32*/
          }
        ]);
      }
      create(value) {
        const message = { expected: 0n, ready: 0n, unknown: 0n, ports: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* int64 expected */
            1:
              message.expected = reader.int64().toBigInt();
              break;
            case /* int64 ready */
            2:
              message.ready = reader.int64().toBigInt();
              break;
            case /* int64 unknown */
            3:
              message.unknown = reader.int64().toBigInt();
              break;
            case /* repeated uint32 ports */
            4:
              if (wireType === WireType.LengthDelimited)
                for (let e = reader.int32() + reader.pos; reader.pos < e; )
                  message.ports.push(reader.uint32());
              else
                message.ports.push(reader.uint32());
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.expected !== 0n)
          writer.tag(1, WireType.Varint).int64(message.expected);
        if (message.ready !== 0n)
          writer.tag(2, WireType.Varint).int64(message.ready);
        if (message.unknown !== 0n)
          writer.tag(3, WireType.Varint).int64(message.unknown);
        if (message.ports.length) {
          writer.tag(4, WireType.LengthDelimited).fork();
          for (let i = 0; i < message.ports.length; i++)
            writer.uint32(message.ports[i]);
          writer.join();
        }
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const K8sState_TargetState = new K8sState_TargetState$Type();
    class GetUpdatesRequest$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.GetUpdatesRequest", [
          {
            no: 1,
            name: "ip",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { ip: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string ip */
            1:
              message.ip = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.ip !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.ip);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const GetUpdatesRequest = new GetUpdatesRequest$Type();
    class StatusUpdate$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.StatusUpdate", [
          { no: 1, name: "state", kind: "message", T: () => GameState },
          { no: 2, name: "opt_info", kind: "message", repeat: 1, T: () => UiInfo },
          {
            no: 3,
            name: "laser_length",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          },
          { no: 4, name: "debug_points_of_interest", kind: "message", repeat: 1, T: () => Vec }
        ]);
      }
      create(value) {
        const message = { optInfo: [], laserLength: 0, debugPointsOfInterest: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.GameState state */
            1:
              message.state = GameState.internalBinaryRead(reader, reader.uint32(), options, message.state);
              break;
            case /* repeated api.unsafe.gui.UiInfo opt_info */
            2:
              message.optInfo.push(UiInfo.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* float laser_length */
            3:
              message.laserLength = reader.float();
              break;
            case /* repeated api.unsafe.gui.Vec debug_points_of_interest */
            4:
              message.debugPointsOfInterest.push(Vec.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.state)
          GameState.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.optInfo.length; i++)
          UiInfo.internalBinaryWrite(message.optInfo[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        if (message.laserLength !== 0)
          writer.tag(3, WireType.Bit32).float(message.laserLength);
        for (let i = 0; i < message.debugPointsOfInterest.length; i++)
          Vec.internalBinaryWrite(message.debugPointsOfInterest[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const StatusUpdate = new StatusUpdate$Type();
    class FrontendLocalStorage$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.FrontendLocalStorage", [
          {
            no: 1,
            name: "api_key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "zoom",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "new_group_name",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 4,
            name: "selected_ship",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { apiKey: "", zoom: "", newGroupName: "", selectedShip: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string api_key */
            1:
              message.apiKey = reader.string();
              break;
            case /* string zoom */
            2:
              message.zoom = reader.string();
              break;
            case /* string new_group_name */
            3:
              message.newGroupName = reader.string();
              break;
            case /* string selected_ship */
            4:
              message.selectedShip = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.apiKey !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.apiKey);
        if (message.zoom !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.zoom);
        if (message.newGroupName !== "")
          writer.tag(3, WireType.LengthDelimited).string(message.newGroupName);
        if (message.selectedShip !== "")
          writer.tag(4, WireType.LengthDelimited).string(message.selectedShip);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    new FrontendLocalStorage$Type();
    class SetThruster$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.SetThruster", [
          {
            no: 1,
            name: "thruster_name",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "amount",
            kind: "scalar",
            T: 5
            /*ScalarType.INT32*/
          }
        ]);
      }
      create(value) {
        const message = { thrusterName: "", amount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string thruster_name */
            1:
              message.thrusterName = reader.string();
              break;
            case /* int32 amount */
            2:
              message.amount = reader.int32();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.thrusterName !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.thrusterName);
        if (message.amount !== 0)
          writer.tag(2, WireType.Varint).int32(message.amount);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const SetThruster = new SetThruster$Type();
    class ResourceBuySell$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.ResourceBuySell", [
          { no: 1, name: "what", kind: "enum", T: () => ["api.unsafe.gui.ResourceType", ResourceType] },
          {
            no: 2,
            name: "buy_price",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 3,
            name: "sell_price",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          }
        ]);
      }
      create(value) {
        const message = { what: 0, buyPrice: 0n, sellPrice: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.ResourceType what */
            1:
              message.what = reader.int32();
              break;
            case /* uint64 buy_price */
            2:
              message.buyPrice = reader.uint64().toBigInt();
              break;
            case /* uint64 sell_price */
            3:
              message.sellPrice = reader.uint64().toBigInt();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.what !== 0)
          writer.tag(1, WireType.Varint).int32(message.what);
        if (message.buyPrice !== 0n)
          writer.tag(2, WireType.Varint).uint64(message.buyPrice);
        if (message.sellPrice !== 0n)
          writer.tag(3, WireType.Varint).uint64(message.sellPrice);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const ResourceBuySell = new ResourceBuySell$Type();
    class ItemToBuy$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.ItemToBuy", [
          { no: 1, name: "item", kind: "message", T: () => ItemId },
          {
            no: 2,
            name: "title",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "text",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 4,
            name: "price",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          }
        ]);
      }
      create(value) {
        const message = { title: "", text: "", price: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.ItemId item */
            1:
              message.item = ItemId.internalBinaryRead(reader, reader.uint32(), options, message.item);
              break;
            case /* string title */
            2:
              message.title = reader.string();
              break;
            case /* string text */
            3:
              message.text = reader.string();
              break;
            case /* uint64 price */
            4:
              message.price = reader.uint64().toBigInt();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.item)
          ItemId.internalBinaryWrite(message.item, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.title !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.title);
        if (message.text !== "")
          writer.tag(3, WireType.LengthDelimited).string(message.text);
        if (message.price !== 0n)
          writer.tag(4, WireType.Varint).uint64(message.price);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const ItemToBuy = new ItemToBuy$Type();
    class Market$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Market", [
          { no: 1, name: "resources", kind: "message", repeat: 1, T: () => ResourceBuySell },
          { no: 2, name: "items", kind: "message", repeat: 1, T: () => ItemToBuy }
        ]);
      }
      create(value) {
        const message = { resources: [], items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* repeated api.unsafe.gui.ResourceBuySell resources */
            1:
              message.resources.push(ResourceBuySell.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* repeated api.unsafe.gui.ItemToBuy items */
            2:
              message.items.push(ItemToBuy.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        for (let i = 0; i < message.resources.length; i++)
          ResourceBuySell.internalBinaryWrite(message.resources[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.items.length; i++)
          ItemToBuy.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Market = new Market$Type();
    class Mission$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Mission", [
          { no: 1, name: "id", kind: "message", T: () => MissionId },
          {
            no: 2,
            name: "title",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "text",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { title: "", text: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.MissionId id */
            1:
              message.id = MissionId.internalBinaryRead(reader, reader.uint32(), options, message.id);
              break;
            case /* string title */
            2:
              message.title = reader.string();
              break;
            case /* string text */
            3:
              message.text = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.id)
          MissionId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.title !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.title);
        if (message.text !== "")
          writer.tag(3, WireType.LengthDelimited).string(message.text);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Mission = new Mission$Type();
    class Communication_SpaceStation$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Communication_SpaceStation", [
          {
            no: 1,
            name: "name",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          { no: 2, name: "market", kind: "message", T: () => Market },
          { no: 3, name: "missions", kind: "message", repeat: 1, T: () => Mission }
        ]);
      }
      create(value) {
        const message = { name: "", missions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string name */
            1:
              message.name = reader.string();
              break;
            case /* api.unsafe.gui.Market market */
            2:
              message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
              break;
            case /* repeated api.unsafe.gui.Mission missions */
            3:
              message.missions.push(Mission.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.name !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.name);
        if (message.market)
          Market.internalBinaryWrite(message.market, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.missions.length; i++)
          Mission.internalBinaryWrite(message.missions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Communication_SpaceStation = new Communication_SpaceStation$Type();
    class Communication$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.Communication", [
          { no: 1, name: "stations_in_range", kind: "message", repeat: 1, T: () => Communication_SpaceStation }
        ]);
      }
      create(value) {
        const message = { stationsInRange: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* repeated api.unsafe.gui.Communication_SpaceStation stations_in_range */
            1:
              message.stationsInRange.push(Communication_SpaceStation.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        for (let i = 0; i < message.stationsInRange.length; i++)
          Communication_SpaceStation.internalBinaryWrite(message.stationsInRange[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const Communication = new Communication$Type();
    class ItemInHold$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.ItemInHold", [
          {
            no: 2,
            name: "title",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "text",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { title: "", text: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string title */
            2:
              message.title = reader.string();
              break;
            case /* string text */
            3:
              message.text = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.title !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.title);
        if (message.text !== "")
          writer.tag(3, WireType.LengthDelimited).string(message.text);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const ItemInHold = new ItemInHold$Type();
    class CargoHold$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CargoHold", [
          {
            no: 1,
            name: "credits",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 2,
            name: "hold_size",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          {
            no: 3,
            name: "free_space",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          { no: 4, name: "resources", kind: "message", repeat: 1, T: () => ResourceInHold },
          { no: 5, name: "items", kind: "message", repeat: 1, T: () => ItemInHold },
          { no: 6, name: "detail_state", kind: "message", T: () => CargoHoldState }
        ]);
      }
      create(value) {
        const message = { credits: 0n, holdSize: 0, freeSpace: 0, resources: [], items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint64 credits */
            1:
              message.credits = reader.uint64().toBigInt();
              break;
            case /* uint32 hold_size */
            2:
              message.holdSize = reader.uint32();
              break;
            case /* uint32 free_space */
            3:
              message.freeSpace = reader.uint32();
              break;
            case /* repeated api.unsafe.gui.ResourceInHold resources */
            4:
              message.resources.push(ResourceInHold.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* repeated api.unsafe.gui.ItemInHold items */
            5:
              message.items.push(ItemInHold.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* api.unsafe.gui.CargoHoldState detail_state */
            6:
              message.detailState = CargoHoldState.internalBinaryRead(reader, reader.uint32(), options, message.detailState);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.credits !== 0n)
          writer.tag(1, WireType.Varint).uint64(message.credits);
        if (message.holdSize !== 0)
          writer.tag(2, WireType.Varint).uint32(message.holdSize);
        if (message.freeSpace !== 0)
          writer.tag(3, WireType.Varint).uint32(message.freeSpace);
        for (let i = 0; i < message.resources.length; i++)
          ResourceInHold.internalBinaryWrite(message.resources[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.items.length; i++)
          ItemInHold.internalBinaryWrite(message.items[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        if (message.detailState)
          CargoHoldState.internalBinaryWrite(message.detailState, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CargoHold = new CargoHold$Type();
    class CargoHoldSwapAdjacentRequest$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CargoHoldSwapAdjacentRequest", [
          { no: 1, name: "a", kind: "message", T: () => CargoHoldState_SlotPos },
          { no: 2, name: "b", kind: "message", T: () => CargoHoldState_SlotPos }
        ]);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.CargoHoldState.SlotPos a */
            1:
              message.a = CargoHoldState_SlotPos.internalBinaryRead(reader, reader.uint32(), options, message.a);
              break;
            case /* api.unsafe.gui.CargoHoldState.SlotPos b */
            2:
              message.b = CargoHoldState_SlotPos.internalBinaryRead(reader, reader.uint32(), options, message.b);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.a)
          CargoHoldState_SlotPos.internalBinaryWrite(message.a, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.b)
          CargoHoldState_SlotPos.internalBinaryWrite(message.b, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CargoHoldSwapAdjacentRequest = new CargoHoldSwapAdjacentRequest$Type();
    class BuySell$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.BuySell", [
          {
            no: 1,
            name: "station",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          { no: 2, name: "what", kind: "enum", T: () => ["api.unsafe.gui.ResourceType", ResourceType] }
        ]);
      }
      create(value) {
        const message = { station: "", what: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string station */
            1:
              message.station = reader.string();
              break;
            case /* api.unsafe.gui.ResourceType what */
            2:
              message.what = reader.int32();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.station !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.station);
        if (message.what !== 0)
          writer.tag(2, WireType.Varint).int32(message.what);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const BuySell = new BuySell$Type();
    class BuyItem$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.BuyItem", [
          {
            no: 1,
            name: "station",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          { no: 2, name: "what", kind: "message", T: () => ItemId }
        ]);
      }
      create(value) {
        const message = { station: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string station */
            1:
              message.station = reader.string();
              break;
            case /* api.unsafe.gui.ItemId what */
            2:
              message.what = ItemId.internalBinaryRead(reader, reader.uint32(), options, message.what);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.station !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.station);
        if (message.what)
          ItemId.internalBinaryWrite(message.what, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const BuyItem = new BuyItem$Type();
    class MissionText$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.MissionText", [
          {
            no: 1,
            name: "text",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { text: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string text */
            1:
              message.text = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.text !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const MissionText = new MissionText$Type();
    class AcceptMission$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.AcceptMission", [
          { no: 1, name: "mission", kind: "message", T: () => MissionId }
        ]);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.MissionId mission */
            1:
              message.mission = MissionId.internalBinaryRead(reader, reader.uint32(), options, message.mission);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.mission)
          MissionId.internalBinaryWrite(message.mission, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const AcceptMission = new AcceptMission$Type();
    class GetMissions$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.GetMissions", [
          { no: 1, name: "active_missions", kind: "message", repeat: 1, T: () => GetMissions_ActiveMission },
          { no: 2, name: "finished_missions", kind: "message", repeat: 1, T: () => GetMissions_FinishedMission }
        ]);
      }
      create(value) {
        const message = { activeMissions: [], finishedMissions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* repeated api.unsafe.gui.GetMissions.ActiveMission active_missions */
            1:
              message.activeMissions.push(GetMissions_ActiveMission.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* repeated api.unsafe.gui.GetMissions.FinishedMission finished_missions */
            2:
              message.finishedMissions.push(GetMissions_FinishedMission.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        for (let i = 0; i < message.activeMissions.length; i++)
          GetMissions_ActiveMission.internalBinaryWrite(message.activeMissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.finishedMissions.length; i++)
          GetMissions_FinishedMission.internalBinaryWrite(message.finishedMissions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const GetMissions = new GetMissions$Type();
    class GetMissions_ActiveMission$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.GetMissions.ActiveMission", [
          {
            no: 1,
            name: "title",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          { no: 2, name: "texts", kind: "message", repeat: 1, T: () => MissionText }
        ]);
      }
      create(value) {
        const message = { title: "", texts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string title */
            1:
              message.title = reader.string();
              break;
            case /* repeated api.unsafe.gui.MissionText texts */
            2:
              message.texts.push(MissionText.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.title !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.title);
        for (let i = 0; i < message.texts.length; i++)
          MissionText.internalBinaryWrite(message.texts[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const GetMissions_ActiveMission = new GetMissions_ActiveMission$Type();
    class GetMissions_FinishedMission$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.GetMissions.FinishedMission", [
          {
            no: 1,
            name: "title",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "text",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { title: "", text: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string title */
            1:
              message.title = reader.string();
              break;
            case /* string text */
            2:
              message.text = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.title !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.title);
        if (message.text !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const GetMissions_FinishedMission = new GetMissions_FinishedMission$Type();
    class InstallableSoftware$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.InstallableSoftware", [
          {
            no: 1,
            name: "name",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string name */
            1:
              message.name = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.name !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const InstallableSoftware = new InstallableSoftware$Type();
    class GetInstallableSoftware$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.GetInstallableSoftware", [
          { no: 1, name: "list", kind: "message", repeat: 1, T: () => InstallableSoftware },
          { no: 2, name: "k8s_state", kind: "message", jsonName: "k8sState", T: () => K8sState }
        ]);
      }
      create(value) {
        const message = { list: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* repeated api.unsafe.gui.InstallableSoftware list */
            1:
              message.list.push(InstallableSoftware.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* api.unsafe.gui.K8sState k8s_state = 2 [json_name = "k8sState"];*/
            2:
              message.k8SState = K8sState.internalBinaryRead(reader, reader.uint32(), options, message.k8SState);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        for (let i = 0; i < message.list.length; i++)
          InstallableSoftware.internalBinaryWrite(message.list[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.k8SState)
          K8sState.internalBinaryWrite(message.k8SState, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const GetInstallableSoftware = new GetInstallableSoftware$Type();
    class DeployInstallableSoftware$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.DeployInstallableSoftware", [
          {
            no: 1,
            name: "name",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string name */
            1:
              message.name = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.name !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const DeployInstallableSoftware = new DeployInstallableSoftware$Type();
    class UndeployInstallableSoftware$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.UndeployInstallableSoftware", [
          {
            no: 1,
            name: "name",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string name */
            1:
              message.name = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.name !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const UndeployInstallableSoftware = new UndeployInstallableSoftware$Type();
    class WipeInstallableSoftware$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.WipeInstallableSoftware", []);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
      }
      internalBinaryWrite(message, writer, options) {
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const WipeInstallableSoftware = new WipeInstallableSoftware$Type();
    class NearObject$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.NearObject", [
          {
            no: 1,
            name: "name",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          { no: 2, name: "pos", kind: "message", T: () => Vec }
        ]);
      }
      create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string name */
            1:
              message.name = reader.string();
              break;
            case /* api.unsafe.gui.Vec pos */
            2:
              message.pos = Vec.internalBinaryRead(reader, reader.uint32(), options, message.pos);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.name !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.name);
        if (message.pos)
          Vec.internalBinaryWrite(message.pos, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const NearObject = new NearObject$Type();
    class ScannerGetNearObjects$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.ScannerGetNearObjects", [
          { no: 1, name: "near_objects", kind: "message", repeat: 1, T: () => NearObject }
        ]);
      }
      create(value) {
        const message = { nearObjects: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* repeated api.unsafe.gui.NearObject near_objects */
            1:
              message.nearObjects.push(NearObject.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        for (let i = 0; i < message.nearObjects.length; i++)
          NearObject.internalBinaryWrite(message.nearObjects[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const ScannerGetNearObjects = new ScannerGetNearObjects$Type();
    class LaserGetState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.LaserGetState", [
          {
            no: 1,
            name: "active",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 2,
            name: "is_mining",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 3,
            name: "is_cooling_down",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          }
        ]);
      }
      create(value) {
        const message = { active: false, isMining: false, isCoolingDown: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* bool active */
            1:
              message.active = reader.bool();
              break;
            case /* bool is_mining */
            2:
              message.isMining = reader.bool();
              break;
            case /* bool is_cooling_down */
            3:
              message.isCoolingDown = reader.bool();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.active !== false)
          writer.tag(1, WireType.Varint).bool(message.active);
        if (message.isMining !== false)
          writer.tag(2, WireType.Varint).bool(message.isMining);
        if (message.isCoolingDown !== false)
          writer.tag(3, WireType.Varint).bool(message.isCoolingDown);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const LaserGetState = new LaserGetState$Type();
    class LaserSetState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.LaserSetState", [
          {
            no: 1,
            name: "active",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          }
        ]);
      }
      create(value) {
        const message = { active: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* bool active */
            1:
              message.active = reader.bool();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.active !== false)
          writer.tag(1, WireType.Varint).bool(message.active);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const LaserSetState = new LaserSetState$Type();
    class LaserSetRotationState$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.LaserSetRotationState", [
          {
            no: 1,
            name: "angle",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          }
        ]);
      }
      create(value) {
        const message = { angle: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* float angle */
            1:
              message.angle = reader.float();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.angle !== 0)
          writer.tag(1, WireType.Bit32).float(message.angle);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const LaserSetRotationState = new LaserSetRotationState$Type();
    class CommSend$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CommSend", [
          {
            no: 1,
            name: "source",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "target",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "data",
            kind: "scalar",
            T: 12
            /*ScalarType.BYTES*/
          }
        ]);
      }
      create(value) {
        const message = { source: "", target: "", data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string source */
            1:
              message.source = reader.string();
              break;
            case /* string target */
            2:
              message.target = reader.string();
              break;
            case /* bytes data */
            3:
              message.data = reader.bytes();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.source !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.source);
        if (message.target !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.target);
        if (message.data.length)
          writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CommSend = new CommSend$Type();
    class CommReceiveRequest$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CommReceiveRequest", [
          {
            no: 1,
            name: "source",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { source: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string source */
            1:
              message.source = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.source !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.source);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CommReceiveRequest = new CommReceiveRequest$Type();
    class CommReceiveResponse$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CommReceiveResponse", [
          { no: 1, name: "messages", kind: "message", repeat: 1, T: () => CommReceiveResponse_Message }
        ]);
      }
      create(value) {
        const message = { messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* repeated api.unsafe.gui.CommReceiveResponse.Message messages */
            1:
              message.messages.push(CommReceiveResponse_Message.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        for (let i = 0; i < message.messages.length; i++)
          CommReceiveResponse_Message.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CommReceiveResponse = new CommReceiveResponse$Type();
    class CommReceiveResponse_Message$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.CommReceiveResponse.Message", [
          {
            no: 1,
            name: "target",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "data",
            kind: "scalar",
            T: 12
            /*ScalarType.BYTES*/
          }
        ]);
      }
      create(value) {
        const message = { target: "", data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string target */
            1:
              message.target = reader.string();
              break;
            case /* bytes data */
            2:
              message.data = reader.bytes();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.target !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.target);
        if (message.data.length)
          writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const CommReceiveResponse_Message = new CommReceiveResponse_Message$Type();
    class HackReadSecretStationDataResponse$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.HackReadSecretStationDataResponse", [
          {
            no: 1,
            name: "data",
            kind: "scalar",
            repeat: 2,
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* repeated string data */
            1:
              message.data.push(reader.string());
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        for (let i = 0; i < message.data.length; i++)
          writer.tag(1, WireType.LengthDelimited).string(message.data[i]);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const HackReadSecretStationDataResponse = new HackReadSecretStationDataResponse$Type();
    class DataTransfer$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.DataTransfer", []);
      }
      create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
      }
      internalBinaryWrite(message, writer, options) {
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    new DataTransfer$Type();
    class DataTransfer_Message$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.DataTransfer.Message", [
          {
            no: 1,
            name: "source",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "destination",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "data",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 4,
            name: "ts",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          }
        ]);
      }
      create(value) {
        const message = { source: "", destination: "", data: "", ts: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string source */
            1:
              message.source = reader.string();
              break;
            case /* string destination */
            2:
              message.destination = reader.string();
              break;
            case /* string data */
            3:
              message.data = reader.string();
              break;
            case /* uint64 ts */
            4:
              message.ts = reader.uint64().toBigInt();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.source !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.source);
        if (message.destination !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.destination);
        if (message.data !== "")
          writer.tag(3, WireType.LengthDelimited).string(message.data);
        if (message.ts !== 0n)
          writer.tag(4, WireType.Varint).uint64(message.ts);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    new DataTransfer_Message$Type();
    class DataTransfer_SignedMessage$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.DataTransfer.SignedMessage", [
          {
            no: 1,
            name: "message",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "signature",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { message: "", signature: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string message */
            1:
              message.message = reader.string();
              break;
            case /* string signature */
            2:
              message.signature = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.message !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.message);
        if (message.signature !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.signature);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    new DataTransfer_SignedMessage$Type();
    class SecondsSinceStart$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.SecondsSinceStart", [
          {
            no: 1,
            name: "seconds",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          },
          {
            no: 2,
            name: "speed_factor",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          }
        ]);
      }
      create(value) {
        const message = { seconds: 0, speedFactor: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* float seconds */
            1:
              message.seconds = reader.float();
              break;
            case /* double speed_factor */
            2:
              message.speedFactor = reader.double();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.seconds !== 0)
          writer.tag(1, WireType.Bit32).float(message.seconds);
        if (message.speedFactor !== 0)
          writer.tag(2, WireType.Bit64).double(message.speedFactor);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const SecondsSinceStart = new SecondsSinceStart$Type();
    class AddGroupRequest$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.AddGroupRequest", [
          {
            no: 1,
            name: "ip",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { ip: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string ip */
            1:
              message.ip = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.ip !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.ip);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const AddGroupRequest = new AddGroupRequest$Type();
    class OutsideUpdatesRequest$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.OutsideUpdatesRequest", [
          {
            no: 1,
            name: "ip",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { ip: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string ip */
            1:
              message.ip = reader.string();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.ip !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.ip);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const OutsideUpdatesRequest = new OutsideUpdatesRequest$Type();
    class OutsideUpdatesUpdatePressureRequest$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.OutsideUpdatesUpdatePressureRequest", [
          {
            no: 1,
            name: "secret",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          {
            no: 2,
            name: "message_no",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          }
        ]);
      }
      create(value) {
        const message = { secret: 0n, messageNo: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint64 secret */
            1:
              message.secret = reader.uint64().toBigInt();
              break;
            case /* uint64 message_no */
            2:
              message.messageNo = reader.uint64().toBigInt();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.secret !== 0n)
          writer.tag(1, WireType.Varint).uint64(message.secret);
        if (message.messageNo !== 0n)
          writer.tag(2, WireType.Varint).uint64(message.messageNo);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const OutsideUpdatesUpdatePressureRequest = new OutsideUpdatesUpdatePressureRequest$Type();
    class OutsideView$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.OutsideView", [
          { no: 3, name: "ships", kind: "map", K: 9, V: { kind: "message", T: () => OutsideView_Ship } },
          { no: 4, name: "space_stations", kind: "message", repeat: 1, T: () => Vec },
          { no: 5, name: "mineable_asteroids", kind: "message", repeat: 1, T: () => Vec },
          { no: 6, name: "asteroids", kind: "message", repeat: 1, T: () => Vec },
          {
            no: 7,
            name: "view_distance",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          },
          { no: 8, name: "debug_points_of_interest", kind: "message", repeat: 1, T: () => Vec }
        ]);
      }
      create(value) {
        const message = { ships: {}, spaceStations: [], mineableAsteroids: [], asteroids: [], viewDistance: 0, debugPointsOfInterest: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* map<string, api.unsafe.gui.OutsideView.Ship> ships */
            3:
              this.binaryReadMap3(message.ships, reader, options);
              break;
            case /* repeated api.unsafe.gui.Vec space_stations */
            4:
              message.spaceStations.push(Vec.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* repeated api.unsafe.gui.Vec mineable_asteroids */
            5:
              message.mineableAsteroids.push(Vec.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* repeated api.unsafe.gui.Vec asteroids */
            6:
              message.asteroids.push(Vec.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* float view_distance */
            7:
              message.viewDistance = reader.float();
              break;
            case /* repeated api.unsafe.gui.Vec debug_points_of_interest */
            8:
              message.debugPointsOfInterest.push(Vec.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      binaryReadMap3(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = OutsideView_Ship.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.OutsideView.ships");
          }
        }
        map2[key ?? ""] = val ?? OutsideView_Ship.create();
      }
      internalBinaryWrite(message, writer, options) {
        for (let k2 of Object.keys(message.ships)) {
          writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          OutsideView_Ship.internalBinaryWrite(message.ships[k2], writer, options);
          writer.join().join();
        }
        for (let i = 0; i < message.spaceStations.length; i++)
          Vec.internalBinaryWrite(message.spaceStations[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.mineableAsteroids.length; i++)
          Vec.internalBinaryWrite(message.mineableAsteroids[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.asteroids.length; i++)
          Vec.internalBinaryWrite(message.asteroids[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        if (message.viewDistance !== 0)
          writer.tag(7, WireType.Bit32).float(message.viewDistance);
        for (let i = 0; i < message.debugPointsOfInterest.length; i++)
          Vec.internalBinaryWrite(message.debugPointsOfInterest[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const OutsideView$1 = new OutsideView$Type();
    class OutsideView_Ship$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.OutsideView.Ship", [
          { no: 1, name: "pos", kind: "message", T: () => Vec },
          { no: 2, name: "thrusters", kind: "message", T: () => ShipThrusters },
          {
            no: 3,
            name: "laser_is_active",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 4,
            name: "laser_angle",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          },
          {
            no: 5,
            name: "laser_length",
            kind: "scalar",
            T: 2
            /*ScalarType.FLOAT*/
          }
        ]);
      }
      create(value) {
        const message = { laserIsActive: false, laserAngle: 0, laserLength: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* api.unsafe.gui.Vec pos */
            1:
              message.pos = Vec.internalBinaryRead(reader, reader.uint32(), options, message.pos);
              break;
            case /* api.unsafe.gui.ShipThrusters thrusters */
            2:
              message.thrusters = ShipThrusters.internalBinaryRead(reader, reader.uint32(), options, message.thrusters);
              break;
            case /* bool laser_is_active */
            3:
              message.laserIsActive = reader.bool();
              break;
            case /* double laser_angle */
            4:
              message.laserAngle = reader.double();
              break;
            case /* float laser_length */
            5:
              message.laserLength = reader.float();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.pos)
          Vec.internalBinaryWrite(message.pos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        if (message.thrusters)
          ShipThrusters.internalBinaryWrite(message.thrusters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        if (message.laserIsActive !== false)
          writer.tag(3, WireType.Varint).bool(message.laserIsActive);
        if (message.laserAngle !== 0)
          writer.tag(4, WireType.Bit64).double(message.laserAngle);
        if (message.laserLength !== 0)
          writer.tag(5, WireType.Bit32).float(message.laserLength);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const OutsideView_Ship = new OutsideView_Ship$Type();
    class OutsideViewSingleShip$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.OutsideViewSingleShip", [
          {
            no: 1,
            name: "secret",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          { no: 2, name: "view", kind: "message", T: () => OutsideView$1 },
          {
            no: 3,
            name: "this_ship",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          { no: 4, name: "info", kind: "message", T: () => UiInfo }
        ]);
      }
      create(value) {
        const message = { secret: 0n, thisShip: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint64 secret */
            1:
              message.secret = reader.uint64().toBigInt();
              break;
            case /* api.unsafe.gui.OutsideView view */
            2:
              message.view = OutsideView$1.internalBinaryRead(reader, reader.uint32(), options, message.view);
              break;
            case /* string this_ship */
            3:
              message.thisShip = reader.string();
              break;
            case /* api.unsafe.gui.UiInfo info */
            4:
              message.info = UiInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.secret !== 0n)
          writer.tag(1, WireType.Varint).uint64(message.secret);
        if (message.view)
          OutsideView$1.internalBinaryWrite(message.view, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        if (message.thisShip !== "")
          writer.tag(3, WireType.LengthDelimited).string(message.thisShip);
        if (message.info)
          UiInfo.internalBinaryWrite(message.info, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const OutsideViewSingleShip = new OutsideViewSingleShip$Type();
    class OutsideViewComplete$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.OutsideViewComplete", [
          {
            no: 1,
            name: "secret",
            kind: "scalar",
            T: 4,
            L: 0
            /*LongType.BIGINT*/
          },
          { no: 2, name: "view", kind: "message", T: () => OutsideView$1 },
          { no: 3, name: "infos", kind: "map", K: 9, V: { kind: "message", T: () => UiInfo } },
          {
            no: 4,
            name: "per_group_mission_count",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          {
            no: 5,
            name: "per_group_mission_weight_sum",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          {
            no: 6,
            name: "per_class_mission_count",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          },
          {
            no: 7,
            name: "per_class_mission_weight_sum",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          }
        ]);
      }
      create(value) {
        const message = { secret: 0n, infos: {}, perGroupMissionCount: 0, perGroupMissionWeightSum: 0, perClassMissionCount: 0, perClassMissionWeightSum: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* uint64 secret */
            1:
              message.secret = reader.uint64().toBigInt();
              break;
            case /* api.unsafe.gui.OutsideView view */
            2:
              message.view = OutsideView$1.internalBinaryRead(reader, reader.uint32(), options, message.view);
              break;
            case /* map<string, api.unsafe.gui.UiInfo> infos */
            3:
              this.binaryReadMap3(message.infos, reader, options);
              break;
            case /* uint32 per_group_mission_count */
            4:
              message.perGroupMissionCount = reader.uint32();
              break;
            case /* uint32 per_group_mission_weight_sum */
            5:
              message.perGroupMissionWeightSum = reader.uint32();
              break;
            case /* uint32 per_class_mission_count */
            6:
              message.perClassMissionCount = reader.uint32();
              break;
            case /* uint32 per_class_mission_weight_sum */
            7:
              message.perClassMissionWeightSum = reader.uint32();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      binaryReadMap3(map2, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case 1:
              key = reader.string();
              break;
            case 2:
              val = UiInfo.internalBinaryRead(reader, reader.uint32(), options);
              break;
            default:
              throw new globalThis.Error("unknown map entry field for field api.unsafe.gui.OutsideViewComplete.infos");
          }
        }
        map2[key ?? ""] = val ?? UiInfo.create();
      }
      internalBinaryWrite(message, writer, options) {
        if (message.secret !== 0n)
          writer.tag(1, WireType.Varint).uint64(message.secret);
        if (message.view)
          OutsideView$1.internalBinaryWrite(message.view, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        for (let k2 of Object.keys(message.infos)) {
          writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k2);
          writer.tag(2, WireType.LengthDelimited).fork();
          UiInfo.internalBinaryWrite(message.infos[k2], writer, options);
          writer.join().join();
        }
        if (message.perGroupMissionCount !== 0)
          writer.tag(4, WireType.Varint).uint32(message.perGroupMissionCount);
        if (message.perGroupMissionWeightSum !== 0)
          writer.tag(5, WireType.Varint).uint32(message.perGroupMissionWeightSum);
        if (message.perClassMissionCount !== 0)
          writer.tag(6, WireType.Varint).uint32(message.perClassMissionCount);
        if (message.perClassMissionWeightSum !== 0)
          writer.tag(7, WireType.Varint).uint32(message.perClassMissionWeightSum);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const OutsideViewComplete = new OutsideViewComplete$Type();
    class WhatsUppContent$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.WhatsUppContent", [
          { no: 1, name: "chats", kind: "message", repeat: 1, T: () => WhatsUppContent_Chat }
        ]);
      }
      create(value) {
        const message = { chats: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* repeated api.unsafe.gui.WhatsUppContent.Chat chats */
            1:
              message.chats.push(WhatsUppContent_Chat.internalBinaryRead(reader, reader.uint32(), options));
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        for (let i = 0; i < message.chats.length; i++)
          WhatsUppContent_Chat.internalBinaryWrite(message.chats[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const WhatsUppContent = new WhatsUppContent$Type();
    class WhatsUppContent_Chat$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.WhatsUppContent.Chat", [
          {
            no: 1,
            name: "script",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "contact_name",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          { no: 3, name: "messages", kind: "message", repeat: 1, T: () => WhatsUppContent_Chat_Message },
          {
            no: 4,
            name: "choices",
            kind: "scalar",
            repeat: 2,
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 5,
            name: "is_writing",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          }
        ]);
      }
      create(value) {
        const message = { script: "", contactName: "", messages: [], choices: [], isWriting: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string script */
            1:
              message.script = reader.string();
              break;
            case /* string contact_name */
            2:
              message.contactName = reader.string();
              break;
            case /* repeated api.unsafe.gui.WhatsUppContent.Chat.Message messages */
            3:
              message.messages.push(WhatsUppContent_Chat_Message.internalBinaryRead(reader, reader.uint32(), options));
              break;
            case /* repeated string choices */
            4:
              message.choices.push(reader.string());
              break;
            case /* bool is_writing */
            5:
              message.isWriting = reader.bool();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.script !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.script);
        if (message.contactName !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.contactName);
        for (let i = 0; i < message.messages.length; i++)
          WhatsUppContent_Chat_Message.internalBinaryWrite(message.messages[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        for (let i = 0; i < message.choices.length; i++)
          writer.tag(4, WireType.LengthDelimited).string(message.choices[i]);
        if (message.isWriting !== false)
          writer.tag(5, WireType.Varint).bool(message.isWriting);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const WhatsUppContent_Chat = new WhatsUppContent_Chat$Type();
    class WhatsUppContent_Chat_Message$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.WhatsUppContent.Chat.Message", [
          {
            no: 1,
            name: "sender",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "text",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "is_edited",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          }
        ]);
      }
      create(value) {
        const message = { sender: "", text: "", isEdited: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string sender */
            1:
              message.sender = reader.string();
              break;
            case /* string text */
            2:
              message.text = reader.string();
              break;
            case /* bool is_edited */
            3:
              message.isEdited = reader.bool();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.sender !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.sender);
        if (message.text !== "")
          writer.tag(2, WireType.LengthDelimited).string(message.text);
        if (message.isEdited !== false)
          writer.tag(3, WireType.Varint).bool(message.isEdited);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const WhatsUppContent_Chat_Message = new WhatsUppContent_Chat_Message$Type();
    class WhatsUppSelectChoice$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.WhatsUppSelectChoice", [
          {
            no: 1,
            name: "script",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 2,
            name: "choice",
            kind: "scalar",
            T: 13
            /*ScalarType.UINT32*/
          }
        ]);
      }
      create(value) {
        const message = { script: "", choice: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* string script */
            1:
              message.script = reader.string();
              break;
            case /* uint32 choice */
            2:
              message.choice = reader.uint32();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.script !== "")
          writer.tag(1, WireType.LengthDelimited).string(message.script);
        if (message.choice !== 0)
          writer.tag(2, WireType.Varint).uint32(message.choice);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const WhatsUppSelectChoice = new WhatsUppSelectChoice$Type();
    class SpeedFactor$Type extends MessageType {
      constructor() {
        super("api.unsafe.gui.SpeedFactor", [
          {
            no: 1,
            name: "speed_factor",
            kind: "scalar",
            T: 1
            /*ScalarType.DOUBLE*/
          }
        ]);
      }
      create(value) {
        const message = { speedFactor: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          reflectionMergePartial(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* double speed_factor */
            1:
              message.speedFactor = reader.double();
              break;
            default:
              let u2 = options.readUnknownField;
              if (u2 === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u2 !== false)
                (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options) {
        if (message.speedFactor !== 0)
          writer.tag(1, WireType.Bit64).double(message.speedFactor);
        let u2 = options.writeUnknownFields;
        if (u2 !== false)
          (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
        return writer;
      }
    }
    const SpeedFactor = new SpeedFactor$Type();
    new ServiceType("api.unsafe.gui.TheShipGui", [
      { name: "getUpdates", serverStreaming: true, options: {}, I: GetUpdatesRequest, O: StatusUpdate },
      { name: "setState", options: {}, I: GameState, O: Void },
      { name: "getState", options: {}, I: Void, O: GameState },
      { name: "addGroup", options: {}, I: AddGroupRequest, O: Void },
      { name: "getAllOutsideUpdates", serverStreaming: true, options: {}, I: Void, O: OutsideViewComplete },
      { name: "setAllOutsideUpdatesUpdatePressure", options: {}, I: OutsideUpdatesUpdatePressureRequest, O: Void },
      { name: "setSpeedFactor", options: {}, I: SpeedFactor, O: Void }
    ]);
    const TheShipLowLevel = new ServiceType("api.unsafe.gui.TheShipLowLevel", [
      { name: "getOutsideUpdates", serverStreaming: true, options: {}, I: OutsideUpdatesRequest, O: OutsideViewSingleShip },
      { name: "setOutsideUpdatesUpdatePressure", options: {}, I: OutsideUpdatesUpdatePressureRequest, O: Void },
      { name: "getPos", options: {}, I: Void, O: PhysicalObject },
      { name: "setThruster", options: {}, I: SetThruster, O: Void },
      { name: "getSecondsSinceStart", options: {}, I: Void, O: SecondsSinceStart },
      { name: "getCommunication", options: {}, I: Void, O: Communication },
      { name: "sellResource", options: {}, I: BuySell, O: Void },
      { name: "buyResource", options: {}, I: BuySell, O: Void },
      { name: "buyItem", options: {}, I: BuyItem, O: Void },
      { name: "getCargoHold", options: {}, I: Void, O: CargoHold },
      { name: "cargoHoldSwapAdjacent", options: {}, I: CargoHoldSwapAdjacentRequest, O: Void },
      { name: "getMissions", options: {}, I: Void, O: GetMissions },
      { name: "acceptMission", options: {}, I: AcceptMission, O: Void },
      { name: "getInstallableSoftware", options: {}, I: Void, O: GetInstallableSoftware },
      { name: "deployInstallableSoftware", options: {}, I: DeployInstallableSoftware, O: Void },
      { name: "undeployInstallableSoftware", options: {}, I: UndeployInstallableSoftware, O: Void },
      { name: "wipeInstallableSoftware", options: {}, I: WipeInstallableSoftware, O: Void },
      { name: "scannerGetNearObjects", options: {}, I: Void, O: ScannerGetNearObjects },
      { name: "laserGetState", options: {}, I: Void, O: LaserGetState },
      { name: "laserSetState", options: {}, I: LaserSetState, O: Void },
      { name: "laserSetRotationState", options: {}, I: LaserSetRotationState, O: Void },
      { name: "commSend", options: {}, I: CommSend, O: Void },
      { name: "commReceive", options: {}, I: CommReceiveRequest, O: CommReceiveResponse },
      { name: "hackReadSecretStationData", options: {}, I: Void, O: HackReadSecretStationDataResponse },
      { name: "whatsUppGetContent", options: {}, I: Void, O: WhatsUppContent },
      { name: "whatsUppSelectChoice", options: {}, I: WhatsUppSelectChoice, O: Void }
    ]);
    class TheShipLowLevelClient {
      constructor(_transport) {
        this._transport = _transport;
        this.typeName = TheShipLowLevel.typeName;
        this.methods = TheShipLowLevel.methods;
        this.options = TheShipLowLevel.options;
      }
      /**
       * game view
       *
       * @generated from protobuf rpc: getOutsideUpdates(api.unsafe.gui.OutsideUpdatesRequest) returns (stream api.unsafe.gui.OutsideViewSingleShip);
       */
      getOutsideUpdates(input, options) {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: setOutsideUpdatesUpdatePressure(api.unsafe.gui.OutsideUpdatesUpdatePressureRequest) returns (api.unsafe.gui.Void);
       */
      setOutsideUpdatesUpdatePressure(input, options) {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * navigation
       *
       * @generated from protobuf rpc: getPos(api.unsafe.gui.Void) returns (api.unsafe.gui.PhysicalObject);
       */
      getPos(input, options) {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: setThruster(api.unsafe.gui.SetThruster) returns (api.unsafe.gui.Void);
       */
      setThruster(input, options) {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: getSecondsSinceStart(api.unsafe.gui.Void) returns (api.unsafe.gui.SecondsSinceStart);
       */
      getSecondsSinceStart(input, options) {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * communication
       *
       * @generated from protobuf rpc: getCommunication(api.unsafe.gui.Void) returns (api.unsafe.gui.Communication);
       */
      getCommunication(input, options) {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: sellResource(api.unsafe.gui.BuySell) returns (api.unsafe.gui.Void);
       */
      sellResource(input, options) {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: buyResource(api.unsafe.gui.BuySell) returns (api.unsafe.gui.Void);
       */
      buyResource(input, options) {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: buyItem(api.unsafe.gui.BuyItem) returns (api.unsafe.gui.Void);
       */
      buyItem(input, options) {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * cargo hold
       *
       * @generated from protobuf rpc: getCargoHold(api.unsafe.gui.Void) returns (api.unsafe.gui.CargoHold);
       */
      getCargoHold(input, options) {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: cargoHoldSwapAdjacent(api.unsafe.gui.CargoHoldSwapAdjacentRequest) returns (api.unsafe.gui.Void);
       */
      cargoHoldSwapAdjacent(input, options) {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * missions
       *
       * @generated from protobuf rpc: getMissions(api.unsafe.gui.Void) returns (api.unsafe.gui.GetMissions);
       */
      getMissions(input, options) {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: acceptMission(api.unsafe.gui.AcceptMission) returns (api.unsafe.gui.Void);
       */
      acceptMission(input, options) {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * installer
       *
       * @generated from protobuf rpc: getInstallableSoftware(api.unsafe.gui.Void) returns (api.unsafe.gui.GetInstallableSoftware);
       */
      getInstallableSoftware(input, options) {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: deployInstallableSoftware(api.unsafe.gui.DeployInstallableSoftware) returns (api.unsafe.gui.Void);
       */
      deployInstallableSoftware(input, options) {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: undeployInstallableSoftware(api.unsafe.gui.UndeployInstallableSoftware) returns (api.unsafe.gui.Void);
       */
      undeployInstallableSoftware(input, options) {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: wipeInstallableSoftware(api.unsafe.gui.WipeInstallableSoftware) returns (api.unsafe.gui.Void);
       */
      wipeInstallableSoftware(input, options) {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * scanner
       *
       * @generated from protobuf rpc: scannerGetNearObjects(api.unsafe.gui.Void) returns (api.unsafe.gui.ScannerGetNearObjects);
       */
      scannerGetNearObjects(input, options) {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * laser
       *
       * @generated from protobuf rpc: laserGetState(api.unsafe.gui.Void) returns (api.unsafe.gui.LaserGetState);
       */
      laserGetState(input, options) {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: laserSetState(api.unsafe.gui.LaserSetState) returns (api.unsafe.gui.Void);
       */
      laserSetState(input, options) {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: laserSetRotationState(api.unsafe.gui.LaserSetRotationState) returns (api.unsafe.gui.Void);
       */
      laserSetRotationState(input, options) {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * comm
       *
       * @generated from protobuf rpc: commSend(api.unsafe.gui.CommSend) returns (api.unsafe.gui.Void);
       */
      commSend(input, options) {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: commReceive(api.unsafe.gui.CommReceiveRequest) returns (api.unsafe.gui.CommReceiveResponse);
       */
      commReceive(input, options) {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * hackingdevice
       *
       * @generated from protobuf rpc: hackReadSecretStationData(api.unsafe.gui.Void) returns (api.unsafe.gui.HackReadSecretStationDataResponse);
       */
      hackReadSecretStationData(input, options) {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * Whatsupp
       *
       * @generated from protobuf rpc: whatsUppGetContent(api.unsafe.gui.Void) returns (api.unsafe.gui.WhatsUppContent);
       */
      whatsUppGetContent(input, options) {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
      /**
       * @generated from protobuf rpc: whatsUppSelectChoice(api.unsafe.gui.WhatsUppSelectChoice) returns (api.unsafe.gui.Void);
       */
      whatsUppSelectChoice(input, options) {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
      }
    }
    var GrpcStatusCode;
    (function(GrpcStatusCode2) {
      GrpcStatusCode2[GrpcStatusCode2["OK"] = 0] = "OK";
      GrpcStatusCode2[GrpcStatusCode2["CANCELLED"] = 1] = "CANCELLED";
      GrpcStatusCode2[GrpcStatusCode2["UNKNOWN"] = 2] = "UNKNOWN";
      GrpcStatusCode2[GrpcStatusCode2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
      GrpcStatusCode2[GrpcStatusCode2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
      GrpcStatusCode2[GrpcStatusCode2["NOT_FOUND"] = 5] = "NOT_FOUND";
      GrpcStatusCode2[GrpcStatusCode2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
      GrpcStatusCode2[GrpcStatusCode2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
      GrpcStatusCode2[GrpcStatusCode2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
      GrpcStatusCode2[GrpcStatusCode2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
      GrpcStatusCode2[GrpcStatusCode2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
      GrpcStatusCode2[GrpcStatusCode2["ABORTED"] = 10] = "ABORTED";
      GrpcStatusCode2[GrpcStatusCode2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
      GrpcStatusCode2[GrpcStatusCode2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
      GrpcStatusCode2[GrpcStatusCode2["INTERNAL"] = 13] = "INTERNAL";
      GrpcStatusCode2[GrpcStatusCode2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
      GrpcStatusCode2[GrpcStatusCode2["DATA_LOSS"] = 15] = "DATA_LOSS";
    })(GrpcStatusCode || (GrpcStatusCode = {}));
    var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    function createGrpcWebRequestHeader(headers, format, timeout, meta, userAgent) {
      if (meta) {
        for (let [k2, v2] of Object.entries(meta)) {
          if (typeof v2 == "string")
            headers.append(k2, v2);
          else
            for (let i of v2)
              headers.append(k2, i);
        }
      }
      headers.set("Content-Type", format === "text" ? "application/grpc-web-text" : "application/grpc-web+proto");
      if (format == "text") {
        headers.set("Accept", "application/grpc-web-text");
      }
      headers.set("X-Grpc-Web", "1");
      if (userAgent)
        headers.set("X-User-Agent", userAgent);
      if (typeof timeout === "number") {
        if (timeout <= 0) {
          throw new RpcError(`timeout ${timeout} ms exceeded`, GrpcStatusCode[GrpcStatusCode.DEADLINE_EXCEEDED]);
        }
        headers.set("grpc-timeout", `${timeout}m`);
      } else if (timeout) {
        const deadline = timeout.getTime();
        const now = Date.now();
        if (deadline <= now) {
          throw new RpcError(`deadline ${timeout} exceeded`, GrpcStatusCode[GrpcStatusCode.DEADLINE_EXCEEDED]);
        }
        headers.set("grpc-timeout", `${deadline - now}m`);
      }
      return headers;
    }
    function createGrpcWebRequestBody(message, format) {
      let body = new Uint8Array(5 + message.length);
      body[0] = GrpcWebFrame.DATA;
      for (let msgLen = message.length, i = 4; i > 0; i--) {
        body[i] = msgLen % 256;
        msgLen >>>= 8;
      }
      body.set(message, 5);
      return format === "binary" ? body : base64encode(body);
    }
    function readGrpcWebResponseHeader(headersOrFetchResponse, httpStatus, httpStatusText) {
      if (arguments.length === 1) {
        let fetchResponse = headersOrFetchResponse;
        let responseType;
        try {
          responseType = fetchResponse.type;
        } catch (_a) {
        }
        switch (responseType) {
          case "error":
          case "opaque":
          case "opaqueredirect":
            throw new RpcError(`fetch response type ${fetchResponse.type}`, GrpcStatusCode[GrpcStatusCode.UNKNOWN]);
        }
        return readGrpcWebResponseHeader(fetchHeadersToHttp(fetchResponse.headers), fetchResponse.status, fetchResponse.statusText);
      }
      let headers = headersOrFetchResponse, httpOk = httpStatus >= 200 && httpStatus < 300, responseMeta = parseMetadata(headers), [statusCode, statusDetail] = parseStatus(headers);
      if ((statusCode === void 0 || statusCode === GrpcStatusCode.OK) && !httpOk) {
        statusCode = httpStatusToGrpc(httpStatus);
        statusDetail = httpStatusText;
      }
      return [statusCode, statusDetail, responseMeta];
    }
    function readGrpcWebResponseTrailer(data2) {
      let headers = parseTrailer(data2), [code2, detail] = parseStatus(headers), meta = parseMetadata(headers);
      return [code2 !== null && code2 !== void 0 ? code2 : GrpcStatusCode.OK, detail, meta];
    }
    var GrpcWebFrame;
    (function(GrpcWebFrame2) {
      GrpcWebFrame2[GrpcWebFrame2["DATA"] = 0] = "DATA";
      GrpcWebFrame2[GrpcWebFrame2["TRAILER"] = 128] = "TRAILER";
    })(GrpcWebFrame || (GrpcWebFrame = {}));
    function readGrpcWebResponseBody(stream, contentType, onFrame) {
      return __awaiter(this, void 0, void 0, function* () {
        let streamReader, base64queue = "", byteQueue = new Uint8Array(0), format = parseFormat(contentType);
        if (isReadableStream(stream)) {
          let whatWgReadableStream = stream.getReader();
          streamReader = {
            next: () => whatWgReadableStream.read()
          };
        } else {
          streamReader = stream[Symbol.asyncIterator]();
        }
        while (true) {
          let result = yield streamReader.next();
          if (result.value !== void 0) {
            if (format === "text") {
              for (let i = 0; i < result.value.length; i++)
                base64queue += String.fromCharCode(result.value[i]);
              let safeLen = base64queue.length - base64queue.length % 4;
              if (safeLen === 0)
                continue;
              byteQueue = concatBytes(byteQueue, base64decode(base64queue.substring(0, safeLen)));
              base64queue = base64queue.substring(safeLen);
            } else {
              byteQueue = concatBytes(byteQueue, result.value);
            }
            while (byteQueue.length >= 5 && byteQueue[0] === GrpcWebFrame.DATA) {
              let msgLen = 0;
              for (let i = 1; i < 5; i++)
                msgLen = (msgLen << 8) + byteQueue[i];
              if (byteQueue.length - 5 >= msgLen) {
                onFrame(GrpcWebFrame.DATA, byteQueue.subarray(5, 5 + msgLen));
                byteQueue = byteQueue.subarray(5 + msgLen);
              } else
                break;
            }
          }
          if (result.done) {
            if (byteQueue.length === 0)
              break;
            if (byteQueue[0] !== GrpcWebFrame.TRAILER || byteQueue.length < 5)
              throw new RpcError("premature EOF", GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
            onFrame(GrpcWebFrame.TRAILER, byteQueue.subarray(5));
            break;
          }
        }
      });
    }
    const isReadableStream = (s) => {
      return typeof s.getReader == "function";
    };
    function concatBytes(a, b) {
      let n2 = new Uint8Array(a.length + b.length);
      n2.set(a);
      n2.set(b, a.length);
      return n2;
    }
    function parseFormat(contentType) {
      switch (contentType) {
        case "application/grpc-web-text":
        case "application/grpc-web-text+proto":
          return "text";
        case "application/grpc-web":
        case "application/grpc-web+proto":
          return "binary";
        case void 0:
        case null:
          throw new RpcError("missing response content type", GrpcStatusCode[GrpcStatusCode.INTERNAL]);
        default:
          throw new RpcError("unexpected response content type: " + contentType, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
      }
    }
    function parseStatus(headers) {
      let code2, message;
      let m2 = headers["grpc-message"];
      if (m2 !== void 0) {
        if (Array.isArray(m2))
          return [GrpcStatusCode.INTERNAL, "invalid grpc-web message"];
        message = m2;
      }
      let s = headers["grpc-status"];
      if (s !== void 0) {
        if (Array.isArray(s))
          return [GrpcStatusCode.INTERNAL, "invalid grpc-web status"];
        code2 = parseInt(s, 10);
        if (GrpcStatusCode[code2] === void 0)
          return [GrpcStatusCode.INTERNAL, "invalid grpc-web status"];
      }
      return [code2, message];
    }
    function parseMetadata(headers) {
      let meta = {};
      for (let [k2, v2] of Object.entries(headers))
        switch (k2) {
          case "grpc-message":
          case "grpc-status":
          case "content-type":
            break;
          default:
            meta[k2] = v2;
        }
      return meta;
    }
    function parseTrailer(trailerData) {
      let headers = {};
      for (let chunk of String.fromCharCode.apply(String, trailerData).trim().split("\r\n")) {
        if (chunk == "")
          continue;
        let [key, ...val] = chunk.split(":");
        const value = val.join(":").trim();
        key = key.trim();
        let e = headers[key];
        if (typeof e == "string")
          headers[key] = [e, value];
        else if (Array.isArray(e))
          e.push(value);
        else
          headers[key] = value;
      }
      return headers;
    }
    function fetchHeadersToHttp(fetchHeaders) {
      let headers = {};
      fetchHeaders.forEach((value, key) => {
        let e = headers[key];
        if (typeof e == "string")
          headers[key] = [e, value];
        else if (Array.isArray(e))
          e.push(value);
        else
          headers[key] = value;
      });
      return headers;
    }
    function httpStatusToGrpc(httpStatus) {
      switch (httpStatus) {
        case 200:
          return GrpcStatusCode.OK;
        case 400:
          return GrpcStatusCode.INVALID_ARGUMENT;
        case 401:
          return GrpcStatusCode.UNAUTHENTICATED;
        case 403:
          return GrpcStatusCode.PERMISSION_DENIED;
        case 404:
          return GrpcStatusCode.NOT_FOUND;
        case 409:
          return GrpcStatusCode.ABORTED;
        case 412:
          return GrpcStatusCode.FAILED_PRECONDITION;
        case 429:
          return GrpcStatusCode.RESOURCE_EXHAUSTED;
        case 499:
          return GrpcStatusCode.CANCELLED;
        case 500:
          return GrpcStatusCode.UNKNOWN;
        case 501:
          return GrpcStatusCode.UNIMPLEMENTED;
        case 503:
          return GrpcStatusCode.UNAVAILABLE;
        case 504:
          return GrpcStatusCode.DEADLINE_EXCEEDED;
        default:
          return GrpcStatusCode.UNKNOWN;
      }
    }
    class GrpcWebFetchTransport {
      constructor(defaultOptions) {
        this.defaultOptions = defaultOptions;
      }
      mergeOptions(options) {
        return mergeRpcOptions(this.defaultOptions, options);
      }
      /**
       * Create an URI for a gRPC web call.
       *
       * Takes the `baseUrl` option and appends:
       * - slash "/"
       * - package name
       * - dot "."
       * - service name
       * - slash "/"
       * - method name
       *
       * If the service was declared without a package, the package name and dot
       * are omitted.
       *
       * All names are used exactly like declared in .proto.
       */
      makeUrl(method, options) {
        let base = options.baseUrl;
        if (base.endsWith("/"))
          base = base.substring(0, base.length - 1);
        return `${base}/${method.service.typeName}/${method.name}`;
      }
      clientStreaming(method) {
        const e = new RpcError("Client streaming is not supported by grpc-web", GrpcStatusCode[GrpcStatusCode.UNIMPLEMENTED]);
        e.methodName = method.name;
        e.serviceName = method.service.typeName;
        throw e;
      }
      duplex(method) {
        const e = new RpcError("Duplex streaming is not supported by grpc-web", GrpcStatusCode[GrpcStatusCode.UNIMPLEMENTED]);
        e.methodName = method.name;
        e.serviceName = method.service.typeName;
        throw e;
      }
      serverStreaming(method, input, options) {
        var _a, _b, _c, _d;
        let opt = options, format = (_a = opt.format) !== null && _a !== void 0 ? _a : "text", fetchInit = (_b = opt.fetchInit) !== null && _b !== void 0 ? _b : {}, url = this.makeUrl(method, opt), inputBytes = method.I.toBinary(input, opt.binaryOptions), defHeader = new Deferred(), responseStream = new RpcOutputStreamController(), responseEmptyBody = true, maybeStatus, defStatus = new Deferred(), maybeTrailer, defTrailer = new Deferred();
        globalThis.fetch(url, Object.assign(Object.assign({}, fetchInit), {
          method: "POST",
          headers: createGrpcWebRequestHeader(new globalThis.Headers(), format, opt.timeout, opt.meta),
          body: createGrpcWebRequestBody(inputBytes, format),
          signal: (_c = options.abort) !== null && _c !== void 0 ? _c : null
          // node-fetch@3.0.0-beta.9 rejects `undefined`
        })).then((fetchResponse) => {
          let [code2, detail, meta] = readGrpcWebResponseHeader(fetchResponse);
          defHeader.resolve(meta);
          if (code2 != null && code2 !== GrpcStatusCode.OK)
            throw new RpcError(detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code2], GrpcStatusCode[code2], meta);
          if (code2 != null)
            maybeStatus = {
              code: GrpcStatusCode[code2],
              detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code2]
            };
          return fetchResponse;
        }).then((fetchResponse) => {
          if (!fetchResponse.body)
            throw new RpcError("missing response body", GrpcStatusCode[GrpcStatusCode.INTERNAL]);
          return readGrpcWebResponseBody(fetchResponse.body, fetchResponse.headers.get("content-type"), (type, data2) => {
            switch (type) {
              case GrpcWebFrame.DATA:
                responseStream.notifyMessage(method.O.fromBinary(data2, opt.binaryOptions));
                responseEmptyBody = false;
                break;
              case GrpcWebFrame.TRAILER:
                let code2, detail;
                [code2, detail, maybeTrailer] = readGrpcWebResponseTrailer(data2);
                maybeStatus = {
                  code: GrpcStatusCode[code2],
                  detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code2]
                };
                break;
            }
          });
        }).then(() => {
          if (!maybeTrailer && !responseEmptyBody)
            throw new RpcError(`missing trailers`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
          if (!maybeStatus)
            throw new RpcError(`missing status`, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
          if (maybeStatus.code !== "OK")
            throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);
          responseStream.notifyComplete();
          defStatus.resolve(maybeStatus);
          defTrailer.resolve(maybeTrailer || {});
        }).catch((reason) => {
          let error;
          if (reason instanceof RpcError)
            error = reason;
          else if (reason instanceof Error && reason.name === "AbortError")
            error = new RpcError(reason.message, GrpcStatusCode[GrpcStatusCode.CANCELLED]);
          else
            error = new RpcError(reason instanceof Error ? reason.message : "" + reason, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
          error.methodName = method.name;
          error.serviceName = method.service.typeName;
          defHeader.rejectPending(error);
          responseStream.notifyError(error);
          defStatus.rejectPending(error);
          defTrailer.rejectPending(error);
        });
        return new ServerStreamingCall(method, (_d = opt.meta) !== null && _d !== void 0 ? _d : {}, input, defHeader.promise, responseStream, defStatus.promise, defTrailer.promise);
      }
      unary(method, input, options) {
        var _a, _b, _c, _d;
        let opt = options, format = (_a = opt.format) !== null && _a !== void 0 ? _a : "text", fetchInit = (_b = opt.fetchInit) !== null && _b !== void 0 ? _b : {}, url = this.makeUrl(method, opt), inputBytes = method.I.toBinary(input, opt.binaryOptions), defHeader = new Deferred(), maybeMessage, defMessage = new Deferred(), maybeStatus, defStatus = new Deferred(), maybeTrailer, defTrailer = new Deferred();
        globalThis.fetch(url, Object.assign(Object.assign({}, fetchInit), {
          method: "POST",
          headers: createGrpcWebRequestHeader(new globalThis.Headers(), format, opt.timeout, opt.meta),
          body: createGrpcWebRequestBody(inputBytes, format),
          signal: (_c = options.abort) !== null && _c !== void 0 ? _c : null
          // node-fetch@3.0.0-beta.9 rejects `undefined`
        })).then((fetchResponse) => {
          let [code2, detail, meta] = readGrpcWebResponseHeader(fetchResponse);
          defHeader.resolve(meta);
          if (code2 != null && code2 !== GrpcStatusCode.OK)
            throw new RpcError(detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code2], GrpcStatusCode[code2], meta);
          if (code2 != null)
            maybeStatus = {
              code: GrpcStatusCode[code2],
              detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code2]
            };
          return fetchResponse;
        }).then((fetchResponse) => {
          if (!fetchResponse.body)
            throw new RpcError("missing response body", GrpcStatusCode[GrpcStatusCode.INTERNAL]);
          return readGrpcWebResponseBody(fetchResponse.body, fetchResponse.headers.get("content-type"), (type, data2) => {
            switch (type) {
              case GrpcWebFrame.DATA:
                if (maybeMessage)
                  throw new RpcError(`unary call received 2nd message`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
                maybeMessage = method.O.fromBinary(data2, opt.binaryOptions);
                break;
              case GrpcWebFrame.TRAILER:
                let code2, detail;
                [code2, detail, maybeTrailer] = readGrpcWebResponseTrailer(data2);
                maybeStatus = {
                  code: GrpcStatusCode[code2],
                  detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code2]
                };
                break;
            }
          });
        }).then(() => {
          if (!maybeTrailer && maybeMessage)
            throw new RpcError(`missing trailers`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
          if (!maybeStatus)
            throw new RpcError(`missing status`, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
          if (!maybeMessage && maybeStatus.code === "OK")
            throw new RpcError("expected error status", GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);
          if (!maybeMessage)
            throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);
          defMessage.resolve(maybeMessage);
          if (maybeStatus.code !== "OK")
            throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);
          defStatus.resolve(maybeStatus);
          defTrailer.resolve(maybeTrailer || {});
        }).catch((reason) => {
          let error;
          if (reason instanceof RpcError)
            error = reason;
          else if (reason instanceof Error && reason.name === "AbortError")
            error = new RpcError(reason.message, GrpcStatusCode[GrpcStatusCode.CANCELLED]);
          else
            error = new RpcError(reason instanceof Error ? reason.message : "" + reason, GrpcStatusCode[GrpcStatusCode.INTERNAL]);
          error.methodName = method.name;
          error.serviceName = method.service.typeName;
          defHeader.rejectPending(error);
          defMessage.rejectPending(error);
          defStatus.rejectPending(error);
          defTrailer.rejectPending(error);
        });
        return new UnaryCall(method, (_d = opt.meta) !== null && _d !== void 0 ? _d : {}, input, defHeader.promise, defMessage.promise, defStatus.promise, defTrailer.promise);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index2 == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      return index2 < 0 ? void 0 : data2[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index2][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    const freeGlobal$1 = freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal$1 || freeSelf || Function("return this")();
    const root$1 = root;
    var Symbol$1 = root$1.Symbol;
    const Symbol$2 = Symbol$1;
    var objectProto$f = Object.prototype;
    var hasOwnProperty$c = objectProto$f.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$f.toString;
    var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$e = Object.prototype;
    var nativeObjectToString = objectProto$e.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObject$1(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction$1(value) {
      if (!isObject$1(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root$1["__core-js_shared__"];
    const coreJsData$1 = coreJsData;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$1 = Function.prototype;
    var funcToString$1 = funcProto$1.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype, objectProto$d = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$b = objectProto$d.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$1(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var Map$1 = getNative(root$1, "Map");
    const Map$2 = Map$1;
    var nativeCreate = getNative(Object, "create");
    const nativeCreate$1 = nativeCreate;
    function hashClear() {
      this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$c = Object.prototype;
    var hasOwnProperty$a = objectProto$c.hasOwnProperty;
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate$1) {
        var result = data2[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$a.call(data2, key) ? data2[key] : void 0;
    }
    var objectProto$b = Object.prototype;
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$9.call(data2, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$2 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map2, key) {
      var data2 = map2.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data2 = getMapData(this, key), size = data2.size;
      data2.set(key, value);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache) {
        var pairs = data2.__data__;
        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    function Stack(entries) {
      var data2 = this.__data__ = new ListCache(entries);
      this.size = data2.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values) {
      var index2 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index2 < arrLength) {
        var arrValue = array[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    var Uint8Array$1 = root$1.Uint8Array;
    const Uint8Array$2 = Uint8Array$1;
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]";
    var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$4:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag$3:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
            return false;
          }
          return true;
        case boolTag$3:
        case dateTag$3:
        case numberTag$3:
          return eq(+object, +other);
        case errorTag$2:
          return object.name == other.name && object.message == other.message;
        case regexpTag$3:
        case stringTag$3:
          return object == other + "";
        case mapTag$5:
          var convert2 = mapToArray;
        case setTag$5:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert2 || (convert2 = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack.set(object, other);
          var result = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag$3:
          if (symbolValueOf$1) {
            return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
          }
      }
      return false;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    var isArray$1 = Array.isArray;
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$a = Object.prototype;
    var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
        return propertyIsEnumerable$1.call(object, symbol);
      });
    };
    const getSymbols$1 = getSymbols;
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var argsTag$3 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$3;
    }
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    var propertyIsEnumerable = objectProto$9.propertyIsEnumerable;
    var isArguments$1 = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    const isArguments$2 = isArguments$1;
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer$1 = nativeIsBuffer || stubFalse;
    const isBuffer$2 = isBuffer$1;
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal$1.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    const nodeUtil$1 = nodeUtil;
    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    const isTypedArray$1 = isTypedArray;
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray$1(value), isArg = !isArr && isArguments$2(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$7 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$7;
      return value === proto2;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    const nativeKeys$1 = nativeKeys;
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys$1(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$6.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction$1(value);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols$1);
    }
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    var DataView$1 = getNative(root$1, "DataView");
    const DataView$2 = DataView$1;
    var Promise$1 = getNative(root$1, "Promise");
    const Promise$2 = Promise$1;
    var Set$1 = getNative(root$1, "Set");
    const Set$2 = Set$1;
    var WeakMap$1 = getNative(root$1, "WeakMap");
    const WeakMap$2 = WeakMap$1;
    var mapTag$3 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$2 = "[object DataView]";
    var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
    var getTag = baseGetTag;
    if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$2 || Map$2 && getTag(new Map$2()) != mapTag$3 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$3 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$2;
            case mapCtorString:
              return mapTag$3;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$3;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    const getTag$1 = getTag;
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$1 = "[object Object]";
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag$1 : getTag$1(object), othTag = othIsArr ? arrayTag$1 : getTag$1(other);
      objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
      othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
      var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer$2(object)) {
        if (!isBuffer$2(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$4.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    const defineProperty$1 = defineProperty;
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty$1) {
        defineProperty$1(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$3.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index2 = -1, length = props.length;
      while (++index2 < length) {
        var key = props[index2];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject$1(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function copyArray(source, array) {
      var index2 = -1, length = source.length;
      array || (array = Array(length));
      while (++index2 < length) {
        array[index2] = source[index2];
      }
      return array;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols$1(source), object);
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    const getPrototype$1 = getPrototype;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols$1(object));
        object = getPrototype$1(object);
      }
      return result;
    };
    const getSymbolsIn$1 = getSymbolsIn;
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn$1(source), object);
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
    }
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$1:
          return cloneArrayBuffer(object);
        case boolTag$1:
        case dateTag$1:
          return new Ctor(+object);
        case dataViewTag$1:
          return cloneDataView(object, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object, isDeep);
        case mapTag$2:
          return new Ctor();
        case numberTag$1:
        case stringTag$1:
          return new Ctor(object);
        case regexpTag$1:
          return cloneRegExp(object);
        case setTag$2:
          return new Ctor();
        case symbolTag$2:
          return cloneSymbol(object);
      }
    }
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto2) {
        if (!isObject$1(proto2)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto2);
        }
        object.prototype = proto2;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    const baseCreate$1 = baseCreate;
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
    }
    var mapTag$1 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag$1(value) == mapTag$1;
    }
    var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    const isMap$1 = isMap;
    var setTag$1 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag$1(value) == setTag$1;
    }
    var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    const isSet$1 = isSet;
    var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$2 = 4;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject$1(value)) {
        return value;
      }
      var isArr = isArray$1(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer$2(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet$1(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap$1(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG$1 = 4;
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG$1, customizer);
    }
    function get_cookie_impl(name2) {
      const cookie_value = document.cookie.replace(
        new RegExp("(?:(?:^|.*;\\s*)" + name2 + "\\s*=\\s*([^;]*).*$)|^.*$"),
        "$1"
      );
      return cookie_value;
    }
    if (get_cookie_impl("ENABLE_VERBOSE_LOGGING") == "1")
      ;
    function assert(condition, msg = null) {
      if (!condition) {
        if (msg != null) {
          console.log(msg);
        }
        const stack = new Error().stack;
        console.log(stack);
        console.log("ASSERTION_FAILED");
        console.trace();
        throw `fatal assert:
${stack}`;
      }
    }
    function assert_is_defined(value, msg) {
      assert(value !== void 0 && value !== null, msg);
    }
    function ensure_non_null(v2) {
      assert_is_defined(v2);
      return v2;
    }
    const ref_constant = "this_is_a_ref__dont_copy_dont_immutable";
    function make_ref(target) {
      return {
        $$ref: ref_constant,
        target
      };
    }
    function is_ref(data2) {
      if (data2 == null) {
        return false;
      }
      if (!has_member(data2, "$$ref")) {
        return false;
      }
      return data2["$$ref"] == ref_constant;
    }
    function Immutable(data2) {
      if (Object.isFrozen(data2) || data2 instanceof Uint8Array || is_ref(data2)) {
        return data2;
      }
      Object.freeze(data2);
      if (data2 !== null) {
        for (const p2 of Object.getOwnPropertyNames(data2)) {
          if (Object.prototype.hasOwnProperty.call(data2, p2) && //eslint-disable-next-line total-functions/no-unsafe-type-assertion
          typeof data2[p2] === "object") {
            if (!is_ref(data2)) {
              Immutable(data2[p2]);
            }
          }
        }
      }
      return data2;
    }
    function make_mutable(data2) {
      assert(!(data2 instanceof File));
      return cloneDeepWith(data2, (obj) => {
        if (is_ref(obj)) {
          return obj;
        }
      });
    }
    function make_immutable(data2) {
      if (Object.isFrozen(data2) || is_ref(data2)) {
        return data2;
      }
      return Immutable(
        cloneDeepWith(data2, (obj) => {
          if (is_ref(obj)) {
            return obj;
          }
          if (Object.isFrozen(obj)) {
            return obj;
          }
        })
      );
    }
    function unsafe_assume_immutable(data2) {
      return Immutable(data2);
    }
    function isInteger(value) {
      return INTEGER_REGEX.test(value);
    }
    var INTEGER_REGEX = /^-?[0-9]+$/;
    function isNumber(value) {
      return NUMBER_REGEX.test(value);
    }
    var NUMBER_REGEX = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
    function isSafeNumber(value, config2) {
      var num = parseFloat(value);
      var str = String(num);
      var v2 = extractSignificantDigits(value);
      var s = extractSignificantDigits(str);
      if (v2 === s) {
        return true;
      }
      if ((config2 === null || config2 === void 0 ? void 0 : config2.approx) === true) {
        var requiredDigits = 14;
        if (!isInteger(value) && s.length >= requiredDigits && v2.startsWith(s.substring(0, requiredDigits))) {
          return true;
        }
      }
      return false;
    }
    var UnsafeNumberReason = /* @__PURE__ */ function(UnsafeNumberReason2) {
      UnsafeNumberReason2["underflow"] = "underflow";
      UnsafeNumberReason2["overflow"] = "overflow";
      UnsafeNumberReason2["truncate_integer"] = "truncate_integer";
      UnsafeNumberReason2["truncate_float"] = "truncate_float";
      return UnsafeNumberReason2;
    }({});
    function getUnsafeNumberReason(value) {
      if (isSafeNumber(value, {
        approx: false
      })) {
        return void 0;
      }
      if (isInteger(value)) {
        return UnsafeNumberReason.truncate_integer;
      }
      var num = parseFloat(value);
      if (!isFinite(num)) {
        return UnsafeNumberReason.overflow;
      }
      if (num === 0) {
        return UnsafeNumberReason.underflow;
      }
      return UnsafeNumberReason.truncate_float;
    }
    function extractSignificantDigits(value) {
      return value.replace(EXPONENTIAL_PART_REGEX, "").replace(DOT_REGEX, "").replace(TRAILING_ZEROS_REGEX, "").replace(LEADING_MINUS_AND_ZEROS_REGEX, "");
    }
    var EXPONENTIAL_PART_REGEX = /[eE][+-]?\d+$/;
    var LEADING_MINUS_AND_ZEROS_REGEX = /^-?(0*)?/;
    var DOT_REGEX = /\./;
    var TRAILING_ZEROS_REGEX = /0+$/;
    function _typeof$3(obj) {
      "@babel/helpers - typeof";
      return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$3(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof$3(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof$3(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof$3(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var LosslessNumber = /* @__PURE__ */ function() {
      function LosslessNumber2(value) {
        _classCallCheck(this, LosslessNumber2);
        _defineProperty(this, "isLosslessNumber", true);
        if (!isNumber(value)) {
          throw new Error('Invalid number (value: "' + value + '")');
        }
        this.value = value;
      }
      _createClass(LosslessNumber2, [{
        key: "valueOf",
        value: function valueOf() {
          var unsafeReason = getUnsafeNumberReason(this.value);
          if (unsafeReason === void 0 || unsafeReason === UnsafeNumberReason.truncate_float) {
            return parseFloat(this.value);
          }
          if (isInteger(this.value)) {
            return BigInt(this.value);
          }
          throw new Error("Cannot safely convert to number: " + "the value '".concat(this.value, "' would ").concat(unsafeReason, " and become ").concat(parseFloat(this.value)));
        }
        /**
         * Get the value of the LosslessNumber as string.
         */
      }, {
        key: "toString",
        value: function toString2() {
          return this.value;
        }
        // Note: we do NOT implement a .toJSON() method, and you should not implement
        // or use that, it cannot safely turn the numeric value in the string into
        // stringified JSON since it has to be parsed into a number first.
      }]);
      return LosslessNumber2;
    }();
    function isLosslessNumber(value) {
      return value && _typeof$3(value) === "object" && value.isLosslessNumber === true || false;
    }
    function parseLosslessNumber(value) {
      return new LosslessNumber(value);
    }
    function _typeof$2(obj) {
      "@babel/helpers - typeof";
      return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$2(obj);
    }
    function revive(json, reviver) {
      return reviveValue({
        "": json
      }, "", json, reviver);
    }
    function reviveValue(context, key, value, reviver) {
      if (Array.isArray(value)) {
        return reviver.call(context, key, reviveArray(value, reviver));
      } else if (value && _typeof$2(value) === "object" && !isLosslessNumber(value)) {
        return reviver.call(context, key, reviveObject(value, reviver));
      } else {
        return reviver.call(context, key, value);
      }
    }
    function reviveObject(object, reviver) {
      Object.keys(object).forEach(function(key) {
        var value = reviveValue(object, key, object[key], reviver);
        if (value !== void 0) {
          object[key] = value;
        } else {
          delete object[key];
        }
      });
      return object;
    }
    function reviveArray(array, reviver) {
      for (var i = 0; i < array.length; i++) {
        array[i] = reviveValue(array, i + "", array[i], reviver);
      }
      return array;
    }
    function _typeof$1(obj) {
      "@babel/helpers - typeof";
      return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$1(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function parse(text2, reviver) {
      var parseNumber = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : parseLosslessNumber;
      var i = 0;
      var value = parseValue();
      expectValue(value);
      expectEndOfInput();
      return reviver ? revive(value, reviver) : value;
      function parseObject() {
        if (text2.charCodeAt(i) === codeOpeningBrace) {
          i++;
          skipWhitespace();
          var object = {};
          var initial = true;
          while (i < text2.length && text2.charCodeAt(i) !== codeClosingBrace) {
            if (!initial) {
              eatComma();
              skipWhitespace();
            } else {
              initial = false;
            }
            var start = i;
            var key = parseString();
            if (key === void 0) {
              throwObjectKeyExpected();
            }
            skipWhitespace();
            eatColon();
            var _value = parseValue();
            if (_value === void 0) {
              throwObjectValueExpected();
            }
            if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(_value, object[key])) {
              throwDuplicateKey(key, start + 1);
            }
            object[key] = _value;
          }
          if (text2.charCodeAt(i) !== codeClosingBrace) {
            throwObjectKeyOrEndExpected();
          }
          i++;
          return object;
        }
      }
      function parseArray() {
        if (text2.charCodeAt(i) === codeOpeningBracket) {
          i++;
          skipWhitespace();
          var array = [];
          var initial = true;
          while (i < text2.length && text2.charCodeAt(i) !== codeClosingBracket) {
            if (!initial) {
              eatComma();
            } else {
              initial = false;
            }
            var _value2 = parseValue();
            expectArrayItem(_value2);
            array.push(_value2);
          }
          if (text2.charCodeAt(i) !== codeClosingBracket) {
            throwArrayItemOrEndExpected();
          }
          i++;
          return array;
        }
      }
      function parseValue() {
        var _ref, _ref2, _ref3, _ref4, _ref5, _parseString;
        skipWhitespace();
        var value2 = (_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_parseString = parseString()) !== null && _parseString !== void 0 ? _parseString : parseNumeric()) !== null && _ref5 !== void 0 ? _ref5 : parseObject()) !== null && _ref4 !== void 0 ? _ref4 : parseArray()) !== null && _ref3 !== void 0 ? _ref3 : parseKeyword("true", true)) !== null && _ref2 !== void 0 ? _ref2 : parseKeyword("false", false)) !== null && _ref !== void 0 ? _ref : parseKeyword("null", null);
        skipWhitespace();
        return value2;
      }
      function parseKeyword(name2, value2) {
        if (text2.slice(i, i + name2.length) === name2) {
          i += name2.length;
          return value2;
        }
      }
      function skipWhitespace() {
        while (isWhitespace(text2.charCodeAt(i))) {
          i++;
        }
      }
      function parseString() {
        if (text2.charCodeAt(i) === codeDoubleQuote) {
          i++;
          var result = "";
          while (i < text2.length && text2.charCodeAt(i) !== codeDoubleQuote) {
            if (text2.charCodeAt(i) === codeBackslash) {
              var char = text2[i + 1];
              var escapeChar = escapeCharacters[char];
              if (escapeChar !== void 0) {
                result += escapeChar;
                i++;
              } else if (char === "u") {
                if (isHex(text2.charCodeAt(i + 2)) && isHex(text2.charCodeAt(i + 3)) && isHex(text2.charCodeAt(i + 4)) && isHex(text2.charCodeAt(i + 5))) {
                  result += String.fromCharCode(parseInt(text2.slice(i + 2, i + 6), 16));
                  i += 5;
                } else {
                  throwInvalidUnicodeCharacter(i);
                }
              } else {
                throwInvalidEscapeCharacter(i);
              }
            } else {
              if (isValidStringCharacter(text2.charCodeAt(i))) {
                result += text2[i];
              } else {
                throwInvalidCharacter(text2[i]);
              }
            }
            i++;
          }
          expectEndOfString();
          i++;
          return result;
        }
      }
      function parseNumeric() {
        var start = i;
        if (text2.charCodeAt(i) === codeMinus) {
          i++;
          expectDigit(start);
        }
        if (text2.charCodeAt(i) === codeZero) {
          i++;
        } else if (isNonZeroDigit(text2.charCodeAt(i))) {
          i++;
          while (isDigit(text2.charCodeAt(i))) {
            i++;
          }
        }
        if (text2.charCodeAt(i) === codeDot) {
          i++;
          expectDigit(start);
          while (isDigit(text2.charCodeAt(i))) {
            i++;
          }
        }
        if (text2.charCodeAt(i) === codeLowercaseE || text2.charCodeAt(i) === codeUppercaseE) {
          i++;
          if (text2.charCodeAt(i) === codeMinus || text2.charCodeAt(i) === codePlus) {
            i++;
          }
          expectDigit(start);
          while (isDigit(text2.charCodeAt(i))) {
            i++;
          }
        }
        if (i > start) {
          return parseNumber(text2.slice(start, i));
        }
      }
      function eatComma() {
        if (text2.charCodeAt(i) !== codeComma) {
          throw new SyntaxError("Comma ',' expected after value ".concat(gotAt()));
        }
        i++;
      }
      function eatColon() {
        if (text2.charCodeAt(i) !== codeColon) {
          throw new SyntaxError("Colon ':' expected after property name ".concat(gotAt()));
        }
        i++;
      }
      function expectValue(value2) {
        if (value2 === void 0) {
          throw new SyntaxError("JSON value expected ".concat(gotAt()));
        }
      }
      function expectArrayItem(value2) {
        if (value2 === void 0) {
          throw new SyntaxError("Array item expected ".concat(gotAt()));
        }
      }
      function expectEndOfInput() {
        if (i < text2.length) {
          throw new SyntaxError("Expected end of input ".concat(gotAt()));
        }
      }
      function expectDigit(start) {
        if (!isDigit(text2.charCodeAt(i))) {
          var numSoFar = text2.slice(start, i);
          throw new SyntaxError("Invalid number '".concat(numSoFar, "', expecting a digit ").concat(gotAt()));
        }
      }
      function expectEndOfString() {
        if (text2.charCodeAt(i) !== codeDoubleQuote) {
          throw new SyntaxError(`End of string '"' expected `.concat(gotAt()));
        }
      }
      function throwObjectKeyExpected() {
        throw new SyntaxError("Quoted object key expected ".concat(gotAt()));
      }
      function throwDuplicateKey(key, pos2) {
        throw new SyntaxError("Duplicate key '".concat(key, "' encountered at position ").concat(pos2));
      }
      function throwObjectKeyOrEndExpected() {
        throw new SyntaxError("Quoted object key or end of object '}' expected ".concat(gotAt()));
      }
      function throwArrayItemOrEndExpected() {
        throw new SyntaxError("Array item or end of array ']' expected ".concat(gotAt()));
      }
      function throwInvalidCharacter(char) {
        throw new SyntaxError("Invalid character '".concat(char, "' ").concat(pos()));
      }
      function throwInvalidEscapeCharacter(start) {
        var chars = text2.slice(start, start + 2);
        throw new SyntaxError("Invalid escape character '".concat(chars, "' ").concat(pos()));
      }
      function throwObjectValueExpected() {
        throw new SyntaxError("Object value expected after ':' ".concat(pos()));
      }
      function throwInvalidUnicodeCharacter(start) {
        var end = start + 2;
        while (/\w/.test(text2[end])) {
          end++;
        }
        var chars = text2.slice(start, end);
        throw new SyntaxError("Invalid unicode character '".concat(chars, "' ").concat(pos()));
      }
      function pos() {
        return "at position ".concat(i);
      }
      function got() {
        return i < text2.length ? "but got '".concat(text2[i], "'") : "but reached end of input";
      }
      function gotAt() {
        return got() + " " + pos();
      }
    }
    function isWhitespace(code2) {
      return code2 === codeSpace || code2 === codeNewline || code2 === codeTab || code2 === codeReturn;
    }
    function isHex(code2) {
      return code2 >= codeZero && code2 <= codeNine || code2 >= codeUppercaseA && code2 <= codeUppercaseF || code2 >= codeLowercaseA && code2 <= codeLowercaseF;
    }
    function isDigit(code2) {
      return code2 >= codeZero && code2 <= codeNine;
    }
    function isNonZeroDigit(code2) {
      return code2 >= codeOne && code2 <= codeNine;
    }
    function isValidStringCharacter(code2) {
      return code2 >= 32 && code2 <= 1114111;
    }
    function isDeepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (Array.isArray(a) && Array.isArray(b)) {
        return a.length === b.length && a.every(function(item, index2) {
          return isDeepEqual(item, b[index2]);
        });
      }
      if (isObject(a) && isObject(b)) {
        var keys2 = _toConsumableArray(new Set([].concat(_toConsumableArray(Object.keys(a)), _toConsumableArray(Object.keys(b)))));
        return keys2.every(function(key) {
          return isDeepEqual(a[key], b[key]);
        });
      }
      return false;
    }
    function isObject(value) {
      return _typeof$1(value) === "object" && value !== null;
    }
    var escapeCharacters = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
      // note that \u is handled separately in parseString()
    };
    var codeBackslash = 92;
    var codeOpeningBrace = 123;
    var codeClosingBrace = 125;
    var codeOpeningBracket = 91;
    var codeClosingBracket = 93;
    var codeSpace = 32;
    var codeNewline = 10;
    var codeTab = 9;
    var codeReturn = 13;
    var codeDoubleQuote = 34;
    var codePlus = 43;
    var codeMinus = 45;
    var codeZero = 48;
    var codeOne = 49;
    var codeNine = 57;
    var codeComma = 44;
    var codeDot = 46;
    var codeColon = 58;
    var codeUppercaseA = 65;
    var codeLowercaseA = 97;
    var codeUppercaseE = 69;
    var codeLowercaseE = 101;
    var codeUppercaseF = 70;
    var codeLowercaseF = 102;
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function stringify(value, replacer, space2, numberStringifiers) {
      var resolvedSpace = resolveSpace(space2);
      var replacedValue = typeof replacer === "function" ? replacer.call({
        "": value
      }, "", value) : value;
      return stringifyValue(replacedValue, "");
      function stringifyValue(value2, indent2) {
        if (Array.isArray(numberStringifiers)) {
          var stringifier = numberStringifiers.find(function(item) {
            return item.test(value2);
          });
          if (stringifier) {
            var str = stringifier.stringify(value2);
            if (typeof str !== "string" || !isNumber(str)) {
              throw new Error("Invalid JSON number: output of a number stringifier must be a string containing a JSON number " + "(output: ".concat(str, ")"));
            }
            return str;
          }
        }
        if (typeof value2 === "boolean" || typeof value2 === "number" || typeof value2 === "string" || value2 === null || value2 instanceof Date || value2 instanceof Boolean || value2 instanceof Number || value2 instanceof String) {
          return JSON.stringify(value2);
        }
        if (value2 && value2.isLosslessNumber) {
          return value2.toString();
        }
        if (typeof value2 === "bigint") {
          return value2.toString();
        }
        if (Array.isArray(value2)) {
          return stringifyArray(value2, indent2);
        }
        if (value2 && _typeof(value2) === "object") {
          return stringifyObject(value2, indent2);
        }
        return void 0;
      }
      function stringifyArray(array, indent2) {
        if (array.length === 0) {
          return "[]";
        }
        var childIndent = resolvedSpace ? indent2 + resolvedSpace : void 0;
        var str = resolvedSpace ? "[\n" : "[";
        for (var i = 0; i < array.length; i++) {
          var item = typeof replacer === "function" ? replacer.call(array, String(i), array[i]) : array[i];
          if (resolvedSpace) {
            str += childIndent;
          }
          if (typeof item !== "undefined" && typeof item !== "function") {
            str += stringifyValue(item, childIndent);
          } else {
            str += "null";
          }
          if (i < array.length - 1) {
            str += resolvedSpace ? ",\n" : ",";
          }
        }
        str += resolvedSpace ? "\n" + indent2 + "]" : "]";
        return str;
      }
      function stringifyObject(object, indent2) {
        if (typeof object.toJSON === "function") {
          return stringify(object.toJSON(), replacer, space2, void 0);
        }
        var keys2 = Array.isArray(replacer) ? replacer.map(String) : Object.keys(object);
        if (keys2.length === 0) {
          return "{}";
        }
        var childIndent = resolvedSpace ? indent2 + resolvedSpace : void 0;
        var first = true;
        var str = resolvedSpace ? "{\n" : "{";
        keys2.forEach(function(key) {
          var value2 = typeof replacer === "function" ? replacer.call(object, key, object[key]) : object[key];
          if (includeProperty(key, value2)) {
            if (first) {
              first = false;
            } else {
              str += resolvedSpace ? ",\n" : ",";
            }
            var keyStr = JSON.stringify(key);
            str += resolvedSpace ? childIndent + keyStr + ": " : keyStr + ":";
            str += stringifyValue(value2, childIndent);
          }
        });
        str += resolvedSpace ? "\n" + indent2 + "}" : "}";
        return str;
      }
      function includeProperty(key, value2) {
        return typeof value2 !== "undefined" && typeof value2 !== "function" && _typeof(value2) !== "symbol";
      }
    }
    function resolveSpace(space2) {
      if (typeof space2 === "number") {
        return " ".repeat(space2);
      }
      if (typeof space2 === "string" && space2 !== "") {
        return space2;
      }
      return void 0;
    }
    var BigIntegerExports = {};
    var BigInteger = {
      get exports() {
        return BigIntegerExports;
      },
      set exports(v2) {
        BigIntegerExports = v2;
      }
    };
    (function(module2) {
      var bigInt2 = function(undefined$1) {
        var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
        var supportsNativeBigInt = typeof BigInt === "function";
        function Integer(v2, radix, alphabet, caseSensitive) {
          if (typeof v2 === "undefined")
            return Integer[0];
          if (typeof radix !== "undefined")
            return +radix === 10 && !alphabet ? parseValue(v2) : parseBase(v2, radix, alphabet, caseSensitive);
          return parseValue(v2);
        }
        function BigInteger2(value, sign) {
          this.value = value;
          this.sign = sign;
          this.isSmall = false;
        }
        BigInteger2.prototype = Object.create(Integer.prototype);
        function SmallInteger(value) {
          this.value = value;
          this.sign = value < 0;
          this.isSmall = true;
        }
        SmallInteger.prototype = Object.create(Integer.prototype);
        function NativeBigInt(value) {
          this.value = value;
        }
        NativeBigInt.prototype = Object.create(Integer.prototype);
        function isPrecise(n2) {
          return -MAX_INT < n2 && n2 < MAX_INT;
        }
        function smallToArray(n2) {
          if (n2 < 1e7)
            return [n2];
          if (n2 < 1e14)
            return [n2 % 1e7, Math.floor(n2 / 1e7)];
          return [n2 % 1e7, Math.floor(n2 / 1e7) % 1e7, Math.floor(n2 / 1e14)];
        }
        function arrayToSmall(arr) {
          trim2(arr);
          var length = arr.length;
          if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
              case 0:
                return 0;
              case 1:
                return arr[0];
              case 2:
                return arr[0] + arr[1] * BASE;
              default:
                return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
          }
          return arr;
        }
        function trim2(v2) {
          var i2 = v2.length;
          while (v2[--i2] === 0)
            ;
          v2.length = i2 + 1;
        }
        function createArray(length) {
          var x2 = new Array(length);
          var i2 = -1;
          while (++i2 < length) {
            x2[i2] = 0;
          }
          return x2;
        }
        function truncate(n2) {
          if (n2 > 0)
            return Math.floor(n2);
          return Math.ceil(n2);
        }
        function add(a, b) {
          var l_a = a.length, l_b = b.length, r2 = new Array(l_a), carry = 0, base = BASE, sum, i2;
          for (i2 = 0; i2 < l_b; i2++) {
            sum = a[i2] + b[i2] + carry;
            carry = sum >= base ? 1 : 0;
            r2[i2] = sum - carry * base;
          }
          while (i2 < l_a) {
            sum = a[i2] + carry;
            carry = sum === base ? 1 : 0;
            r2[i2++] = sum - carry * base;
          }
          if (carry > 0)
            r2.push(carry);
          return r2;
        }
        function addAny(a, b) {
          if (a.length >= b.length)
            return add(a, b);
          return add(b, a);
        }
        function addSmall(a, carry) {
          var l2 = a.length, r2 = new Array(l2), base = BASE, sum, i2;
          for (i2 = 0; i2 < l2; i2++) {
            sum = a[i2] - base + carry;
            carry = Math.floor(sum / base);
            r2[i2] = sum - carry * base;
            carry += 1;
          }
          while (carry > 0) {
            r2[i2++] = carry % base;
            carry = Math.floor(carry / base);
          }
          return r2;
        }
        BigInteger2.prototype.add = function(v2) {
          var n2 = parseValue(v2);
          if (this.sign !== n2.sign) {
            return this.subtract(n2.negate());
          }
          var a = this.value, b = n2.value;
          if (n2.isSmall) {
            return new BigInteger2(addSmall(a, Math.abs(b)), this.sign);
          }
          return new BigInteger2(addAny(a, b), this.sign);
        };
        BigInteger2.prototype.plus = BigInteger2.prototype.add;
        SmallInteger.prototype.add = function(v2) {
          var n2 = parseValue(v2);
          var a = this.value;
          if (a < 0 !== n2.sign) {
            return this.subtract(n2.negate());
          }
          var b = n2.value;
          if (n2.isSmall) {
            if (isPrecise(a + b))
              return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
          }
          return new BigInteger2(addSmall(b, Math.abs(a)), a < 0);
        };
        SmallInteger.prototype.plus = SmallInteger.prototype.add;
        NativeBigInt.prototype.add = function(v2) {
          return new NativeBigInt(this.value + parseValue(v2).value);
        };
        NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
        function subtract(a, b) {
          var a_l = a.length, b_l = b.length, r2 = new Array(a_l), borrow = 0, base = BASE, i2, difference;
          for (i2 = 0; i2 < b_l; i2++) {
            difference = a[i2] - borrow - b[i2];
            if (difference < 0) {
              difference += base;
              borrow = 1;
            } else
              borrow = 0;
            r2[i2] = difference;
          }
          for (i2 = b_l; i2 < a_l; i2++) {
            difference = a[i2] - borrow;
            if (difference < 0)
              difference += base;
            else {
              r2[i2++] = difference;
              break;
            }
            r2[i2] = difference;
          }
          for (; i2 < a_l; i2++) {
            r2[i2] = a[i2];
          }
          trim2(r2);
          return r2;
        }
        function subtractAny(a, b, sign) {
          var value;
          if (compareAbs(a, b) >= 0) {
            value = subtract(a, b);
          } else {
            value = subtract(b, a);
            sign = !sign;
          }
          value = arrayToSmall(value);
          if (typeof value === "number") {
            if (sign)
              value = -value;
            return new SmallInteger(value);
          }
          return new BigInteger2(value, sign);
        }
        function subtractSmall(a, b, sign) {
          var l2 = a.length, r2 = new Array(l2), carry = -b, base = BASE, i2, difference;
          for (i2 = 0; i2 < l2; i2++) {
            difference = a[i2] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r2[i2] = difference < 0 ? difference + base : difference;
          }
          r2 = arrayToSmall(r2);
          if (typeof r2 === "number") {
            if (sign)
              r2 = -r2;
            return new SmallInteger(r2);
          }
          return new BigInteger2(r2, sign);
        }
        BigInteger2.prototype.subtract = function(v2) {
          var n2 = parseValue(v2);
          if (this.sign !== n2.sign) {
            return this.add(n2.negate());
          }
          var a = this.value, b = n2.value;
          if (n2.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
          return subtractAny(a, b, this.sign);
        };
        BigInteger2.prototype.minus = BigInteger2.prototype.subtract;
        SmallInteger.prototype.subtract = function(v2) {
          var n2 = parseValue(v2);
          var a = this.value;
          if (a < 0 !== n2.sign) {
            return this.add(n2.negate());
          }
          var b = n2.value;
          if (n2.isSmall) {
            return new SmallInteger(a - b);
          }
          return subtractSmall(b, Math.abs(a), a >= 0);
        };
        SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
        NativeBigInt.prototype.subtract = function(v2) {
          return new NativeBigInt(this.value - parseValue(v2).value);
        };
        NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
        BigInteger2.prototype.negate = function() {
          return new BigInteger2(this.value, !this.sign);
        };
        SmallInteger.prototype.negate = function() {
          var sign = this.sign;
          var small = new SmallInteger(-this.value);
          small.sign = !sign;
          return small;
        };
        NativeBigInt.prototype.negate = function() {
          return new NativeBigInt(-this.value);
        };
        BigInteger2.prototype.abs = function() {
          return new BigInteger2(this.value, false);
        };
        SmallInteger.prototype.abs = function() {
          return new SmallInteger(Math.abs(this.value));
        };
        NativeBigInt.prototype.abs = function() {
          return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
        };
        function multiplyLong(a, b) {
          var a_l = a.length, b_l = b.length, l2 = a_l + b_l, r2 = createArray(l2), base = BASE, product, carry, i2, a_i, b_j;
          for (i2 = 0; i2 < a_l; ++i2) {
            a_i = a[i2];
            for (var j = 0; j < b_l; ++j) {
              b_j = b[j];
              product = a_i * b_j + r2[i2 + j];
              carry = Math.floor(product / base);
              r2[i2 + j] = product - carry * base;
              r2[i2 + j + 1] += carry;
            }
          }
          trim2(r2);
          return r2;
        }
        function multiplySmall(a, b) {
          var l2 = a.length, r2 = new Array(l2), base = BASE, carry = 0, product, i2;
          for (i2 = 0; i2 < l2; i2++) {
            product = a[i2] * b + carry;
            carry = Math.floor(product / base);
            r2[i2] = product - carry * base;
          }
          while (carry > 0) {
            r2[i2++] = carry % base;
            carry = Math.floor(carry / base);
          }
          return r2;
        }
        function shiftLeft(x2, n2) {
          var r2 = [];
          while (n2-- > 0)
            r2.push(0);
          return r2.concat(x2);
        }
        function multiplyKaratsuba(x2, y2) {
          var n2 = Math.max(x2.length, y2.length);
          if (n2 <= 30)
            return multiplyLong(x2, y2);
          n2 = Math.ceil(n2 / 2);
          var b = x2.slice(n2), a = x2.slice(0, n2), d = y2.slice(n2), c = y2.slice(0, n2);
          var ac2 = multiplyKaratsuba(a, c), bd2 = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
          var product = addAny(addAny(ac2, shiftLeft(subtract(subtract(abcd, ac2), bd2), n2)), shiftLeft(bd2, 2 * n2));
          trim2(product);
          return product;
        }
        function useKaratsuba(l1, l2) {
          return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;
        }
        BigInteger2.prototype.multiply = function(v2) {
          var n2 = parseValue(v2), a = this.value, b = n2.value, sign = this.sign !== n2.sign, abs;
          if (n2.isSmall) {
            if (b === 0)
              return Integer[0];
            if (b === 1)
              return this;
            if (b === -1)
              return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
              return new BigInteger2(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
          }
          if (useKaratsuba(a.length, b.length))
            return new BigInteger2(multiplyKaratsuba(a, b), sign);
          return new BigInteger2(multiplyLong(a, b), sign);
        };
        BigInteger2.prototype.times = BigInteger2.prototype.multiply;
        function multiplySmallAndArray(a, b, sign) {
          if (a < BASE) {
            return new BigInteger2(multiplySmall(b, a), sign);
          }
          return new BigInteger2(multiplyLong(b, smallToArray(a)), sign);
        }
        SmallInteger.prototype._multiplyBySmall = function(a) {
          if (isPrecise(a.value * this.value)) {
            return new SmallInteger(a.value * this.value);
          }
          return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
        };
        BigInteger2.prototype._multiplyBySmall = function(a) {
          if (a.value === 0)
            return Integer[0];
          if (a.value === 1)
            return this;
          if (a.value === -1)
            return this.negate();
          return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
        };
        SmallInteger.prototype.multiply = function(v2) {
          return parseValue(v2)._multiplyBySmall(this);
        };
        SmallInteger.prototype.times = SmallInteger.prototype.multiply;
        NativeBigInt.prototype.multiply = function(v2) {
          return new NativeBigInt(this.value * parseValue(v2).value);
        };
        NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
        function square(a) {
          var l2 = a.length, r2 = createArray(l2 + l2), base = BASE, product, carry, i2, a_i, a_j;
          for (i2 = 0; i2 < l2; i2++) {
            a_i = a[i2];
            carry = 0 - a_i * a_i;
            for (var j = i2; j < l2; j++) {
              a_j = a[j];
              product = 2 * (a_i * a_j) + r2[i2 + j] + carry;
              carry = Math.floor(product / base);
              r2[i2 + j] = product - carry * base;
            }
            r2[i2 + l2] = carry;
          }
          trim2(r2);
          return r2;
        }
        BigInteger2.prototype.square = function() {
          return new BigInteger2(square(this.value), false);
        };
        SmallInteger.prototype.square = function() {
          var value = this.value * this.value;
          if (isPrecise(value))
            return new SmallInteger(value);
          return new BigInteger2(square(smallToArray(Math.abs(this.value))), false);
        };
        NativeBigInt.prototype.square = function(v2) {
          return new NativeBigInt(this.value * this.value);
        };
        function divMod1(a, b) {
          var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l2, q2;
          if (remainder.length <= a_l)
            remainder.push(0);
          divisor.push(0);
          divisorMostSignificantDigit = divisor[b_l - 1];
          for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            carry = 0;
            borrow = 0;
            l2 = divisor.length;
            for (i2 = 0; i2 < l2; i2++) {
              carry += quotientDigit * divisor[i2];
              q2 = Math.floor(carry / base);
              borrow += remainder[shift + i2] - (carry - q2 * base);
              carry = q2;
              if (borrow < 0) {
                remainder[shift + i2] = borrow + base;
                borrow = -1;
              } else {
                remainder[shift + i2] = borrow;
                borrow = 0;
              }
            }
            while (borrow !== 0) {
              quotientDigit -= 1;
              carry = 0;
              for (i2 = 0; i2 < l2; i2++) {
                carry += remainder[shift + i2] - base + divisor[i2];
                if (carry < 0) {
                  remainder[shift + i2] = carry + base;
                  carry = 0;
                } else {
                  remainder[shift + i2] = carry;
                  carry = 1;
                }
              }
              borrow += carry;
            }
            result[shift] = quotientDigit;
          }
          remainder = divModSmall(remainder, lambda)[0];
          return [arrayToSmall(result), arrayToSmall(remainder)];
        }
        function divMod2(a, b) {
          var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;
          while (a_l) {
            part.unshift(a[--a_l]);
            trim2(part);
            if (compareAbs(part, b) < 0) {
              result.push(0);
              continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
              highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
              check = multiplySmall(b, guess);
              if (compareAbs(check, part) <= 0)
                break;
              guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
          }
          result.reverse();
          return [arrayToSmall(result), arrayToSmall(part)];
        }
        function divModSmall(value, lambda) {
          var length = value.length, quotient = createArray(length), base = BASE, i2, q2, remainder, divisor;
          remainder = 0;
          for (i2 = length - 1; i2 >= 0; --i2) {
            divisor = remainder * base + value[i2];
            q2 = truncate(divisor / lambda);
            remainder = divisor - q2 * lambda;
            quotient[i2] = q2 | 0;
          }
          return [quotient, remainder | 0];
        }
        function divModAny(self2, v2) {
          var value, n2 = parseValue(v2);
          if (supportsNativeBigInt) {
            return [new NativeBigInt(self2.value / n2.value), new NativeBigInt(self2.value % n2.value)];
          }
          var a = self2.value, b = n2.value;
          var quotient;
          if (b === 0)
            throw new Error("Cannot divide by zero");
          if (self2.isSmall) {
            if (n2.isSmall) {
              return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self2];
          }
          if (n2.isSmall) {
            if (b === 1)
              return [self2, Integer[0]];
            if (b == -1)
              return [self2.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
              value = divModSmall(a, abs);
              quotient = arrayToSmall(value[0]);
              var remainder = value[1];
              if (self2.sign)
                remainder = -remainder;
              if (typeof quotient === "number") {
                if (self2.sign !== n2.sign)
                  quotient = -quotient;
                return [new SmallInteger(quotient), new SmallInteger(remainder)];
              }
              return [new BigInteger2(quotient, self2.sign !== n2.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
          }
          var comparison = compareAbs(a, b);
          if (comparison === -1)
            return [Integer[0], self2];
          if (comparison === 0)
            return [Integer[self2.sign === n2.sign ? 1 : -1], Integer[0]];
          if (a.length + b.length <= 200)
            value = divMod1(a, b);
          else
            value = divMod2(a, b);
          quotient = value[0];
          var qSign = self2.sign !== n2.sign, mod = value[1], mSign = self2.sign;
          if (typeof quotient === "number") {
            if (qSign)
              quotient = -quotient;
            quotient = new SmallInteger(quotient);
          } else
            quotient = new BigInteger2(quotient, qSign);
          if (typeof mod === "number") {
            if (mSign)
              mod = -mod;
            mod = new SmallInteger(mod);
          } else
            mod = new BigInteger2(mod, mSign);
          return [quotient, mod];
        }
        BigInteger2.prototype.divmod = function(v2) {
          var result = divModAny(this, v2);
          return {
            quotient: result[0],
            remainder: result[1]
          };
        };
        NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger2.prototype.divmod;
        BigInteger2.prototype.divide = function(v2) {
          return divModAny(this, v2)[0];
        };
        NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v2) {
          return new NativeBigInt(this.value / parseValue(v2).value);
        };
        SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger2.prototype.over = BigInteger2.prototype.divide;
        BigInteger2.prototype.mod = function(v2) {
          return divModAny(this, v2)[1];
        };
        NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v2) {
          return new NativeBigInt(this.value % parseValue(v2).value);
        };
        SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger2.prototype.remainder = BigInteger2.prototype.mod;
        BigInteger2.prototype.pow = function(v2) {
          var n2 = parseValue(v2), a = this.value, b = n2.value, value, x2, y2;
          if (b === 0)
            return Integer[1];
          if (a === 0)
            return Integer[0];
          if (a === 1)
            return Integer[1];
          if (a === -1)
            return n2.isEven() ? Integer[1] : Integer[-1];
          if (n2.sign) {
            return Integer[0];
          }
          if (!n2.isSmall)
            throw new Error("The exponent " + n2.toString() + " is too large.");
          if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
              return new SmallInteger(truncate(value));
          }
          x2 = this;
          y2 = Integer[1];
          while (true) {
            if (b & true) {
              y2 = y2.times(x2);
              --b;
            }
            if (b === 0)
              break;
            b /= 2;
            x2 = x2.square();
          }
          return y2;
        };
        SmallInteger.prototype.pow = BigInteger2.prototype.pow;
        NativeBigInt.prototype.pow = function(v2) {
          var n2 = parseValue(v2);
          var a = this.value, b = n2.value;
          var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
          if (b === _0)
            return Integer[1];
          if (a === _0)
            return Integer[0];
          if (a === _1)
            return Integer[1];
          if (a === BigInt(-1))
            return n2.isEven() ? Integer[1] : Integer[-1];
          if (n2.isNegative())
            return new NativeBigInt(_0);
          var x2 = this;
          var y2 = Integer[1];
          while (true) {
            if ((b & _1) === _1) {
              y2 = y2.times(x2);
              --b;
            }
            if (b === _0)
              break;
            b /= _2;
            x2 = x2.square();
          }
          return y2;
        };
        BigInteger2.prototype.modPow = function(exp, mod) {
          exp = parseValue(exp);
          mod = parseValue(mod);
          if (mod.isZero())
            throw new Error("Cannot take modPow with modulus 0");
          var r2 = Integer[1], base = this.mod(mod);
          if (exp.isNegative()) {
            exp = exp.multiply(Integer[-1]);
            base = base.modInv(mod);
          }
          while (exp.isPositive()) {
            if (base.isZero())
              return Integer[0];
            if (exp.isOdd())
              r2 = r2.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
          }
          return r2;
        };
        NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger2.prototype.modPow;
        function compareAbs(a, b) {
          if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
          }
          for (var i2 = a.length - 1; i2 >= 0; i2--) {
            if (a[i2] !== b[i2])
              return a[i2] > b[i2] ? 1 : -1;
          }
          return 0;
        }
        BigInteger2.prototype.compareAbs = function(v2) {
          var n2 = parseValue(v2), a = this.value, b = n2.value;
          if (n2.isSmall)
            return 1;
          return compareAbs(a, b);
        };
        SmallInteger.prototype.compareAbs = function(v2) {
          var n2 = parseValue(v2), a = Math.abs(this.value), b = n2.value;
          if (n2.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
          }
          return -1;
        };
        NativeBigInt.prototype.compareAbs = function(v2) {
          var a = this.value;
          var b = parseValue(v2).value;
          a = a >= 0 ? a : -a;
          b = b >= 0 ? b : -b;
          return a === b ? 0 : a > b ? 1 : -1;
        };
        BigInteger2.prototype.compare = function(v2) {
          if (v2 === Infinity) {
            return -1;
          }
          if (v2 === -Infinity) {
            return 1;
          }
          var n2 = parseValue(v2), a = this.value, b = n2.value;
          if (this.sign !== n2.sign) {
            return n2.sign ? 1 : -1;
          }
          if (n2.isSmall) {
            return this.sign ? -1 : 1;
          }
          return compareAbs(a, b) * (this.sign ? -1 : 1);
        };
        BigInteger2.prototype.compareTo = BigInteger2.prototype.compare;
        SmallInteger.prototype.compare = function(v2) {
          if (v2 === Infinity) {
            return -1;
          }
          if (v2 === -Infinity) {
            return 1;
          }
          var n2 = parseValue(v2), a = this.value, b = n2.value;
          if (n2.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
          }
          if (a < 0 !== n2.sign) {
            return a < 0 ? -1 : 1;
          }
          return a < 0 ? 1 : -1;
        };
        SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
        NativeBigInt.prototype.compare = function(v2) {
          if (v2 === Infinity) {
            return -1;
          }
          if (v2 === -Infinity) {
            return 1;
          }
          var a = this.value;
          var b = parseValue(v2).value;
          return a === b ? 0 : a > b ? 1 : -1;
        };
        NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
        BigInteger2.prototype.equals = function(v2) {
          return this.compare(v2) === 0;
        };
        NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger2.prototype.eq = BigInteger2.prototype.equals;
        BigInteger2.prototype.notEquals = function(v2) {
          return this.compare(v2) !== 0;
        };
        NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger2.prototype.neq = BigInteger2.prototype.notEquals;
        BigInteger2.prototype.greater = function(v2) {
          return this.compare(v2) > 0;
        };
        NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger2.prototype.gt = BigInteger2.prototype.greater;
        BigInteger2.prototype.lesser = function(v2) {
          return this.compare(v2) < 0;
        };
        NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger2.prototype.lt = BigInteger2.prototype.lesser;
        BigInteger2.prototype.greaterOrEquals = function(v2) {
          return this.compare(v2) >= 0;
        };
        NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger2.prototype.geq = BigInteger2.prototype.greaterOrEquals;
        BigInteger2.prototype.lesserOrEquals = function(v2) {
          return this.compare(v2) <= 0;
        };
        NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger2.prototype.leq = BigInteger2.prototype.lesserOrEquals;
        BigInteger2.prototype.isEven = function() {
          return (this.value[0] & 1) === 0;
        };
        SmallInteger.prototype.isEven = function() {
          return (this.value & 1) === 0;
        };
        NativeBigInt.prototype.isEven = function() {
          return (this.value & BigInt(1)) === BigInt(0);
        };
        BigInteger2.prototype.isOdd = function() {
          return (this.value[0] & 1) === 1;
        };
        SmallInteger.prototype.isOdd = function() {
          return (this.value & 1) === 1;
        };
        NativeBigInt.prototype.isOdd = function() {
          return (this.value & BigInt(1)) === BigInt(1);
        };
        BigInteger2.prototype.isPositive = function() {
          return !this.sign;
        };
        SmallInteger.prototype.isPositive = function() {
          return this.value > 0;
        };
        NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
        BigInteger2.prototype.isNegative = function() {
          return this.sign;
        };
        SmallInteger.prototype.isNegative = function() {
          return this.value < 0;
        };
        NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
        BigInteger2.prototype.isUnit = function() {
          return false;
        };
        SmallInteger.prototype.isUnit = function() {
          return Math.abs(this.value) === 1;
        };
        NativeBigInt.prototype.isUnit = function() {
          return this.abs().value === BigInt(1);
        };
        BigInteger2.prototype.isZero = function() {
          return false;
        };
        SmallInteger.prototype.isZero = function() {
          return this.value === 0;
        };
        NativeBigInt.prototype.isZero = function() {
          return this.value === BigInt(0);
        };
        BigInteger2.prototype.isDivisibleBy = function(v2) {
          var n2 = parseValue(v2);
          if (n2.isZero())
            return false;
          if (n2.isUnit())
            return true;
          if (n2.compareAbs(2) === 0)
            return this.isEven();
          return this.mod(n2).isZero();
        };
        NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger2.prototype.isDivisibleBy;
        function isBasicPrime(v2) {
          var n2 = v2.abs();
          if (n2.isUnit())
            return false;
          if (n2.equals(2) || n2.equals(3) || n2.equals(5))
            return true;
          if (n2.isEven() || n2.isDivisibleBy(3) || n2.isDivisibleBy(5))
            return false;
          if (n2.lesser(49))
            return true;
        }
        function millerRabinTest(n2, a) {
          var nPrev = n2.prev(), b = nPrev, r2 = 0, d, i2, x2;
          while (b.isEven())
            b = b.divide(2), r2++;
          next:
            for (i2 = 0; i2 < a.length; i2++) {
              if (n2.lesser(a[i2]))
                continue;
              x2 = bigInt2(a[i2]).modPow(b, n2);
              if (x2.isUnit() || x2.equals(nPrev))
                continue;
              for (d = r2 - 1; d != 0; d--) {
                x2 = x2.square().mod(n2);
                if (x2.isUnit())
                  return false;
                if (x2.equals(nPrev))
                  continue next;
              }
              return false;
            }
          return true;
        }
        BigInteger2.prototype.isPrime = function(strict) {
          var isPrime = isBasicPrime(this);
          if (isPrime !== undefined$1)
            return isPrime;
          var n2 = this.abs();
          var bits = n2.bitLength();
          if (bits <= 64)
            return millerRabinTest(n2, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
          var logN = Math.log(2) * bits.toJSNumber();
          var t2 = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
          for (var a = [], i2 = 0; i2 < t2; i2++) {
            a.push(bigInt2(i2 + 2));
          }
          return millerRabinTest(n2, a);
        };
        NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger2.prototype.isPrime;
        BigInteger2.prototype.isProbablePrime = function(iterations, rng) {
          var isPrime = isBasicPrime(this);
          if (isPrime !== undefined$1)
            return isPrime;
          var n2 = this.abs();
          var t2 = iterations === undefined$1 ? 5 : iterations;
          for (var a = [], i2 = 0; i2 < t2; i2++) {
            a.push(bigInt2.randBetween(2, n2.minus(2), rng));
          }
          return millerRabinTest(n2, a);
        };
        NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger2.prototype.isProbablePrime;
        BigInteger2.prototype.modInv = function(n2) {
          var t2 = bigInt2.zero, newT = bigInt2.one, r2 = parseValue(n2), newR = this.abs(), q2, lastT, lastR;
          while (!newR.isZero()) {
            q2 = r2.divide(newR);
            lastT = t2;
            lastR = r2;
            t2 = newT;
            r2 = newR;
            newT = lastT.subtract(q2.multiply(newT));
            newR = lastR.subtract(q2.multiply(newR));
          }
          if (!r2.isUnit())
            throw new Error(this.toString() + " and " + n2.toString() + " are not co-prime");
          if (t2.compare(0) === -1) {
            t2 = t2.add(n2);
          }
          if (this.isNegative()) {
            return t2.negate();
          }
          return t2;
        };
        NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger2.prototype.modInv;
        BigInteger2.prototype.next = function() {
          var value = this.value;
          if (this.sign) {
            return subtractSmall(value, 1, this.sign);
          }
          return new BigInteger2(addSmall(value, 1), this.sign);
        };
        SmallInteger.prototype.next = function() {
          var value = this.value;
          if (value + 1 < MAX_INT)
            return new SmallInteger(value + 1);
          return new BigInteger2(MAX_INT_ARR, false);
        };
        NativeBigInt.prototype.next = function() {
          return new NativeBigInt(this.value + BigInt(1));
        };
        BigInteger2.prototype.prev = function() {
          var value = this.value;
          if (this.sign) {
            return new BigInteger2(addSmall(value, 1), true);
          }
          return subtractSmall(value, 1, this.sign);
        };
        SmallInteger.prototype.prev = function() {
          var value = this.value;
          if (value - 1 > -MAX_INT)
            return new SmallInteger(value - 1);
          return new BigInteger2(MAX_INT_ARR, true);
        };
        NativeBigInt.prototype.prev = function() {
          return new NativeBigInt(this.value - BigInt(1));
        };
        var powersOfTwo = [1];
        while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)
          powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
        var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
        function shift_isSmall(n2) {
          return Math.abs(n2) <= BASE;
        }
        BigInteger2.prototype.shiftLeft = function(v2) {
          var n2 = parseValue(v2).toJSNumber();
          if (!shift_isSmall(n2)) {
            throw new Error(String(n2) + " is too large for shifting.");
          }
          if (n2 < 0)
            return this.shiftRight(-n2);
          var result = this;
          if (result.isZero())
            return result;
          while (n2 >= powers2Length) {
            result = result.multiply(highestPower2);
            n2 -= powers2Length - 1;
          }
          return result.multiply(powersOfTwo[n2]);
        };
        NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger2.prototype.shiftLeft;
        BigInteger2.prototype.shiftRight = function(v2) {
          var remQuo;
          var n2 = parseValue(v2).toJSNumber();
          if (!shift_isSmall(n2)) {
            throw new Error(String(n2) + " is too large for shifting.");
          }
          if (n2 < 0)
            return this.shiftLeft(-n2);
          var result = this;
          while (n2 >= powers2Length) {
            if (result.isZero() || result.isNegative() && result.isUnit())
              return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n2 -= powers2Length - 1;
          }
          remQuo = divModAny(result, powersOfTwo[n2]);
          return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        };
        NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger2.prototype.shiftRight;
        function bitwise(x2, y2, fn) {
          y2 = parseValue(y2);
          var xSign = x2.isNegative(), ySign = y2.isNegative();
          var xRem = xSign ? x2.not() : x2, yRem = ySign ? y2.not() : y2;
          var xDigit = 0, yDigit = 0;
          var xDivMod = null, yDivMod = null;
          var result = [];
          while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
              xDigit = highestPower2 - 1 - xDigit;
            }
            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
              yDigit = highestPower2 - 1 - yDigit;
            }
            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
          }
          var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt2(-1) : bigInt2(0);
          for (var i2 = result.length - 1; i2 >= 0; i2 -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt2(result[i2]));
          }
          return sum;
        }
        BigInteger2.prototype.not = function() {
          return this.negate().prev();
        };
        NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger2.prototype.not;
        BigInteger2.prototype.and = function(n2) {
          return bitwise(this, n2, function(a, b) {
            return a & b;
          });
        };
        NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger2.prototype.and;
        BigInteger2.prototype.or = function(n2) {
          return bitwise(this, n2, function(a, b) {
            return a | b;
          });
        };
        NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger2.prototype.or;
        BigInteger2.prototype.xor = function(n2) {
          return bitwise(this, n2, function(a, b) {
            return a ^ b;
          });
        };
        NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger2.prototype.xor;
        var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
        function roughLOB(n2) {
          var v2 = n2.value, x2 = typeof v2 === "number" ? v2 | LOBMASK_I : typeof v2 === "bigint" ? v2 | BigInt(LOBMASK_I) : v2[0] + v2[1] * BASE | LOBMASK_BI;
          return x2 & -x2;
        }
        function integerLogarithm(value, base) {
          if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p2 = tmp.p;
            var e = tmp.e;
            var t2 = p2.multiply(base);
            return t2.compareTo(value) <= 0 ? { p: t2, e: e * 2 + 1 } : { p: p2, e: e * 2 };
          }
          return { p: bigInt2(1), e: 0 };
        }
        BigInteger2.prototype.bitLength = function() {
          var n2 = this;
          if (n2.compareTo(bigInt2(0)) < 0) {
            n2 = n2.negate().subtract(bigInt2(1));
          }
          if (n2.compareTo(bigInt2(0)) === 0) {
            return bigInt2(0);
          }
          return bigInt2(integerLogarithm(n2, bigInt2(2)).e).add(bigInt2(1));
        };
        NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger2.prototype.bitLength;
        function max(a, b) {
          a = parseValue(a);
          b = parseValue(b);
          return a.greater(b) ? a : b;
        }
        function min(a, b) {
          a = parseValue(a);
          b = parseValue(b);
          return a.lesser(b) ? a : b;
        }
        function gcd(a, b) {
          a = parseValue(a).abs();
          b = parseValue(b).abs();
          if (a.equals(b))
            return a;
          if (a.isZero())
            return b;
          if (b.isZero())
            return a;
          var c = Integer[1], d, t2;
          while (a.isEven() && b.isEven()) {
            d = min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
          }
          while (a.isEven()) {
            a = a.divide(roughLOB(a));
          }
          do {
            while (b.isEven()) {
              b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
              t2 = b;
              b = a;
              a = t2;
            }
            b = b.subtract(a);
          } while (!b.isZero());
          return c.isUnit() ? a : a.multiply(c);
        }
        function lcm(a, b) {
          a = parseValue(a).abs();
          b = parseValue(b).abs();
          return a.divide(gcd(a, b)).multiply(b);
        }
        function randBetween(a, b, rng) {
          a = parseValue(a);
          b = parseValue(b);
          var usedRNG = rng || Math.random;
          var low = min(a, b), high = max(a, b);
          var range = high.subtract(low).add(1);
          if (range.isSmall)
            return low.add(Math.floor(usedRNG() * range));
          var digits = toBase(range, BASE).value;
          var result = [], restricted = true;
          for (var i2 = 0; i2 < digits.length; i2++) {
            var top = restricted ? digits[i2] + (i2 + 1 < digits.length ? digits[i2 + 1] / BASE : 0) : BASE;
            var digit = truncate(usedRNG() * top);
            result.push(digit);
            if (digit < digits[i2])
              restricted = false;
          }
          return low.add(Integer.fromArray(result, BASE, false));
        }
        var parseBase = function(text2, base, alphabet, caseSensitive) {
          alphabet = alphabet || DEFAULT_ALPHABET;
          text2 = String(text2);
          if (!caseSensitive) {
            text2 = text2.toLowerCase();
            alphabet = alphabet.toLowerCase();
          }
          var length = text2.length;
          var i2;
          var absBase = Math.abs(base);
          var alphabetValues = {};
          for (i2 = 0; i2 < alphabet.length; i2++) {
            alphabetValues[alphabet[i2]] = i2;
          }
          for (i2 = 0; i2 < length; i2++) {
            var c = text2[i2];
            if (c === "-")
              continue;
            if (c in alphabetValues) {
              if (alphabetValues[c] >= absBase) {
                if (c === "1" && absBase === 1)
                  continue;
                throw new Error(c + " is not a valid digit in base " + base + ".");
              }
            }
          }
          base = parseValue(base);
          var digits = [];
          var isNegative = text2[0] === "-";
          for (i2 = isNegative ? 1 : 0; i2 < text2.length; i2++) {
            var c = text2[i2];
            if (c in alphabetValues)
              digits.push(parseValue(alphabetValues[c]));
            else if (c === "<") {
              var start = i2;
              do {
                i2++;
              } while (text2[i2] !== ">" && i2 < text2.length);
              digits.push(parseValue(text2.slice(start + 1, i2)));
            } else
              throw new Error(c + " is not a valid character");
          }
          return parseBaseFromArray(digits, base, isNegative);
        };
        function parseBaseFromArray(digits, base, isNegative) {
          var val = Integer[0], pow = Integer[1], i2;
          for (i2 = digits.length - 1; i2 >= 0; i2--) {
            val = val.add(digits[i2].times(pow));
            pow = pow.times(base);
          }
          return isNegative ? val.negate() : val;
        }
        function stringify2(digit, alphabet) {
          alphabet = alphabet || DEFAULT_ALPHABET;
          if (digit < alphabet.length) {
            return alphabet[digit];
          }
          return "<" + digit + ">";
        }
        function toBase(n2, base) {
          base = bigInt2(base);
          if (base.isZero()) {
            if (n2.isZero())
              return { value: [0], isNegative: false };
            throw new Error("Cannot convert nonzero numbers to base 0.");
          }
          if (base.equals(-1)) {
            if (n2.isZero())
              return { value: [0], isNegative: false };
            if (n2.isNegative())
              return {
                value: [].concat.apply(
                  [],
                  Array.apply(null, Array(-n2.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
                ),
                isNegative: false
              };
            var arr = Array.apply(null, Array(n2.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
              value: [].concat.apply([], arr),
              isNegative: false
            };
          }
          var neg = false;
          if (n2.isNegative() && base.isPositive()) {
            neg = true;
            n2 = n2.abs();
          }
          if (base.isUnit()) {
            if (n2.isZero())
              return { value: [0], isNegative: false };
            return {
              value: Array.apply(null, Array(n2.toJSNumber())).map(Number.prototype.valueOf, 1),
              isNegative: neg
            };
          }
          var out = [];
          var left = n2, divmod;
          while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
              digit = base.minus(digit).abs();
              left = left.next();
            }
            out.push(digit.toJSNumber());
          }
          out.push(left.toJSNumber());
          return { value: out.reverse(), isNegative: neg };
        }
        function toBaseString(n2, base, alphabet) {
          var arr = toBase(n2, base);
          return (arr.isNegative ? "-" : "") + arr.value.map(function(x2) {
            return stringify2(x2, alphabet);
          }).join("");
        }
        BigInteger2.prototype.toArray = function(radix) {
          return toBase(this, radix);
        };
        SmallInteger.prototype.toArray = function(radix) {
          return toBase(this, radix);
        };
        NativeBigInt.prototype.toArray = function(radix) {
          return toBase(this, radix);
        };
        BigInteger2.prototype.toString = function(radix, alphabet) {
          if (radix === undefined$1)
            radix = 10;
          if (radix !== 10)
            return toBaseString(this, radix, alphabet);
          var v2 = this.value, l2 = v2.length, str = String(v2[--l2]), zeros = "0000000", digit;
          while (--l2 >= 0) {
            digit = String(v2[l2]);
            str += zeros.slice(digit.length) + digit;
          }
          var sign = this.sign ? "-" : "";
          return sign + str;
        };
        SmallInteger.prototype.toString = function(radix, alphabet) {
          if (radix === undefined$1)
            radix = 10;
          if (radix != 10)
            return toBaseString(this, radix, alphabet);
          return String(this.value);
        };
        NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
        NativeBigInt.prototype.toJSON = BigInteger2.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
          return this.toString();
        };
        BigInteger2.prototype.valueOf = function() {
          return parseInt(this.toString(), 10);
        };
        BigInteger2.prototype.toJSNumber = BigInteger2.prototype.valueOf;
        SmallInteger.prototype.valueOf = function() {
          return this.value;
        };
        SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
        NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
          return parseInt(this.toString(), 10);
        };
        function parseStringValue(v2) {
          if (isPrecise(+v2)) {
            var x2 = +v2;
            if (x2 === truncate(x2))
              return supportsNativeBigInt ? new NativeBigInt(BigInt(x2)) : new SmallInteger(x2);
            throw new Error("Invalid integer: " + v2);
          }
          var sign = v2[0] === "-";
          if (sign)
            v2 = v2.slice(1);
          var split = v2.split(/e/i);
          if (split.length > 2)
            throw new Error("Invalid integer: " + split.join("e"));
          if (split.length === 2) {
            var exp = split[1];
            if (exp[0] === "+")
              exp = exp.slice(1);
            exp = +exp;
            if (exp !== truncate(exp) || !isPrecise(exp))
              throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
            var text2 = split[0];
            var decimalPlace = text2.indexOf(".");
            if (decimalPlace >= 0) {
              exp -= text2.length - decimalPlace - 1;
              text2 = text2.slice(0, decimalPlace) + text2.slice(decimalPlace + 1);
            }
            if (exp < 0)
              throw new Error("Cannot include negative exponent part for integers");
            text2 += new Array(exp + 1).join("0");
            v2 = text2;
          }
          var isValid = /^([0-9][0-9]*)$/.test(v2);
          if (!isValid)
            throw new Error("Invalid integer: " + v2);
          if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign ? "-" + v2 : v2));
          }
          var r2 = [], max2 = v2.length, l2 = LOG_BASE, min2 = max2 - l2;
          while (max2 > 0) {
            r2.push(+v2.slice(min2, max2));
            min2 -= l2;
            if (min2 < 0)
              min2 = 0;
            max2 -= l2;
          }
          trim2(r2);
          return new BigInteger2(r2, sign);
        }
        function parseNumberValue(v2) {
          if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v2));
          }
          if (isPrecise(v2)) {
            if (v2 !== truncate(v2))
              throw new Error(v2 + " is not an integer.");
            return new SmallInteger(v2);
          }
          return parseStringValue(v2.toString());
        }
        function parseValue(v2) {
          if (typeof v2 === "number") {
            return parseNumberValue(v2);
          }
          if (typeof v2 === "string") {
            return parseStringValue(v2);
          }
          if (typeof v2 === "bigint") {
            return new NativeBigInt(v2);
          }
          return v2;
        }
        for (var i = 0; i < 1e3; i++) {
          Integer[i] = parseValue(i);
          if (i > 0)
            Integer[-i] = parseValue(-i);
        }
        Integer.one = Integer[1];
        Integer.zero = Integer[0];
        Integer.minusOne = Integer[-1];
        Integer.max = max;
        Integer.min = min;
        Integer.gcd = gcd;
        Integer.lcm = lcm;
        Integer.isInstance = function(x2) {
          return x2 instanceof BigInteger2 || x2 instanceof SmallInteger || x2 instanceof NativeBigInt;
        };
        Integer.randBetween = randBetween;
        Integer.fromArray = function(digits, base, isNegative) {
          return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
        };
        return Integer;
      }();
      if (module2.hasOwnProperty("exports")) {
        module2.exports = bigInt2;
      }
    })(BigInteger);
    const bigInt = BigIntegerExports;
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    Array.prototype.unique_by = function(prop) {
      return clone(this).filter((obj, pos, arr) => {
        return arr.map((mapObj) => mapObj[prop]).indexOf(obj[prop]) === pos;
      });
    };
    function is_equal(value_1, value_2) {
      return isEqual(value_1, value_2);
    }
    function dict_to_list(dict) {
      return Object.entries(dict);
    }
    const number_regex = /^[0-9]+$/;
    function parse_json(text2) {
      return parse(text2, (_key, value) => {
        if (value instanceof LosslessNumber) {
          const num_str = value.toString();
          if (number_regex.test(num_str)) {
            const num = bigInt(value.toString());
            if (num.gt(Number.MIN_SAFE_INTEGER) && num.lt(Number.MAX_SAFE_INTEGER)) {
              return Number(num_str);
            }
            return num;
          } else {
            return Number(num_str);
          }
        }
        return value;
      });
    }
    function stringify_json(obj, space2) {
      assert_is_defined(obj);
      return ensure_non_null(
        stringify(obj, void 0, space2, [
          {
            test: (value) => bigInt.isInstance(value),
            stringify: (value) => {
              assert(bigInt.isInstance(value));
              return value.toString();
            }
          }
        ])
      );
    }
    function has_member(obj, key) {
      if (obj == null) {
        return false;
      }
      if (typeof obj !== "object") {
        return false;
      }
      return key in obj;
    }
    function is_array(value) {
      return isArray$1(value);
    }
    function sleep_for_ms(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }
    /**
     * @remix-run/router v1.9.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$2() {
      _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$2.apply(this, arguments);
    }
    var Action;
    (function(Action2) {
      Action2["Pop"] = "POP";
      Action2["Push"] = "PUSH";
      Action2["Replace"] = "REPLACE";
    })(Action || (Action = {}));
    const PopStateEventType = "popstate";
    function createBrowserHistory(options) {
      if (options === void 0) {
        options = {};
      }
      function createBrowserLocation(window2, globalHistory) {
        let {
          pathname,
          search: search2,
          hash
        } = window2.location;
        return createLocation(
          "",
          {
            pathname,
            search: search2,
            hash
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createBrowserHref(window2, to) {
        return typeof to === "string" ? to : createPath(to);
      }
      return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
    }
    function invariant(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined")
          console.warn(message);
        try {
          throw new Error(message);
        } catch (e) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location, index2) {
      return {
        usr: location.state,
        key: location.key,
        idx: index2
      };
    }
    function createLocation(current, to, state, key) {
      if (state === void 0) {
        state = null;
      }
      let location = _extends$2({
        pathname: typeof current === "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to === "string" ? parsePath(to) : to, {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key || createKey()
      });
      return location;
    }
    function createPath(_ref) {
      let {
        pathname = "/",
        search: search2 = "",
        hash = ""
      } = _ref;
      if (search2 && search2 !== "?")
        pathname += search2.charAt(0) === "?" ? search2 : "?" + search2;
      if (hash && hash !== "#")
        pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
      return pathname;
    }
    function parsePath(path2) {
      let parsedPath = {};
      if (path2) {
        let hashIndex = path2.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path2.substr(hashIndex);
          path2 = path2.substr(0, hashIndex);
        }
        let searchIndex = path2.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path2.substr(searchIndex);
          path2 = path2.substr(0, searchIndex);
        }
        if (path2) {
          parsedPath.pathname = path2;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      if (options === void 0) {
        options = {};
      }
      let {
        window: window2 = document.defaultView,
        v5Compat = false
      } = options;
      let globalHistory = window2.history;
      let action = Action.Pop;
      let listener = null;
      let index2 = getIndex();
      if (index2 == null) {
        index2 = 0;
        globalHistory.replaceState(_extends$2({}, globalHistory.state, {
          idx: index2
        }), "");
      }
      function getIndex() {
        let state = globalHistory.state || {
          idx: null
        };
        return state.idx;
      }
      function handlePop() {
        action = Action.Pop;
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index2;
        index2 = nextIndex;
        if (listener) {
          listener({
            action,
            location: history.location,
            delta
          });
        }
      }
      function push2(to, state) {
        action = Action.Push;
        let location = createLocation(history.location, to, state);
        if (validateLocation)
          validateLocation(location, to);
        index2 = getIndex() + 1;
        let historyState = getHistoryState(location, index2);
        let url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError") {
            throw error;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 1
          });
        }
      }
      function replace2(to, state) {
        action = Action.Replace;
        let location = createLocation(history.location, to, state);
        if (validateLocation)
          validateLocation(location, to);
        index2 = getIndex();
        let historyState = getHistoryState(location, index2);
        let url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 0
          });
        }
      }
      function createURL(to) {
        let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
        let href = typeof to === "string" ? to : createPath(to);
        invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
        return new URL(href, base);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to) {
          return createHref(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url = createURL(to);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push: push2,
        replace: replace2,
        go(n2) {
          return globalHistory.go(n2);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2["data"] = "data";
      ResultType2["deferred"] = "deferred";
      ResultType2["redirect"] = "redirect";
      ResultType2["error"] = "error";
    })(ResultType || (ResultType = {}));
    const immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
    function isIndexRoute(route) {
      return route.index === true;
    }
    function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {
      if (parentPath === void 0) {
        parentPath = [];
      }
      if (manifest === void 0) {
        manifest = {};
      }
      return routes.map((route, index2) => {
        let treePath = [...parentPath, index2];
        let id2 = typeof route.id === "string" ? route.id : treePath.join("-");
        invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
        invariant(!manifest[id2], 'Found a route id collision on id "' + id2 + `".  Route id's must be globally unique within Data Router usages`);
        if (isIndexRoute(route)) {
          let indexRoute = _extends$2({}, route, mapRouteProperties2(route), {
            id: id2
          });
          manifest[id2] = indexRoute;
          return indexRoute;
        } else {
          let pathOrLayoutRoute = _extends$2({}, route, mapRouteProperties2(route), {
            id: id2,
            children: void 0
          });
          manifest[id2] = pathOrLayoutRoute;
          if (route.children) {
            pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);
          }
          return pathOrLayoutRoute;
        }
      });
    }
    function matchRoutes(routes, locationArg, basename2) {
      if (basename2 === void 0) {
        basename2 = "/";
      }
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename2);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches = null;
      for (let i = 0; matches == null && i < branches.length; ++i) {
        matches = matchRouteBranch(
          branches[i],
          // Incoming pathnames are generally encoded from either window.location
          // or from router.navigate, but we want to match against the unencoded
          // paths in the route definitions.  Memory router locations won't be
          // encoded here but there also shouldn't be anything to decode so this
          // should be a safe operation.  This avoids needing matchRoutes to be
          // history-aware.
          safelyDecodeURI(pathname)
        );
      }
      return matches;
    }
    function convertRouteMatchToUiMatch(match, loaderData) {
      let {
        route,
        pathname,
        params
      } = match;
      return {
        id: route.id,
        pathname,
        params,
        data: loaderData[route.id],
        handle: route.handle
      };
    }
    function flattenRoutes(routes, branches, parentsMeta, parentPath) {
      if (branches === void 0) {
        branches = [];
      }
      if (parentsMeta === void 0) {
        parentsMeta = [];
      }
      if (parentPath === void 0) {
        parentPath = "";
      }
      let flattenRoute = (route, index2, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index2,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path2 = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path2 + '".')
          );
          flattenRoutes(route.children, branches, routesMeta, path2);
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path: path2,
          score: computeScore(path2, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index2) => {
        var _route$path;
        if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
          flattenRoute(route, index2);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index2, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path2) {
      let segments = path2.split("/");
      if (segments.length === 0)
        return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map((exploded) => path2.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
      branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
    }
    const paramRe = /^:\w+$/;
    const dynamicSegmentValue = 3;
    const indexRouteValue = 2;
    const emptySegmentValue = 1;
    const staticSegmentValue = 10;
    const splatPenalty = -2;
    const isSplat = (s) => s === "*";
    function computeScore(path2, index2) {
      let segments = path2.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index2) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a, b) {
      let siblings = a.length === b.length && a.slice(0, -1).every((n2, i) => n2 === b[i]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname) {
      let {
        routesMeta
      } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i];
        let end = i === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end
        }, remainingPathname);
        if (!match)
          return null;
        Object.assign(matchedParams, match.params);
        let route = meta.route;
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
          route
        });
        if (match.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
        }
      }
      return matches;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = {
          path: pattern,
          caseSensitive: false,
          end: true
        };
      }
      let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
      let match = pathname.match(matcher);
      if (!match)
        return null;
      let matchedPathname = match[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match.slice(1);
      let params = paramNames.reduce((memo, paramName, index2) => {
        if (paramName === "*") {
          let splatValue = captureGroups[index2] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
        return memo;
      }, {});
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path2, caseSensitive, end) {
      if (caseSensitive === void 0) {
        caseSensitive = false;
      }
      if (end === void 0) {
        end = true;
      }
      warning(path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"), 'Route path "' + path2 + '" will be treated as if it were ' + ('"' + path2.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path2.replace(/\*$/, "/*") + '".'));
      let paramNames = [];
      let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_, paramName) => {
        paramNames.push(paramName);
        return "/([^\\/]+)";
      });
      if (path2.endsWith("*")) {
        paramNames.push("*");
        regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path2 !== "" && path2 !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else
        ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, paramNames];
    }
    function safelyDecodeURI(value) {
      try {
        return decodeURI(value);
      } catch (error) {
        warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
        return value;
      }
    }
    function safelyDecodeURIComponent(value, paramName) {
      try {
        return decodeURIComponent(value);
      } catch (error) {
        warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
        return value;
      }
    }
    function stripBasename(pathname, basename2) {
      if (basename2 === "/")
        return pathname;
      if (!pathname.toLowerCase().startsWith(basename2.toLowerCase())) {
        return null;
      }
      let startIndex = basename2.endsWith("/") ? basename2.length - 1 : basename2.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    function resolvePath(to, fromPathname) {
      if (fromPathname === void 0) {
        fromPathname = "/";
      }
      let {
        pathname: toPathname,
        search: search2 = "",
        hash = ""
      } = typeof to === "string" ? parsePath(to) : to;
      let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
      return {
        pathname,
        search: normalizeSearch(search2),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1)
            segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path2) {
      return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path2) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
    }
    function getPathContributingMatches(matches) {
      return matches.filter((match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      if (isPathRelative === void 0) {
        isPathRelative = false;
      }
      let to;
      if (typeof toArg === "string") {
        to = parsePath(toArg);
      } else {
        to = _extends$2({}, toArg);
        invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
        invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
        invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
      }
      let isEmptyPath = toArg === "" || to.pathname === "";
      let toPathname = isEmptyPath ? "/" : to.pathname;
      let from;
      if (isPathRelative || toPathname == null) {
        from = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to.pathname = toSegments.join("/");
        }
        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path2 = resolvePath(to, from);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path2.pathname += "/";
      }
      return path2;
    }
    const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    const normalizeSearch = (search2) => !search2 || search2 === "?" ? "" : search2.startsWith("?") ? search2 : "?" + search2;
    const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    class ErrorResponseImpl {
      constructor(status, statusText, data2, internal) {
        if (internal === void 0) {
          internal = false;
        }
        this.status = status;
        this.statusText = statusText || "";
        this.internal = internal;
        if (data2 instanceof Error) {
          this.data = data2.toString();
          this.error = data2;
        } else {
          this.data = data2;
        }
      }
    }
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    const validMutationMethodsArr = ["post", "put", "patch", "delete"];
    const validMutationMethods = new Set(validMutationMethodsArr);
    const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
    const validRequestMethods = new Set(validRequestMethodsArr);
    const redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    const redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
    const IDLE_NAVIGATION = {
      state: "idle",
      location: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    const IDLE_FETCHER = {
      state: "idle",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    const IDLE_BLOCKER = {
      state: "unblocked",
      proceed: void 0,
      reset: void 0,
      location: void 0
    };
    const ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    const defaultMapRouteProperties = (route) => ({
      hasErrorBoundary: Boolean(route.hasErrorBoundary)
    });
    function createRouter(init) {
      const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
      const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
      const isServer = !isBrowser2;
      invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
      let mapRouteProperties2;
      if (init.mapRouteProperties) {
        mapRouteProperties2 = init.mapRouteProperties;
      } else if (init.detectErrorBoundary) {
        let detectErrorBoundary = init.detectErrorBoundary;
        mapRouteProperties2 = (route) => ({
          hasErrorBoundary: detectErrorBoundary(route)
        });
      } else {
        mapRouteProperties2 = defaultMapRouteProperties;
      }
      let manifest = {};
      let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);
      let inFlightDataRoutes;
      let basename2 = init.basename || "/";
      let future = _extends$2({
        v7_normalizeFormMethod: false,
        v7_prependBasename: false
      }, init.future);
      let unlistenHistory = null;
      let subscribers = /* @__PURE__ */ new Set();
      let savedScrollPositions = null;
      let getScrollRestorationKey = null;
      let getScrollPosition = null;
      let initialScrollRestored = init.hydrationData != null;
      let initialMatches = matchRoutes(dataRoutes, init.history.location, basename2);
      let initialErrors = null;
      if (initialMatches == null) {
        let error = getInternalRouterError(404, {
          pathname: init.history.location.pathname
        });
        let {
          matches,
          route
        } = getShortCircuitMatches(dataRoutes);
        initialMatches = matches;
        initialErrors = {
          [route.id]: error
        };
      }
      let initialized = (
        // All initialMatches need to be loaded before we're ready.  If we have lazy
        // functions around still then we'll need to run them in initialize()
        !initialMatches.some((m2) => m2.route.lazy) && // And we have to either have no loaders or have been provided hydrationData
        (!initialMatches.some((m2) => m2.route.loader) || init.hydrationData != null)
      );
      let router;
      let state = {
        historyAction: init.history.action,
        location: init.history.location,
        matches: initialMatches,
        initialized,
        navigation: IDLE_NAVIGATION,
        // Don't restore on initial updateState() if we were SSR'd
        restoreScrollPosition: init.hydrationData != null ? false : null,
        preventScrollReset: false,
        revalidation: "idle",
        loaderData: init.hydrationData && init.hydrationData.loaderData || {},
        actionData: init.hydrationData && init.hydrationData.actionData || null,
        errors: init.hydrationData && init.hydrationData.errors || initialErrors,
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      };
      let pendingAction = Action.Pop;
      let pendingPreventScrollReset = false;
      let pendingNavigationController;
      let isUninterruptedRevalidation = false;
      let isRevalidationRequired = false;
      let cancelledDeferredRoutes = [];
      let cancelledFetcherLoads = [];
      let fetchControllers = /* @__PURE__ */ new Map();
      let incrementingLoadId = 0;
      let pendingNavigationLoadId = -1;
      let fetchReloadIds = /* @__PURE__ */ new Map();
      let fetchRedirectIds = /* @__PURE__ */ new Set();
      let fetchLoadMatches = /* @__PURE__ */ new Map();
      let activeDeferreds = /* @__PURE__ */ new Map();
      let blockerFunctions = /* @__PURE__ */ new Map();
      let ignoreNextHistoryUpdate = false;
      function initialize() {
        unlistenHistory = init.history.listen((_ref) => {
          let {
            action: historyAction,
            location,
            delta
          } = _ref;
          if (ignoreNextHistoryUpdate) {
            ignoreNextHistoryUpdate = false;
            return;
          }
          warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
          let blockerKey = shouldBlockNavigation({
            currentLocation: state.location,
            nextLocation: location,
            historyAction
          });
          if (blockerKey && delta != null) {
            ignoreNextHistoryUpdate = true;
            init.history.go(delta * -1);
            updateBlocker(blockerKey, {
              state: "blocked",
              location,
              proceed() {
                updateBlocker(blockerKey, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location
                });
                init.history.go(delta);
              },
              reset() {
                let blockers = new Map(state.blockers);
                blockers.set(blockerKey, IDLE_BLOCKER);
                updateState({
                  blockers
                });
              }
            });
            return;
          }
          return startNavigation(historyAction, location);
        });
        if (!state.initialized) {
          startNavigation(Action.Pop, state.location);
        }
        return router;
      }
      function dispose() {
        if (unlistenHistory) {
          unlistenHistory();
        }
        subscribers.clear();
        pendingNavigationController && pendingNavigationController.abort();
        state.fetchers.forEach((_, key) => deleteFetcher(key));
        state.blockers.forEach((_, key) => deleteBlocker(key));
      }
      function subscribe(fn) {
        subscribers.add(fn);
        return () => subscribers.delete(fn);
      }
      function updateState(newState) {
        state = _extends$2({}, state, newState);
        subscribers.forEach((subscriber) => subscriber(state));
      }
      function completeNavigation(location, newState) {
        var _location$state, _location$state2;
        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
        let actionData;
        if (newState.actionData) {
          if (Object.keys(newState.actionData).length > 0) {
            actionData = newState.actionData;
          } else {
            actionData = null;
          }
        } else if (isActionReload) {
          actionData = state.actionData;
        } else {
          actionData = null;
        }
        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
        let blockers = state.blockers;
        if (blockers.size > 0) {
          blockers = new Map(blockers);
          blockers.forEach((_, k2) => blockers.set(k2, IDLE_BLOCKER));
        }
        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
        if (inFlightDataRoutes) {
          dataRoutes = inFlightDataRoutes;
          inFlightDataRoutes = void 0;
        }
        if (isUninterruptedRevalidation)
          ;
        else if (pendingAction === Action.Pop)
          ;
        else if (pendingAction === Action.Push) {
          init.history.push(location, location.state);
        } else if (pendingAction === Action.Replace) {
          init.history.replace(location, location.state);
        }
        updateState(_extends$2({}, newState, {
          actionData,
          loaderData,
          historyAction: pendingAction,
          location,
          initialized: true,
          navigation: IDLE_NAVIGATION,
          revalidation: "idle",
          restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
          preventScrollReset,
          blockers
        }));
        pendingAction = Action.Pop;
        pendingPreventScrollReset = false;
        isUninterruptedRevalidation = false;
        isRevalidationRequired = false;
        cancelledDeferredRoutes = [];
        cancelledFetcherLoads = [];
      }
      async function navigate(to, opts) {
        if (typeof to === "number") {
          init.history.go(to);
          return;
        }
        let normalizedPath = normalizeTo(state.location, state.matches, basename2, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
        let {
          path: path2,
          submission,
          error
        } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
        let currentLocation = state.location;
        let nextLocation = createLocation(state.location, path2, opts && opts.state);
        nextLocation = _extends$2({}, nextLocation, init.history.encodeLocation(nextLocation));
        let userReplace = opts && opts.replace != null ? opts.replace : void 0;
        let historyAction = Action.Push;
        if (userReplace === true) {
          historyAction = Action.Replace;
        } else if (userReplace === false)
          ;
        else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
          historyAction = Action.Replace;
        }
        let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
        let blockerKey = shouldBlockNavigation({
          currentLocation,
          nextLocation,
          historyAction
        });
        if (blockerKey) {
          updateBlocker(blockerKey, {
            state: "blocked",
            location: nextLocation,
            proceed() {
              updateBlocker(blockerKey, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: nextLocation
              });
              navigate(to, opts);
            },
            reset() {
              let blockers = new Map(state.blockers);
              blockers.set(blockerKey, IDLE_BLOCKER);
              updateState({
                blockers
              });
            }
          });
          return;
        }
        return await startNavigation(historyAction, nextLocation, {
          submission,
          // Send through the formData serialization error if we have one so we can
          // render at the right error boundary after we match routes
          pendingError: error,
          preventScrollReset,
          replace: opts && opts.replace
        });
      }
      function revalidate() {
        interruptActiveLoads();
        updateState({
          revalidation: "loading"
        });
        if (state.navigation.state === "submitting") {
          return;
        }
        if (state.navigation.state === "idle") {
          startNavigation(state.historyAction, state.location, {
            startUninterruptedRevalidation: true
          });
          return;
        }
        startNavigation(pendingAction || state.historyAction, state.navigation.location, {
          overrideNavigation: state.navigation
        });
      }
      async function startNavigation(historyAction, location, opts) {
        pendingNavigationController && pendingNavigationController.abort();
        pendingNavigationController = null;
        pendingAction = historyAction;
        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
        saveScrollPosition(state.location, state.matches);
        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let loadingNavigation = opts && opts.overrideNavigation;
        let matches = matchRoutes(routesToUse, location, basename2);
        if (!matches) {
          let error = getInternalRouterError(404, {
            pathname: location.pathname
          });
          let {
            matches: notFoundMatches,
            route
          } = getShortCircuitMatches(routesToUse);
          cancelActiveDeferreds();
          completeNavigation(location, {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          });
          return;
        }
        if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
          completeNavigation(location, {
            matches
          });
          return;
        }
        pendingNavigationController = new AbortController();
        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
        let pendingActionData;
        let pendingError;
        if (opts && opts.pendingError) {
          pendingError = {
            [findNearestBoundary(matches).route.id]: opts.pendingError
          };
        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
          let actionOutput = await handleAction(request, location, opts.submission, matches, {
            replace: opts.replace
          });
          if (actionOutput.shortCircuited) {
            return;
          }
          pendingActionData = actionOutput.pendingActionData;
          pendingError = actionOutput.pendingActionError;
          loadingNavigation = getLoadingNavigation(location, opts.submission);
          request = new Request(request.url, {
            signal: request.signal
          });
        }
        let {
          shortCircuited,
          loaderData,
          errors
        } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);
        if (shortCircuited) {
          return;
        }
        pendingNavigationController = null;
        completeNavigation(location, _extends$2({
          matches
        }, pendingActionData ? {
          actionData: pendingActionData
        } : {}, {
          loaderData,
          errors
        }));
      }
      async function handleAction(request, location, submission, matches, opts) {
        if (opts === void 0) {
          opts = {};
        }
        interruptActiveLoads();
        let navigation = getSubmittingNavigation(location, submission);
        updateState({
          navigation
        });
        let result;
        let actionMatch = getTargetMatch(matches, location);
        if (!actionMatch.route.action && !actionMatch.route.lazy) {
          result = {
            type: ResultType.error,
            error: getInternalRouterError(405, {
              method: request.method,
              pathname: location.pathname,
              routeId: actionMatch.route.id
            })
          };
        } else {
          result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties2, basename2);
          if (request.signal.aborted) {
            return {
              shortCircuited: true
            };
          }
        }
        if (isRedirectResult(result)) {
          let replace2;
          if (opts && opts.replace != null) {
            replace2 = opts.replace;
          } else {
            replace2 = result.location === state.location.pathname + state.location.search;
          }
          await startRedirectNavigation(state, result, {
            submission,
            replace: replace2
          });
          return {
            shortCircuited: true
          };
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
          if ((opts && opts.replace) !== true) {
            pendingAction = Action.Push;
          }
          return {
            // Send back an empty object we can use to clear out any prior actionData
            pendingActionData: {},
            pendingActionError: {
              [boundaryMatch.route.id]: result.error
            }
          };
        }
        if (isDeferredResult(result)) {
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        }
        return {
          pendingActionData: {
            [actionMatch.route.id]: result.data
          }
        };
      }
      async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace2, pendingActionData, pendingError) {
        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename2, pendingActionData, pendingError);
        cancelActiveDeferreds((routeId) => !(matches && matches.some((m2) => m2.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m2) => m2.route.id === routeId));
        pendingNavigationLoadId = ++incrementingLoadId;
        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
          let updatedFetchers2 = markFetchRedirectsDone();
          completeNavigation(location, _extends$2({
            matches,
            loaderData: {},
            // Commit pending error if we're short circuiting
            errors: pendingError || null
          }, pendingActionData ? {
            actionData: pendingActionData
          } : {}, updatedFetchers2 ? {
            fetchers: new Map(state.fetchers)
          } : {}));
          return {
            shortCircuited: true
          };
        }
        if (!isUninterruptedRevalidation) {
          revalidatingFetchers.forEach((rf2) => {
            let fetcher = state.fetchers.get(rf2.key);
            let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
            state.fetchers.set(rf2.key, revalidatingFetcher);
          });
          let actionData = pendingActionData || state.actionData;
          updateState(_extends$2({
            navigation: loadingNavigation
          }, actionData ? Object.keys(actionData).length === 0 ? {
            actionData: null
          } : {
            actionData
          } : {}, revalidatingFetchers.length > 0 ? {
            fetchers: new Map(state.fetchers)
          } : {}));
        }
        revalidatingFetchers.forEach((rf2) => {
          if (fetchControllers.has(rf2.key)) {
            abortFetcher(rf2.key);
          }
          if (rf2.controller) {
            fetchControllers.set(rf2.key, rf2.controller);
          }
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f2) => abortFetcher(f2.key));
        if (pendingNavigationController) {
          pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        }
        let {
          results,
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
        if (request.signal.aborted) {
          return {
            shortCircuited: true
          };
        }
        if (pendingNavigationController) {
          pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
        }
        revalidatingFetchers.forEach((rf2) => fetchControllers.delete(rf2.key));
        let redirect = findRedirect(results);
        if (redirect) {
          if (redirect.idx >= matchesToLoad.length) {
            let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
            fetchRedirectIds.add(fetcherKey);
          }
          await startRedirectNavigation(state, redirect.result, {
            replace: replace2
          });
          return {
            shortCircuited: true
          };
        }
        let {
          loaderData,
          errors
        } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
        activeDeferreds.forEach((deferredData, routeId) => {
          deferredData.subscribe((aborted) => {
            if (aborted || deferredData.done) {
              activeDeferreds.delete(routeId);
            }
          });
        });
        let updatedFetchers = markFetchRedirectsDone();
        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
        return _extends$2({
          loaderData,
          errors
        }, shouldUpdateFetchers ? {
          fetchers: new Map(state.fetchers)
        } : {});
      }
      function getFetcher(key) {
        return state.fetchers.get(key) || IDLE_FETCHER;
      }
      function fetch2(key, routeId, href, opts) {
        if (isServer) {
          throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
        }
        if (fetchControllers.has(key))
          abortFetcher(key);
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let normalizedPath = normalizeTo(state.location, state.matches, basename2, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);
        let matches = matchRoutes(routesToUse, normalizedPath, basename2);
        if (!matches) {
          setFetcherError(key, routeId, getInternalRouterError(404, {
            pathname: normalizedPath
          }));
          return;
        }
        let {
          path: path2,
          submission,
          error
        } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
        if (error) {
          setFetcherError(key, routeId, error);
          return;
        }
        let match = getTargetMatch(matches, path2);
        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
        if (submission && isMutationMethod(submission.formMethod)) {
          handleFetcherAction(key, routeId, path2, match, matches, submission);
          return;
        }
        fetchLoadMatches.set(key, {
          routeId,
          path: path2
        });
        handleFetcherLoader(key, routeId, path2, match, matches, submission);
      }
      async function handleFetcherAction(key, routeId, path2, match, requestMatches, submission) {
        interruptActiveLoads();
        fetchLoadMatches.delete(key);
        if (!match.route.action && !match.route.lazy) {
          let error = getInternalRouterError(405, {
            method: submission.formMethod,
            pathname: path2,
            routeId
          });
          setFetcherError(key, routeId, error);
          return;
        }
        let existingFetcher = state.fetchers.get(key);
        let fetcher = getSubmittingFetcher(submission, existingFetcher);
        state.fetchers.set(key, fetcher);
        updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortController = new AbortController();
        let fetchRequest = createClientSideRequest(init.history, path2, abortController.signal, submission);
        fetchControllers.set(key, abortController);
        let originatingLoadId = incrementingLoadId;
        let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, mapRouteProperties2, basename2);
        if (fetchRequest.signal.aborted) {
          if (fetchControllers.get(key) === abortController) {
            fetchControllers.delete(key);
          }
          return;
        }
        if (isRedirectResult(actionResult)) {
          fetchControllers.delete(key);
          if (pendingNavigationLoadId > originatingLoadId) {
            let doneFetcher = getDoneFetcher(void 0);
            state.fetchers.set(key, doneFetcher);
            updateState({
              fetchers: new Map(state.fetchers)
            });
            return;
          } else {
            fetchRedirectIds.add(key);
            let loadingFetcher = getLoadingFetcher(submission);
            state.fetchers.set(key, loadingFetcher);
            updateState({
              fetchers: new Map(state.fetchers)
            });
            return startRedirectNavigation(state, actionResult, {
              fetcherSubmission: submission
            });
          }
        }
        if (isErrorResult(actionResult)) {
          setFetcherError(key, routeId, actionResult.error);
          return;
        }
        if (isDeferredResult(actionResult)) {
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        }
        let nextLocation = state.navigation.location || state.location;
        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename2) : state.matches;
        invariant(matches, "Didn't find any matches after fetcher action");
        let loadId = ++incrementingLoadId;
        fetchReloadIds.set(key, loadId);
        let loadFetcher = getLoadingFetcher(submission, actionResult.data);
        state.fetchers.set(key, loadFetcher);
        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
          init.history,
          state,
          matches,
          submission,
          nextLocation,
          isRevalidationRequired,
          cancelledDeferredRoutes,
          cancelledFetcherLoads,
          fetchLoadMatches,
          fetchRedirectIds,
          routesToUse,
          basename2,
          {
            [match.route.id]: actionResult.data
          },
          void 0
          // No need to send through errors since we short circuit above
        );
        revalidatingFetchers.filter((rf2) => rf2.key !== key).forEach((rf2) => {
          let staleKey = rf2.key;
          let existingFetcher2 = state.fetchers.get(staleKey);
          let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
          state.fetchers.set(staleKey, revalidatingFetcher);
          if (fetchControllers.has(staleKey)) {
            abortFetcher(staleKey);
          }
          if (rf2.controller) {
            fetchControllers.set(staleKey, rf2.controller);
          }
        });
        updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf2) => abortFetcher(rf2.key));
        abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        let {
          results,
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
        if (abortController.signal.aborted) {
          return;
        }
        abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
        fetchReloadIds.delete(key);
        fetchControllers.delete(key);
        revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
        let redirect = findRedirect(results);
        if (redirect) {
          if (redirect.idx >= matchesToLoad.length) {
            let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
            fetchRedirectIds.add(fetcherKey);
          }
          return startRedirectNavigation(state, redirect.result);
        }
        let {
          loaderData,
          errors
        } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
        if (state.fetchers.has(key)) {
          let doneFetcher = getDoneFetcher(actionResult.data);
          state.fetchers.set(key, doneFetcher);
        }
        let didAbortFetchLoads = abortStaleFetchLoads(loadId);
        if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
          invariant(pendingAction, "Expected pending action");
          pendingNavigationController && pendingNavigationController.abort();
          completeNavigation(state.navigation.location, {
            matches,
            loaderData,
            errors,
            fetchers: new Map(state.fetchers)
          });
        } else {
          updateState(_extends$2({
            errors,
            loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
          }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
            fetchers: new Map(state.fetchers)
          } : {}));
          isRevalidationRequired = false;
        }
      }
      async function handleFetcherLoader(key, routeId, path2, match, matches, submission) {
        let existingFetcher = state.fetchers.get(key);
        let loadingFetcher = getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0);
        state.fetchers.set(key, loadingFetcher);
        updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortController = new AbortController();
        let fetchRequest = createClientSideRequest(init.history, path2, abortController.signal);
        fetchControllers.set(key, abortController);
        let originatingLoadId = incrementingLoadId;
        let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, mapRouteProperties2, basename2);
        if (isDeferredResult(result)) {
          result = await resolveDeferredData(result, fetchRequest.signal, true) || result;
        }
        if (fetchControllers.get(key) === abortController) {
          fetchControllers.delete(key);
        }
        if (fetchRequest.signal.aborted) {
          return;
        }
        if (isRedirectResult(result)) {
          if (pendingNavigationLoadId > originatingLoadId) {
            let doneFetcher2 = getDoneFetcher(void 0);
            state.fetchers.set(key, doneFetcher2);
            updateState({
              fetchers: new Map(state.fetchers)
            });
            return;
          } else {
            fetchRedirectIds.add(key);
            await startRedirectNavigation(state, result);
            return;
          }
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(state.matches, routeId);
          state.fetchers.delete(key);
          updateState({
            fetchers: new Map(state.fetchers),
            errors: {
              [boundaryMatch.route.id]: result.error
            }
          });
          return;
        }
        invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
        let doneFetcher = getDoneFetcher(result.data);
        state.fetchers.set(key, doneFetcher);
        updateState({
          fetchers: new Map(state.fetchers)
        });
      }
      async function startRedirectNavigation(state2, redirect, _temp) {
        let {
          submission,
          fetcherSubmission,
          replace: replace2
        } = _temp === void 0 ? {} : _temp;
        if (redirect.revalidate) {
          isRevalidationRequired = true;
        }
        let redirectLocation = createLocation(state2.location, redirect.location, {
          _isRedirect: true
        });
        invariant(redirectLocation, "Expected a location on the redirect navigation");
        if (isBrowser2) {
          let isDocumentReload = false;
          if (redirect.reloadDocument) {
            isDocumentReload = true;
          } else if (ABSOLUTE_URL_REGEX$1.test(redirect.location)) {
            const url = init.history.createURL(redirect.location);
            isDocumentReload = // Hard reload if it's an absolute URL to a new origin
            url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
            stripBasename(url.pathname, basename2) == null;
          }
          if (isDocumentReload) {
            if (replace2) {
              routerWindow.location.replace(redirect.location);
            } else {
              routerWindow.location.assign(redirect.location);
            }
            return;
          }
        }
        pendingNavigationController = null;
        let redirectHistoryAction = replace2 === true ? Action.Replace : Action.Push;
        let {
          formMethod,
          formAction,
          formEncType
        } = state2.navigation;
        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
          submission = getSubmissionFromNavigation(state2.navigation);
        }
        let activeSubmission = submission || fetcherSubmission;
        if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
          await startNavigation(redirectHistoryAction, redirectLocation, {
            submission: _extends$2({}, activeSubmission, {
              formAction: redirect.location
            }),
            // Preserve this flag across redirects
            preventScrollReset: pendingPreventScrollReset
          });
        } else {
          let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
          await startNavigation(redirectHistoryAction, redirectLocation, {
            overrideNavigation,
            // Send fetcher submissions through for shouldRevalidate
            fetcherSubmission,
            // Preserve this flag across redirects
            preventScrollReset: pendingPreventScrollReset
          });
        }
      }
      async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
        let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties2, basename2)), ...fetchersToLoad.map((f2) => {
          if (f2.matches && f2.match && f2.controller) {
            return callLoaderOrAction("loader", createClientSideRequest(init.history, f2.path, f2.controller.signal), f2.match, f2.matches, manifest, mapRouteProperties2, basename2);
          } else {
            let error = {
              type: ResultType.error,
              error: getInternalRouterError(404, {
                pathname: f2.path
              })
            };
            return error;
          }
        })]);
        let loaderResults = results.slice(0, matchesToLoad.length);
        let fetcherResults = results.slice(matchesToLoad.length);
        await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f2) => f2.match), fetcherResults, fetchersToLoad.map((f2) => f2.controller ? f2.controller.signal : null), true)]);
        return {
          results,
          loaderResults,
          fetcherResults
        };
      }
      function interruptActiveLoads() {
        isRevalidationRequired = true;
        cancelledDeferredRoutes.push(...cancelActiveDeferreds());
        fetchLoadMatches.forEach((_, key) => {
          if (fetchControllers.has(key)) {
            cancelledFetcherLoads.push(key);
            abortFetcher(key);
          }
        });
      }
      function setFetcherError(key, routeId, error) {
        let boundaryMatch = findNearestBoundary(state.matches, routeId);
        deleteFetcher(key);
        updateState({
          errors: {
            [boundaryMatch.route.id]: error
          },
          fetchers: new Map(state.fetchers)
        });
      }
      function deleteFetcher(key) {
        let fetcher = state.fetchers.get(key);
        if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
          abortFetcher(key);
        }
        fetchLoadMatches.delete(key);
        fetchReloadIds.delete(key);
        fetchRedirectIds.delete(key);
        state.fetchers.delete(key);
      }
      function abortFetcher(key) {
        let controller = fetchControllers.get(key);
        invariant(controller, "Expected fetch controller: " + key);
        controller.abort();
        fetchControllers.delete(key);
      }
      function markFetchersDone(keys2) {
        for (let key of keys2) {
          let fetcher = getFetcher(key);
          let doneFetcher = getDoneFetcher(fetcher.data);
          state.fetchers.set(key, doneFetcher);
        }
      }
      function markFetchRedirectsDone() {
        let doneKeys = [];
        let updatedFetchers = false;
        for (let key of fetchRedirectIds) {
          let fetcher = state.fetchers.get(key);
          invariant(fetcher, "Expected fetcher: " + key);
          if (fetcher.state === "loading") {
            fetchRedirectIds.delete(key);
            doneKeys.push(key);
            updatedFetchers = true;
          }
        }
        markFetchersDone(doneKeys);
        return updatedFetchers;
      }
      function abortStaleFetchLoads(landedId) {
        let yeetedKeys = [];
        for (let [key, id2] of fetchReloadIds) {
          if (id2 < landedId) {
            let fetcher = state.fetchers.get(key);
            invariant(fetcher, "Expected fetcher: " + key);
            if (fetcher.state === "loading") {
              abortFetcher(key);
              fetchReloadIds.delete(key);
              yeetedKeys.push(key);
            }
          }
        }
        markFetchersDone(yeetedKeys);
        return yeetedKeys.length > 0;
      }
      function getBlocker(key, fn) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        if (blockerFunctions.get(key) !== fn) {
          blockerFunctions.set(key, fn);
        }
        return blocker;
      }
      function deleteBlocker(key) {
        state.blockers.delete(key);
        blockerFunctions.delete(key);
      }
      function updateBlocker(key, newBlocker) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
        let blockers = new Map(state.blockers);
        blockers.set(key, newBlocker);
        updateState({
          blockers
        });
      }
      function shouldBlockNavigation(_ref2) {
        let {
          currentLocation,
          nextLocation,
          historyAction
        } = _ref2;
        if (blockerFunctions.size === 0) {
          return;
        }
        if (blockerFunctions.size > 1) {
          warning(false, "A router only supports one blocker at a time");
        }
        let entries = Array.from(blockerFunctions.entries());
        let [blockerKey, blockerFunction] = entries[entries.length - 1];
        let blocker = state.blockers.get(blockerKey);
        if (blocker && blocker.state === "proceeding") {
          return;
        }
        if (blockerFunction({
          currentLocation,
          nextLocation,
          historyAction
        })) {
          return blockerKey;
        }
      }
      function cancelActiveDeferreds(predicate) {
        let cancelledRouteIds = [];
        activeDeferreds.forEach((dfd, routeId) => {
          if (!predicate || predicate(routeId)) {
            dfd.cancel();
            cancelledRouteIds.push(routeId);
            activeDeferreds.delete(routeId);
          }
        });
        return cancelledRouteIds;
      }
      function enableScrollRestoration(positions, getPosition, getKey) {
        savedScrollPositions = positions;
        getScrollPosition = getPosition;
        getScrollRestorationKey = getKey || null;
        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
          initialScrollRestored = true;
          let y2 = getSavedScrollPosition(state.location, state.matches);
          if (y2 != null) {
            updateState({
              restoreScrollPosition: y2
            });
          }
        }
        return () => {
          savedScrollPositions = null;
          getScrollPosition = null;
          getScrollRestorationKey = null;
        };
      }
      function getScrollKey(location, matches) {
        if (getScrollRestorationKey) {
          let key = getScrollRestorationKey(location, matches.map((m2) => convertRouteMatchToUiMatch(m2, state.loaderData)));
          return key || location.key;
        }
        return location.key;
      }
      function saveScrollPosition(location, matches) {
        if (savedScrollPositions && getScrollPosition) {
          let key = getScrollKey(location, matches);
          savedScrollPositions[key] = getScrollPosition();
        }
      }
      function getSavedScrollPosition(location, matches) {
        if (savedScrollPositions) {
          let key = getScrollKey(location, matches);
          let y2 = savedScrollPositions[key];
          if (typeof y2 === "number") {
            return y2;
          }
        }
        return null;
      }
      function _internalSetRoutes(newRoutes) {
        manifest = {};
        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
      }
      router = {
        get basename() {
          return basename2;
        },
        get state() {
          return state;
        },
        get routes() {
          return dataRoutes;
        },
        initialize,
        subscribe,
        enableScrollRestoration,
        navigate,
        fetch: fetch2,
        revalidate,
        // Passthrough to history-aware createHref used by useHref so we get proper
        // hash-aware URLs in DOM paths
        createHref: (to) => init.history.createHref(to),
        encodeLocation: (to) => init.history.encodeLocation(to),
        getFetcher,
        deleteFetcher,
        dispose,
        getBlocker,
        deleteBlocker,
        _internalFetchControllers: fetchControllers,
        _internalActiveDeferreds: activeDeferreds,
        // TODO: Remove setRoutes, it's temporary to avoid dealing with
        // updating the tree while validating the update algorithm.
        _internalSetRoutes
      };
      return router;
    }
    function isSubmissionNavigation(opts) {
      return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
    }
    function normalizeTo(location, matches, basename2, prependBasename, to, fromRouteId, relative) {
      let contextualMatches;
      let activeRouteMatch;
      if (fromRouteId != null && relative !== "path") {
        contextualMatches = [];
        for (let match of matches) {
          contextualMatches.push(match);
          if (match.route.id === fromRouteId) {
            activeRouteMatch = match;
            break;
          }
        }
      } else {
        contextualMatches = matches;
        activeRouteMatch = matches[matches.length - 1];
      }
      let path2 = resolveTo(to ? to : ".", getPathContributingMatches(contextualMatches).map((m2) => m2.pathnameBase), stripBasename(location.pathname, basename2) || location.pathname, relative === "path");
      if (to == null) {
        path2.search = location.search;
        path2.hash = location.hash;
      }
      if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path2.search)) {
        path2.search = path2.search ? path2.search.replace(/^\?/, "?index&") : "?index";
      }
      if (prependBasename && basename2 !== "/") {
        path2.pathname = path2.pathname === "/" ? basename2 : joinPaths([basename2, path2.pathname]);
      }
      return createPath(path2);
    }
    function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path2, opts) {
      if (!opts || !isSubmissionNavigation(opts)) {
        return {
          path: path2
        };
      }
      if (opts.formMethod && !isValidMethod(opts.formMethod)) {
        return {
          path: path2,
          error: getInternalRouterError(405, {
            method: opts.formMethod
          })
        };
      }
      let getInvalidBodyError = () => ({
        path: path2,
        error: getInternalRouterError(400, {
          type: "invalid-body"
        })
      });
      let rawFormMethod = opts.formMethod || "get";
      let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
      let formAction = stripHashFromPath(path2);
      if (opts.body !== void 0) {
        if (opts.formEncType === "text/plain") {
          if (!isMutationMethod(formMethod)) {
            return getInvalidBodyError();
          }
          let text2 = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
            // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
            Array.from(opts.body.entries()).reduce((acc, _ref3) => {
              let [name2, value] = _ref3;
              return "" + acc + name2 + "=" + value + "\n";
            }, "")
          ) : String(opts.body);
          return {
            path: path2,
            submission: {
              formMethod,
              formAction,
              formEncType: opts.formEncType,
              formData: void 0,
              json: void 0,
              text: text2
            }
          };
        } else if (opts.formEncType === "application/json") {
          if (!isMutationMethod(formMethod)) {
            return getInvalidBodyError();
          }
          try {
            let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
            return {
              path: path2,
              submission: {
                formMethod,
                formAction,
                formEncType: opts.formEncType,
                formData: void 0,
                json,
                text: void 0
              }
            };
          } catch (e) {
            return getInvalidBodyError();
          }
        }
      }
      invariant(typeof FormData === "function", "FormData is not available in this environment");
      let searchParams;
      let formData;
      if (opts.formData) {
        searchParams = convertFormDataToSearchParams(opts.formData);
        formData = opts.formData;
      } else if (opts.body instanceof FormData) {
        searchParams = convertFormDataToSearchParams(opts.body);
        formData = opts.body;
      } else if (opts.body instanceof URLSearchParams) {
        searchParams = opts.body;
        formData = convertSearchParamsToFormData(searchParams);
      } else if (opts.body == null) {
        searchParams = new URLSearchParams();
        formData = new FormData();
      } else {
        try {
          searchParams = new URLSearchParams(opts.body);
          formData = convertSearchParamsToFormData(searchParams);
        } catch (e) {
          return getInvalidBodyError();
        }
      }
      let submission = {
        formMethod,
        formAction,
        formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
        formData,
        json: void 0,
        text: void 0
      };
      if (isMutationMethod(submission.formMethod)) {
        return {
          path: path2,
          submission
        };
      }
      let parsedPath = parsePath(path2);
      if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
        searchParams.append("index", "");
      }
      parsedPath.search = "?" + searchParams;
      return {
        path: createPath(parsedPath),
        submission
      };
    }
    function getLoaderMatchesUntilBoundary(matches, boundaryId) {
      let boundaryMatches = matches;
      if (boundaryId) {
        let index2 = matches.findIndex((m2) => m2.route.id === boundaryId);
        if (index2 >= 0) {
          boundaryMatches = matches.slice(0, index2);
        }
      }
      return boundaryMatches;
    }
    function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename2, pendingActionData, pendingError) {
      let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0;
      let currentUrl = history.createURL(state.location);
      let nextUrl = history.createURL(location);
      let boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0;
      let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
      let navigationMatches = boundaryMatches.filter((match, index2) => {
        if (match.route.lazy) {
          return true;
        }
        if (match.route.loader == null) {
          return false;
        }
        if (isNewLoader(state.loaderData, state.matches[index2], match) || cancelledDeferredRoutes.some((id2) => id2 === match.route.id)) {
          return true;
        }
        let currentRouteMatch = state.matches[index2];
        let nextRouteMatch = match;
        return shouldRevalidateLoader(match, _extends$2({
          currentUrl,
          currentParams: currentRouteMatch.params,
          nextUrl,
          nextParams: nextRouteMatch.params
        }, submission, {
          actionResult,
          defaultShouldRevalidate: (
            // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
            isRevalidationRequired || // Clicked the same link, resubmitted a GET form
            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
          )
        }));
      });
      let revalidatingFetchers = [];
      fetchLoadMatches.forEach((f2, key) => {
        if (!matches.some((m2) => m2.route.id === f2.routeId)) {
          return;
        }
        let fetcherMatches = matchRoutes(routesToUse, f2.path, basename2);
        if (!fetcherMatches) {
          revalidatingFetchers.push({
            key,
            routeId: f2.routeId,
            path: f2.path,
            matches: null,
            match: null,
            controller: null
          });
          return;
        }
        let fetcher = state.fetchers.get(key);
        let fetcherMatch = getTargetMatch(fetcherMatches, f2.path);
        let shouldRevalidate = false;
        if (fetchRedirectIds.has(key)) {
          shouldRevalidate = false;
        } else if (cancelledFetcherLoads.includes(key)) {
          shouldRevalidate = true;
        } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
          shouldRevalidate = isRevalidationRequired;
        } else {
          shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends$2({
            currentUrl,
            currentParams: state.matches[state.matches.length - 1].params,
            nextUrl,
            nextParams: matches[matches.length - 1].params
          }, submission, {
            actionResult,
            defaultShouldRevalidate: isRevalidationRequired
          }));
        }
        if (shouldRevalidate) {
          revalidatingFetchers.push({
            key,
            routeId: f2.routeId,
            path: f2.path,
            matches: fetcherMatches,
            match: fetcherMatch,
            controller: new AbortController()
          });
        }
      });
      return [navigationMatches, revalidatingFetchers];
    }
    function isNewLoader(currentLoaderData, currentMatch, match) {
      let isNew = (
        // [a] -> [a, b]
        !currentMatch || // [a, b] -> [a, c]
        match.route.id !== currentMatch.route.id
      );
      let isMissingData = currentLoaderData[match.route.id] === void 0;
      return isNew || isMissingData;
    }
    function isNewRouteInstance(currentMatch, match) {
      let currentPath = currentMatch.route.path;
      return (
        // param change for this match, /users/123 -> /users/456
        currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
        // e.g. /files/images/avatar.jpg -> files/finances.xls
        currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
      );
    }
    function shouldRevalidateLoader(loaderMatch, arg) {
      if (loaderMatch.route.shouldRevalidate) {
        let routeChoice = loaderMatch.route.shouldRevalidate(arg);
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return arg.defaultShouldRevalidate;
    }
    async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
      if (!route.lazy) {
        return;
      }
      let lazyRoute = await route.lazy();
      if (!route.lazy) {
        return;
      }
      let routeToUpdate = manifest[route.id];
      invariant(routeToUpdate, "No route found in manifest");
      let routeUpdates = {};
      for (let lazyRouteProperty in lazyRoute) {
        let staticRouteValue = routeToUpdate[lazyRouteProperty];
        let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
        // on the route updates
        lazyRouteProperty !== "hasErrorBoundary";
        warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.'));
        if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
          routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
        }
      }
      Object.assign(routeToUpdate, routeUpdates);
      Object.assign(routeToUpdate, _extends$2({}, mapRouteProperties2(routeToUpdate), {
        lazy: void 0
      }));
    }
    async function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties2, basename2, opts) {
      if (opts === void 0) {
        opts = {};
      }
      let resultType;
      let result;
      let onReject;
      let runHandler = (handler) => {
        let reject;
        let abortPromise = new Promise((_, r2) => reject = r2);
        onReject = () => reject();
        request.signal.addEventListener("abort", onReject);
        return Promise.race([handler({
          request,
          params: match.params,
          context: opts.requestContext
        }), abortPromise]);
      };
      try {
        let handler = match.route[type];
        if (match.route.lazy) {
          if (handler) {
            let handlerError;
            let values = await Promise.all([
              // If the handler throws, don't let it immediately bubble out,
              // since we need to let the lazy() execution finish so we know if this
              // route has a boundary that can handle the error
              runHandler(handler).catch((e) => {
                handlerError = e;
              }),
              loadLazyRouteModule(match.route, mapRouteProperties2, manifest)
            ]);
            if (handlerError) {
              throw handlerError;
            }
            result = values[0];
          } else {
            await loadLazyRouteModule(match.route, mapRouteProperties2, manifest);
            handler = match.route[type];
            if (handler) {
              result = await runHandler(handler);
            } else if (type === "action") {
              let url = new URL(request.url);
              let pathname = url.pathname + url.search;
              throw getInternalRouterError(405, {
                method: request.method,
                pathname,
                routeId: match.route.id
              });
            } else {
              return {
                type: ResultType.data,
                data: void 0
              };
            }
          }
        } else if (!handler) {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(404, {
            pathname
          });
        } else {
          result = await runHandler(handler);
        }
        invariant(result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
      } catch (e) {
        resultType = ResultType.error;
        result = e;
      } finally {
        if (onReject) {
          request.signal.removeEventListener("abort", onReject);
        }
      }
      if (isResponse(result)) {
        let status = result.status;
        if (redirectStatusCodes.has(status)) {
          let location = result.headers.get("Location");
          invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
          if (!ABSOLUTE_URL_REGEX$1.test(location)) {
            location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename2, true, location);
          } else if (!opts.isStaticRequest) {
            let currentUrl = new URL(request.url);
            let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
            let isSameBasename = stripBasename(url.pathname, basename2) != null;
            if (url.origin === currentUrl.origin && isSameBasename) {
              location = url.pathname + url.search + url.hash;
            }
          }
          if (opts.isStaticRequest) {
            result.headers.set("Location", location);
            throw result;
          }
          return {
            type: ResultType.redirect,
            status,
            location,
            revalidate: result.headers.get("X-Remix-Revalidate") !== null,
            reloadDocument: result.headers.get("X-Remix-Reload-Document") !== null
          };
        }
        if (opts.isRouteRequest) {
          let queryRouteResponse = {
            type: resultType === ResultType.error ? ResultType.error : ResultType.data,
            response: result
          };
          throw queryRouteResponse;
        }
        let data2;
        let contentType = result.headers.get("Content-Type");
        if (contentType && /\bapplication\/json\b/.test(contentType)) {
          data2 = await result.json();
        } else {
          data2 = await result.text();
        }
        if (resultType === ResultType.error) {
          return {
            type: resultType,
            error: new ErrorResponseImpl(status, result.statusText, data2),
            headers: result.headers
          };
        }
        return {
          type: ResultType.data,
          data: data2,
          statusCode: result.status,
          headers: result.headers
        };
      }
      if (resultType === ResultType.error) {
        return {
          type: resultType,
          error: result
        };
      }
      if (isDeferredData(result)) {
        var _result$init, _result$init2;
        return {
          type: ResultType.deferred,
          deferredData: result,
          statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
          headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
        };
      }
      return {
        type: ResultType.data,
        data: result
      };
    }
    function createClientSideRequest(history, location, signal, submission) {
      let url = history.createURL(stripHashFromPath(location)).toString();
      let init = {
        signal
      };
      if (submission && isMutationMethod(submission.formMethod)) {
        let {
          formMethod,
          formEncType
        } = submission;
        init.method = formMethod.toUpperCase();
        if (formEncType === "application/json") {
          init.headers = new Headers({
            "Content-Type": formEncType
          });
          init.body = JSON.stringify(submission.json);
        } else if (formEncType === "text/plain") {
          init.body = submission.text;
        } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
          init.body = convertFormDataToSearchParams(submission.formData);
        } else {
          init.body = submission.formData;
        }
      }
      return new Request(url, init);
    }
    function convertFormDataToSearchParams(formData) {
      let searchParams = new URLSearchParams();
      for (let [key, value] of formData.entries()) {
        searchParams.append(key, typeof value === "string" ? value : value.name);
      }
      return searchParams;
    }
    function convertSearchParamsToFormData(searchParams) {
      let formData = new FormData();
      for (let [key, value] of searchParams.entries()) {
        formData.append(key, value);
      }
      return formData;
    }
    function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
      let loaderData = {};
      let errors = null;
      let statusCode;
      let foundError = false;
      let loaderHeaders = {};
      results.forEach((result, index2) => {
        let id2 = matchesToLoad[index2].route.id;
        invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, id2);
          let error = result.error;
          if (pendingError) {
            error = Object.values(pendingError)[0];
            pendingError = void 0;
          }
          errors = errors || {};
          if (errors[boundaryMatch.route.id] == null) {
            errors[boundaryMatch.route.id] = error;
          }
          loaderData[id2] = void 0;
          if (!foundError) {
            foundError = true;
            statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
          }
          if (result.headers) {
            loaderHeaders[id2] = result.headers;
          }
        } else {
          if (isDeferredResult(result)) {
            activeDeferreds.set(id2, result.deferredData);
            loaderData[id2] = result.deferredData.data;
          } else {
            loaderData[id2] = result.data;
          }
          if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
            statusCode = result.statusCode;
          }
          if (result.headers) {
            loaderHeaders[id2] = result.headers;
          }
        }
      });
      if (pendingError) {
        errors = pendingError;
        loaderData[Object.keys(pendingError)[0]] = void 0;
      }
      return {
        loaderData,
        errors,
        statusCode: statusCode || 200,
        loaderHeaders
      };
    }
    function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
      let {
        loaderData,
        errors
      } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);
      for (let index2 = 0; index2 < revalidatingFetchers.length; index2++) {
        let {
          key,
          match,
          controller
        } = revalidatingFetchers[index2];
        invariant(fetcherResults !== void 0 && fetcherResults[index2] !== void 0, "Did not find corresponding fetcher result");
        let result = fetcherResults[index2];
        if (controller && controller.signal.aborted) {
          continue;
        } else if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
          if (!(errors && errors[boundaryMatch.route.id])) {
            errors = _extends$2({}, errors, {
              [boundaryMatch.route.id]: result.error
            });
          }
          state.fetchers.delete(key);
        } else if (isRedirectResult(result)) {
          invariant(false, "Unhandled fetcher revalidation redirect");
        } else if (isDeferredResult(result)) {
          invariant(false, "Unhandled fetcher deferred data");
        } else {
          let doneFetcher = getDoneFetcher(result.data);
          state.fetchers.set(key, doneFetcher);
        }
      }
      return {
        loaderData,
        errors
      };
    }
    function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
      let mergedLoaderData = _extends$2({}, newLoaderData);
      for (let match of matches) {
        let id2 = match.route.id;
        if (newLoaderData.hasOwnProperty(id2)) {
          if (newLoaderData[id2] !== void 0) {
            mergedLoaderData[id2] = newLoaderData[id2];
          }
        } else if (loaderData[id2] !== void 0 && match.route.loader) {
          mergedLoaderData[id2] = loaderData[id2];
        }
        if (errors && errors.hasOwnProperty(id2)) {
          break;
        }
      }
      return mergedLoaderData;
    }
    function findNearestBoundary(matches, routeId) {
      let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1) : [...matches];
      return eligibleMatches.reverse().find((m2) => m2.route.hasErrorBoundary === true) || matches[0];
    }
    function getShortCircuitMatches(routes) {
      let route = routes.find((r2) => r2.index || !r2.path || r2.path === "/") || {
        id: "__shim-error-route__"
      };
      return {
        matches: [{
          params: {},
          pathname: "",
          pathnameBase: "",
          route
        }],
        route
      };
    }
    function getInternalRouterError(status, _temp4) {
      let {
        pathname,
        routeId,
        method,
        type
      } = _temp4 === void 0 ? {} : _temp4;
      let statusText = "Unknown Server Error";
      let errorMessage = "Unknown @remix-run/router error";
      if (status === 400) {
        statusText = "Bad Request";
        if (method && pathname && routeId) {
          errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request.";
        } else if (type === "defer-action") {
          errorMessage = "defer() is not supported in actions";
        } else if (type === "invalid-body") {
          errorMessage = "Unable to encode submission body";
        }
      } else if (status === 403) {
        statusText = "Forbidden";
        errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"';
      } else if (status === 404) {
        statusText = "Not Found";
        errorMessage = 'No route matches URL "' + pathname + '"';
      } else if (status === 405) {
        statusText = "Method Not Allowed";
        if (method && pathname && routeId) {
          errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request.";
        } else if (method) {
          errorMessage = 'Invalid request method "' + method.toUpperCase() + '"';
        }
      }
      return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
    }
    function findRedirect(results) {
      for (let i = results.length - 1; i >= 0; i--) {
        let result = results[i];
        if (isRedirectResult(result)) {
          return {
            result,
            idx: i
          };
        }
      }
    }
    function stripHashFromPath(path2) {
      let parsedPath = typeof path2 === "string" ? parsePath(path2) : path2;
      return createPath(_extends$2({}, parsedPath, {
        hash: ""
      }));
    }
    function isHashChangeOnly(a, b) {
      if (a.pathname !== b.pathname || a.search !== b.search) {
        return false;
      }
      if (a.hash === "") {
        return b.hash !== "";
      } else if (a.hash === b.hash) {
        return true;
      } else if (b.hash !== "") {
        return true;
      }
      return false;
    }
    function isDeferredResult(result) {
      return result.type === ResultType.deferred;
    }
    function isErrorResult(result) {
      return result.type === ResultType.error;
    }
    function isRedirectResult(result) {
      return (result && result.type) === ResultType.redirect;
    }
    function isDeferredData(value) {
      let deferred = value;
      return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
    }
    function isResponse(value) {
      return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
    }
    function isValidMethod(method) {
      return validRequestMethods.has(method.toLowerCase());
    }
    function isMutationMethod(method) {
      return validMutationMethods.has(method.toLowerCase());
    }
    async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
      for (let index2 = 0; index2 < results.length; index2++) {
        let result = results[index2];
        let match = matchesToLoad[index2];
        if (!match) {
          continue;
        }
        let currentMatch = currentMatches.find((m2) => m2.route.id === match.route.id);
        let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;
        if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
          let signal = signals[index2];
          invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result");
          await resolveDeferredData(result, signal, isFetcher).then((result2) => {
            if (result2) {
              results[index2] = result2 || results[index2];
            }
          });
        }
      }
    }
    async function resolveDeferredData(result, signal, unwrap) {
      if (unwrap === void 0) {
        unwrap = false;
      }
      let aborted = await result.deferredData.resolveData(signal);
      if (aborted) {
        return;
      }
      if (unwrap) {
        try {
          return {
            type: ResultType.data,
            data: result.deferredData.unwrappedData
          };
        } catch (e) {
          return {
            type: ResultType.error,
            error: e
          };
        }
      }
      return {
        type: ResultType.data,
        data: result.deferredData.data
      };
    }
    function hasNakedIndexQuery(search2) {
      return new URLSearchParams(search2).getAll("index").some((v2) => v2 === "");
    }
    function getTargetMatch(matches, location) {
      let search2 = typeof location === "string" ? parsePath(location).search : location.search;
      if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search2 || "")) {
        return matches[matches.length - 1];
      }
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches[pathMatches.length - 1];
    }
    function getSubmissionFromNavigation(navigation) {
      let {
        formMethod,
        formAction,
        formEncType,
        text: text2,
        formData,
        json
      } = navigation;
      if (!formMethod || !formAction || !formEncType) {
        return;
      }
      if (text2 != null) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData: void 0,
          json: void 0,
          text: text2
        };
      } else if (formData != null) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData,
          json: void 0,
          text: void 0
        };
      } else if (json !== void 0) {
        return {
          formMethod,
          formAction,
          formEncType,
          formData: void 0,
          json,
          text: void 0
        };
      }
    }
    function getLoadingNavigation(location, submission) {
      if (submission) {
        let navigation = {
          state: "loading",
          location,
          formMethod: submission.formMethod,
          formAction: submission.formAction,
          formEncType: submission.formEncType,
          formData: submission.formData,
          json: submission.json,
          text: submission.text
        };
        return navigation;
      } else {
        let navigation = {
          state: "loading",
          location,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          json: void 0,
          text: void 0
        };
        return navigation;
      }
    }
    function getSubmittingNavigation(location, submission) {
      let navigation = {
        state: "submitting",
        location,
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text
      };
      return navigation;
    }
    function getLoadingFetcher(submission, data2) {
      if (submission) {
        let fetcher = {
          state: "loading",
          formMethod: submission.formMethod,
          formAction: submission.formAction,
          formEncType: submission.formEncType,
          formData: submission.formData,
          json: submission.json,
          text: submission.text,
          data: data2
        };
        return fetcher;
      } else {
        let fetcher = {
          state: "loading",
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          json: void 0,
          text: void 0,
          data: data2
        };
        return fetcher;
      }
    }
    function getSubmittingFetcher(submission, existingFetcher) {
      let fetcher = {
        state: "submitting",
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text,
        data: existingFetcher ? existingFetcher.data : void 0
      };
      return fetcher;
    }
    function getDoneFetcher(data2) {
      let fetcher = {
        state: "idle",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: data2
      };
      return fetcher;
    }
    /**
     * React Router v6.16.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }
    const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
    const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
    const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
    const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
    const RouteContext = /* @__PURE__ */ reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
    function useHref(to, _temp) {
      let {
        relative
      } = _temp === void 0 ? {} : _temp;
      !useInRouterContext() ? invariant(false) : void 0;
      let {
        basename: basename2,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        hash,
        pathname,
        search: search2
      } = useResolvedPath(to, {
        relative
      });
      let joinedPathname = pathname;
      if (basename2 !== "/") {
        joinedPathname = pathname === "/" ? basename2 : joinPaths([basename2, pathname]);
      }
      return navigator2.createHref({
        pathname: joinedPathname,
        search: search2,
        hash
      });
    }
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      !useInRouterContext() ? invariant(false) : void 0;
      return reactExports.useContext(LocationContext).location;
    }
    function useIsomorphicLayoutEffect(cb2) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb2);
      }
    }
    function useNavigate() {
      let {
        isDataRoute
      } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      !useInRouterContext() ? invariant(false) : void 0;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let {
        basename: basename2,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to === "number") {
          navigator2.go(to);
          return;
        }
        let path2 = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
        if (dataRouterContext == null && basename2 !== "/") {
          path2.pathname = path2.pathname === "/" ? basename2 : joinPaths([basename2, path2.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(path2, options.state, options);
      }, [basename2, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
      return navigate;
    }
    function useParams() {
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let routeMatch = matches[matches.length - 1];
      return routeMatch ? routeMatch.params : {};
    }
    function useResolvedPath(to, _temp2) {
      let {
        relative
      } = _temp2 === void 0 ? {} : _temp2;
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
      return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState) {
      !useInRouterContext() ? invariant(false) : void 0;
      let {
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches: parentMatches
      } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      routeMatch && routeMatch.route;
      let locationFromContext = useLocation();
      let location;
      if (locationArg) {
        var _parsedLocationArg$pa;
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
        location = parsedLocationArg;
      } else {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
      let matches = matchRoutes(routes, {
        pathname: remainingPathname
      });
      let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
        params: Object.assign({}, parentParams, match.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
        ]),
        pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
        ])
      })), parentMatches, dataRouterState);
      if (locationArg && renderedMatches) {
        return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
          value: {
            location: _extends$1({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default"
            }, location),
            navigationType: Action.Pop
          }
        }, renderedMatches);
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error = useRouteError();
      let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = {
        padding: "0.5rem",
        backgroundColor: lightgrey
      };
      let devInfo = null;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
        style: {
          fontStyle: "italic"
        }
      }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
        style: preStyles
      }, stack) : null, devInfo);
    }
    const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    class RenderErrorBoundary extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error || state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error("React Router caught the following error during render", error, errorInfo);
      }
      render() {
        return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
          value: this.props.routeContext
        }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
          value: this.state.error,
          children: this.props.component
        })) : this.props.children;
      }
    }
    function RenderedRoute(_ref) {
      let {
        routeContext,
        match,
        children
      } = _ref;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
        value: routeContext
      }, children);
    }
    function _renderMatches(matches, parentMatches, dataRouterState) {
      var _dataRouterState2;
      if (parentMatches === void 0) {
        parentMatches = [];
      }
      if (dataRouterState === void 0) {
        dataRouterState = null;
      }
      if (matches == null) {
        var _dataRouterState;
        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches;
      let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
        !(errorIndex >= 0) ? invariant(false) : void 0;
        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
      }
      return renderedMatches.reduceRight((outlet, match, index2) => {
        let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;
        let errorElement = null;
        if (dataRouterState) {
          errorElement = match.route.errorElement || defaultErrorElement;
        }
        let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
        let getChildren = () => {
          let children;
          if (error) {
            children = errorElement;
          } else if (match.route.Component) {
            children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
          } else if (match.route.element) {
            children = match.route.element;
          } else {
            children = outlet;
          }
          return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
            match,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          });
        };
        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: {
            outlet: null,
            matches: matches2,
            isDataRoute: true
          }
        }) : getChildren();
      }, null);
    }
    var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
      DataRouterHook2["UseBlocker"] = "useBlocker";
      DataRouterHook2["UseRevalidator"] = "useRevalidator";
      DataRouterHook2["UseNavigateStable"] = "useNavigate";
      return DataRouterHook2;
    }(DataRouterHook$1 || {});
    var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
      DataRouterStateHook2["UseBlocker"] = "useBlocker";
      DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
      DataRouterStateHook2["UseActionData"] = "useActionData";
      DataRouterStateHook2["UseRouteError"] = "useRouteError";
      DataRouterStateHook2["UseNavigation"] = "useNavigation";
      DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
      DataRouterStateHook2["UseMatches"] = "useMatches";
      DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
      DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
      DataRouterStateHook2["UseRouteId"] = "useRouteId";
      return DataRouterStateHook2;
    }(DataRouterStateHook$1 || {});
    function useDataRouterContext(hookName) {
      let ctx2 = reactExports.useContext(DataRouterContext);
      !ctx2 ? invariant(false) : void 0;
      return ctx2;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      !state ? invariant(false) : void 0;
      return state;
    }
    function useRouteContext(hookName) {
      let route = reactExports.useContext(RouteContext);
      !route ? invariant(false) : void 0;
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext();
      let thisRoute = route.matches[route.matches.length - 1];
      !thisRoute.route.id ? invariant(false) : void 0;
      return thisRoute.route.id;
    }
    function useRouteError() {
      var _state$errors;
      let error = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
      let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
      if (error) {
        return error;
      }
      return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
    }
    function useNavigateStable() {
      let {
        router
      } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
      let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to === "number") {
          router.navigate(to);
        } else {
          router.navigate(to, _extends$1({
            fromRouteId: id2
          }, options));
        }
      }, [router, id2]);
      return navigate;
    }
    const START_TRANSITION = "startTransition";
    const startTransitionImpl = React$1[START_TRANSITION];
    function RouterProvider(_ref) {
      let {
        fallbackElement,
        router,
        future
      } = _ref;
      let [state, setStateImpl] = reactExports.useState(router.state);
      let {
        v7_startTransition
      } = future || {};
      let setState = reactExports.useCallback((newState) => {
        v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
      }, [setStateImpl, v7_startTransition]);
      reactExports.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
      let navigator2 = reactExports.useMemo(() => {
        return {
          createHref: router.createHref,
          encodeLocation: router.encodeLocation,
          go: (n2) => router.navigate(n2),
          push: (to, state2, opts) => router.navigate(to, {
            state: state2,
            preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
          }),
          replace: (to, state2, opts) => router.navigate(to, {
            replace: true,
            state: state2,
            preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
          })
        };
      }, [router]);
      let basename2 = router.basename || "/";
      let dataRouterContext = reactExports.useMemo(() => ({
        router,
        navigator: navigator2,
        static: false,
        basename: basename2
      }), [router, navigator2, basename2]);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(DataRouterContext.Provider, {
        value: dataRouterContext
      }, /* @__PURE__ */ reactExports.createElement(DataRouterStateContext.Provider, {
        value: state
      }, /* @__PURE__ */ reactExports.createElement(Router, {
        basename: basename2,
        location: state.location,
        navigationType: state.historyAction,
        navigator: navigator2
      }, state.initialized ? /* @__PURE__ */ reactExports.createElement(DataRoutes, {
        routes: router.routes,
        state
      }) : fallbackElement))), null);
    }
    function DataRoutes(_ref2) {
      let {
        routes,
        state
      } = _ref2;
      return useRoutesImpl(routes, void 0, state);
    }
    function Router(_ref5) {
      let {
        basename: basenameProp = "/",
        children = null,
        location: locationProp,
        navigationType = Action.Pop,
        navigator: navigator2,
        static: staticProp = false
      } = _ref5;
      !!useInRouterContext() ? invariant(false) : void 0;
      let basename2 = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(() => ({
        basename: basename2,
        navigator: navigator2,
        static: staticProp
      }), [basename2, navigator2, staticProp]);
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search: search2 = "",
        hash = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename2);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search: search2,
            hash,
            state,
            key
          },
          navigationType
        };
      }, [basename2, pathname, search2, hash, state, key, navigationType]);
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
        value: navigationContext
      }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
        children,
        value: locationContext
      }));
    }
    new Promise(() => {
    });
    function mapRouteProperties(route) {
      let updates = {
        // Note: this check also occurs in createRoutesFromChildren so update
        // there if you change this -- please and thank you!
        hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
      };
      if (route.Component) {
        Object.assign(updates, {
          element: /* @__PURE__ */ reactExports.createElement(route.Component),
          Component: void 0
        });
      }
      if (route.ErrorBoundary) {
        Object.assign(updates, {
          errorElement: /* @__PURE__ */ reactExports.createElement(route.ErrorBoundary),
          ErrorBoundary: void 0
        });
      }
      return updates;
    }
    /**
     * React Router DOM v6.16.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
      return event.button === 0 && // Ignore everything but left clicks
      (!target || target === "_self") && // Let browser handle "target=_blank" etc.
      !isModifiedEvent(event);
    }
    const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
    function createBrowserRouter(routes, opts) {
      return createRouter({
        basename: opts == null ? void 0 : opts.basename,
        future: _extends({}, opts == null ? void 0 : opts.future, {
          v7_prependBasename: true
        }),
        history: createBrowserHistory({
          window: opts == null ? void 0 : opts.window
        }),
        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
        routes,
        mapRouteProperties
      }).initialize();
    }
    function parseHydrationData() {
      var _window;
      let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
      if (state && state.errors) {
        state = _extends({}, state, {
          errors: deserializeErrors(state.errors)
        });
      }
      return state;
    }
    function deserializeErrors(errors) {
      if (!errors)
        return null;
      let entries = Object.entries(errors);
      let serialized = {};
      for (let [key, val] of entries) {
        if (val && val.__type === "RouteErrorResponse") {
          serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
        } else if (val && val.__type === "Error") {
          if (val.__subType) {
            let ErrorConstructor = window[val.__subType];
            if (typeof ErrorConstructor === "function") {
              try {
                let error = new ErrorConstructor(val.message);
                error.stack = "";
                serialized[key] = error;
              } catch (e) {
              }
            }
          }
          if (serialized[key] == null) {
            let error = new Error(val.message);
            error.stack = "";
            serialized[key] = error;
          }
        } else {
          serialized[key] = val;
        }
      }
      return serialized;
    }
    const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref4, ref) {
      let {
        onClick,
        relative,
        reloadDocument,
        replace: replace2,
        state,
        target,
        to,
        preventScrollReset
      } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
      let {
        basename: basename2
      } = reactExports.useContext(NavigationContext);
      let absoluteHref;
      let isExternal = false;
      if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
        absoluteHref = to;
        if (isBrowser) {
          try {
            let currentUrl = new URL(window.location.href);
            let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
            let path2 = stripBasename(targetUrl.pathname, basename2);
            if (targetUrl.origin === currentUrl.origin && path2 != null) {
              to = path2 + targetUrl.search + targetUrl.hash;
            } else {
              isExternal = true;
            }
          } catch (e) {
          }
        }
      }
      let href = useHref(to, {
        relative
      });
      let internalOnClick = useLinkClickHandler(to, {
        replace: replace2,
        state,
        target,
        preventScrollReset,
        relative
      });
      function handleClick(event) {
        if (onClick)
          onClick(event);
        if (!event.defaultPrevented) {
          internalOnClick(event);
        }
      }
      return (
        // eslint-disable-next-line jsx-a11y/anchor-has-content
        /* @__PURE__ */ reactExports.createElement("a", _extends({}, rest, {
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref,
          target
        }))
      );
    });
    var DataRouterHook;
    (function(DataRouterHook2) {
      DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
      DataRouterHook2["UseSubmit"] = "useSubmit";
      DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
      DataRouterHook2["UseFetcher"] = "useFetcher";
    })(DataRouterHook || (DataRouterHook = {}));
    var DataRouterStateHook;
    (function(DataRouterStateHook2) {
      DataRouterStateHook2["UseFetchers"] = "useFetchers";
      DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
    })(DataRouterStateHook || (DataRouterStateHook = {}));
    function useLinkClickHandler(to, _temp) {
      let {
        target,
        replace: replaceProp,
        state,
        preventScrollReset,
        relative
      } = _temp === void 0 ? {} : _temp;
      let navigate = useNavigate();
      let location = useLocation();
      let path2 = useResolvedPath(to, {
        relative
      });
      return reactExports.useCallback((event) => {
        if (shouldProcessLinkClick(event, target)) {
          event.preventDefault();
          let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path2);
          navigate(to, {
            replace: replace2,
            state,
            preventScrollReset,
            relative
          });
        }
      }, [location, navigate, path2, replaceProp, state, target, to, preventScrollReset, relative]);
    }
    const index = "";
    const shared = "";
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    var INFINITY$1 = 1 / 0;
    var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$1(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    function toString$1(value) {
      return value == null ? "" : baseToString(value);
    }
    function add_nonraw_implementations(state) {
      const tmp = {
        tag: state.tag,
        value: state.value,
        replace: state.replace,
        update: (updater) => {
          state.replace((state2) => {
            updater(state2);
            return state2;
          });
        },
        set: (new_state) => {
          state.replace((_old_state) => {
            return make_mutable(new_state);
          });
        },
        sub: (_property) => {
          assert(false);
        },
        unpack_null: () => {
          assert(false);
        },
        try_sub: (_property) => {
          assert(false);
        },
        transform: (_to, _mutable_to, _from) => {
          assert(false);
        }
      };
      tmp.sub = (property2) => {
        if (typeof property2 == "number") {
          const result = create_sub_updater_array(
            //eslint-disable-next-line total-functions/no-unsafe-type-assertion
            tmp,
            property2
          );
          return result;
        } else {
          return create_sub_updater_dict(
            //eslint-disable-next-line total-functions/no-unsafe-type-assertion
            tmp,
            //eslint-disable-next-line total-functions/no-unsafe-type-assertion
            property2
          );
        }
      };
      tmp.unpack_null = () => {
        return unpack_null(
          //eslint-disable-next-line total-functions/no-unsafe-type-assertion
          tmp
        );
      };
      tmp.try_sub = (property2) => {
        return create_sub_updater_dict(
          //eslint-disable-next-line total-functions/no-unsafe-type-assertion
          tmp,
          //eslint-disable-next-line total-functions/no-unsafe-type-assertion
          property2
        );
      };
      tmp.transform = (to, mutable_to, from) => {
        return create_sub_updater_transform(
          tmp,
          to,
          mutable_to,
          from
        );
      };
      return tmp;
    }
    function useLocalUpdateableState(initial_state) {
      const [current_state_to_render, dispatch] = reactExports.useReducer(
        (state, replacer) => {
          const mutable_state = make_mutable(state.curr);
          const new_state = replacer(mutable_state);
          const next_state_holder = {
            curr: mutable_state === new_state ? unsafe_assume_immutable(mutable_state) : make_immutable(new_state)
          };
          return next_state_holder;
        },
        {
          curr: initial_state
        }
      );
      return add_nonraw_implementations({
        tag: "local",
        value: current_state_to_render.curr,
        replace: (replacer, _options) => dispatch(replacer)
      });
    }
    function useReadWriteSubscription(subject) {
      const state = useLocalUpdateableState({
        last: subject.lowlevel.getValue().data,
        last_change_no: subject.lowlevel.getValue().change_no,
        last_subject: make_ref(subject)
      });
      const last_change_no = state.value.last_change_no;
      const last_subject = state.value.last_subject;
      const last = state.value.last;
      const update = state.update;
      reactExports.useEffect(() => {
        const handle2 = subject.subscribe((d, change_no) => {
          if (last_subject.target == subject) {
            if (!is_equal(last_change_no, change_no)) {
              update((s) => {
                s.last_change_no = change_no;
                s.last = make_mutable(d);
                s.last_subject = make_ref(subject);
              });
            }
          } else {
            if (!is_equal(last, d)) {
              update((s) => {
                s.last_change_no = change_no;
                s.last = make_mutable(d);
                s.last_subject = make_ref(subject);
              });
            }
          }
        });
        return () => {
          handle2.unsubscribe();
        };
      }, [subject, last_subject, update, last, last_change_no]);
      return add_nonraw_implementations({
        tag: "local",
        value: state.value.last,
        replace: (replacer, _options) => {
          const new_value = replacer(make_mutable(subject.get_value()));
          subject.next(unsafe_assume_immutable(new_value));
        }
      });
    }
    function useSubscription(subject) {
      return useReadWriteSubscription(subject).value;
    }
    function create_sub_updater_transform(updateable, to, mutable_to, from) {
      const value = to(updateable.value);
      return add_nonraw_implementations({
        tag: updateable.tag,
        value,
        replace: (replacer) => updateable.replace((state) => {
          return from(replacer(mutable_to(state)));
        })
      });
    }
    function create_sub_updater_dict(updateable, key) {
      const value = updateable.value[key];
      if (value === void 0) {
        return null;
      }
      return add_nonraw_implementations({
        tag: updateable.tag,
        value,
        replace: (replacer) => updateable.replace((state) => {
          const entry = state[key];
          if (entry === void 0) {
            return state;
          }
          state[key] = replacer(entry);
          return state;
        })
      });
    }
    function create_sub_updater_array(updateable, index2) {
      const value = updateable.value[index2];
      if (value == void 0) {
        return null;
      }
      return add_nonraw_implementations({
        tag: updateable.tag,
        value,
        replace: (replacer) => updateable.replace((state) => {
          const entry = state[index2];
          if (entry == void 0) {
            return state;
          }
          state[index2] = replacer(entry);
          return state;
        })
      });
    }
    function unpack_null(updateable) {
      if (updateable.value == null) {
        return null;
      }
      return add_nonraw_implementations({
        tag: updateable.tag,
        value: updateable.value,
        replace: (replacer) => updateable.replace((state) => {
          if (state == null) {
            return null;
          }
          return replacer(state);
        })
      });
    }
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p2))
            d2[p2] = b2[p2];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
      if (m2)
        return m2.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n2) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2)
        return o;
      var i = m2.call(o), r2, ar = [], e;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
          ar.push(r2.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i["return"]))
            m2.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    }
    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l2 = from.length, ar; i < l2; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function createErrorClass(createImpl) {
      var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
    }
    var UnsubscriptionError = createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
    function arrRemove(arr, item) {
      if (arr) {
        var index2 = arr.indexOf(item);
        0 <= index2 && arr.splice(index2, 1);
      }
    }
    var Subscription = function() {
      function Subscription2(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription2.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                    _a.call(_parentage_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError ? e.errors : [e];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError) {
                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                  _b.call(_finalizers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError(errors);
          }
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription2) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      };
      Subscription2.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription2.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription2.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove(_parentage, parent);
        }
      };
      Subscription2.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription2) {
          teardown._removeParent(this);
        }
      };
      Subscription2.EMPTY = function() {
        var empty2 = new Subscription2();
        empty2.closed = true;
        return empty2;
      }();
      return Subscription2;
    }();
    var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
      return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
    }
    function execFinalizer(finalizer) {
      if (isFunction(finalizer)) {
        finalizer();
      } else {
        finalizer.unsubscribe();
      }
    }
    var config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
    var timeoutProvider = {
      setTimeout: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
        }
        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
      },
      clearTimeout: function(handle2) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle2);
      },
      delegate: void 0
    };
    function reportUnhandledError(err) {
      timeoutProvider.setTimeout(function() {
        {
          throw err;
        }
      });
    }
    function noop() {
    }
    function errorContext(cb2) {
      {
        cb2();
      }
    }
    var Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped)
          ;
        else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped)
          ;
        else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped)
          ;
        else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription);
    var _bind = Function.prototype.bind;
    function bind(fn, thisArg) {
      return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      return ConsumerObserver2;
    }();
    var SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context_1),
              error: observerOrNext.error && bind(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    function handleUnhandledError(error) {
      {
        reportUnhandledError(error);
      }
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    var EMPTY_OBSERVER = {
      closed: true,
      next: noop,
      error: defaultErrorHandler,
      complete: noop
    };
    var observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
    function identity$1(x2) {
      return x2;
    }
    function pipeFromArray(fns) {
      if (fns.length === 0) {
        return identity$1;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn) {
          return fn(prev);
        }, input);
      };
    }
    var Observable = function() {
      function Observable2(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable2 = new Observable2();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
        errorContext(function() {
          var _a = _this, operator = _a.operator, source = _a.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable2.prototype[observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x2) {
            return value = x2;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
    function getPromiseCtor(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
      return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
    }
    function isSubscriber(value) {
      return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
    }
    var ObjectUnsubscribedError = createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
    var Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
      };
      Subject2.prototype.next = function(value) {
        var _this = this;
        errorContext(function() {
          var e_1, _a;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return))
                  _a.call(_b);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      };
      Subject2.prototype.error = function(err) {
        var _this = this;
        errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject2.prototype.complete = function() {
        var _this = this;
        errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject2.prototype, "observed", {
        get: function() {
          var _a;
          return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject2.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject2.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
          return EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription(function() {
          _this.currentObservers = null;
          arrRemove(observers, subscriber);
        });
      };
      Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable2 = new Observable();
        observable2.source = this;
        return observable2;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable);
    var AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject);
    var BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject);
    function to_versioned_subject(lowlevel) {
      return {
        lowlevel,
        get_value: () => {
          return lowlevel.value.data;
        },
        next: (data2) => {
          lowlevel.next({ change_no: lowlevel.value.change_no + 1, data: data2 });
        },
        subscribe: (callback) => {
          const handle2 = lowlevel.subscribe((data2) => {
            callback(data2.data, data2.change_no);
          });
          return {
            unsubscribe: () => {
              handle2.unsubscribe();
            }
          };
        }
      };
    }
    function create_versioned_subject(init) {
      return to_versioned_subject(
        new BehaviorSubject({
          change_no: 0,
          data: init
        })
      );
    }
    function register_local_storage(config2) {
      const try_parse = (stored_str) => {
        if (stored_str == null) {
          return null;
        }
        const stored = parse_json(stored_str);
        if (!has_member(stored, "version") || typeof stored["version"] != "number" || !has_member(stored, "data")) {
          return null;
        }
        return config2.parse(stored.version, stored.data);
      };
      const opt_initial_state = make_immutable(
        try_parse(window.localStorage.getItem(config2.name))
      );
      const subj = to_versioned_subject(
        new BehaviorSubject({
          change_no: 0,
          data: opt_initial_state ?? config2.initial_state
        })
      );
      const sync = {
        is_updating: false,
        //update only changes from remote
        curr_timeout: null
        //defer saving to local storage by 100ms
      };
      window.addEventListener("storage", (e) => {
        if (e.key == config2.name) {
          if (sync.is_updating) {
            return;
          }
          if (e.newValue != null) {
            const parsed = make_immutable(try_parse(e.newValue));
            if (parsed != null) {
              if (!is_equal(subj.get_value(), parsed)) {
                sync.is_updating = true;
                subj.next(parsed);
                sync.is_updating = false;
              }
            }
          }
        }
      });
      subj.subscribe((data2) => {
        if (sync.is_updating) {
          return;
        }
        if (sync.curr_timeout != null) {
          window.clearTimeout(sync.curr_timeout);
        }
        const store = () => {
          sync.curr_timeout = null;
          const stored_data = {
            version: config2.version,
            data: data2
          };
          sync.is_updating = true;
          window.localStorage.setItem(config2.name, stringify_json(stored_data));
          sync.is_updating = false;
        };
        if (config2.deferred_store) {
          sync.curr_timeout = window.setTimeout(store, 100);
        } else {
          store();
        }
      });
      return { __marker: "__localstorage__", data: subj };
    }
    function RawInput(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          id: props.id,
          className: `form-control${props.className == void 0 ? "" : ` ${props.className}`}`,
          style: {
            maxWidth: "100%"
          },
          type: props.type,
          value: props.value.kind == "disabled" ? props.value.value : props.value.render(props.value.value.value),
          disabled: props.value.kind == "disabled",
          onInput: (e) => {
            e.preventDefault();
            if (props.value.kind != "disabled") {
              const value = e.currentTarget.value;
              props.value.value.set(props.value.parse(value));
              if (props.on_input !== void 0) {
                props.on_input(value);
              }
            }
          },
          placeholder: props.placeholder
        }
      );
    }
    function Input(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        RawInput,
        {
          id: props.id,
          className: props.className,
          placeholder: props.placeholder,
          type: props.type,
          on_input: props.on_input,
          value: typeof props.value == "string" ? { kind: "disabled", value: props.value } : {
            kind: "enabled",
            value: props.value,
            parse: (s) => s,
            render: (s) => s
          }
        }
      );
    }
    function NoOpForm(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "form",
        {
          onSubmit: (e) => {
            e.preventDefault();
          },
          children: props.children
        }
      );
    }
    function TextEdit(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          className: "mb-3",
          id: props.id,
          type: "text",
          value: props.state,
          placeholder: props.placeholder
        }
      );
    }
    const background_shadowy = "/assets/background_shadowy-6b14ae7e.png";
    const background = "/assets/background-f2541ca3.jpg";
    function thruster_to_level(thruster) {
      if (thruster > 0.8) {
        return 5;
      }
      if (thruster > 0.6) {
        return 4;
      }
      if (thruster > 0.4) {
        return 3;
      }
      if (thruster > 0.2) {
        return 2;
      }
      if (thruster > 0) {
        return 1;
      }
      return 0;
    }
    function Ship(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "scale(0.3 0.3)", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `rotate(${props.angle} 0 0)`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "g",
        {
          transform: `translate(${-376 / 2},${-842 / 2}) scale(1.000000,1.000000)`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "340.47",
                  y1: "623.45",
                  x2: "477.74",
                  y2: "623.45",
                  gradientTransform: "translate(813.27 297.45) rotate(90)",
                  gradientUnits: "userSpaceOnUse",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: "#ffef26" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".02", stopColor: "#fee921" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".1", stopColor: "#fdd70e" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".19", stopColor: "#fdcb03" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".28", stopColor: "#fdc800" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".55", stopColor: "#f18f34" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".7", stopColor: "#e95f32" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".81", stopColor: "#e43d2e" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: "#e3312d" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-2",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "340.07",
                  x2: "458.73",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-3",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "340.33",
                  x2: "438.41",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-4",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "340.33",
                  x2: "421.83",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-5",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "340.07",
                  x2: "407.43",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-6",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "729.42",
                  y1: "647.82",
                  x2: "777.41",
                  y2: "647.82",
                  gradientTransform: "translate(825.13 1200.39) rotate(-180)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-7",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "728.04",
                  y1: "961.34",
                  x2: "776.02",
                  y2: "961.34",
                  gradientTransform: "translate(825.13 1200.39) rotate(-180)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-8",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "367.83",
                  y1: "253.1",
                  x2: "415.81",
                  y2: "253.1",
                  gradientTransform: "translate(12.03 860.37) rotate(-90)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-9",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "368.74",
                  y1: "102.17",
                  x2: "416.73",
                  y2: "102.17",
                  gradientTransform: "translate(12.03 860.37) rotate(-90)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-10",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "283.01",
                  y1: "240.42",
                  x2: "330.99",
                  y2: "240.42",
                  gradientTransform: "matrix(1,0,0,1,0,0)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-11",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "283.01",
                  y1: "553.94",
                  x2: "330.99",
                  y2: "553.94",
                  gradientTransform: "matrix(1,0,0,1,0,0)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-12",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "729.42",
                  y1: "647.75",
                  x2: "772.42",
                  y2: "647.75",
                  gradientTransform: "translate(825.13 1200.39) rotate(-180)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-13",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "728.09",
                  y1: "961.34",
                  x2: "771.09",
                  y2: "961.34",
                  gradientTransform: "translate(825.13 1200.39) rotate(-180)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-14",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "367.83",
                  y1: "253.1",
                  x2: "410.82",
                  y2: "253.1",
                  gradientTransform: "translate(12.03 860.37) rotate(-90)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-15",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "367.83",
                  y1: "101.99",
                  x2: "410.82",
                  y2: "101.99",
                  gradientTransform: "translate(12.03 860.37) rotate(-90)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-16",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "283.01",
                  y1: "240.42",
                  x2: "326.01",
                  y2: "240.42",
                  gradientTransform: "matrix(1,0,0,1,0,0)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-17",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "283.09",
                  y1: "553.94",
                  x2: "326.08",
                  y2: "553.94",
                  gradientTransform: "matrix(1,0,0,1,0,0)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-18",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "727.95",
                  y1: "647.75",
                  x2: "768.34",
                  y2: "647.75",
                  gradientTransform: "translate(825.13 1200.39) rotate(-180)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-19",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "727.95",
                  y1: "961.5",
                  x2: "768.34",
                  y2: "961.5",
                  gradientTransform: "translate(825.13 1200.39) rotate(-180)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-20",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "367.67",
                  y1: "253.1",
                  x2: "408.06",
                  y2: "253.1",
                  gradientTransform: "translate(12.03 860.37) rotate(-90)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-21",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "367.83",
                  y1: "101.99",
                  x2: "408.21",
                  y2: "101.99",
                  gradientTransform: "translate(12.03 860.37) rotate(-90)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-22",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "282.92",
                  y1: "240.42",
                  x2: "323.31",
                  y2: "240.42",
                  gradientTransform: "matrix(1,0,0,1,0,0)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-23",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "283.09",
                  y1: "553.94",
                  x2: "323.47",
                  y2: "553.94",
                  gradientTransform: "matrix(1,0,0,1,0,0)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-24",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "727.95",
                  y1: "647.75",
                  x2: "762.27",
                  y2: "647.75",
                  gradientTransform: "translate(825.13 1200.39) rotate(-180)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-25",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "727.93",
                  y1: "961.5",
                  x2: "762.25",
                  y2: "961.5",
                  gradientTransform: "translate(825.13 1200.39) rotate(-180)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-26",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "367.44",
                  y1: "253.17",
                  x2: "401.76",
                  y2: "253.17",
                  gradientTransform: "translate(12.03 860.37) rotate(-90)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-27",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "367.83",
                  y1: "101.99",
                  x2: "402.15",
                  y2: "101.99",
                  gradientTransform: "translate(12.03 860.37) rotate(-90)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-28",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "282.92",
                  y1: "240.13",
                  x2: "317.24",
                  y2: "240.13",
                  gradientTransform: "matrix(1,0,0,1,0,0)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-29",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "282.92",
                  y1: "553.94",
                  x2: "317.24",
                  y2: "553.94",
                  gradientTransform: "matrix(1,0,0,1,0,0)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-30",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "727.95",
                  y1: "648.05",
                  x2: "755.47",
                  y2: "648.05",
                  gradientTransform: "translate(825.13 1200.39) rotate(-180)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-31",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "727.95",
                  y1: "961.5",
                  x2: "755.47",
                  y2: "961.5",
                  gradientTransform: "translate(825.13 1200.39) rotate(-180)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-32",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "367.83",
                  y1: "253.17",
                  x2: "395.34",
                  y2: "253.17",
                  gradientTransform: "translate(12.03 860.37) rotate(-90)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-33",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "367.83",
                  y1: "101.99",
                  x2: "395.34",
                  y2: "101.99",
                  gradientTransform: "translate(12.03 860.37) rotate(-90)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-34",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "282.92",
                  y1: "240.13",
                  x2: "310.44",
                  y2: "240.13",
                  gradientTransform: "matrix(1,0,0,1,0,0)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "linearGradient",
                {
                  id: "Unbenannter_Verlauf_14-35",
                  "data-name": "Unbenannter Verlauf 14",
                  x1: "282.92",
                  y1: "553.94",
                  x2: "310.44",
                  y2: "553.94",
                  gradientTransform: "matrix(1,0,0,1,0,0)",
                  xlinkHref: "#Unbenannter_Verlauf_14"
                }
              )
            ] }),
            null,
            /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Rumpf", children: [
              thruster_to_level(props.thrusters.back) >= 5 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  id: "Heckantrieb_5",
                  d: "m222.63,637.92c5.22,33.91.2,59.3-5.51,76.42,0,0-27.87,60.85-27.87,60.85h0s-5.66-9.62-11.9-21.85c-7.39-14.46-12.58-28.47-15.38-37.44-9.59-30.66-7.35-62.67-5.61-77.98h66.28Z",
                  fill: "url(#Unbenannter_Verlauf_14)",
                  strokeWidth: "0"
                }
              ) : null,
              thruster_to_level(props.thrusters.back) >= 4 ? /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Heckantrieb_4", opacity: ".8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Heckantrieb", opacity: ".8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "m218.19,637.52c4.51,29.32.17,51.26-4.76,66.06,0,0-24.1,52.6-24.1,52.6h0s-4.89-8.32-10.29-18.89c-6.38-12.5-10.87-24.61-13.3-32.37-8.29-26.5-6.36-54.18-4.85-67.41h57.29Z",
                  fill: "url(#Unbenannter_Verlauf_14-2)",
                  strokeWidth: "0"
                }
              ) }) }) : null,
              thruster_to_level(props.thrusters.back) >= 3 ? /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Heckantrieb_3", opacity: ".8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Heckantrieb-2", "data-name": "Heckantrieb", opacity: ".8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "m213.26,637.78c3.73,24.23.14,42.37-3.94,54.6,0,0-19.92,43.48-19.92,43.48h0s-4.05-6.88-8.51-15.61c-5.28-10.33-8.99-20.34-10.99-26.75-6.85-21.91-5.25-44.78-4.01-55.72h47.35Z",
                  fill: "url(#Unbenannter_Verlauf_14-3)",
                  strokeWidth: "0"
                }
              ) }) }) : null,
              thruster_to_level(props.thrusters.back) >= 2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Heckantrieb_2", opacity: ".8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Heckantrieb-3", "data-name": "Heckantrieb", opacity: ".8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "m209.3,637.78c3.1,20.13.12,35.21-3.27,45.37,0,0-16.55,36.13-16.55,36.13h0s-3.36-5.71-7.07-12.97c-4.39-8.59-7.47-16.9-9.13-22.23-5.69-18.2-4.37-37.21-3.33-46.3h39.35Z",
                  fill: "url(#Unbenannter_Verlauf_14-4)",
                  strokeWidth: "0"
                }
              ) }) }) : null,
              thruster_to_level(props.thrusters.back) >= 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Heckantrieb_1", opacity: ".8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Heckantrieb-4", "data-name": "Heckantrieb", opacity: ".8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "m205.92,637.52c2.56,16.64.1,29.1-2.7,37.5,0,0-13.68,29.86-13.68,29.86h0s-2.78-4.72-5.84-10.72c-3.62-7.1-6.17-13.97-7.55-18.37-4.71-15.05-3.61-30.75-2.75-38.27h32.52Z",
                  fill: "url(#Unbenannter_Verlauf_14-5)",
                  strokeWidth: "0"
                }
              ) }) }) : null,
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  id: "Rumpf-2",
                  "data-name": "Rumpf",
                  d: "m246.37,177.89l-.05-.15s-10.41-26.97-18.86-37.22c-8.45-10.25-26.79-28.33-37.2-28.33s-29.98,17.69-39.46,31.29c-9.48,13.61-17.82,34.19-17.82,34.19,0,0-5.23,25.2-5.23,46.07s-.17,399.2-.17,399.2c2.17,6.27,16.32,45.31,23.1,45.31h79.91c5.79,0,20.47-44.59,20.47-44.59l.16-.56V227.34c0-17.85-4.43-46.8-4.84-49.45Z",
                  fill: "#b2b2b2",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            ] }),
            props.name.length < 8 ? /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `translate(160, 400)`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `rotate(90 0 0)`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("text", { style: { fontSize: "70pt" }, children: props.name }) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `translate(175, 400)`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `rotate(90 0 0)`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "text",
              {
                style: { fontSize: "40pt" },
                textLength: "130pt",
                lengthAdjust: "spacingAndGlyphs",
                children: props.name
              }
            ) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Fenster", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                id: "Kopf_Fenster",
                d: "m189.5,121c17.74-.54,23.05,12.75,23.1,14.31h0c.05,1.56-5.66-8.33-22.47-7.82-16.81.51-21.9,10.72-21.95,9.17h0c-.05-1.56,3.58-15.11,21.32-15.65Z",
                fill: "#fbf7ca",
                opacity: ".5",
                strokeWidth: "0"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Raumschiffenergie", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "rect",
                {
                  id: "Ladestation_Schutzschild",
                  "data-name": "Ladestation Schutzschild",
                  x: "164.71",
                  y: "585.92",
                  width: "53.46",
                  height: "27.03",
                  fill: "#878787",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Schutzschildladung", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    id: "Linie9",
                    x1: "169.07",
                    y1: "611.16",
                    x2: "169.07",
                    y2: "587.68",
                    fill: "none",
                    stroke: "#dedc00",
                    strokeMiterlimit: "10",
                    strokeWidth: "2"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    id: "Linie1",
                    x1: "213.78",
                    y1: "611.16",
                    x2: "213.78",
                    y2: "587.68",
                    fill: "none",
                    stroke: "#dedc00",
                    strokeMiterlimit: "10",
                    strokeWidth: "2"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    id: "Linie5",
                    x1: "191.42",
                    y1: "611.16",
                    x2: "191.42",
                    y2: "587.68",
                    fill: "none",
                    stroke: "#dedc00",
                    strokeMiterlimit: "10",
                    strokeWidth: "2"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    id: "Linie8",
                    x1: "174.66",
                    y1: "611.16",
                    x2: "174.66",
                    y2: "587.68",
                    fill: "none",
                    stroke: "#dedc00",
                    strokeMiterlimit: "10",
                    strokeWidth: "2"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    id: "Linie7",
                    x1: "180.25",
                    y1: "611.16",
                    x2: "180.25",
                    y2: "587.68",
                    fill: "none",
                    stroke: "#dedc00",
                    strokeMiterlimit: "10",
                    strokeWidth: "2"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    id: "Linie6",
                    x1: "185.83",
                    y1: "611.16",
                    x2: "185.83",
                    y2: "587.68",
                    fill: "none",
                    stroke: "#dedc00",
                    strokeMiterlimit: "10",
                    strokeWidth: "2"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    id: "Linie4",
                    x1: "197.01",
                    y1: "611.16",
                    x2: "197.01",
                    y2: "587.68",
                    fill: "none",
                    stroke: "#dedc00",
                    strokeMiterlimit: "10",
                    strokeWidth: "2"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    id: "Linie3",
                    x1: "202.6",
                    y1: "611.16",
                    x2: "202.6",
                    y2: "587.68",
                    fill: "none",
                    stroke: "#dedc00",
                    strokeMiterlimit: "10",
                    strokeWidth: "2"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    id: "Linie2",
                    x1: "208.19",
                    y1: "611.16",
                    x2: "208.19",
                    y2: "587.68",
                    fill: "none",
                    stroke: "#dedc00",
                    strokeMiterlimit: "10",
                    strokeWidth: "2"
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Antenne", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  id: "Drehunterbau",
                  cx: "189.53",
                  cy: "287.29",
                  r: "7.83",
                  fill: "#9d9d9c",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Schüssel", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "189.52",
                    y1: "291.95",
                    x2: "189.52",
                    y2: "275.84",
                    fill: "none",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m217.47,277.32c0,8.25-12.51,14.94-27.94,14.94s-27.94-6.69-27.94-14.94h55.87Z",
                    fill: "#9d9d9c",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "circle",
                  {
                    cx: "189.52",
                    cy: "273.45",
                    r: "2.29",
                    fill: "#9d9d9c",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                )
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Schutzschild_Ladung", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  id: "Stufe1",
                  cx: "189.42",
                  cy: "365.85",
                  r: "26.41",
                  fill: "#9d9d9c",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  id: "Stufe2",
                  cx: "189.38",
                  cy: "365.39",
                  r: "21.97",
                  fill: "#29235c",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  id: "Stufe3",
                  cx: "189.42",
                  cy: "365.85",
                  r: "18.11",
                  fill: "#2d2e83",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  id: "Stufe4",
                  cx: "189.42",
                  cy: "365.85",
                  r: "13.37",
                  fill: "#1d71b8",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  id: "Stufe5",
                  cx: "189.42",
                  cy: "365.31",
                  r: "9.3",
                  fill: "#009fe3",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Laser", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Aufbau", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "polygon",
                  {
                    id: "Aufbau-2",
                    "data-name": "Aufbau",
                    points: "199.75 178.45 178.97 178.45 168.58 196.45 178.97 214.44 199.75 214.44 210.13 196.45 199.75 178.45",
                    fill: "#9d9d9c",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "circle",
                  {
                    cx: "189.39",
                    cy: "196.41",
                    r: "10.5",
                    fill: "#9d9d9c",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  id: "Linie9-2",
                  "data-name": "Linie9",
                  x1: "182.71",
                  y1: "212.6",
                  x2: "182.71",
                  y2: "209.34",
                  fill: "none",
                  stroke: "#e94e1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  id: "Linie1-2",
                  "data-name": "Linie1",
                  x1: "196.77",
                  y1: "212.6",
                  x2: "196.77",
                  y2: "209.34",
                  fill: "none",
                  stroke: "#e94e1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  id: "Linie5-2",
                  "data-name": "Linie5",
                  x1: "189.74",
                  y1: "212.6",
                  x2: "189.74",
                  y2: "209.34",
                  fill: "none",
                  stroke: "#e94e1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  id: "Linie8-2",
                  "data-name": "Linie8",
                  x1: "184.47",
                  y1: "212.6",
                  x2: "184.47",
                  y2: "209.34",
                  fill: "none",
                  stroke: "#e94e1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  id: "Linie7-2",
                  "data-name": "Linie7",
                  x1: "186.23",
                  y1: "212.6",
                  x2: "186.23",
                  y2: "209.34",
                  fill: "none",
                  stroke: "#e94e1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  id: "Linie6-2",
                  "data-name": "Linie6",
                  x1: "187.99",
                  y1: "212.6",
                  x2: "187.99",
                  y2: "209.34",
                  fill: "none",
                  stroke: "#e94e1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  id: "Linie4-2",
                  "data-name": "Linie4",
                  x1: "191.5",
                  y1: "212.6",
                  x2: "191.5",
                  y2: "209.34",
                  fill: "none",
                  stroke: "#e94e1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  id: "Linie3-2",
                  "data-name": "Linie3",
                  x1: "193.26",
                  y1: "212.6",
                  x2: "193.26",
                  y2: "209.34",
                  fill: "none",
                  stroke: "#e94e1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  id: "Linie2-2",
                  "data-name": "Linie2",
                  x1: "195.01",
                  y1: "212.6",
                  x2: "195.01",
                  y2: "209.34",
                  fill: "none",
                  stroke: "#e94e1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "g",
                {
                  transform: `rotate(${props.laser.angle} 189.5 196.5)`,
                  id: "Kanone",
                  children: [
                    props.laser.active ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "line",
                      {
                        x1: "189.5",
                        y1: "180",
                        x2: "189.5",
                        y2: 180 - props.laser.length * 3.3,
                        stroke: "red",
                        strokeWidth: 3.5,
                        opacity: 0.8
                      }
                    ) : null,
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "rect",
                      {
                        id: "Kanone-2",
                        "data-name": "Kanone",
                        x: "185.09",
                        y: "190.43",
                        width: "8.75",
                        height: "11.65",
                        fill: "#706f6f",
                        stroke: "#1d1d1b",
                        strokeMiterlimit: "10",
                        strokeWidth: ".5"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "rect",
                      {
                        id: "Kanone-3",
                        "data-name": "Kanone",
                        x: "188.04",
                        y: "179.15",
                        width: "2.84",
                        height: "11.28",
                        fill: "#706f6f",
                        stroke: "#1d1d1b",
                        strokeMiterlimit: "10",
                        strokeWidth: ".5"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "rect",
                      {
                        id: "Kanone-4",
                        "data-name": "Kanone",
                        x: "186.68",
                        y: "174.82",
                        width: "5.56",
                        height: "4.4",
                        fill: "#706f6f",
                        stroke: "#1d1d1b",
                        strokeMiterlimit: "10",
                        strokeWidth: ".5"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "rect",
                      {
                        id: "Kanone-5",
                        "data-name": "Kanone",
                        x: "188.04",
                        y: "170.23",
                        width: "2.84",
                        height: "4.52",
                        fill: "#706f6f",
                        stroke: "#1d1d1b",
                        strokeMiterlimit: "10",
                        strokeWidth: ".5"
                      }
                    )
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Düsen", children: [
              thruster_to_level(props.thrusters.bottomleft) >= 5 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_hinten_links_5",
                  "data-name": "Flamme hinten links_5",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m95.71,560.88c-11.85,1.32-20.73.05-26.71-1.4,0,0-21.27-7.07-21.27-7.07h0s3.36-1.44,7.64-3.02c5.06-1.87,9.95-3.19,13.09-3.9,10.72-2.43,21.91-1.86,27.26-1.42v16.8Z",
                      fill: "url(#Unbenannter_Verlauf_14-6)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.topleft) >= 5 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_vorne_links_5",
                  "data-name": "Flamme vorne links_5",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m97.09,247.36c-11.85,1.32-20.73.05-26.71-1.4,0,0-21.27-7.07-21.27-7.07h0s3.36-1.44,7.64-3.02c5.06-1.87,9.95-3.19,13.09-3.9,10.72-2.43,21.91-1.86,27.26-1.42v16.8Z",
                      fill: "url(#Unbenannter_Verlauf_14-7)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.sideup) >= 5 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_Bremse_rechts_5",
                  "data-name": "Flamme Bremse rechts_5",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m256.81,492.54c-1.32-11.85-.05-20.73,1.4-26.71,0,0,7.07-21.27,7.07-21.27h0s1.44,3.36,3.02,7.64c1.87,5.06,3.19,9.95,3.9,13.09,2.43,10.72,1.86,21.91,1.42,27.26h-16.8Z",
                      fill: "url(#Unbenannter_Verlauf_14-8)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.sideup) >= 5 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_Bremse_links_5",
                  "data-name": "Flamme Bremse links_5",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m105.88,491.62c-1.32-11.85-.05-20.73,1.4-26.71,0,0,7.07-21.27,7.07-21.27h0s1.44,3.36,3.02,7.64c1.87,5.06,3.19,9.95,3.9,13.09,2.43,10.72,1.86,21.91,1.42,27.26h-16.8Z",
                      fill: "url(#Unbenannter_Verlauf_14-9)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.topright) >= 5 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_vorne_rechts_5",
                  "data-name": "Flamme vorne rechts_5",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m283.01,232.1c11.85-1.32,20.73-.05,26.71,1.4,0,0,21.27,7.07,21.27,7.07h0s-3.36,1.44-7.64,3.02c-5.06,1.87-9.95,3.19-13.09,3.9-10.72,2.43-21.91,1.86-27.26,1.42v-16.8Z",
                      fill: "url(#Unbenannter_Verlauf_14-10)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.bottomright) >= 5 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_hinten_rechts_5",
                  "data-name": "Flamme hinten rechts_5",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m283.01,545.62c11.85-1.32,20.73-.05,26.71,1.4,0,0,21.27,7.07,21.27,7.07h0s-3.36,1.44-7.64,3.02c-5.06,1.87-9.95,3.19-13.09,3.9-10.72,2.43-21.91,1.86-27.26,1.42v-16.8Z",
                      fill: "url(#Unbenannter_Verlauf_14-11)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.bottomleft) >= 4 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_hinten_links_4",
                  "data-name": "Flamme hinten links_4",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m95.71,560.09c-10.62,1.18-18.57.05-23.94-1.25,0,0-19.06-6.33-19.06-6.33h0s3.01-1.29,6.84-2.7c4.53-1.68,8.92-2.86,11.73-3.49,9.6-2.18,19.63-1.67,24.43-1.27v15.05Z",
                      fill: "url(#Unbenannter_Verlauf_14-12)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.topleft) >= 4 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_vorne_links_4",
                  "data-name": "Flamme vorne links_4",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m97.03,246.5c-10.62,1.18-18.57.05-23.94-1.25,0,0-19.06-6.33-19.06-6.33h0s3.01-1.29,6.84-2.7c4.53-1.68,8.92-2.86,11.73-3.49,9.6-2.18,19.63-1.67,24.43-1.27v15.05Z",
                      fill: "url(#Unbenannter_Verlauf_14-13)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.sideup) >= 4 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_Bremse_rechts_4",
                  "data-name": "Flamme Bremse rechts_4",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m257.68,492.54c-1.18-10.62-.05-18.57,1.25-23.94,0,0,6.33-19.06,6.33-19.06h0s1.29,3.01,2.7,6.84c1.68,4.53,2.86,8.92,3.49,11.73,2.18,9.6,1.67,19.63,1.27,24.43h-15.05Z",
                      fill: "url(#Unbenannter_Verlauf_14-14)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.sideup) >= 4 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_Bremse_links_4",
                  "data-name": "Flamme Bremse links_4",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m106.56,492.54c-1.18-10.62-.05-18.57,1.25-23.94,0,0,6.33-19.06,6.33-19.06h0s1.29,3.01,2.7,6.84c1.68,4.53,2.86,8.92,3.49,11.73,2.18,9.6,1.67,19.63,1.27,24.43h-15.05Z",
                      fill: "url(#Unbenannter_Verlauf_14-15)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.topright) >= 4 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_vorne_rechts_4",
                  "data-name": "Flamme vorne rechts_4",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m283.01,232.96c10.62-1.18,18.57-.05,23.94,1.25,0,0,19.06,6.33,19.06,6.33h0s-3.01,1.29-6.84,2.7c-4.53,1.68-8.92,2.86-11.73,3.49-9.6,2.18-19.63,1.67-24.43,1.27v-15.05Z",
                      fill: "url(#Unbenannter_Verlauf_14-16)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.bottomright) >= 4 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_hinten_rechts_4",
                  "data-name": "Flamme hinten rechts_4",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m283.09,546.48c10.62-1.18,18.57-.05,23.94,1.25,0,0,19.06,6.33,19.06,6.33h0s-3.01,1.29-6.84,2.7c-4.53,1.68-8.92,2.86-11.73,3.49-9.6,2.18-19.63,1.67-24.43,1.27v-15.05Z",
                      fill: "url(#Unbenannter_Verlauf_14-17)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.bottomleft) >= 3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_hinten_links_3",
                  "data-name": "Flamme hinten links_3",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m97.18,559.64c-9.98,1.11-17.45.04-22.48-1.18,0,0-17.9-5.95-17.9-5.95h0s2.83-1.21,6.43-2.54c4.26-1.58,8.38-2.68,11.02-3.28,9.02-2.05,18.44-1.57,22.94-1.2v14.14Z",
                      fill: "url(#Unbenannter_Verlauf_14-18)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.topleft) >= 3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_vorne_links_3",
                  "data-name": "Flamme vorne links_3",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m97.18,245.89c-9.98,1.11-17.45.04-22.48-1.18,0,0-17.9-5.95-17.9-5.95h0s2.83-1.21,6.43-2.54c4.26-1.58,8.38-2.68,11.02-3.28,9.02-2.05,18.44-1.57,22.94-1.2v14.14Z",
                      fill: "url(#Unbenannter_Verlauf_14-19)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.sideup) >= 3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_Bremse_rechts_3",
                  "data-name": "Flamme Bremse rechts_3",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m258.13,492.7c-1.11-9.98-.04-17.45,1.18-22.48,0,0,5.95-17.9,5.95-17.9h0s1.21,2.83,2.54,6.43c1.58,4.26,2.68,8.38,3.28,11.02,2.05,9.02,1.57,18.44,1.2,22.94h-14.14Z",
                      fill: "url(#Unbenannter_Verlauf_14-20)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.sideup) >= 3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_Bremse_links_3",
                  "data-name": "Flamme Bremse links_3",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m107.01,492.54c-1.11-9.98-.04-17.45,1.18-22.48,0,0,5.95-17.9,5.95-17.9h0s1.21,2.83,2.54,6.43c1.58,4.26,2.68,8.38,3.28,11.02,2.05,9.02,1.57,18.44,1.2,22.94h-14.14Z",
                      fill: "url(#Unbenannter_Verlauf_14-21)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.topright) >= 3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_vorne_rechts_3",
                  "data-name": "Flamme vorne rechts_3",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m282.92,233.42c9.98-1.11,17.45-.04,22.48,1.18,0,0,17.9,5.95,17.9,5.95h0s-2.83,1.21-6.43,2.54c-4.26,1.58-8.38,2.68-11.02,3.28-9.02,2.05-18.44,1.57-22.94,1.2v-14.14Z",
                      fill: "url(#Unbenannter_Verlauf_14-22)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.bottomright) >= 3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_hinten_rechts_3",
                  "data-name": "Flamme hinten rechts_3",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m283.09,546.94c9.98-1.11,17.45-.04,22.48,1.18,0,0,17.9,5.95,17.9,5.95h0s-2.83,1.21-6.43,2.54c-4.26,1.58-8.38,2.68-11.02,3.28-9.02,2.05-18.44,1.57-22.94,1.2v-14.14Z",
                      fill: "url(#Unbenannter_Verlauf_14-23)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.bottomleft) >= 2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_hinten_links_2",
                  "data-name": "Flamme hinten links_2",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m97.18,558.59c-8.48.95-14.83.04-19.11-1,0,0-15.21-5.05-15.21-5.05h0s2.41-1.03,5.46-2.16c3.62-1.34,7.12-2.28,9.36-2.79,7.67-1.74,15.67-1.33,19.5-1.02v12.01Z",
                      fill: "url(#Unbenannter_Verlauf_14-24)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.topleft) >= 2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_vorne_links_2",
                  "data-name": "Flamme vorne links_2",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m97.19,244.84c-8.48.95-14.83.04-19.11-1,0,0-15.21-5.05-15.21-5.05h0s2.41-1.03,5.46-2.16c3.62-1.34,7.12-2.28,9.36-2.79,7.67-1.74,15.67-1.33,19.5-1.02v12.01Z",
                      fill: "url(#Unbenannter_Verlauf_14-25)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.sideup) >= 2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_Bremse_rechts_2",
                  "data-name": "Flamme Bremse rechts_2",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m259.25,492.92c-.95-8.48-.04-14.83,1-19.11,0,0,5.05-15.21,5.05-15.21h0s1.03,2.41,2.16,5.46c1.34,3.62,2.28,7.12,2.79,9.36,1.74,7.67,1.33,15.67,1.02,19.5h-12.01Z",
                      fill: "url(#Unbenannter_Verlauf_14-26)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.sideup) >= 2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_Bremse_links_2",
                  "data-name": "Flamme Bremse links_2",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m108.06,492.54c-.95-8.48-.04-14.83,1-19.11,0,0,5.05-15.21,5.05-15.21h0s1.03,2.41,2.16,5.46c1.34,3.62,2.28,7.12,2.79,9.36,1.74,7.67,1.33,15.67,1.02,19.5h-12.01Z",
                      fill: "url(#Unbenannter_Verlauf_14-27)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.topright) >= 2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_vorne_rechts_2",
                  "data-name": "Flamme vorne rechts_2",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m282.92,234.18c8.48-.95,14.83-.04,19.11,1,0,0,15.21,5.05,15.21,5.05h0s-2.41,1.03-5.46,2.16c-3.62,1.34-7.12,2.28-9.36,2.79-7.67,1.74-15.67,1.33-19.5,1.02v-12.01Z",
                      fill: "url(#Unbenannter_Verlauf_14-28)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.bottomright) >= 2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_hinten_rechts_2",
                  "data-name": "Flamme hinten rechts_2",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m282.92,547.99c8.48-.95,14.83-.04,19.11,1,0,0,15.21,5.05,15.21,5.05h0s-2.41,1.03-5.46,2.16c-3.62,1.34-7.12,2.28-9.36,2.79-7.67,1.74-15.67,1.33-19.5,1.02v-12.01Z",
                      fill: "url(#Unbenannter_Verlauf_14-29)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.bottomleft) >= 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_hinten_links_1",
                  "data-name": "Flamme hinten links_1",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m97.18,557.11c-6.8.76-11.89.03-15.32-.8,0,0-12.2-4.05-12.2-4.05h0s1.93-.82,4.38-1.73c2.9-1.07,5.71-1.83,7.51-2.24,6.15-1.39,12.56-1.07,15.63-.82v9.63Z",
                      fill: "url(#Unbenannter_Verlauf_14-30)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.topleft) >= 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_vorne_links_1",
                  "data-name": "Flamme vorne links_1",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m97.18,243.66c-6.8.76-11.89.03-15.32-.8,0,0-12.2-4.05-12.2-4.05h0s1.93-.82,4.38-1.73c2.9-1.07,5.71-1.83,7.51-2.24,6.15-1.39,12.56-1.07,15.63-.82v9.63Z",
                      fill: "url(#Unbenannter_Verlauf_14-31)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.sideup) >= 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_Bremse_rechts_1",
                  "data-name": "Flamme Bremse rechts_1",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m260.43,492.54c-.76-6.8-.03-11.89.8-15.32,0,0,4.05-12.2,4.05-12.2h0s.82,1.93,1.73,4.38c1.07,2.9,1.83,5.71,2.24,7.51,1.39,6.15,1.07,12.56.82,15.63h-9.63Z",
                      fill: "url(#Unbenannter_Verlauf_14-32)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.sideup) >= 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_Bremse_links_1",
                  "data-name": "Flamme Bremse links_1",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m109.24,492.54c-.76-6.8-.03-11.89.8-15.32,0,0,4.05-12.2,4.05-12.2h0s.82,1.93,1.73,4.38c1.07,2.9,1.83,5.71,2.24,7.51,1.39,6.15,1.07,12.56.82,15.63h-9.63Z",
                      fill: "url(#Unbenannter_Verlauf_14-33)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.topright) >= 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_vorne_rechts_1",
                  "data-name": "Flamme vorne rechts_1",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m282.92,235.36c6.8-.76,11.89-.03,15.32.8,0,0,12.2,4.05,12.2,4.05h0s-1.93.82-4.38,1.73c-2.9,1.07-5.71,1.83-7.51,2.24-6.15,1.39-12.56,1.07-15.63.82v-9.63Z",
                      fill: "url(#Unbenannter_Verlauf_14-34)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              thruster_to_level(props.thrusters.bottomright) >= 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Flamme_hinten_rechts_1",
                  "data-name": "Flamme hinten rechts_1",
                  opacity: ".8",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "m282.92,549.17c6.8-.76,11.89-.03,15.32.8,0,0,12.2,4.05,12.2,4.05h0s-1.93.82-4.38,1.73c-2.9,1.07-5.71,1.83-7.51,2.24-6.15,1.39-12.56,1.07-15.63.82v-9.63Z",
                      fill: "url(#Unbenannter_Verlauf_14-35)",
                      strokeWidth: "0"
                    }
                  )
                }
              ) : null,
              /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Bremse_links", "data-name": "Bremse links", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m109.3,487.79h9.11c7.01,0,10.75,8.05,10.75,11.05l-.9,24.9c0,3-5.68,5.44-12.69,5.44h-5.1c-7.01,0-12.69-2.44-12.69-5.44l.9-24.9c0-3,3.62-11.05,10.62-11.05Z",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m129.16,498.73s-7.42-.77-16.11-.77-14.18.77-14.18.77",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "122.2",
                    y1: "498.06",
                    x2: "117.5",
                    y2: "487.79",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "105.65",
                    y1: "497.96",
                    x2: "110.48",
                    y2: "487.85",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Bremse_rechts", "data-name": "Bremse rechts", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m260.08,487.78h9.11c7.01,0,10.75,8.05,10.75,11.05l-.9,24.9c0,3-5.68,5.44-12.69,5.44h-5.1c-7.01,0-12.69-2.44-12.69-5.44l.9-24.9c0-3,3.62-11.05,10.62-11.05Z",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m279.93,498.72s-7.43-.77-16.11-.77-14.18.77-14.18.77",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "272.98",
                    y1: "498.06",
                    x2: "268.27",
                    y2: "487.78",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "256.43",
                    y1: "497.95",
                    x2: "261.28",
                    y2: "487.78",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Düse_hinten_links", "data-name": "Düse hinten links", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m91.71,556.51v-9.11c0-7.01,8.05-10.75,11.05-10.75l24.9.9c3,0,5.44,5.68,5.44,12.69v5.1c0,7.01-2.44,12.69-5.44,12.69l-24.9-.9c-3,0-11.05-3.62-11.05-10.62Z",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m102.65,536.65s-.77,7.46-.77,16.19.77,14.26.77,14.26",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "101.98",
                    y1: "543.61",
                    x2: "91.71",
                    y2: "548.31",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "101.88",
                    y1: "560.16",
                    x2: "91.77",
                    y2: "555.33",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Düse_hinten_rechts", "data-name": "Düse hinten rechts", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m287.39,548.47v9.11c0,7.01-8.05,10.75-11.05,10.75l-24.9-.9c-3,0-5.44-5.68-5.44-12.69v-5.1c0-7.01,2.44-12.69,5.44-12.69l24.9.9c3,0,11.05,3.62,11.05,10.62Z",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m276.45,568.33s.77-7.42.77-16.1-.77-14.17-.77-14.17",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "277.12",
                    y1: "561.37",
                    x2: "287.39",
                    y2: "556.67",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "277.22",
                    y1: "544.82",
                    x2: "287.27",
                    y2: "549.62",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Düse_vorne_links", "data-name": "Düse vorne links", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m91.9,243.73v-9.11c0-7.01,8.05-10.75,11.05-10.75l24.9.9c3,0,5.44,5.68,5.44,12.69v5.1c0,7.01-2.44,12.69-5.44,12.69l-24.9-.9c-3,0-11.05-3.62-11.05-10.62Z",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m102.84,223.87s-.77,7.36-.77,15.97.77,14.06.77,14.06",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "102.17",
                    y1: "230.83",
                    x2: "91.9",
                    y2: "235.53",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "102.28",
                    y1: "247.48",
                    x2: "92.11",
                    y2: "242.73",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Düse_vorne_rechts", "data-name": "Düse vorne rechts", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m287.75,235.43v9.11c0,7.01-8.05,10.75-11.05,10.75l-24.9-.9c-3,0-5.44-5.68-5.44-12.69v-5.1c0-7.01,2.44-12.69,5.44-12.69l24.9.9c3,0,11.05,3.62,11.05,10.62Z",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "m276.81,255.29s.77-7.43.77-16.12-.77-14.2-.77-14.2",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "277.48",
                    y1: "248.33",
                    x2: "287.75",
                    y2: "243.62",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "277.58",
                    y1: "231.78",
                    x2: "287.59",
                    y2: "236.56",
                    fill: "#b2b2b2",
                    stroke: "#1d1d1b",
                    strokeMiterlimit: "10",
                    strokeWidth: ".5"
                  }
                )
              ] })
            ] }),
            null
          ]
        }
      ) }) });
    }
    function SpaceStation(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "scale(1 1)", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `rotate(${props.angle} 0 0)`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { transform: "translate(-130.000000,-130.000000) scale(1.000000,1.000000)", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "polygon",
          {
            id: "Gang_quer_oben",
            "data-name": "Gang quer oben",
            points: "143.07 100.96 119.22 100.96 116.59 .25 146.31 .25 143.07 100.96",
            fill: "#9d9d9c",
            stroke: "#1d1d1b",
            strokeMiterlimit: "10",
            strokeWidth: ".5"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "polygon",
          {
            id: "Gang_quer_unten",
            "data-name": "Gang quer unten",
            points: "118.21 150.73 142.06 150.73 144.69 258.37 114.97 258.37 118.21 150.73",
            fill: "#9d9d9c",
            stroke: "#1d1d1b",
            strokeMiterlimit: "10",
            strokeWidth: ".5"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "polygon",
          {
            id: "Gang_quer_rechts",
            "data-name": "Gang quer rechts",
            points: "153.67 136.51 153.67 112.66 259.41 110.03 259.41 139.75 153.67 136.51",
            fill: "#9d9d9c",
            stroke: "#1d1d1b",
            strokeMiterlimit: "10",
            strokeWidth: ".5"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "polygon",
          {
            id: "Gang_quer_links",
            "data-name": "Gang quer links",
            points: "106.26 117.09 106.26 140.94 .25 143.57 .25 113.85 106.26 117.09",
            fill: "#9d9d9c",
            stroke: "#1d1d1b",
            strokeMiterlimit: "10",
            strokeWidth: ".5"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            id: "Ring",
            d: "m129.83,11.13C64.85,11.13,12.17,63.81,12.17,128.79s52.68,117.66,117.66,117.66,117.66-52.68,117.66-117.66S194.81,11.13,129.83,11.13Zm0,200.67c-45.85,0-83.01-37.17-83.01-83.01s37.17-83.01,83.01-83.01,83.01,37.17,83.01,83.01-37.17,83.01-83.01,83.01Z",
            fill: "#b2b2b2",
            stroke: "#1d1d1b",
            strokeMiterlimit: "10",
            strokeWidth: ".5"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Mittelteil", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "circle",
            {
              cx: "129.83",
              cy: "126.41",
              r: "30.71",
              fill: "#9d9d9c",
              stroke: "#1d1d1b",
              strokeMiterlimit: "10",
              strokeWidth: ".5"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "circle",
            {
              cx: "129.83",
              cy: "126.41",
              r: "18.25",
              fill: "#b2b2b2",
              stroke: "#1d1d1b",
              strokeMiterlimit: "10",
              strokeWidth: ".5"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Kommunikationseinheit_2", "data-name": "Kommunikationseinheit 2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "circle",
            {
              id: "Drehunterbau",
              cx: "135.2",
              cy: "121.93",
              r: "3.71",
              fill: "#706f6f",
              stroke: "#1d1d1b",
              strokeMiterlimit: "10",
              strokeWidth: ".5"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Schüssel", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "line",
              {
                x1: "134.57",
                y1: "124.05",
                x2: "136.73",
                y2: "116.72",
                fill: "#706f6f",
                stroke: "#1d1d1b",
                strokeMiterlimit: "10",
                strokeWidth: ".5"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m149.24,121.15c-1.11,3.75-7.69,5.11-14.7,3.03s-11.8-6.79-10.69-10.54l25.39,7.51Z",
                fill: "#706f6f",
                stroke: "#1d1d1b",
                strokeMiterlimit: "10",
                strokeWidth: ".5"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                cx: "137.06",
                cy: "115.64",
                r: "1.09",
                fill: "#706f6f",
                stroke: "#1d1d1b",
                strokeMiterlimit: "10",
                strokeWidth: ".5"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Kommunikationseinheit_1", "data-name": "Kommunikationseinheit 1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "circle",
            {
              id: "Drehunterbau-2",
              "data-name": "Drehunterbau",
              cx: "123.76",
              cy: "138.78",
              r: "4.75",
              fill: "#706f6f",
              stroke: "#1d1d1b",
              strokeMiterlimit: "10",
              strokeWidth: ".5"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Schüssel-2", "data-name": "Schüssel", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "line",
              {
                x1: "126.55",
                y1: "138.31",
                x2: "116.91",
                y2: "139.94",
                fill: "#706f6f",
                stroke: "#1d1d1b",
                strokeMiterlimit: "10",
                strokeWidth: ".5"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m114.97,123.07c4.94-.83,10.2,5.97,11.76,15.2,1.56,9.23-1.17,17.39-6.11,18.23l-5.66-33.43Z",
                fill: "#706f6f",
                stroke: "#1d1d1b",
                strokeMiterlimit: "10",
                strokeWidth: ".5"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                cx: "115.48",
                cy: "140.18",
                r: "1.39",
                fill: "#706f6f",
                stroke: "#1d1d1b",
                strokeMiterlimit: "10",
                strokeWidth: ".5"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "123.6",
                  y1: "246.09",
                  x2: "125.39",
                  y2: "211.36",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-2",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "94.57",
                  y1: "240.9",
                  x2: "104.95",
                  y2: "207.7",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-3",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "67.76",
                  y1: "228.64",
                  x2: "86.06",
                  y2: "199.07",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-4",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "44.83",
                  y1: "210.1",
                  x2: "69.91",
                  y2: "186.01",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-5",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "27.23",
                  y1: "186.45",
                  x2: "57.52",
                  y2: "169.35",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-6",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "16.07",
                  y1: "159.15",
                  x2: "49.65",
                  y2: "150.13",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-7",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "12.04",
                  y1: "129.94",
                  x2: "46.82",
                  y2: "129.55",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-8",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "15.41",
                  y1: "100.65",
                  x2: "49.19",
                  y2: "108.92",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-9",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "25.96",
                  y1: "73.12",
                  x2: "56.62",
                  y2: "89.53",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-10",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "43.02",
                  y1: "49.07",
                  x2: "68.64",
                  y2: "72.59",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-11",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "65.53",
                  y1: "30.02",
                  x2: "84.49",
                  y2: "59.17",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-12",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "92.06",
                  y1: "17.17",
                  x2: "103.18",
                  y2: "50.12",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-13",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "120.96",
                  y1: "11.32",
                  x2: "123.53",
                  y2: "46",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-14",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "150.41",
                  y1: "12.84",
                  x2: "144.28",
                  y2: "47.07",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-15",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "178.55",
                  y1: "21.63",
                  x2: "164.1",
                  y2: "53.27",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-16",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "203.62",
                  y1: "37.15",
                  x2: "181.76",
                  y2: "64.2",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-17",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "224.05",
                  y1: "58.42",
                  x2: "196.14",
                  y2: "79.18",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-18",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "238.54",
                  y1: "84.1",
                  x2: "206.35",
                  y2: "97.26",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-19",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "246.19",
                  y1: "112.57",
                  x2: "211.74",
                  y2: "117.32",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-20",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "246.52",
                  y1: "142.05",
                  x2: "211.97",
                  y2: "138.08",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-21",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "239.51",
                  y1: "170.69",
                  x2: "207.04",
                  y2: "158.26",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-22",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "225.6",
                  y1: "196.69",
                  x2: "197.23",
                  y2: "176.57",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-23",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "205.66",
                  y1: "218.41",
                  x2: "183.19",
                  y2: "191.86",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-24",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "180.94",
                  y1: "234.49",
                  x2: "165.78",
                  y2: "203.19",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "_Radiale_Wiederholung_-25",
              "data-name": "&lt;Radiale Wiederholung&gt;",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: "153",
                  y1: "243.91",
                  x2: "146.1",
                  y2: "209.83",
                  fill: "none",
                  stroke: "#1d1d1b",
                  strokeMiterlimit: "10",
                  strokeWidth: ".5"
                }
              )
            }
          )
        ] })
      ] }) }) });
    }
    function Asteroid(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "scale(0.1 0.1)", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `rotate(${props.angle} 0 0)`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "g",
        {
          transform: `translate(${-1e3 / 2},${-1e3 / 2}) scale(1.000000,1.000000)`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { transform: "translate(0.000000,511.000000) scale(0.100000,-0.100000)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5292.6,4765.9c-162.1-10.7-238.9-25.6-320-64c-168.5-83.2-379.7-315.7-667.6-742.3c-160-234.6-309.3-430.9-377.6-494.9c-192-172.8-320-183.4-1002.5-85.3c-369,51.2-678.3,46.9-853.2-12.8c-285.8-100.3-738-755.1-1077.2-1557.1C855.8,1481,751.3,1284.7,542.2,958.3C220.2,452.8,122,213.9,105-103.9c-10.7-196.3-8.5-213.3,51.2-341.3c91.7-196.3,264.5-369,686.8-684.7c501.3-375.4,565.3-443.7,682.6-708.2c249.6-569.5,437.3-874.6,744.4-1211.6c104.5-115.2,285.8-343.4,401-511.9c364.8-524.7,614.3-744.5,970.5-857.5c309.3-98.1,507.7-121.6,1113.5-132.3c819.1-17.1,947.1,10.7,1621.1,347.7c415.9,209.1,511.9,247.4,991.9,392.5c473.6,142.9,729.5,270.9,964.2,479.9c100.2,87.5,345.5,273,543.9,411.7c889.5,612.2,1070.8,970.5,866,1721.4c-224,827.6-247.4,955.6-213.3,1171c12.8,70.4,100.2,360.5,196.2,642.1l174.9,511.9v266.6v266.6l-100.3,209c-172.8,356.2-471.4,765.8-883.1,1209.5c-125.9,134.4-390.4,424.5-588.8,644.2c-492.7,546.1-708.2,731.6-1028.1,883.1c-281.6,134.4-471.4,162.1-1175.3,168.5C5785.3,4776.5,5409.9,4774.4,5292.6,4765.9z M6572.4,4465.1c593-55.5,842.6-206.9,1437.7-863.9c166.3-185.6,433-475.7,590.8-642.1c452.2-486.3,738-866,910.8-1211.6c138.7-277.3,128-390.4-115.2-1068.7c-275.2-774.3-275.2-782.8,4.3-1838.7c42.7-157.9,70.4-328.5,76.8-456.5c10.7-189.8,8.5-215.4-44.8-330.6c-81.1-177.1-337-418.1-738-695.4c-181.3-128-415.9-307.1-520.5-401c-104.5-91.7-258.1-204.8-337-247.4c-81-42.7-364.7-147.2-631.4-234.6c-386.1-125.9-578-204.8-942.8-381.8c-251.7-121.6-531.1-243.2-618.6-268.8c-313.6-89.6-1328.9-76.8-1747,23.5c-396.8,96-573.8,238.9-930,748.7c-117.3,166.4-294.4,394.6-394.6,505.5c-347.7,384-501.3,625-708.2,1109.2c-59.7,136.5-134.4,288-166.4,334.9c-91.7,132.2-302.9,322.1-620.7,558.9C576.4-519.9,418.5-345,418.5-153c0,206.9,132.3,533.3,392.5,968.4c228.2,381.8,322.1,556.7,428.7,812.7c234.6,548.2,484.2,985.5,733.8,1275.6c115.2,134.4,145.1,157.9,251.7,187.7c142.9,40.5,305,34.1,765.8-36.3c420.2-64,755.1-51.2,942.8,32c185.6,85.3,369,285.8,652.7,714.6c243.2,369,373.3,524.7,501.3,605.8c68.3,42.7,113,49.1,418.1,59.7C6105.3,4486.4,6331.4,4486.4,6572.4,4465.1z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6702.5,2340.6c-275.2-66.1-590.9-296.5-727.4-529c-232.5-396.8-224-893.8,19.2-1260.6c422.3-637.8,1282-729.5,1815.3-194.1c467.1,471.4,465,1200.9-8.5,1674.5C7519.5,2312.8,7088.6,2434.4,6702.5,2340.6z M7129.1,2031.3c465-85.3,776.4-543.9,680.5-1002.5c-55.4-275.2-204.8-467.1-454.4-590.9c-155.7-74.7-170.6-78.9-377.5-78.9c-198.4,0-224,4.3-356.2,70.4c-78.9,38.4-189.8,115.2-243.1,170.6c-283.7,281.6-324.3,748.7-96,1079.3c123.7,181.3,339.1,317.8,554.6,354.1C6979.8,2056.9,6988.4,2056.9,7129.1,2031.3z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3577.6,1978c-337-91.7-529-439.4-418.1-755.1c138.7-394.6,659.1-524.7,987.6-247.4c181.3,155.7,249.6,445.8,153.6,669.8C4185.5,1911.8,3867.7,2059,3577.6,1978z M3891.1,1628.1c153.6-93.9,170.6-283.7,34.1-403.1c-209-183.4-554.6,32-450.1,279.4C3539.2,1658,3744,1717.7,3891.1,1628.1z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1969.3,1137.5c-375.4-93.9-633.5-477.8-637.8-949.2c-2.1-326.4,89.6-580.2,283.7-780.7c288-296.5,710.3-290.1,998.3,12.8c183.4,194.1,279.4,450.1,279.4,746.6c0,298.6-96,552.5-281.6,750.8C2434.3,1101.3,2182.6,1188.7,1969.3,1137.5z M2276.4,774.9c179.2-91.7,288-328.5,283.7-618.6c-6.4-386.1-211.2-661.3-477.8-635.7c-409.6,40.5-578.1,778.6-262.4,1145.5C1950.1,819.7,2112.2,858.1,2276.4,774.9z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5196.6-2051.4c-234.6-72.5-452.2-268.8-509.8-458.6c-32-106.6-27.7-290.1,6.4-390.3c160-447.9,868.2-612.2,1282-298.6c454.3,347.7,309.3,976.9-264.5,1145.4C5569.9-2013,5326.7-2010.9,5196.6-2051.4z M5710.7-2418.3c279.4-142.9,275.2-407.4-6.4-548.2c-241-121.6-586.6-40.5-689,157.9c-110.9,215.4,115.2,447.9,437.3,447.9C5565.6-2360.7,5618.9-2373.5,5710.7-2418.3z" })
          ] })
        }
      ) }) });
    }
    function get_mineable_asteroid_style(color2) {
      return {
        fill: color2,
        fillOpacity: 1,
        fillRule: "evenodd",
        stroke: "none",
        strokeWidth: 0.0352778
      };
    }
    function MineableAsteroid(props) {
      const offset = -100;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: "scale(1 1)", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `rotate(${props.angle} 0 0)`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "g",
        {
          transform: `translate(${offset}, ${offset}) scale(1.000000,1.000000)`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "g1415", transform: "matrix(1,0,0,1.0559068,0,-0.8657427)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 177.86014,83.295552 c 3.06564,18.856678 -1.3977,38.393518 -12.59099,54.093188 -3.15913,4.43089 -5.7651,8.26664 -8.71926,12.83688 -2.80035,4.33175 -6.89821,8.29204 -12.0463,11.28289 -5.15162,2.99402 -10.62673,4.59458 -15.78116,4.87891 -5.42114,0.30022 -10.033,0.66287 -15.43474,1.20827 -25.431754,2.5721 -51.466044,-8.32591 -67.154784,-30.76187 -2.45498,-3.51049 -4.55612,-7.16174 -6.31225,-10.91248 -1.5808,-3.37502 -4.51838,-5.53614 -8.21055,-6.04308 -5.40985,-0.74189 -9.82909,-10.99044 -10.0143,-23.589196 -0.18592,-12.601223 3.93065,-22.975712 9.31686,-23.875648 3.683,-0.614892 6.56096,-2.869142 8.0391,-6.298495 5.17595,-12.009262 13.64474,-22.775688 25.14918,-30.82008 1.5568,-1.089025 3.14148,-2.107847 4.7498,-3.057878 3.19475,-1.886656 6.81319,-4.595636 9.29816,-7.350478 9.55463,-10.594623 28.416604,-12.822062 40.594494,-3.654778 1.87854,1.414286 3.85657,2.810228 6.12705,3.421239 5.81448,1.564922 11.44869,3.8481 16.75447,6.826603 3.23109,1.812925 6.737,2.084211 10.20763,0.787753 5.38762,-2.012597 15.06255,4.275667 22.50299,14.915093 7.44079,10.640131 10.0263,21.885982 6.2872,26.255135 -2.40912,2.814814 -3.35844,6.200422 -2.7626,9.858022",
                style: get_mineable_asteroid_style("#5e88c0"),
                id: "path14"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 177.86014,83.295552 c 3.06564,18.856678 -1.3977,38.393518 -12.59099,54.093188 -3.15913,4.43089 -5.7651,8.26664 -8.71926,12.83688 -2.80035,4.33175 -6.89821,8.29204 -12.0463,11.28289 -5.15162,2.99402 -10.62673,4.59458 -15.78116,4.87891 -5.42114,0.30022 -10.033,0.66287 -15.43474,1.20827 -2.53047,0.25647 -5.06695,0.37747 -7.59848,0.36759 2.47086,-0.42898 4.67431,-1.92863 5.96583,-4.16489 1.67216,-2.89737 1.50918,-6.50205 -0.41769,-9.23643 -2.58092,-3.66042 -3.55918,-7.39069 -3.32211,-10.98197 l -0.007,0.006 -0.4826,-9.1373 C 106.8615,123.763 98.32533,115.22719 87.640746,114.66275 l 4.999217,-0.93663 c 9.154937,-1.71415 18.593157,0.81457 25.663877,6.8767 2.03518,1.74413 5.16255,2.68676 7.79745,2.19287 l -7e-4,0.002 c 6.73981,-2.79894 14.35135,-3.70876 20.99133,-1.6951 9.81604,2.97674 19.25814,-10.62285 21.46724,-19.75415 1.78329,-7.372348 -0.29916,-15.146159 -5.52979,-20.63891 -3.88374,-4.078111 -7.36953,-8.490656 -10.42318,-13.177309 l -7e-4,3.53e-4 -2.1008,-1.428045 c -8.03416,-5.461706 -18.3208,-5.461706 -25.62225,0 l 1.13948,-1.524 c 3.1376,-4.195939 7.79039,-6.990645 13.0757,-7.853539 1.77342,-0.289278 3.2692,-1.370189 4.07141,-2.94252 0.60643,-1.188861 0.76871,-2.563283 0.48437,-3.896078 -0.81316,-2.149122 -1.54623,-4.332464 -2.19746,-6.544734 -1.51835,-5.159022 -4.24497,-9.880953 -7.95372,-13.77562 l -3.00461,-3.155597 c 3.82764,1.368425 7.55226,3.059994 11.12731,5.066947 3.2311,1.812925 6.737,2.084211 10.20763,0.787753 5.38762,-2.012597 15.06255,4.275667 22.50299,14.915093 7.44079,10.640131 10.0263,21.885982 6.28721,26.255135 -2.40912,2.814814 -3.35845,6.200422 -2.76261,9.858022",
                style: get_mineable_asteroid_style("#4873ae"),
                id: "path16"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 76.432996,161.75757 c -11.80007,-5.19571 -22.37176,-13.58547 -30.30009,-24.92375 -2.45498,-3.51049 -4.55612,-7.16174 -6.31225,-10.91248 -1.5808,-3.37502 -4.51838,-5.53614 -8.21055,-6.04308 -5.40985,-0.74189 -9.82909,-10.99044 -10.0143,-23.589196 -0.18592,-12.601223 3.93065,-22.975712 9.31686,-23.875648 3.683,-0.614892 6.56096,-2.869142 8.0391,-6.298495 5.17595,-12.009262 13.64474,-22.775688 25.14918,-30.82008 1.5568,-1.089025 3.14148,-2.107847 4.7498,-3.057878 1.97555,-1.166636 4.11268,-2.647597 6.04379,-4.259439 h 3.5e-4 c -2.62361,4.397022 -4.78861,8.762295 1.62525,12.343342 6.45936,3.606448 14.352055,2.649362 21.110924,5.656792 11.06946,4.925484 19.23839,14.416265 17.87666,29.271033 -1.42981,15.605831 -11.74891,31.896409 -33.502954,33.290939 -12.23751,0.78422 -21.98829,10.53465 -22.77251,22.77286 -0.81315,12.67884 5.95348,24.61613 17.20074,30.44508",
                style: get_mineable_asteroid_style("#79a4dc"),
                id: "path18"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 173.00874,48.1102 c 6.50205,9.297812 8.92916,18.823518 5.4222,21.276382 -3.50697,2.452159 -11.62086,-3.096683 -18.12291,-12.394142 -6.50204,-9.298165 -8.92951,-18.823518 -5.42219,-21.276382 3.50732,-2.452511 11.62085,3.096683 18.1229,12.394142",
                style: get_mineable_asteroid_style("#2d4f85"),
                id: "path20"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 142.24264,156.62148 c -9.57651,5.56471 -20.75816,4.19241 -24.97491,-3.06494 -4.21675,-7.25734 0.12806,-17.65159 9.70492,-23.21595 9.57615,-5.56472 20.7578,-4.19276 24.9749,3.06493 4.21676,7.25699 -0.12841,17.65195 -9.70491,23.21596",
                style: get_mineable_asteroid_style("#acd1f0"),
                id: "path22"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 173.68008,69.354127 c -3.93348,-1.58362 -9.01524,-6.130926 -13.37205,-12.361687 -4.35715,-6.231467 -6.88445,-12.564887 -7.02169,-16.802807 3.93383,1.58362 9.01418,6.130925 13.37205,12.361687 4.3568,6.231114 6.8841,12.564181 7.02169,16.802807",
                style: get_mineable_asteroid_style("#20314b"),
                id: "path24"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 141.13809,155.71625 c -9.57651,5.56472 -20.75815,4.19241 -24.97526,-3.06458 -4.21675,-7.25735 0.12806,-17.65159 9.70492,-23.2156 9.5765,-5.56507 20.75815,-4.19206 24.97526,3.06422 4.21675,7.25735 -0.12842,17.65159 -9.70492,23.21596",
                style: get_mineable_asteroid_style("#2d4f85"),
                id: "path26"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 114.58239,147.39916 c -0.42933,-6.41315 3.85127,-13.64368 11.28536,-17.96309 7.43409,-4.32047 15.83514,-4.45841 21.19489,-0.90982 0.42933,6.41421 -3.85128,13.64404 -11.28572,17.96415 -7.43443,4.31942 -15.83513,4.45841 -21.19453,0.90876",
                style: get_mineable_asteroid_style("#20314b"),
                id: "path28"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 23.423546,96.261195 c -0.16193,-9.695392 2.85715,-17.596204 6.7437,-17.646651 3.88585,-0.0508 7.16703,7.76852 7.32861,17.464265 0.16192,9.695391 -2.8568,17.596561 -6.74335,17.647361 -3.8862,0.0497 -7.16774,-7.76888 -7.32896,-17.464975",
                style: get_mineable_asteroid_style("#acd1f0"),
                id: "path30"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 23.422486,96.261195 c -0.14252,-9.695392 2.5206,-17.596204 5.94925,-17.646651 3.42794,-0.0508 6.32248,7.76852 6.46535,17.464265 0.14288,9.695391 -2.52059,17.596561 -5.94889,17.647361 -3.42829,0.0497 -6.32283,-7.76888 -6.46571,-17.464975",
                style: get_mineable_asteroid_style("#3f659b"),
                id: "path32"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 32.509686,80.91783 c 1.90006,3.008489 3.2318,8.662812 3.3274,15.160979 0.0952,6.498171 -1.06927,12.189181 -2.87972,15.252351 -1.90042,-3.00814 -3.2318,-8.66211 -3.3274,-15.160982 -0.0956,-6.498167 1.06892,-12.189531 2.87972,-15.252348",
                style: get_mineable_asteroid_style("#20314b"),
                id: "path34"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 99.930819,30.833613 c 7.915981,0 14.372521,-3.139017 14.372521,-6.98747 0,-3.848806 -6.45654,-6.987822 -14.372521,-6.987822 -7.915276,0 -14.371463,3.139016 -14.371463,6.987822 0,3.848453 6.456187,6.98747 14.371463,6.98747",
                style: get_mineable_asteroid_style("#acd1f0"),
                id: "path36"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 99.930819,29.568199 c 7.915981,0 14.372521,-2.854678 14.372521,-6.354939 0,-3.500262 -6.45654,-6.355292 -14.372521,-6.355292 -7.915276,0 -14.371463,2.85503 -14.371463,6.355292 0,3.500261 6.456187,6.354939 14.371463,6.354939",
                style: get_mineable_asteroid_style("#3f659b"),
                id: "path38"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 112.38,26.390729 c -2.48497,1.899709 -7.12964,3.17747 -12.449181,3.17747 -5.319537,0 -9.963504,-1.277761 -12.448473,-3.17747 2.484969,-1.899355 7.128936,-3.177116 12.448473,-3.177116 5.319541,0 9.964211,1.277761 12.449181,3.177116",
                style: get_mineable_asteroid_style("#20314b"),
                id: "path40"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 80.202426,93.917692 c 11.99762,0 21.784384,-9.785703 21.784384,-21.784029 0,-11.998326 -9.786764,-21.784382 -21.784384,-21.784382 -11.99833,0 -21.78403,9.786056 -21.78403,21.784382 0,11.998326 9.7857,21.784029 21.78403,21.784029",
                style: get_mineable_asteroid_style("#acd1f0"),
                id: "path42"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 81.613536,95.046581 c 11.997621,0 21.783674,-9.786056 21.783674,-21.784382 0,-11.998326 -9.786053,-21.784382 -21.783674,-21.784382 -11.99832,0 -21.78403,9.786056 -21.78403,21.784382 0,11.998326 9.78571,21.784382 21.78403,21.784382",
                style: get_mineable_asteroid_style("#3f659b"),
                id: "path44"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 73.288336,127.74168 c 0.74189,-6.12317 6.30661,-10.48491 12.42907,-9.74267 6.122454,0.74083 10.484904,6.3059 9.743365,12.42836 -0.742244,6.12246 -6.306961,10.48456 -12.429415,9.74267 -6.12246,-0.74154 -10.48491,-6.30626 -9.74302,-12.42836",
                style: get_mineable_asteroid_style("#acd1f0"),
                id: "path46"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 100.43388,62.288693 c 1.88348,3.222625 2.96333,6.971595 2.96333,10.973506 0,12.031134 -9.752892,21.784382 -21.783674,21.784382 -5.11528,0 -9.81816,-1.763889 -13.53502,-4.715581 -1.88349,-3.222272 -2.96369,-6.971595 -2.96369,-10.973506 0,-12.030781 9.75325,-21.784382 21.78438,-21.784382 5.114926,0 9.817454,1.764242 13.534674,4.715581",
                style: get_mineable_asteroid_style("#20314b"),
                id: "path48"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 74.473666,126.78177 c 0.74154,-6.12281 6.3059,-10.48491 12.42836,-9.74267 6.123167,0.74119 10.485265,6.30591 9.743726,12.42907 -0.741892,6.12246 -6.306962,10.48456 -12.429416,9.74302 -6.12246,-0.74189 -10.48456,-6.30626 -9.74267,-12.42942",
                style: get_mineable_asteroid_style("#3f659b"),
                id: "path50"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 149.85205,100.22889 c -7.90575,4.59352 -18.03929,1.90888 -22.63352,-5.997579 -4.59387,-7.906103 -1.90888,-18.039292 5.99758,-22.633165 7.90575,-4.594225 18.03929,-1.90888 22.63352,5.99687 4.59387,7.906456 1.90817,18.039646 -5.99758,22.633874",
                style: get_mineable_asteroid_style("#acd1f0"),
                id: "path52"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 81.135166,117.86989 c 1.75649,-0.75917 3.73063,-1.07773 5.76686,-0.83079 6.123167,0.74119 10.485265,6.30591 9.743726,12.42907 -0.316089,2.60209 -1.503186,4.88703 -3.234267,6.5973 -1.756128,0.75918 -3.730625,1.07773 -5.766859,0.83079 -6.12281,-0.74119 -10.48491,-6.3059 -9.74337,-12.42872 0.31538,-2.60244 1.50283,-4.88738 3.23391,-6.59765",
                style: get_mineable_asteroid_style("#20314b"),
                id: "path54"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 148.66707,99.613995 c -7.90575,4.594225 -18.03929,1.909235 -22.63281,-5.997575 -4.59458,-7.905398 -1.90994,-18.039293 5.99687,-22.632813 7.90575,-4.593872 18.03965,-1.90888 22.63352,5.997223 4.59352,7.906103 1.90888,18.039645 -5.99758,22.633165",
                style: get_mineable_asteroid_style("#3f659b"),
                id: "path56"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "m 132.17118,99.696192 c -2.46838,-1.397705 -4.60904,-3.449814 -6.13692,-6.079772 -4.59458,-7.905398 -1.90994,-18.039293 5.99687,-22.632813 3.36091,-1.95333 7.12505,-2.589742 10.69446,-2.069747 2.46838,1.398764 4.60904,3.449814 6.13763,6.079773 4.59387,7.906103 1.90923,18.039292 -5.99758,22.633518 -3.36091,1.952977 -7.12505,2.589389 -10.69446,2.069041",
                style: get_mineable_asteroid_style("#20314b"),
                id: "path58"
              }
            )
          ] })
        }
      ) }) });
    }
    function get_pos_on_svg(viewbox, ship, obj) {
      const ship_on_svg = {
        x: viewbox.width / 2,
        y: viewbox.height / 2
      };
      return {
        x: ship_on_svg.x + obj.x - ship.x,
        y: ship_on_svg.y + -(obj.y - ship.y)
      };
    }
    function TransformedPos(props) {
      const pos = get_pos_on_svg(props.viewbox, props.camera, props.obj);
      if (pos === null) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `translate(${pos.x} ${pos.y})`, children: props.children });
    }
    function strength_to_gui_thruster(thruster) {
      return thruster.strength / 1e3;
    }
    const background_shadowy_scale = 4;
    const background_shadowy_length = 800 * background_shadowy_scale;
    function calc_shadowy_background_vec(ship) {
      const len = background_shadowy_length / 2;
      const x2 = Math.trunc(ship.x / len);
      const y2 = Math.trunc(ship.y / len);
      const x_offset = ship.x % len;
      const y_offset = ship.y % len;
      return {
        x: x2 * len % background_shadowy_length - x_offset,
        y: y2 * len % background_shadowy_length - y_offset,
        angle: 0
      };
    }
    function ShadowyBackgroundImage(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "g",
        {
          transform: `translate(${background_shadowy_length * props.x - background_shadowy_length / 2} ${background_shadowy_length * props.y - background_shadowy_length / 2})`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              transform: `scale(${/*firefox does it right, but chrome has visible edges between the tiles for some reason. a little bit biffer makes it go away */
              background_shadowy_scale + 0.01} ${background_shadowy_scale + 0.01})`,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("image", { href: background_shadowy, type: "image/png" })
            }
          )
        }
      );
    }
    function GameView(props) {
      var _a, _b;
      const focused_ship = props.selected_ship == null ? props.state.thisShip : props.selected_ship.value;
      const camera_pos = (_b = (_a = props.state.view) == null ? void 0 : _a.ships[focused_ship]) == null ? void 0 : _b.pos;
      const background_shadowy_pos = calc_shadowy_background_vec(camera_pos);
      const zoom_scale = (() => {
        const num = Number.parseFloat(props.zoom.value);
        if (Number.isNaN(num)) {
          return 1;
        } else {
          return Math.min(Math.max(num, 0.1), 10);
        }
      })();
      const viewbox = {
        width: 700 / zoom_scale,
        height: 700 / zoom_scale
      };
      const fov_outer_size = 1e5;
      const fov_inner_size = props.state.view.viewDistance - 120;
      const group = props.state.info.optGroup[0];
      const members_list = group === void 0 ? [] : dict_to_list(group.members);
      if (members_list !== void 0) {
        members_list.sort(([name_a, _1], [name_b, _2]) => {
          return name_a < name_b ? 1 : -1;
        });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "game_view", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            className: "game_content",
            viewBox: `0 0 ${viewbox.width} ${viewbox.height}`,
            style: props.style,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "rect",
                {
                  x: -viewbox.width,
                  y: -viewbox.height,
                  width: viewbox.width * 100,
                  height: viewbox.height * 100,
                  fill: "#202020"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "background", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TransformedPos,
                {
                  viewbox,
                  camera: camera_pos,
                  obj: camera_pos,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `scale(0.85 0.85)`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `translate(-${3854 / 2} -${3333 / 2})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("image", { href: background, type: "image/jpeg" }) }) })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "background-shadowy", opacity: 0.3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TransformedPos,
                {
                  viewbox,
                  camera: { x: 0, y: 0, angle: 0 },
                  obj: background_shadowy_pos,
                  children: [-1, 0, 1].map(
                    (x2) => [-1, 0, 1].map((y2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ShadowyBackgroundImage, { x: x2, y: y2 }, `${x2}|${y2}`))
                  )
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "asteroids", children: props.state.view.asteroids.map((asteroid, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                TransformedPos,
                {
                  viewbox,
                  camera: camera_pos,
                  obj: asteroid,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Asteroid, { angle: asteroid.angle })
                },
                idx
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "mineable_asteroids", children: props.state.view.mineableAsteroids.map((asteroid, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                TransformedPos,
                {
                  viewbox,
                  camera: camera_pos,
                  obj: asteroid,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(MineableAsteroid, { angle: asteroid.angle })
                },
                idx
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "space_stations", children: props.state.view.spaceStations.map((station, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                TransformedPos,
                {
                  viewbox,
                  camera: camera_pos,
                  obj: station,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(SpaceStation, { angle: station.angle })
                },
                idx
              )) }),
              [
                ...dict_to_list(props.state.view.ships).filter(
                  ([name2, _]) => name2 != focused_ship
                ),
                [focused_ship, props.state.view.ships[focused_ship]]
              ].map(([name2, ship], idx) => {
                const prefix = "192.168.100.";
                if (name2.startsWith(prefix)) {
                  name2 = name2.substring(prefix.length);
                }
                return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "ship", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TransformedPos,
                  {
                    viewbox,
                    camera: camera_pos,
                    obj: ship.pos,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Ship,
                      {
                        name: name2,
                        angle: ship.pos.angle,
                        thrusters: {
                          back: strength_to_gui_thruster(ship.thrusters.back),
                          topleft: strength_to_gui_thruster(
                            ship.thrusters.frontLeft
                          ),
                          topright: strength_to_gui_thruster(
                            ship.thrusters.frontRight
                          ),
                          bottomleft: strength_to_gui_thruster(
                            ship.thrusters.bottomLeft
                          ),
                          bottomright: strength_to_gui_thruster(
                            ship.thrusters.bottomRight
                          ),
                          sideup: strength_to_gui_thruster(ship.thrusters.front)
                        },
                        laser: {
                          angle: ship.laserAngle,
                          active: ship.laserIsActive,
                          length: ship.laserLength
                        }
                      }
                    )
                  }
                ) }, idx);
              }),
              props.state.view.debugPointsOfInterest.map((p2, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                TransformedPos,
                {
                  viewbox,
                  camera: camera_pos,
                  obj: p2,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "-3", y1: "-3", x2: "3", y2: "3", stroke: "red" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "-3", y1: "3", x2: "3", y2: "-3", stroke: "red" })
                  ]
                },
                idx
              )),
              /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "field-of-view", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TransformedPos,
                {
                  viewbox,
                  camera: camera_pos,
                  obj: camera_pos,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "circle",
                    {
                      strokeWidth: fov_outer_size,
                      r: fov_outer_size / 2 + fov_inner_size,
                      strokeOpacity: 1,
                      stroke: "black",
                      fill: "transparent"
                    }
                  )
                }
              ) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "game_hud", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "game_hud_content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("table", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Ship:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: props.selected_ship == null ? props.state.thisShip : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "select",
                {
                  defaultValue: props.selected_ship.value,
                  value: props.selected_ship.value,
                  onChange: (e) => {
                    assert(props.selected_ship != null);
                    props.selected_ship.set(e.target.value);
                  },
                  children: props.ships.map((ship) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: ship, children: ship }, ship))
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Zoom:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextEdit, { state: props.zoom, placeholder: "1.0" }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Geschwindigkeit:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                props.state.info.ship.forwardSpeed.toFixed(1),
                " m/s"
              ] })
            ] }),
            group === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Upgrades:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "upgrades_table", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Antrieb" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                    Math.round(group.thrusterStrength * 100),
                    "%"
                  ] })
                ] }),
                group.laserSpeedFactor > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Laser" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                    Math.round(group.laserSpeedFactor * 100),
                    "%"
                  ] })
                ] }) : null,
                group.robotSpeedFactor > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Cargo Bot" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { children: [
                    Math.round(group.robotSpeedFactor * 100),
                    "%"
                  ] })
                ] }) : null
              ] }) })
            ] })
          ] }) }),
          members_list.length == 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "noten", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Wer" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Klasse" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Gruppe" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Total" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: members_list.map(([name2, member_info]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: name2 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: member_info.noteClass.toFixed(1) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: member_info.noteGroup.toFixed(1) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: member_info == null ? "" : member_info.noteTotal.toFixed(1) })
            ] })) })
          ] })
        ] }) })
      ] });
    }
    function connect_to_outside(get_updates, set_backpressure) {
      const current_outside_status2 = create_versioned_subject({
        kind: "offline"
      });
      async function read_outside_updates() {
        let last_message = null;
        let last_successful_ts = Date.now();
        let last_backpressure_ts = Date.now();
        let last_backpressure_task = null;
        while (true) {
          try {
            const response = get_updates();
            let count = 0n;
            for await (const message of response.responses) {
              ++count;
              last_message = message;
              last_successful_ts = Date.now();
              if (Date.now() - last_backpressure_ts > 1e3) {
                await last_backpressure_task;
                last_backpressure_task = null;
                last_backpressure_ts = Date.now();
                last_backpressure_task = set_backpressure({
                  secret: message.secret,
                  messageNo: count
                });
              }
              current_outside_status2.next({ kind: "current", status: message });
            }
          } catch (ex) {
            if (last_message == null || Date.now() - last_successful_ts > 5e3) {
              current_outside_status2.next({ kind: "offline" });
            } else {
              current_outside_status2.next({
                kind: "temp_error",
                status: last_message
              });
            }
            if (Date.now() - last_successful_ts > 5e3) {
              await sleep_for_ms(1e3);
            } else {
              await sleep_for_ms(100);
            }
          }
        }
      }
      read_outside_updates();
      return current_outside_status2;
    }
    var isPlainObj = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
    const isPlainObject = isPlainObj;
    var sortKeys$1 = (object, options = {}) => {
      if (!isPlainObject(object) && !Array.isArray(object)) {
        throw new TypeError("Expected a plain object or array");
      }
      const { deep } = options;
      const seenInput = [];
      const seenOutput = [];
      const deepSortArray = (array) => {
        const seenIndex = seenInput.indexOf(array);
        if (seenIndex !== -1) {
          return seenOutput[seenIndex];
        }
        const result = [];
        seenInput.push(array);
        seenOutput.push(result);
        result.push(...array.map((item) => {
          if (Array.isArray(item)) {
            return deepSortArray(item);
          }
          if (isPlainObject(item)) {
            return sortKeys2(item);
          }
          return item;
        }));
        return result;
      };
      const sortKeys2 = (object2) => {
        const seenIndex = seenInput.indexOf(object2);
        if (seenIndex !== -1) {
          return seenOutput[seenIndex];
        }
        const result = {};
        const keys2 = Object.keys(object2).sort(options.compare);
        seenInput.push(object2);
        seenOutput.push(result);
        for (const key of keys2) {
          const value = object2[key];
          let newValue;
          if (deep && Array.isArray(value)) {
            newValue = deepSortArray(value);
          } else {
            newValue = deep && isPlainObject(value) ? sortKeys2(value) : value;
          }
          Object.defineProperty(result, key, {
            ...Object.getOwnPropertyDescriptor(object2, key),
            value: newValue
          });
        }
        return result;
      };
      if (Array.isArray(object)) {
        return deep ? deepSortArray(object) : object.slice();
      }
      return sortKeys2(object);
    };
    var toString = Object.prototype.toString;
    var kindOf$1 = function kindOf2(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name2, val) {
      return ctorName(name2) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
    const sortKeys = sortKeys$1;
    const kindOf = kindOf$1;
    const inArray = (value, arr) => !arr || kindOf(arr) !== "array" ? false : arr.indexOf(value) > -1;
    const sortObjectKeys = (obj, compare) => sortKeys(obj, { compare });
    const sortArray = (arr, opts) => {
      const compareFunction = opts && opts.compareFunction;
      return arr.slice().sort(compareFunction);
    };
    function sortObject(obj, opts) {
      const compareFunction = opts && opts.compareFunction;
      const result = sortObjectKeys(obj, compareFunction);
      Object.keys(obj).forEach(function(key) {
        const current = result[key];
        const type = kindOf(current);
        if (type === "object") {
          if (!opts || !inArray(key, opts.ignoreObjectAtKeys)) {
            result[key] = sortObject(current, opts);
          }
          return;
        }
        if (type === "array") {
          if (!opts || !inArray(key, opts.ignoreArrayAtKeys)) {
            result[key] = sortArray(current, opts);
          }
        }
      });
      return result;
    }
    const sort = (something, opts) => {
      const type = kindOf(something);
      return sort[type] ? sort[type](something, opts) : something;
    };
    sort.array = sortArray;
    sort.object = sortObject;
    var sortKeysRecursive = sort;
    var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray$1(value) || isArguments$2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index2 = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index2 < length) {
        var value = array[index2];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray$1(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver2) {
      if (typeof func != "function" || resolver2 != null && typeof resolver2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver2 ? resolver2.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
      });
      return result;
    });
    const stringToPath$1 = stringToPath;
    function castPath(value, object) {
      if (isArray$1(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath$1(toString$1(value));
    }
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function baseGet(object, path2) {
      path2 = castPath(path2, object);
      var index2 = 0, length = path2.length;
      while (object != null && index2 < length) {
        object = object[toKey(path2[index2++])];
      }
      return index2 && index2 == length ? object : void 0;
    }
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index2 = matchData.length, length = index2, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index2--) {
        var data2 = matchData[index2];
        if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
          return false;
        }
      }
      while (++index2 < length) {
        data2 = matchData[index2];
        var key = data2[0], objValue = object[key], srcValue = data2[1];
        if (noCustomizer && data2[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function isStrictComparable(value) {
      return value === value && !isObject$1(value);
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function get(object, path2, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path2);
      return result === void 0 ? defaultValue : result;
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function hasPath(object, path2, hasFunc) {
      path2 = castPath(path2, object);
      var index2 = -1, length = path2.length, result = false;
      while (++index2 < length) {
        var key = toKey(path2[index2]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index2 != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments$2(object));
    }
    function hasIn(object, path2) {
      return object != null && hasPath(object, path2, baseHasIn);
    }
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object) {
        var objValue = get(object, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    function identity(value) {
      return value;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function basePropertyDeep(path2) {
      return function(object) {
        return baseGet(object, path2);
      };
    }
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    const baseFor$1 = baseFor;
    function baseForOwn(object, iteratee) {
      return object && baseFor$1(object, iteratee, keys);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index2-- : ++index2 < length) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    var baseEach = createBaseEach(baseForOwn);
    const baseEach$1 = baseEach;
    function baseMap(collection, iteratee) {
      var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach$1(collection, function(value, key, collection2) {
        result[++index2] = iteratee(value, key, collection2);
      });
      return result;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    function compareMultiple(object, other, orders) {
      var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index2 < length) {
        var result = compareAscending(objCriteria[index2], othCriteria[index2]);
        if (result) {
          if (index2 >= ordersLength) {
            return result;
          }
          var order2 = orders[index2];
          return result * (order2 == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray$1(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index2 = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index2, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index2 < length) {
          array[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var baseSetToString = !defineProperty$1 ? identity : function(func, string2) {
      return defineProperty$1(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    const baseSetToString$1 = baseSetToString;
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    var setToString = shortOut(baseSetToString$1);
    const setToString$1 = setToString;
    function baseRest(func, start) {
      return setToString$1(overRest(func, start, identity), func + "");
    }
    function isIterateeCall(value, index2, object) {
      if (!isObject$1(object)) {
        return false;
      }
      var type = typeof index2;
      if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
        return eq(object[index2], value);
      }
      return false;
    }
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach$1(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray$1(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee), accumulator);
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });
    function connect() {
      const abort_controller = new AbortController();
      if (window.location.search !== "") {
        const backend = new URLSearchParams(window.location.search).get("backend");
        return {
          abort: (reason) => abort_controller.abort(reason),
          cockpit_client: new CockpitGuiClient(
            new GrpcWebFetchTransport({
              baseUrl: `http://${backend}:2001`,
              meta: {},
              abort: abort_controller.signal
            })
          )
        };
      } else {
        return {
          abort: (reason) => abort_controller.abort(reason),
          cockpit_client: new CockpitGuiClient(
            new GrpcWebFetchTransport({
              baseUrl: `${window.location.protocol}//${window.location.hostname}:2001`,
              meta: {},
              abort: abort_controller.signal
            })
          )
        };
      }
    }
    const connection = connect();
    const frontend_config_storage = register_local_storage({
      version: 2,
      name: "theship_config",
      parse: (_version, json) => {
        if (!is_array(json)) {
          return null;
        }
        const parsed = json.map((e) => {
          if (e === null) {
            return null;
          }
          if (!has_member(e, "id")) {
            return null;
          }
          const id2 = e.id;
          if (typeof id2 !== "number") {
            return null;
          }
          if (!has_member(e, "content")) {
            return null;
          }
          if (!has_member(e, "doc")) {
            return null;
          }
          const doc = e.doc;
          if (doc !== null && typeof doc !== "string") {
            return null;
          }
          return {
            id: id2,
            content: e.content,
            doc
          };
        });
        if (parsed.some((e) => e === null)) {
          return null;
        }
        return parsed.map(ensure_non_null);
      },
      initial_state: null,
      deferred_store: true
    });
    const frontend_filter_storage = register_local_storage({
      version: 1,
      name: "theship_filter",
      parse: (_version, json) => {
        if (!has_member(json, "include")) {
          return null;
        }
        const include = json.include;
        if (typeof include !== "string") {
          return null;
        }
        if (!has_member(json, "exclude")) {
          return null;
        }
        const exclude = json.exclude;
        if (typeof exclude !== "string") {
          return null;
        }
        if (!has_member(json, "zoom")) {
          return null;
        }
        const zoom = json.zoom;
        if (typeof zoom !== "string") {
          return null;
        }
        return {
          include,
          exclude,
          zoom
        };
      },
      initial_state: { include: "", exclude: "", zoom: "1.0" },
      deferred_store: false
    });
    function sleep(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }
    function handle_update(status, update) {
      switch (update.what.oneofKind) {
        case "widgetUpdate": {
          const widget = status.find((e) => e.id == update.widgetId);
          if (widget === void 0) {
            status.push({
              id: update.widgetId,
              content: parse_json(update.what.widgetUpdate.contentJson),
              doc: null
            });
          } else {
            widget.content = parse_json(update.what.widgetUpdate.contentJson);
          }
          break;
        }
        case "docUpdate": {
          const widget = status.find((e) => e.id == update.widgetId);
          if (widget === void 0) {
            status.push({
              id: update.widgetId,
              content: null,
              doc: update.what.docUpdate.doc
            });
          } else {
            widget.doc = update.what.docUpdate.doc;
          }
          break;
        }
        case "widgetRemove": {
          const widget_index = status.findIndex((e) => e.id == update.widgetId);
          if (widget_index >= 0) {
            status.splice(widget_index, 1);
          }
          break;
        }
      }
    }
    const current_status = create_versioned_subject({ kind: "offline", status: frontend_config_storage.data.get_value() });
    async function read_updates() {
      let last_message_received = window.performance.now();
      let timeout_handle = null;
      while (true) {
        try {
          const response = connection.cockpit_client.getUpdates({});
          const status = [];
          for await (const message of response.responses) {
            last_message_received = window.performance.now();
            for (const update of message.updates) {
              handle_update(status, sortKeysRecursive(update));
            }
            const curr_status = make_immutable(status);
            current_status.next({ kind: "current", status: curr_status });
            frontend_config_storage.data.next(curr_status);
            if (timeout_handle !== null) {
              clearTimeout(timeout_handle);
            }
            timeout_handle = setTimeout(() => {
              current_status.next({
                kind: "offline",
                status: current_status.get_value().status
              });
              timeout_handle = null;
            }, 1e4);
          }
        } catch (ex) {
          const last_known_status = current_status.get_value();
          if (last_known_status.kind == "offline") {
            current_status.next({
              kind: "offline",
              status: last_known_status.status
            });
          } else {
            current_status.next({
              kind: "temp_error",
              status: last_known_status.status
            });
          }
          const time_since_last_message_ms = window.performance.now() - last_message_received;
          if (time_since_last_message_ms > 1e4) {
            await sleep(1e3);
          } else {
            await sleep(200);
          }
        }
      }
    }
    read_updates();
    const current_outside_status = create_versioned_subject({
      kind: "offline"
    });
    let connecting_to_outside_started = false;
    async function start_connecting_to_outside() {
      if (connecting_to_outside_started) {
        return;
      }
      connecting_to_outside_started = true;
      while (true) {
        try {
          const result = await connection.cockpit_client.getSimulatorInfo({});
          const abort_controller = new AbortController();
          const client2 = new TheShipLowLevelClient(
            new GrpcWebFetchTransport({
              baseUrl: `${window.location.protocol}//${result.response.simulatorIp}:8080`,
              meta: {},
              abort: abort_controller.signal
            })
          );
          connect_to_outside(
            () => {
              return client2.getOutsideUpdates({ ip: result.response.brainIp });
            },
            async (msg) => {
              await client2.setOutsideUpdatesUpdatePressure(msg);
            }
          ).subscribe((status) => {
            current_outside_status.next(status);
          });
          return;
        } catch (ex) {
        }
        await sleep_for_ms(200);
      }
    }
    function Content(props) {
      const content2 = props.content;
      if (!has_member(content2, "kind") || typeof content2.kind != "string") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid content" });
      }
      switch (content2.kind) {
        case "text":
          if (!has_member(content2, "text") || typeof content2.text != "string") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid text" });
          }
          if (has_member(content2, "style") && typeof content2.style != "string") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid style" });
          }
          const style2 = (() => {
            if (has_member(content2, "style") && typeof content2.style == "string") {
              switch (content2.style) {
                case "bold":
                  return { fontWeight: "bolder" };
                case "inactive":
                  return { color: "gray" };
              }
              return {};
            } else {
              return {};
            }
          })();
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: style2, children: content2.text == "" ? " " : content2.text });
        case "table":
          if (!has_member(content2, "header")) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid table (missing header)" });
          }
          const header = content2.header;
          if (!is_array(header) && header != null) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid table.header" });
          }
          if (!has_member(content2, "rows")) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid table (missing rows)" });
          }
          const rows = content2.rows;
          if (!is_array(rows)) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid table.rows" });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
            header != null ? /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: header.map((col, idx) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { widget_id: props.widget_id, content: col }) }, idx);
            }) }) }) : null,
            /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: rows.map((row, idx) => {
              if (!is_array(row)) {
                return /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "invalid row" }, idx);
              }
              return /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: row.map((col, idx2) => {
                return /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { widget_id: props.widget_id, content: col }) }, idx2);
              }) }, idx);
            }) })
          ] });
        case "button":
          if (!has_member(content2, "id")) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid button (no id)" });
          }
          const id2 = content2.id;
          if (typeof id2 != "string") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid button (id has wrong type)" });
          }
          if (!has_member(content2, "text") || typeof content2.text != "string") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid button (no text)" });
          }
          if (!has_member(content2, "pressed") || typeof content2.pressed != "boolean") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid button (no pressed state)" });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `button ${content2.pressed ? "pressed" : "unpressed"}`,
              onMouseDown: () => {
                connection.cockpit_client.buttonPressed({
                  widgetId: props.widget_id,
                  elementId: id2
                });
              },
              onMouseUp: () => {
                connection.cockpit_client.buttonUnPressed({
                  widgetId: props.widget_id,
                  elementId: id2
                });
              },
              children: content2.text
            }
          );
        case "stack":
          if (!has_member(content2, "content") || !is_array(content2.content)) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Invalid stack" });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: content2.content.map((entry, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { content: entry, widget_id: props.widget_id }, idx)) });
        case "image":
          if (!has_member(content2, "url")) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "url missing" });
          }
          if (typeof content2.url !== "string") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "url should be string" });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: content2.url, width: "100%" }) });
        case "whatsupp":
          const parsed = parse_whatsupp(content2);
          if (parsed.kind == "error") {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              parsed.msg,
              " "
            ] });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(WhatsUpp, { widget_id: props.widget_id, content: parsed.parsed });
        default:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            "Unknown kind: ",
            content2.kind,
            " "
          ] });
      }
    }
    function parse_whatsupp(content2) {
      if (!has_member(content2, "id")) {
        return { kind: "error", msg: "id is missing" };
      }
      const id2 = content2.id;
      if (typeof id2 !== "string") {
        return { kind: "error", msg: "idis not a string" };
      }
      if (!has_member(content2, "open_chat")) {
        return { kind: "error", msg: "open_chat is missing" };
      }
      const open_chat = content2.open_chat;
      if (typeof open_chat !== "string" && open_chat !== null) {
        return { kind: "error", msg: "open_chat is not a string" };
      }
      if (!has_member(content2, "chats")) {
        return { kind: "error", msg: "chats is missing" };
      }
      const chats = content2.chats;
      if (!is_array(chats)) {
        return { kind: "error", msg: "chats is not an array" };
      }
      const parsed_chats = chats.map(
        (chat) => {
          if (!has_member(chat, "script")) {
            return { kind: "error", msg: "chat[].script is missing" };
          }
          const script = chat.script;
          if (typeof script !== "string") {
            return { kind: "error", msg: "chat[].script is not a string" };
          }
          if (!has_member(chat, "contact_name")) {
            return { kind: "error", msg: "chat[].contact_name is missing" };
          }
          const contact_name = chat.contact_name;
          if (typeof contact_name !== "string") {
            return { kind: "error", msg: "chat[].contact_name is not a string" };
          }
          if (!has_member(chat, "is_writing")) {
            return { kind: "error", msg: "chat[].is_writing is missing" };
          }
          const is_writing = chat.is_writing;
          if (typeof is_writing !== "boolean") {
            return { kind: "error", msg: "chat[].is_writing is not a boolean" };
          }
          if (!has_member(chat, "messages")) {
            return { kind: "error", msg: "chat[].messages is missing" };
          }
          const messages2 = chat.messages;
          if (!is_array(messages2)) {
            return { kind: "error", msg: "chat[].messages is not an array" };
          }
          const parsed_messages = messages2.map(
            (message) => {
              if (!has_member(message, "sender")) {
                return { kind: "error", msg: "chat[].message[].sender is missing" };
              }
              const sender = message.sender;
              if (typeof sender !== "string") {
                return {
                  kind: "error",
                  msg: "chat[].message[].sender is not a string"
                };
              }
              if (!has_member(message, "is_edited")) {
                return {
                  kind: "error",
                  msg: "chat[].message[].is_edited is missing"
                };
              }
              const is_edited = message.is_edited;
              if (typeof is_edited !== "boolean") {
                return {
                  kind: "error",
                  msg: "chat[].message[].is_edited is not a boolean"
                };
              }
              if (!has_member(message, "text")) {
                return { kind: "error", msg: "chat[].message[].text is missing" };
              }
              const text2 = message.text;
              if (typeof text2 !== "string") {
                return {
                  kind: "error",
                  msg: "chat[].message[].text is not a string"
                };
              }
              return {
                kind: "success",
                parsed: {
                  sender,
                  is_edited,
                  text: text2
                }
              };
            }
          );
          {
            const errors2 = parsed_messages.filter((entry) => entry.kind == "error");
            if (errors2.length > 0) {
              const error = errors2[0];
              assert(error.kind == "error");
              return error;
            }
          }
          if (!has_member(chat, "choices")) {
            return { kind: "error", msg: "chat[].choices is missing" };
          }
          const choices = chat.choices;
          if (!is_array(choices)) {
            return { kind: "error", msg: "chat[].choices is not an array" };
          }
          const parsed_choices = choices.map(
            (choice) => {
              if (typeof choice !== "string") {
                return { kind: "error", msg: "chat[].choice[] is not a string" };
              }
              return {
                kind: "success",
                parsed: choice
              };
            }
          );
          {
            const errors2 = parsed_choices.filter((entry) => entry.kind == "error");
            if (errors2.length > 0) {
              const error = errors2[0];
              assert(error.kind == "error");
              return error;
            }
          }
          return {
            kind: "success",
            parsed: {
              script,
              contact_name,
              messages: parsed_messages.map((entry) => {
                assert(entry.kind == "success");
                return entry.parsed;
              }),
              choices: parsed_choices.map((entry) => {
                assert(entry.kind == "success");
                return entry.parsed;
              }),
              is_writing
            }
          };
        }
      );
      const errors = parsed_chats.filter((entry) => entry.kind == "error");
      if (errors.length > 0) {
        const error = errors[0];
        assert(error.kind == "error");
        return error;
      }
      return {
        kind: "success",
        parsed: {
          id: id2,
          open_chat,
          chats: parsed_chats.map((entry) => {
            assert(entry.kind == "success");
            return entry.parsed;
          })
        }
      };
    }
    function WhatsUpp(props) {
      const open_chat = props.content.chats.find(
        (chat) => chat.script == props.content.open_chat
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "whatsupp", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contacts", children: props.content.chats.map((chat) => {
          const last_message = chat.messages[chat.messages.length - 1];
          const last_sender = (() => {
            switch (last_message == null ? void 0 : last_message.sender) {
              case "computer":
                return chat.contact_name;
              case "user":
                return "Ihr";
            }
          })();
          const last_msg = (last_message == null ? void 0 : last_message.text) ?? "";
          const last_msg_truncated = last_msg.substring(0, 12);
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `contact${chat.script == props.content.open_chat ? " selected" : ""}`,
              onMouseDown: () => {
                connection.cockpit_client.buttonPressed({
                  widgetId: props.widget_id,
                  elementId: stringify_json({
                    id: props.content.id,
                    kind: "select_script",
                    script: chat.script
                  })
                });
              },
              onMouseUp: () => {
                connection.cockpit_client.buttonUnPressed({
                  widgetId: props.widget_id,
                  elementId: stringify_json({
                    id: props.content.id,
                    kind: "select_script",
                    script: chat.script
                  })
                });
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contact_name", children: chat.contact_name }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contact_last_msg", children: [
                  last_sender,
                  ":",
                  " ",
                  last_msg == last_msg_truncated ? last_msg : last_msg_truncated + "…"
                ] })
              ]
            },
            chat.script
          );
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat", children: [
          open_chat === void 0 ? null : open_chat.messages.map((message, idx) => {
            switch (message.sender) {
              case "computer":
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "message_received", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text", children: message.text }),
                  message.is_edited ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "edited", children: "Bearbeitet" }) : null
                ] }, idx);
              case "user":
                return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "message_sent", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text", children: message.text }) }, idx);
            }
          }),
          open_chat !== void 0 && open_chat.is_writing ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "message_received typing_indicator", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dot" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dot" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dot" })
          ] }) : null
        ] }),
        open_chat === void 0 || open_chat.choices.length == 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "message_input", children: open_chat.choices.map((choice, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "answer",
            onMouseDown: () => {
              connection.cockpit_client.buttonPressed({
                widgetId: props.widget_id,
                elementId: stringify_json({
                  id: props.content.id,
                  kind: "select_choice",
                  script: open_chat.script,
                  choice: idx
                })
              });
            },
            onMouseUp: () => {
              connection.cockpit_client.buttonUnPressed({
                widgetId: props.widget_id,
                elementId: stringify_json({
                  id: props.content.id,
                  kind: "select_contact",
                  script: open_chat.script,
                  choice: idx
                })
              });
            },
            children: choice
          },
          idx
        )) })
      ] });
    }
    function ParsedWidget(props) {
      const invalid_widget = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "widget", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "title", children: "Invalid Widget" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content" })
      ] });
      const widget = props.widget.content;
      if (!has_member(widget, "title") || typeof widget.title != "string") {
        return invalid_widget;
      }
      if (!has_member(widget, "content")) {
        return invalid_widget;
      }
      if (!has_member(widget, "width") || typeof widget.width != "number") {
        return invalid_widget;
      }
      if (!has_member(widget, "height") || typeof widget.height != "number") {
        return invalid_widget;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "widget",
          style: {
            gridColumn: `span ${widget.width}`,
            gridRow: `span ${2 + widget.height}`
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "title", children: widget.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "actions", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: props.doc_url, children: "doc" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "|" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: props.fullscreen_url, children: "max" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { content: widget.content, widget_id: props.widget.id }) })
          ]
        }
      );
    }
    function OutdatedWarning() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "warning-block", children: "Information may be outdated Connecting to backend..." });
    }
    function get_widget_title(widget) {
      if (!has_member(widget.content, "title") || typeof widget.content.title != "string") {
        return null;
      } else {
        return widget.content.title;
      }
    }
    function get_widget_group(widget) {
      if (!has_member(widget.content, "group") || typeof widget.content.group != "string") {
        return "ungrouped";
      } else {
        return widget.content.group;
      }
    }
    function parse_regex(str) {
      try {
        return str === "" ? null : new RegExp(str, "i");
      } catch (ex) {
        return null;
      }
    }
    function useOutsideStatus() {
      start_connecting_to_outside();
      return sortKeysRecursive(
        make_mutable(useSubscription(current_outside_status))
      );
    }
    function OutsideView(_) {
      const status = useOutsideStatus();
      const filter = useReadWriteSubscription(frontend_filter_storage.data);
      const height = "500pt";
      if (status.kind == "offline") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height }, children: "connecting..." });
      } else {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          GameView,
          {
            state: status.status,
            zoom: filter.sub("zoom"),
            style: {
              border: "solid 1px black",
              width: "100%",
              height
            },
            ships: [],
            selected_ship: null
          }
        );
      }
    }
    function Cockpit(__props) {
      const status = useSubscription(current_status);
      const filter = useReadWriteSubscription(frontend_filter_storage.data);
      const include = parse_regex(filter.value.include);
      const exclude = parse_regex(filter.value.exclude);
      if (status.status === null) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Connecting..." });
      }
      const widgets = status.status.filter((widget) => widget.content !== null).filter((widget) => {
        const title = (() => {
          const title2 = get_widget_title(widget);
          if (title2 == null) {
            return "";
          } else {
            return title2;
          }
        })();
        if (include != null && include.test(title)) {
          return true;
        }
        if (exclude != null && exclude.test(title)) {
          return false;
        }
        if (include != null && !include.test(title)) {
          return false;
        }
        return true;
      });
      const grouped_widgets = groupBy(widgets, get_widget_group);
      const groups = ["user", "auxiliary"];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(OutsideView, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { margin: "1em" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { children: [
            "The Ship - Cockpit",
            status.kind == "offline" ? /* @__PURE__ */ jsxRuntimeExports.jsx(OutdatedWarning, {}) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(NoOpForm, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "grid",
                gridTemplateColumns: "min-content auto",
                gridTemplateRows: "repeat(2, auto)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Include: " }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextEdit,
                  {
                    state: filter.sub("include"),
                    placeholder: "regex of titles that should be included"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Exclude: " }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextEdit,
                  {
                    state: filter.sub("exclude"),
                    placeholder: "regex of titles that should be excluded"
                  }
                )
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                display: "grid",
                gridTemplateColumns: "auto"
              },
              children: sortBy(dict_to_list(grouped_widgets), ([group, _]) => {
                const idx = groups.indexOf(group);
                if (idx == -1) {
                  return 1e4;
                }
                return idx;
              }).map(([group, widgets2]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: group }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "widgets", children: sortBy(widgets2, (widget) => {
                  var _a;
                  const title = get_widget_title(widget);
                  const instanceNo = (_a = status.status) == null ? void 0 : _a.filter((w2) => get_widget_title(w2) == title).map((w2) => w2.id).indexOf(widget.id);
                  return [title, widget.id, instanceNo];
                }).map((widget) => {
                  var _a;
                  const title = get_widget_title(widget);
                  const instance_no = (_a = status.status) == null ? void 0 : _a.filter((w2) => get_widget_title(w2) == title).map((w2) => w2.id).indexOf(widget.id);
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ParsedWidget,
                    {
                      doc_url: `/doc/${title}/${instance_no}`,
                      fullscreen_url: `/widget/${title}/${instance_no}`,
                      widget_id: widget.id,
                      widget
                    },
                    widget.id
                  );
                }) })
              ] }, group))
            }
          )
        ] })
      ] });
    }
    const markdown_components = {
      code(props) {
        const { children, className, node: node2, ...rest } = props;
        const match = /language-(\w+)/.exec(className || "");
        return match ? children === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "error" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SyntaxHighlighter,
          {
            ...rest,
            ref: props.ref,
            style: props.style,
            children: String(children).replace(/\n$/, ""),
            language: match[1],
            PreTag: "div"
          }
        ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { ...rest, className, children }) });
      }
    };
    function Documentation(props) {
      const status = useSubscription(current_status);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { children: [
          "The Ship - Documentation",
          status.kind == "offline" ? /* @__PURE__ */ jsxRuntimeExports.jsx(OutdatedWarning, {}) : null
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", children: "home" }),
        props.widget.doc == null ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Documentation" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "documentation", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Markdown,
            {
              remarkPlugins: [remarkGfm],
              components: markdown_components,
              children: props.widget.doc
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Widget" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "grid",
              gridTemplateColumns: "min-content auto",
              gap: "1em"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "widgets",
                  style: {
                    display: "grid",
                    gridTemplateColumns: "unset",
                    gridAutoColumns: "6em",
                    gridTemplateRows: "min-content"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ParsedWidget,
                    {
                      doc_url: "#",
                      fullscreen_url: props.fullscreen_url,
                      widget_id: props.widget.id,
                      widget: props.widget
                    },
                    props.widget.id
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { overflowX: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: stringify_json(props.widget.content, 2) }) })
            ]
          }
        )
      ] });
    }
    function App() {
      const router = createBrowserRouter([
        {
          path: "/",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(Cockpit, {})
        },
        {
          path: "/widget/:widget_title/:instance_no",
          Component: (_props) => {
            const status = useSubscription(current_status);
            const widget_title = useParams().widget_title;
            const instance_no_str = useParams().instance_no;
            assert(widget_title !== void 0);
            assert(instance_no_str !== void 0);
            const instance_no = parseInt(instance_no_str);
            if (status.status == null) {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Connecting..." });
            }
            const widgets = status.status.filter(
              (w2) => get_widget_title(w2) == widget_title
            );
            if (widgets.length <= instance_no) {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Widget not found" });
            }
            const widget = widgets[instance_no];
            assert(widget != null);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", children: "home" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: "100vw",
                    gridTemplateRows: "calc(100vh - 2em)"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ParsedWidget,
                    {
                      widget_id: widget.id,
                      widget: ensure_non_null(widgets[instance_no]),
                      doc_url: `/doc/${widget_title}/${instance_no}`,
                      fullscreen_url: "#"
                    }
                  )
                }
              )
            ] });
          }
        },
        {
          path: "/doc/:widget_title/:instance_no",
          Component: (_props) => {
            const status = useSubscription(current_status);
            const widget_title = useParams().widget_title;
            const instance_no_str = useParams().instance_no;
            assert(widget_title !== void 0);
            assert(instance_no_str !== void 0);
            const instance_no = parseInt(instance_no_str);
            if (status.status == null) {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Connecting..." });
            }
            const widgets = status.status.filter(
              (w2) => get_widget_title(w2) == widget_title
            );
            if (widgets.length <= instance_no) {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Widget not found" });
            }
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Documentation,
              {
                widget: ensure_non_null(widgets[instance_no]),
                fullscreen_url: `/widget/${widget_title}/${instance_no}`
              }
            );
          }
        }
      ]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router });
    }
    const root_container = document.getElementById("app");
    assert(root_container instanceof HTMLElement);
    client.createRoot(root_container).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
    );
  }
});
export default require_index_001();
